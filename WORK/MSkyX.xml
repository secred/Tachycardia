<?xml version="1.0"?>
<doc>
    <assembly>
        "MSkyX"
    </assembly>
    <members>
        <member name="P:MSkyX.BasicController.MoonPhase">
            <summary>Get/Set moon phase.</summary>
            <param name="value">Moon phase in [-1,1] range, where -1 means fully covered Moon, 0 clear Moon and 1 fully covered Moon.</param>
            <returns>Moon phase in [-1,1] range, where -1 means fully covered Moon, 0 clear Moon and 1 fully covered Moon.</returns>
        </member>
        <member name="P:MSkyX.BasicController.EastDirection">
            <summary>Get/Set eastn direction.</summary>
            <param name="value">East direction, in X,Z world coords (must be normalized).</param>
            <returns>Current east direction, in X,Z world coords.</returns>
        </member>
        <member name="P:MSkyX.BasicController.Time">
            <summary>Get/Set time.</summary>
            <param name="value">Time, where x = time in [0, 24]h range, y = sunrise hour in [0, 24]h range, z = sunset hour in [0, 24] range.</param>
            <returns>Current time, where x = time in [0, 24]h range, y = sunrise hour in [0, 24]h range, z = sunset hour in [0, 24] range.</returns>
        </member>
        <member name="P:MSkyX.BasicController.DeleteBySkyX">
            <summary>Must the controller be destroyed by SkyX?</summary>
            <returns>True if yes, false if not.</returns>
        </member>
        <member name="P:MSkyX.BasicController.MoonDirection">
            <summary>Get moon direction.</summary>
            <returns>Moon direction, Earth-to-Moon direction.</returns>
        </member>
        <member name="P:MSkyX.BasicController.SunDirection">
            <summary>Get sun direction.</summary>
            <returns>Sun direction, the Earth-to-Sun direction.</returns>
        </member>
        <member name="M:MSkyX.BasicController.Update(System.Single)">
            <summary>Update controller.</summary>
            <param name="SimDeltaTime">Simulation delta time (It's not the time since last frame, it's the delta simulation time, one time the time since last frame has been multiplied by the time multiplier).</param>
        </member>
        <member name="M:MSkyX.BasicController.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:MSkyX.BasicController.#ctor(CLRObject*)">
            <summary>Copy constructor.</summary>
            <param name="obj">SkyX::BasicController to copy data from.</param>
            <remarks>For internal use only.</remarks>
        </member>
        <member name="T:MSkyX.BasicController">
            <summary>Basic controller class</summary>
        </member>
        <member name="F:SkyX.Controller.mDeleteBySkyX">
Must the controller be destroyed by SkyX?
</member>
        <member name="M:SkyX.Controller.getDeleteBySkyX">
Must the controller be destroyed by SkyX?
		@return true if yes, false if not

</member>
        <member name="M:SkyX.Controller.getMoonPhase">
Get moon phase
		@return Moon phase in [-1,1] range, where -1 means fully covered Moon, 0 clear Moon and 1 fully covered Moon

</member>
        <member name="M:SkyX.Controller.getMoonDirection">
Get moon direction
		@return Moon direction, Earth-to-Moon direction

</member>
        <member name="M:SkyX.Controller.getSunDirection">
Get sun direction
		@return Sun direction, the Earth-to-Sun direction

</member>
        <member name="M:SkyX.Controller.update(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update controller
		@param simDeltaTime Simulation delta time (It's not the time since last frame, it's the delta simulation time, one
		time the time since last frame has been multiplied by the time multiplier)

</member>
        <member name="M:SkyX.Controller.Dispose">
Destructor

</member>
        <member name="M:SkyX.Controller.#ctor(System.Boolean!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor
		@param deleteBySkyX true to automatically destroy the controller by SkyX, false otherwise

</member>
        <member name="T:SkyX.Controller">
Controller base class

</member>
        <member name="P:MSkyX.VClouds.GeometryBlock.WorldOffset">
            <summary>Set world offset.</summary>
            <param name="WorldOffset">World offset.</param>
        </member>
        <member name="M:MSkyX.VClouds.GeometryBlock.UpdateGeometry(Mogre.Camera,Mogre.Vector3)">
            <summary>Update geometry.</summary>
            <param name="c">Camera.</param>
            <param name="displacement">Current offset in world units per zone.</param>
        </member>
        <member name="M:MSkyX.VClouds.GeometryBlock.Remove">
            <summary>Remove.</summary>
        </member>
        <member name="M:MSkyX.VClouds.GeometryBlock.Create">
            <summary>Create.</summary>
        </member>
        <member name="M:MSkyX.VClouds.GeometryBlock.#ctor(CLRObject*)">
            <summary>Copy constructor.</summary>
            <param name="obj">SkyX::VClouds::GeometryBlock to copy data from.</param>
        </member>
        <member name="T:MSkyX.VClouds.GeometryBlock">
            <summary />
        </member>
        <member name="M:MSkyX.ColorGradient.GetColor(System.Single)">
            <summary>Get color value.</summary>
            <param name="p">The gradient point in [0,1] range.</param>
            <returns>Color at the given gradient position.</returns>
        </member>
        <member name="M:MSkyX.ColorGradient.Clear">
            <summary>Clear color gradient.</summary>
        </member>
        <member name="M:MSkyX.ColorGradient.AddCFrame(System.ValueType!System.Collections.Generic.KeyValuePair`2{Mogre.Vector3,System.Single}!System.Runtime.CompilerServices.IsBoxed@)">
            <summary>Add color frame.</summary>
            <param name="CFrame">Color frame.</param>
        </member>
        <member name="M:MSkyX.ColorGradient.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:MSkyX.ColorGradient.#ctor(CLRObject*)">
            <summary>Copy constructor.</summary>
            <param name="obj">SkyX::CloudLayer to copy data from.</param>
        </member>
        <member name="T:MSkyX.ColorGradient">
            <summary>Color gradient.</summary>
        </member>
        <member name="D:MSkyX.ColorFrame">
            <summary>
Color frame type definition.
ColorFrame.Key: Colour value
ColorFrame.Value: Position in the gradient [0,1] range
</summary>
        </member>
        <member name="P:MSkyX.VClouds.FastFakeRandom.Get">
            <summary>Get random number.</summary>
            <returns>Random number.</returns>
        </member>
        <member name="M:MSkyX.VClouds.FastFakeRandom.#ctor(System.Int32,System.Single,System.Single)">
            <summary>Constructor.</summary>
            <param name="n">Capacity.</param>
            <param name="min">Min value.</param>
            <param name="max">Max value.</param>
        </member>
        <member name="M:MSkyX.VClouds.FastFakeRandom.#ctor(CLRObject*)">
            <summary>Copy constructor.</summary>
            <param name="native">SkyX::VClouds::FastFakeRandom to copy data from.</param>
        </member>
        <member name="T:MSkyX.VClouds.FastFakeRandom">
            <summary>Fast fake random number generator.</summary>
        </member>
        <member name="P:MSkyX.IController.DeleteBySkyX">
            <summary>Must the controller be destroyed by SkyX?</summary>
            <returns>True if yes, false if not.</returns>
        </member>
        <member name="P:MSkyX.IController.MoonPhase">
            <summary>Get moon phase.</summary>
            <returns>Moon phase in [-1,1] range, where -1 means fully covered Moon, 0 clear Moon and 1 fully covered Moon.</returns>
        </member>
        <member name="P:MSkyX.IController.MoonDirection">
            <summary>Get moon direction.</summary>
            <returns>Moon direction, Earth-to-Moon direction.</returns>
        </member>
        <member name="P:MSkyX.IController.SunDirection">
            <summary>Get sun direction.</summary>
            <returns>Sun direction, the Earth-to-Sun direction.</returns>
        </member>
        <member name="M:MSkyX.IController.Update(System.Single)">
            <summary>Update controller.</summary>
            <param name="SimDeltaTime">Simulation delta time (It's not the time since last frame, it's the delta simulation time, one time the time since last frame has been multiplied by the time multiplier).</param>
        </member>
        <member name="T:MSkyX.IController">
            <summary>Controller interface.</summary>
        </member>
        <member name="T:Ogre.UTFString">
\addtogroup Core
	*  @{

\addtogroup Overlays
	*  @{

</member>
        <member name="T:CLRObject">
@} 
@} 
</member>
        <member name="M:Ogre.NedPoolingPolicy.getMaxAllocationSize">
Get the maximum size of a single allocation
</member>
        <member name="T:Ogre.NedPoolingPolicy">
An allocation policy for use with AllocatedObject and 
	STLAllocator. This is the class that actually does the allocation
	and deallocation of physical memory, and is what you will want to 
	provide a custom version of if you wish to change how memory is allocated.
	@par
	This allocation policy uses nedmalloc 
		(http://nedprod.com/programs/portable/nedmalloc/index.html). 

</member>
        <member name="T:Ogre.NedPoolingImpl">
\addtogroup Core
	*  @{

\addtogroup Memory
	*  @{

Non-templated utility class just to hide nedmalloc.

</member>
        <member name="T:Ogre.MemoryCategory">
\addtogroup Core
	*  @{

\addtogroup Memory
	*  @{

A set of categories that indicate the purpose of a chunk of memory
	being allocated. 
	These categories will be provided at allocation time in order to allow
	the allocation policy to vary its behaviour if it wishes. This allows you
	to use a single policy but still have variant behaviour. The level of 
	control it gives you is at a higher level than assigning different 
	policies to different classes, but is the only control you have over
	general allocations that are primitive types.

</member>
        <member name="F:MEMCATEGORY_RENDERSYS">
Rendersystem structures
</member>
        <member name="F:MEMCATEGORY_SCRIPTING">
Scripting
</member>
        <member name="F:MEMCATEGORY_RESOURCE">
Other resources
</member>
        <member name="F:MEMCATEGORY_SCENE_OBJECTS">
Scene object instances
</member>
        <member name="F:MEMCATEGORY_SCENE_CONTROL">
Nodes, control data
</member>
        <member name="F:MEMCATEGORY_ANIMATION">
Animation data like tracks, bone matrices
</member>
        <member name="F:MEMCATEGORY_GEOMETRY">
Geometry held in main memory
</member>
        <member name="F:MEMCATEGORY_GENERAL">
General purpose
</member>
        <member name="D:Ogre.uchar">
In order to avoid finger-aches :)

</member>
        <member name="D:Ogre.Real">
Software floating point type.
		@note Not valid as a pointer to GPU buffers / parameters

</member>
        <member name="M:MSkyX.VClouds.Lightning.Update(System.Single)">
            <summary> Update.</summary>
            <param name="timeSinceLastFrame">Time since last frame</param>
        </member>
        <member name="M:MSkyX.VClouds.Lightning.Remove">
            <summary> Remove.</summary>
        </member>
        <member name="M:MSkyX.VClouds.Lightning.Create">
            <summary>Create.</summary>
        </member>
        <member name="M:MSkyX.VClouds.Lightning.#ctor(CLRObject*)">
            <summary>Copy constructor.</summary>
            <param name="obj">SkyX::Lightning to copy data from.</param>
        </member>
        <member name="T:MSkyX.VClouds.Lightning">
            <summary>Color gradient.</summary>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.SetWheater(System.Single,System.Single,System.Boolean)">
            <summary>Set wheater parameters. Use this funtion to update the cloud field parameters, you'll get a smart and smooth transition from your old setting to your new ones.</summary>
            <param name="Humidity">Humidity, in other words: the percentage of clouds in [0,1] range.</param>
            <param name="AverageCloudsSize">Average clouds size, for example: if previous wheater clouds size parameter was very different from new one(i.e: more little) only the old biggest clouds are going to be keept and the little ones are going to be replaced</param>
            <param name="DelayedResponse">false to change wheather conditions over several updates, true to change it at the moment.</param>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.NotifyCameraRender(Mogre.Camera,System.Single)">
            <summary>Notify camera render, to be invoked per-camera and per-frame.</summary>
            <param name="c">Rendering camera.</param>
            <param name="timeSinceLastCameraFrame">Time since last CAMERA frame.</param>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.Update(System.Single)">
            <summary>Update, to be invoked per frame.</summary>
            <param name="timeSinceLastFrame">Time since last frame.</param>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.Remove">
            <summary>Remove.</summary>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.Create(Mogre.Vector2,System.Single)">
            <summary>Create.</summary>
            <param name="Height">x = Cloud field y-coord start, y: Field height (both in world coordinates).</param>
            <param name="Radius">Radius.</param>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.Create(MSkyX.VClouds.VClouds.GeometrySettings)">
            <summary>Create.</summary>
            <param name="gs">Geometry settings.</param>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.Create">
            <summary>Create.</summary>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.#ctor(CLRObject*)">
            <summary>Copy constructor.</summary>
            <param name="native">SkyX::VClouds to copy data from.</param>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.CameraData.#ctor(Mogre.Camera)">
            <summary>Constructor.</summary>
            <param name="c">Camera.</param>
        </member>
        <member name="F:MSkyX.VClouds.VClouds.CameraData.GeometryDisplacement">
            <summary>Geometry displacement.</summary>
        </member>
        <member name="F:MSkyX.VClouds.VClouds.CameraData.CameraOffset">
            <summary>Camera offset.</summary>
        </member>
        <member name="F:MSkyX.VClouds.VClouds.CameraData.LastPosition">
            <summary>Last camera position.</summary>
        </member>
        <member name="F:MSkyX.VClouds.VClouds.CameraData.Camera">
            <summary>Camera.</summary>
        </member>
        <member name="T:MSkyX.VClouds.VClouds.CameraData">
            <summary>Camera data struct.</summary>
        </member>
        <member name="F:MSkyX.VClouds.VClouds.GeometrySettings.DEFAULT">
            <summary>Default geometry settings.</summary>
            <returns>Default geometry settings.</returns>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.GeometrySettings.#ctor(Mogre.Vector2,System.Single,Mogre.Radian,Mogre.Radian,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
            <param name="_Height">x = Cloud field y-coord start, y: Field height (both in world coordinates).</param>
            <param name="_Radius">Radius.</param>
            <param name="_Alpha">Alpha angle.</param>
            <param name="_Beta">Beta angle.</param>
            <param name="_NumberOfBlocks">Number of geometry blocks.</param>
            <param name="_Na">Number of slices in A zone.</param>
            <param name="_Nb">Number of slices in B zone.</param>
            <param name="_Nb">Number of slices in C zone.</param>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.GeometrySettings.#ctor(Mogre.Vector2,System.Single,Mogre.Radian,Mogre.Radian,System.Int32,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
            <param name="_Height">x = Cloud field y-coord start, y: Field height (both in world coordinates).</param>
            <param name="_Radius">Radius.</param>
            <param name="_Alpha">Alpha angle.</param>
            <param name="_Beta">Beta angle.</param>
            <param name="_NumberOfBlocks">Number of geometry blocks.</param>
            <param name="_Na">Number of slices in A zone.</param>
            <param name="_Nb">Number of slices in B zone.</param>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.GeometrySettings.#ctor(Mogre.Vector2,System.Single,Mogre.Radian,Mogre.Radian,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
            <param name="_Height">x = Cloud field y-coord start, y: Field height (both in world coordinates).</param>
            <param name="_Radius">Radius.</param>
            <param name="_Alpha">Alpha angle.</param>
            <param name="_Beta">Beta angle.</param>
            <param name="_NumberOfBlocks">Number of geometry blocks.</param>
            <param name="_Na">Number of slices in A zone.</param>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.GeometrySettings.#ctor(Mogre.Vector2,System.Single,Mogre.Radian,Mogre.Radian,System.Int32)">
            <summary>Constructor.</summary>
            <param name="_Height">x = Cloud field y-coord start, y: Field height (both in world coordinates).</param>
            <param name="_Radius">Radius.</param>
            <param name="_Alpha">Alpha angle.</param>
            <param name="_Beta">Beta angle.</param>
            <param name="_NumberOfBlocks">Number of geometry blocks.</param>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.GeometrySettings.#ctor(Mogre.Vector2,System.Single,Mogre.Radian,Mogre.Radian)">
            <summary>Constructor.</summary>
            <param name="_Height">x = Cloud field y-coord start, y: Field height (both in world coordinates).</param>
            <param name="_Radius">Radius.</param>
            <param name="_Alpha">Alpha angle.</param>
            <param name="_Beta">Beta angle.</param>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.GeometrySettings.#ctor(Mogre.Vector2,System.Single,Mogre.Radian)">
            <summary>Constructor.</summary>
            <param name="_Height">x = Cloud field y-coord start, y: Field height (both in world coordinates).</param>
            <param name="_Radius">Radius.</param>
            <param name="_Alpha">Alpha angle.</param>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.GeometrySettings.#ctor(Mogre.Vector2,System.Single)">
            <summary>Constructor.</summary>
            <param name="_Height">x = Cloud field y-coord start, y: Field height (both in world coordinates).</param>
            <param name="_Radius">Radius.</param>
        </member>
        <member name="F:MSkyX.VClouds.VClouds.GeometrySettings.Nc">
            <summary>Number of slices per geometry zone.</summary>
        </member>
        <member name="F:MSkyX.VClouds.VClouds.GeometrySettings.Nb">
            <summary>Number of slices per geometry zone.</summary>
        </member>
        <member name="F:MSkyX.VClouds.VClouds.GeometrySettings.Na">
            <summary>Number of slices per geometry zone.</summary>
        </member>
        <member name="F:MSkyX.VClouds.VClouds.GeometrySettings.NumberOfBlocks">
            <summary>Number of blocks.</summary>
        </member>
        <member name="F:MSkyX.VClouds.VClouds.GeometrySettings.Radius">
            <summary>Radius.</summary>
        </member>
        <member name="F:MSkyX.VClouds.VClouds.GeometrySettings.Beta">
            <summary>Beta angle.</summary>
        </member>
        <member name="F:MSkyX.VClouds.VClouds.GeometrySettings.Alpha">
            <summary>Alpha angle.</summary>
        </member>
        <member name="F:MSkyX.VClouds.VClouds.GeometrySettings.Height">
            <summary>Height: x = Altitude over the camera, y: Field height (both in world coordinates).</summary>
        </member>
        <member name="T:MSkyX.VClouds.VClouds.GeometrySettings">
            <summary>Geometry settings.</summary>
        </member>
        <member name="M:MSkyX.VClouds.VClouds.RenderQueueGroups.#ctor(System.Byte,System.Byte)">
            <summary>Constructor.</summary>
            <param name="vc">VClouds render queue group.</param>
            <param name="vcl">VClouds lightnings render queue group.</param>
        </member>
        <member name="F:MSkyX.VClouds.VClouds.RenderQueueGroups.VCloudsLightnings">
            <summary>VClouds lightnings render queue group.</summary>
        </member>
        <member name="F:MSkyX.VClouds.VClouds.RenderQueueGroups.VClouds">
            <summary>VClouds render queue group.</summary>
        </member>
        <member name="T:MSkyX.VClouds.VClouds.RenderQueueGroups">
            <summary>Render queue groups.</summary>
        </member>
        <member name="M:MSkyX.VClouds.LightningManager.RemoveListeners">
            <summary>Remove listeners.</summary>
        </member>
        <member name="M:MSkyX.VClouds.LightningManager.Update(System.Single)">
            <summary>Update, to be invoked per frame.</summary>
            <param name="timeSinceLastFrame">Time since last frame.</param>
        </member>
        <member name="M:MSkyX.VClouds.LightningManager.Remove">
            <summary>Remove.</summary>
        </member>
        <member name="M:MSkyX.VClouds.LightningManager.Create">
            <summary>Create.</summary>
        </member>
        <member name="M:MSkyX.VClouds.LightningManager.Dispose">
            <summary>Destructor.</summary>
        </member>
        <member name="M:MSkyX.VClouds.LightningManager.#ctor(CLRObject*)">
            <summary>Copy constructor.</summary>
            <param name="obj">SkyX::LightningManager to copy data from.</param>
        </member>
        <member name="T:MSkyX.VClouds.LightningManager">
            <summary>Lightning manager.</summary>
        </member>
        <member name="M:MSkyX.VClouds.GeometryManager.UpdateGeometry(Mogre.Camera,System.Single)">
            <summary>Update geoemtry.</summary>
            <param name="c">Camera</param>
            <param name="timeSinceLastCameraFrame">Time since last CAMERA frame</param>
        </member>
        <member name="M:MSkyX.VClouds.GeometryManager.Update(System.Single)">
            <summary>Update, to be invoked per frame.</summary>
            <param name="timeSinceLastFrame">Time since last frame</param>
        </member>
        <member name="M:MSkyX.VClouds.GeometryManager.Remove">
            <summary>Remove.</summary>
        </member>
        <member name="M:MSkyX.VClouds.GeometryManager.Create(Mogre.Vector2,System.Single,Mogre.Radian,Mogre.Radian,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Create.</summary>
            <param name="Height">x = Field altitude, y: Field height (both in world coordinates)</param>
            <param name="Radius">Radius</param>
            <param name="Alpha">Alpha angle</param>
            <param name="Beta">Beta angle</param>
            <param name="NumberOfBlocks">Number of geometry blocks</param>
            <param name="Na">Number of slices in A zone</param>
            <param name="Nb">Number of slices in B zone</param>
            <param name="Nc">Number of slices in C zone</param>
        </member>
        <member name="M:MSkyX.VClouds.GeometryManager.#ctor(CLRObject*)">
            <summary>Copy constructor.</summary>
            <param name="obj">SkyX::GeometryManager to copy data from.</param>
        </member>
        <member name="M:MSkyX.MSkyX.Remove">
            <summary>Remove SkyX (free resources).</summary>
        </member>
        <member name="M:MSkyX.MSkyX.Create">
            <summary>Create SkyX.</summary>
        </member>
        <member name="M:MSkyX.MSkyX.Dispose">
            <summary>Destructor.</summary>
        </member>
        <member name="M:MSkyX.MSkyX.#ctor(Mogre.SceneManager,Mogre.RenderWindow,MSkyX.IController)">
            <summary>Constructor.</summary>
            <param name="sm">Mogre Scene manager.</param>
            <param name="c">MSkyX controller.</param>
        </member>
        <member name="M:MSkyX.MSkyX.OnPreViewportUpdate(Mogre.RenderTargetViewportEvent_NativePtr)">
            <summary>Fired before update a render target viewport.</summary>
            <param name="evt">Render target viewport event.</param>
        </member>
        <member name="M:MSkyX.MSkyX.OnFrameStarted(Mogre.FrameEvent)">
            <summary>Fired on frame start.</summary>
            <param name="evt">Frame event.</param>
        </member>
        <member name="M:MSkyX.MSkyX.RenderQueueGroups.#ctor(SkyX.SkyX.RenderQueueGroups)">
            <summary>Copy constructor.</summary>
            <param name="cl">SkyX::SkyX::RenderQueueGroups to copy data from.</param>
        </member>
        <member name="M:MSkyX.MSkyX.RenderQueueGroups.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>Constructor.</summary>
            <param name="s">Skydome render queue group.</param>
            <param name="vc">VClouds render queue group.</param>
            <param name="vcl">VClouds lightnings render queue group.</param>
        </member>
        <member name="F:MSkyX.MSkyX.RenderQueueGroups.VCloudsLightnings">
            <summary>VClouds lightnings render queue group.</summary>
        </member>
        <member name="F:MSkyX.MSkyX.RenderQueueGroups.VClouds">
            <summary>VClouds render queue group.</summary>
        </member>
        <member name="F:MSkyX.MSkyX.RenderQueueGroups.Skydome">
            <summary>Skydome render queue group.</summary>
        </member>
        <member name="T:MSkyX.MSkyX.RenderQueueGroups">
            <summary>Render queue groups.</summary>
        </member>
        <member name="F:MSkyX.MSkyX.LightingMode.LM_HDR">
            <summary>High dynamic range.</summary>
        </member>
        <member name="F:MSkyX.MSkyX.LightingMode.LM_LDR">
            <summary>Low dynamic range.</summary>
        </member>
        <member name="T:MSkyX.MSkyX.LightingMode">
            <summary>
Lighting mode enumeration
SkyX is designed for true HDR rendering, but there is a big number of applications
which don't use HDR rendering, due to this fact a little exponential tone-mapping 
algoritm is applied to SkyX materials if LM_LDR is selected. (See: AtmosphereManager::Options::Exposure)
Select LM_HDR if your app is designed for true HDR rendering.
</summary>
        </member>
        <member name="T:MSkyX.MSkyX">
            <summary>
MSkyX class.
Create simple and beautiful skies!
</summary>
            <remarks> How to update MSkyX:
Updating SkyX is a very easy task that can be done manually or automatically by using listeners. There're two update steps in SkyX: per-frame update and per-camera update, and the order is very important. The per-frame update must be performed at first: SkyX::update(...), after that and before each camera render operation SkyX::notifyCameraRender(...) must be invoked. Both updates can be automatically performed by using listeners: the Ogre::FrameListener is used for the per-frame udpate, and the Ogre::RenderTargetListener is used for the per-camera update. For more information have a look to sample projects.
</remarks>
        </member>
        <member name="F:SkyX.VClouds.Ellipsoid.mDensity">
Cloud density
</member>
        <member name="F:SkyX.VClouds.Ellipsoid.mNx">
Cells size
</member>
        <member name="F:SkyX.VClouds.Ellipsoid.mX">
Position
</member>
        <member name="F:SkyX.VClouds.Ellipsoid.mA">
Ellipsoid parameters
</member>
        <member name="M:SkyX.VClouds.Ellipsoid._getLength(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get length
		@param x x Coord
		@param y y Coord
		@param z z Coord
		@return [0,1] range where 0 is the center of the ellipsoid and 1 the superfice

</member>
        <member name="M:SkyX.VClouds.Ellipsoid.setPosition(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set position
		@param Position New position

</member>
        <member name="M:SkyX.VClouds.Ellipsoid.setDimensions(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set dimensions
		@param Dimensions New dimensions

</member>
        <member name="M:SkyX.VClouds.Ellipsoid.getPosition">
Get position
		@return Position

</member>
        <member name="M:SkyX.VClouds.Ellipsoid.getDimensions">
Get dimensions
		@return Ellipsoid dimensions

</member>
        <member name="M:SkyX.VClouds.Ellipsoid.isOutOfCells">
Determines if the ellipsoid is out of the cells domain and needs to be removed

</member>
        <member name="M:SkyX.VClouds.Ellipsoid.updateProbabilities(SkyX.VClouds.DataManager.Cell***,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update probabilities
		@param c Cells
		@param nx X complexity
		@param ny Y complexity
		@param nz Z complexity
		@param delayedResponse true to get a delayed response, updating only probabilities, false to also set clouds

</member>
        <member name="M:SkyX.VClouds.Ellipsoid.getProbabilities(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get probabilities at a point
		@param x x Coord
		@param y y Coord
		@param z z Coord 
		@return Probabilities (Hum, Ext, Act)

</member>
        <member name="M:SkyX.VClouds.Ellipsoid.move(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Move the ellipsoid
		@param Ax x increment
		@param Ay y increment
		@param Az z increment

</member>
        <member name="M:SkyX.VClouds.Ellipsoid.Dispose">
Destructor 

</member>
        <member name="M:SkyX.VClouds.Ellipsoid.#ctor(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerSer">
Constructor
		@param a A constant
		@param b B constant
		@param c C constant
		@param nx X size
		@param ny Y size
		@param nz Z size
		@param x x Coord (position)
		@param y y Coord (position)
		@param z z Coord (position)
		@param Density Cloud density

</member>
        <member name="T:SkyX.VClouds.Ellipsoid">
Ellipsoid class
	x^2   y^2   z^2
	/   + /   + /    = 1
	a^2   b^2   c^2

</member>
        <member name="F:SkyX.BasicController.mMoonPhase">
Moon phase
</member>
        <member name="F:SkyX.BasicController.mMoonDirection">
Moon direction
</member>
        <member name="F:SkyX.BasicController.mSunDirection">
Sun direction
</member>
        <member name="F:SkyX.BasicController.mEastDirection">
East direction (in X,Z world coords)
</member>
        <member name="F:SkyX.BasicController.mTime">
Time information: x = time in [0, 24]h range, y = sunrise hour in [0, 24]h range, z = sunset hour in [0, 24] range
</member>
        <member name="M:SkyX.BasicController.getMoonPhase">
Get moon phase
		@return Moon phase in [-1,1] range, where -1 means fully covered Moon, 0 clear Moon and 1 fully covered Moon

</member>
        <member name="M:SkyX.BasicController.setMoonPhase(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set moon phase
		@param mp Moon phase in [-1,1] range, where -1 means fully covered Moon, 0 clear Moon and 1 fully covered Moon

</member>
        <member name="M:SkyX.BasicController.getMoonDirection">
Get moon direction
		@return Moon direction, Earth-to-Moon direction

</member>
        <member name="M:SkyX.BasicController.getSunDirection">
Get sun direction
		@return Sun direction, the Earth-to-Sun direction

</member>
        <member name="M:SkyX.BasicController.getEastDirection">
Get east direction
		@return Current east direction, in X,Z world coords

</member>
        <member name="M:SkyX.BasicController.setEastDirection(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set eastn direction
		@param ed East direction, in X,Z world coords (must be normalized)

</member>
        <member name="M:SkyX.BasicController.getTime">
Get time
		@return Current time, where x = time in [0, 24]h range, y = sunrise hour in [0, 24]h range, z = sunset hour in [0, 24] range

</member>
        <member name="M:SkyX.BasicController.setTime(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set time
		@param t Time, where x = time in [0, 24]h range, y = sunrise hour in [0, 24]h range, z = sunset hour in [0, 24] range

</member>
        <member name="M:SkyX.BasicController.update(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update controller
		@param simDeltaTime Simulation delta time (It's not the time since last frame, it's the delta simulation time, one
		time the time since last frame has been multiplied by the time multiplier)

</member>
        <member name="M:SkyX.BasicController.#ctor(System.Boolean!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor
		@param deleteBySkyX true to automatically destroy the controller by SkyX, false otherwise

</member>
        <member name="T:SkyX.BasicController">
Basic controller class		         

</member>
        <member name="P:MSkyX.VCloudsManager.IsCreated">
            <summary>Is vclouds manager created?</summary>
            <returns>true if yes, false if not.</returns>
        </member>
        <member name="P:MSkyX.VCloudsManager.VClouds">
            <summary>Get VClouds.</summary>
        </member>
        <member name="P:MSkyX.VCloudsManager.WindSpeed">
            <summary>Get/Set wind speed.</summary>
            <param name="value">Wind speed.</param>
            <returns>Wind speed.</returns>
        </member>
        <member name="P:MSkyX.VCloudsManager.Autoupdate">
            <summary>Get/Set autoupdate.</summary>
            <param name="value">True if you want to update volumetric clouds wind depending of the SkyX time multiplier.</param>
            <returns>True if you want to update volumetric clouds wind depending of the SkyX time multiplier.</returns>
            <remarks> You can use VClouds-&gt;setWindSpeed(..) for different winds speeds.</remarks>
        </member>
        <member name="P:MSkyX.VCloudsManager.Height">
            <summary>Get/Set height parameters.</summary>
            <param name="value">x = Cloud field y-coord start, y: Field height (both in world coordinates).</param>
            <returns>Height: x = Cloud field y-coord start, y: Field height (both in world coordinates).</returns>
            <remarks>Assing value before calling Create(), for now... For autocalculated height based on the radius length set (-1,-1) as height params.</remarks>
        </member>
        <member name="P:MSkyX.VCloudsManager.SunGradient">
            <summary>Get/Set sun gradient.</summary>
            <param name="value">Sun color gradient.</param>
            <returns>Sun color gradient.</returns>
        </member>
        <member name="P:MSkyX.VCloudsManager.AmbientGradient">
            <summary>Get/Set ambient gradient.</summary>
            <param name="value">Ambient color gradient.</param>
            <returns>Ambient color gradient.</returns>
        </member>
        <member name="M:MSkyX.VCloudsManager.Remove">
            <summary>Remove all resources.</summary>
        </member>
        <member name="M:MSkyX.VCloudsManager.NotifyCameraRender(Mogre.Camera)">
            <summary>Notify camera render, to be invoked per-camera and per-frame.</summary>
            <param name="c">Rendering camera.</param>
            <remarks>The VClouds system needs the CAMERA time since last frame, so here we assume that all render targets are being updated one time per frame(in other words, all render targets are being updated at the same rate).</remarks>
        </member>
        <member name="M:MSkyX.VCloudsManager.Update(System.Single)">
            <summary>Update.</summary>
            <param name="timeSinceLastFrame">Time since last frame.</param>
        </member>
        <member name="M:MSkyX.VCloudsManager.Create(System.Single)">
            <summary>Create all resources.</summary>
            <param name="radius">Volumetric cloud field radius, -1 to use current VClouds::mGeometrySettings::Radius.</param>
        </member>
        <member name="M:MSkyX.VCloudsManager.Create">
            <summary>Create all resources.</summary>
        </member>
        <member name="F:SkyX.VClouds.VClouds.mCamerasData">
Cameras data
</member>
        <member name="F:SkyX.VClouds.VClouds.mVolCloudsLightningMaterial">
Vol. clouds + lightning material
</member>
        <member name="F:SkyX.VClouds.VClouds.mVolCloudsMaterial">
Vol. clouds material
</member>
        <member name="F:SkyX.VClouds.VClouds.mCamera">
Current rendering camera
</member>
        <member name="F:SkyX.VClouds.VClouds.mSceneManager">
Ogre::SceneManager pointer
</member>
        <member name="F:SkyX.VClouds.VClouds.mLightningManager">
Lightning manager
</member>
        <member name="F:SkyX.VClouds.VClouds.mGeometryManager">
Geometry manager
</member>
        <member name="F:SkyX.VClouds.VClouds.mDataManager">
Data manager
</member>
        <member name="F:SkyX.VClouds.VClouds.mVisible">
Is VClouds visible?
</member>
        <member name="F:SkyX.VClouds.VClouds.mNoiseScale">
Noise scale
</member>
        <member name="F:SkyX.VClouds.VClouds.mCloudFieldScale">
Cloud field scale
</member>
        <member name="F:SkyX.VClouds.VClouds.mGlobalOpacity">
Global opacity
</member>
        <member name="F:SkyX.VClouds.VClouds.mAmbientFactors">
Ambient factors
		x - constant, y - linear, z - cuadratic, w - cubic

</member>
        <member name="F:SkyX.VClouds.VClouds.mLightResponse">
Light response:
		x - Sun light power
		y - Sun beta multiplier
		z - Ambient color multiplier
		w - Distance attenuation

</member>
        <member name="F:SkyX.VClouds.VClouds.mAmbientColor">
Ambient color
</member>
        <member name="F:SkyX.VClouds.VClouds.mSunColor">
Sun color
</member>
        <member name="F:SkyX.VClouds.VClouds.mSunDirection">
Sun direction
</member>
        <member name="F:SkyX.VClouds.VClouds.mDelayedResponse">
Delayed response (This param is stored to allow the user call setWheater(...) before create() )
</member>
        <member name="F:SkyX.VClouds.VClouds.mWheater">
Wheater parameters: x = Humidity, y = Average clouds size, both un [0,1] range
</member>
        <member name="F:SkyX.VClouds.VClouds.mWindSpeed">
Wind speed
</member>
        <member name="F:SkyX.VClouds.VClouds.mWindDirection">
Wind direction
</member>
        <member name="F:SkyX.VClouds.VClouds.mRenderQueueGroups">
Render queue groups
</member>
        <member name="F:SkyX.VClouds.VClouds.mDistanceFallingParams">
Geometry distance falling params
</member>
        <member name="F:SkyX.VClouds.VClouds.mGeometrySettings">
Geometry settings
</member>
        <member name="F:SkyX.VClouds.VClouds.mCreated">
Has been create(...) already called?
</member>
        <member name="M:SkyX.VClouds.VClouds._getCamerasData">
Get cameras data
		@return Cameras data
		@remarks Only for internal use

</member>
        <member name="M:SkyX.VClouds.VClouds.getLightningManager">
Get lightning manager
		@return Lightning manager

</member>
        <member name="M:SkyX.VClouds.VClouds.getGeometryManager">
Get geometry manager
		@return Geometry manager

</member>
        <member name="M:SkyX.VClouds.VClouds.getDataManager">
Get data manager
		@return Data manager

</member>
        <member name="M:SkyX.VClouds.VClouds.getCamera">
Get current rendering camera
		@return Current rendering camera

</member>
        <member name="M:SkyX.VClouds.VClouds.getSceneManager">
Get scene manager
		@return Ogre::SceneManager pointer

</member>
        <member name="M:SkyX.VClouds.VClouds.isVisible">
Is VClouds visible?
		@return true if VClouds is visible, false otherwise

</member>
        <member name="M:SkyX.VClouds.VClouds.setVisible(System.Boolean!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set visible
		@param visible true to set VClouds visible, false to hide it

</member>
        <member name="M:SkyX.VClouds.VClouds.getWheater">
Get wheater
		@return Wheater parameters: x = Humidity, y = Average clouds size, both un [0,1] range

</member>
        <member name="M:SkyX.VClouds.VClouds.setWheater(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set wheater parameters
		Use this funtion to update the cloud field parameters, you'll get a smart and smooth transition from your old 
		setting to your new ones.
		@param Humidity Humidity, in other words: the percentage of clouds in [0,1] range.
		@param AverageCloudsSize Average clouds size, for example: if previous wheater clouds size parameter was very different from new one(i.e: more little)
		only the old biggest clouds are going to be keept and the little ones are going to be replaced
		@param DelayedResponse false to change wheather conditions over several updates, true to change it at the moment

</member>
        <member name="M:SkyX.VClouds.VClouds.getNoiseScale">
Get noise scale
		@return Noise scale

</member>
        <member name="M:SkyX.VClouds.VClouds.setNoiseScale(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set noise scale
		@param NoiseScale Noise scale

</member>
        <member name="M:SkyX.VClouds.VClouds.getCloudFieldScale">
Get cloud field scale
		@return Cloud field scale

</member>
        <member name="M:SkyX.VClouds.VClouds.setCloudFieldScale(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set cloud field scale
		@param CloudFieldScale Cloud field scale

</member>
        <member name="M:SkyX.VClouds.VClouds.getGlobalOpacity">
Get global opacity
		@return Global opacity

</member>
        <member name="M:SkyX.VClouds.VClouds.setGlobalOpacity(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set global opacity
		@param GlobalOpacity Global opacity: [0,1] range 0-&gt;Transparent cloud field

</member>
        <member name="M:SkyX.VClouds.VClouds.getAmbientFactors">
Get ambient factors
		@return Ambient factors

</member>
        <member name="M:SkyX.VClouds.VClouds.setAmbientFactors(Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set ambient factors
		@param AmbientFactors x - constant, y - linear, z - cuadratic, w - cubic

</member>
        <member name="M:SkyX.VClouds.VClouds.getLightResponse">
Get light response
		@return Light response

</member>
        <member name="M:SkyX.VClouds.VClouds.setLightResponse(Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set light response
		@param LightResponse
		x - Sun light power
		y - Sun beta multiplier
		z - Ambient color multiplier
		w - Distance attenuation

</member>
        <member name="M:SkyX.VClouds.VClouds.getAmbientColor">
Get Ambient color
		@return Ambient color

</member>
        <member name="M:SkyX.VClouds.VClouds.setAmbientColor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set ambient color
		@param AmbientColor Ambient color

</member>
        <member name="M:SkyX.VClouds.VClouds.getSunColor">
Get sun color
		@return Sun color

</member>
        <member name="M:SkyX.VClouds.VClouds.setSunColor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set sun color
		@param SunColor Sun color

</member>
        <member name="M:SkyX.VClouds.VClouds.getSunDirection">
Get sun direction
		@return Sun direction

</member>
        <member name="M:SkyX.VClouds.VClouds.setSunDirection(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set sun direction
		@param SunDirection Sun direction

</member>
        <member name="M:SkyX.VClouds.VClouds.getWindSpeed">
Get wind speed
		@return Wind speed

</member>
        <member name="M:SkyX.VClouds.VClouds.setWindSpeed(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set wind speed
		@param WindSpeed Wind speed

</member>
        <member name="M:SkyX.VClouds.VClouds.getWindDirectionV2">
Get wind direction as a Vector2
		@return Wind direction

</member>
        <member name="M:SkyX.VClouds.VClouds.getWindDirection">
Get wind direction
		@return Wind direction

</member>
        <member name="M:SkyX.VClouds.VClouds.setWindDirection(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set wind direction
		@param WindDirection Wind direction

</member>
        <member name="M:SkyX.VClouds.VClouds.getRenderQueueGroups">
Get render queue groups
		@return Current render queue groups

</member>
        <member name="M:SkyX.VClouds.VClouds.setRenderQueueGroups(SkyX.VClouds.VClouds.RenderQueueGroups!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set render queue groups
		@param rqg Render queue groups

</member>
        <member name="M:SkyX.VClouds.VClouds.getDistanceFallingParams">
Get distance falling params
		@return DistanceFallingParams.x = Distance falling factor (How much the cloud field geometry falls with the distance)
		Remember that the geometry falling is relative to the distance(height) between the camera
		and the cloud field.
		Typical range is [0, ~2] 0 = no falling
		DistanceFallingParams.y = Max falling (in world coords), useful when , i.e., you've water and you want to go in. 
		That param will allow you to avoid the cloud field geometry falls into the ocean. 
		-1 means not max falling. (default)
		@remarks See GoemetryBlock::_setVertexData(...) for more info

</member>
        <member name="M:SkyX.VClouds.VClouds.setDistanceFallingParams(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set distance falling params
		@param DistanceFallingParams
		DistanceFallingParams.x = Distance falling factor (How much the cloud field geometry falls with the distance)
		Remember that the geometry falling is relative to the distance(height) between the camera
		and the cloud field. Typical range is [0, ~2] 0 = no falling
		DistanceFallingParams.y = Max falling (in world coords), useful when , i.e., you've water and you want to go in. 
		That param will allow you to avoid the cloud field geometry falls into the ocean. 
		-1 means not max falling. (default)
		@remarks See GoemetryBlock::_setVertexData(...) for more info

</member>
        <member name="M:SkyX.VClouds.VClouds.getGeometrySettings">
Get geometry settings
		@return Geometry settings

</member>
        <member name="M:SkyX.VClouds.VClouds.setGeometrySettings(SkyX.VClouds.VClouds.GeometrySettings!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set geometry settings
		@param GeometrySettings Geometry settings
		@remarks Set geometry settings before call create(...)

</member>
        <member name="M:SkyX.VClouds.VClouds.isCreated">
Has been create() already called?
		@return true if created() have been already called, false if not

</member>
        <member name="M:SkyX.VClouds.VClouds.unregisterCamera(Ogre.Camera*)">
Unregister camera
		@param c Camera
		@remarks After having used a camera (i.e. before removing the camera), the user should manually unregister it

</member>
        <member name="M:SkyX.VClouds.VClouds.registerCamera(Ogre.Camera*)">
Register camera
		@param c Camera
		@remarks If a rendering camera is used(in notifyCameraRender(...)) without having registered it before,
		all will work as expected but a warning will be logged since the user should manually unregister 
		the camera one time it'll be remove

</member>
        <member name="M:SkyX.VClouds.VClouds.notifyCameraRender(Ogre.Camera*,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Notify camera render, to be invoked per-camera and per-frame
		@param c Rendering camera
		@param timeSinceLastCameraFrame Time since last CAMERA frame

</member>
        <member name="M:SkyX.VClouds.VClouds.update(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update, to be invoked per frame
		@param timeSinceLastFrame Time since last frame

</member>
        <member name="M:SkyX.VClouds.VClouds.remove">
Remove

</member>
        <member name="M:SkyX.VClouds.VClouds.create(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create
		@param Height x = Cloud field y-coord start, y: Field height (both in world coordinates)
		@param Radius Radius

</member>
        <member name="M:SkyX.VClouds.VClouds.create(SkyX.VClouds.VClouds.GeometrySettings!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create
		@param gs Geometry settings

</member>
        <member name="M:SkyX.VClouds.VClouds.create">
Create

</member>
        <member name="M:SkyX.VClouds.VClouds.Dispose">
Destructor

</member>
        <member name="M:SkyX.VClouds.VClouds.#ctor(Ogre.SceneManager*)">
Simple constructor
		@param sm Scene manager 

</member>
        <member name="F:SkyX.VClouds.VClouds.CameraData.geometryDisplacement">
Geometry displacement
</member>
        <member name="F:SkyX.VClouds.VClouds.CameraData.cameraOffset">
Camera offset
</member>
        <member name="F:SkyX.VClouds.VClouds.CameraData.lastPosition">
Last camera position
</member>
        <member name="F:SkyX.VClouds.VClouds.CameraData.camera">
Camera
</member>
        <member name="M:SkyX.VClouds.VClouds.CameraData.#ctor(Ogre.Camera*)">
Constructor
			@param c Camera

</member>
        <member name="M:SkyX.VClouds.VClouds.CameraData.#ctor">
Default constructor

</member>
        <member name="T:SkyX.VClouds.VClouds.CameraData">
Camera data struct

</member>
        <member name="M:SkyX.VClouds.VClouds.GeometrySettings.#ctor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runti">
Constructor
			@param _Height x = Cloud field y-coord start, y: Field height (both in world coordinates)
			@param _Radius Radius
			@param _Alpha Alpha angle
			@param _Beta Beta angle
			@param _NumberOfBlocks Number of geometry blocks
			@param _Na Number of slices in A zone
			@param _Nb Number of slices in B zone
			@param _Nc Number of slices in C zone

</member>
        <member name="M:SkyX.VClouds.VClouds.GeometrySettings.#ctor">
Default constructor

</member>
        <member name="F:SkyX.VClouds.VClouds.GeometrySettings.Na">
Number of slices per geometry zone
</member>
        <member name="F:SkyX.VClouds.VClouds.GeometrySettings.NumberOfBlocks">
Number of blocks
</member>
        <member name="F:SkyX.VClouds.VClouds.GeometrySettings.Radius">
Radius
</member>
        <member name="F:SkyX.VClouds.VClouds.GeometrySettings.Alpha">
Angles
</member>
        <member name="F:SkyX.VClouds.VClouds.GeometrySettings.Height">
Height: x = Altitude over the camera, y: Field height (both in world coordinates)
</member>
        <member name="T:SkyX.VClouds.VClouds.GeometrySettings">
Geometry settings

</member>
        <member name="F:SkyX.VClouds.VClouds.RenderQueueGroups.vcloudsLightnings">
VClouds lightnings render queue group
</member>
        <member name="F:SkyX.VClouds.VClouds.RenderQueueGroups.vclouds">
VClouds render queue group
</member>
        <member name="M:SkyX.VClouds.VClouds.RenderQueueGroups.#ctor(System.Byte!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor
			@param vc VClouds render queue group
			@param vcl VClouds lightnings render queue group

</member>
        <member name="T:SkyX.VClouds.VClouds.RenderQueueGroups">
Render queue groups

</member>
        <member name="F:SkyX.VClouds.LightningManager.mVClouds">
VClouds pointer
</member>
        <member name="F:SkyX.VClouds.LightningManager.mCreated">
Has been create() already called?
</member>
        <member name="F:SkyX.VClouds.LightningManager.mListeners">
Listeners
</member>
        <member name="F:SkyX.VClouds.LightningManager.mLightningMaterial">
Lightning material
</member>
        <member name="F:SkyX.VClouds.LightningManager.mVolCloudsLightningMaterial">
Vol. clouds + lightning material
</member>
        <member name="F:SkyX.VClouds.LightningManager.mRemainingTime">
Remaining time for next lightning
</member>
        <member name="F:SkyX.VClouds.LightningManager.mAverageLightningApparitionTime">
Average lightning apparition time (in seconds)
</member>
        <member name="F:SkyX.VClouds.LightningManager.mLightningTimeMultiplier">
Lightning time multiplier
</member>
        <member name="F:SkyX.VClouds.LightningManager.mLightningColor">
Lightning color
</member>
        <member name="F:SkyX.VClouds.LightningManager.mEnabled">
Is the lightning system enabled?
</member>
        <member name="F:SkyX.VClouds.LightningManager.mSceneNodes">
Scene nodes
</member>
        <member name="F:SkyX.VClouds.LightningManager.mLightnings">
Lightnings
</member>
        <member name="M:SkyX.VClouds.LightningManager._setVisible(System.Boolean!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set visible
		@param v Visible?
		@remarks Only for internal use. Use VClouds::setVisible(...) instead.

</member>
        <member name="M:SkyX.VClouds.LightningManager._updateRenderQueueGroup(System.Byte!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update render queue group
		@param rqg Render queue group
		@remarks Only for internal use. Use VClouds::setRenderQueueGroups(...) instead.

</member>
        <member name="M:SkyX.VClouds.LightningManager.isCreated">
Has been create() already called?
		@return true if created() have been already called, false if not

</member>
        <member name="M:SkyX.VClouds.LightningManager.getAverageLightningApparitionTime">
Get average lightning apparition time
		@return Average lightning apparition time

</member>
        <member name="M:SkyX.VClouds.LightningManager.setAverageLightningApparitionTime(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set average lightning apparition time
		@param alat Average lightning apparition time

</member>
        <member name="M:SkyX.VClouds.LightningManager.getLightningTimeMultiplier">
Set lightning time multiplier
		@return Lightning time multiplier

</member>
        <member name="M:SkyX.VClouds.LightningManager.setLightningTimeMultiplier(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set lightning time multiplier
		@param c Lightning time multiplier
		@remarks Changes applies to new lightnings, not to existing ones

</member>
        <member name="M:SkyX.VClouds.LightningManager.getLightningColor">
Get lightning color
		@return Lightning color

</member>
        <member name="M:SkyX.VClouds.LightningManager.setLightningColor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set lightning color
		@param c Lightning color

</member>
        <member name="M:SkyX.VClouds.LightningManager.isEnabled">
Get whether the lightning system is enabled or not
		@return true if the lightning system is enabled, false otherwise
		@remarks Even if the lightning system is disabled, you'll be able to manually add lightnings trhough LightningManager::addLightning(...)

</member>
        <member name="M:SkyX.VClouds.LightningManager.setEnabled(System.Boolean!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Enable or disable the lightning system
		@param enable true to enable the lightning system, false otherwise

</member>
        <member name="M:SkyX.VClouds.LightningManager.getListeners">
Get listeners
		@return Listeners

</member>
        <member name="M:SkyX.VClouds.LightningManager.removeListeners">
Remove listeners

</member>
        <member name="M:SkyX.VClouds.LightningManager.removeListener(SkyX.VClouds.LightningManager.Listener*)">
Remove listener
		@param listener Listener to be removed

</member>
        <member name="M:SkyX.VClouds.LightningManager.addListener(SkyX.VClouds.LightningManager.Listener*)">
Add listener
		@param listener Listener

</member>
        <member name="M:SkyX.VClouds.LightningManager.updateMaterial">
Update material
		@remarks To be invoked before each camera rendering process

</member>
        <member name="M:SkyX.VClouds.LightningManager.addLightning(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add lightning
		@param p Lightning position
		@param d Lightning direction
		@param l Lightning length
		@return The lightning or null in error case (the max number of simultaneous lightnings is 3)
		@remarks The lightning will be automatically destroyed one time it'll be finished, so the returned ptr will not
		be available one time the lightning will have disappeared

</member>
        <member name="M:SkyX.VClouds.LightningManager.update(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update, to be invoked per frame
		@param timeSinceLastFrame Time since last frame

</member>
        <member name="M:SkyX.VClouds.LightningManager.remove">
Remove

</member>
        <member name="M:SkyX.VClouds.LightningManager.create">
Create

</member>
        <member name="M:SkyX.VClouds.LightningManager.Dispose">
Destructor

</member>
        <member name="M:SkyX.VClouds.LightningManager.#ctor(SkyX.VClouds.VClouds*)">
Constructor
		@param vc VClouds pointer

</member>
        <member name="M:SkyX.VClouds.LightningManager.Listener.lightningAdded(SkyX.VClouds.Lightning*)">
Lightning added
			@param l Lightning that has been added
			@remarks Useful when, for example, the app needs to known when a Lightning has been created (by manually
			invoking LightningManager::addLightning(...) or automatically based on the lightning creation
			probabilities) in order to play a sound, etc.
			The lightning position is accessible through Lightning::getSceneNode()-&gt;getPosition().

</member>
        <member name="T:SkyX.VClouds.LightningManager.Listener">
Listener class

</member>
        <member name="F:SkyX.VClouds.Lightning.mFinished">
Has the ray finished?
</member>
        <member name="F:SkyX.VClouds.Lightning.mCreated">
Has been create() already called?
</member>
        <member name="F:SkyX.VClouds.Lightning.mSceneNode">
Scene node
</member>
        <member name="F:SkyX.VClouds.Lightning.mSceneManager">
Scene manager
</member>
        <member name="F:SkyX.VClouds.Lightning.mBillboardSet">
Billboard set
</member>
        <member name="F:SkyX.VClouds.Lightning.mChildren">
Children lightnings
</member>
        <member name="F:SkyX.VClouds.Lightning.mSegments">
Segments
</member>
        <member name="F:SkyX.VClouds.Lightning.mIntensity">
Lightning intensity
</member>
        <member name="F:SkyX.VClouds.Lightning.mTimeMultipliers">
Per step time multipliers
</member>
        <member name="F:SkyX.VClouds.Lightning.mTimeMultiplier">
Global time multiplier
</member>
        <member name="F:SkyX.VClouds.Lightning.mTime">
Current elapsed time
</member>
        <member name="F:SkyX.VClouds.Lightning.mAngleRange">
Angle range (Little values -&gt; Less derivations, bigger values -&gt; More derivations)
</member>
        <member name="F:SkyX.VClouds.Lightning.mBounds">
Ray bounds (for internal visual calculations)
</member>
        <member name="F:SkyX.VClouds.Lightning.mWidthMultiplier">
Width multiplier
</member>
        <member name="F:SkyX.VClouds.Lightning.mRecursivity">
Recursivity level
</member>
        <member name="F:SkyX.VClouds.Lightning.mDivisions">
Number of divisions
</member>
        <member name="F:SkyX.VClouds.Lightning.mRealLength">
Real ray length (total segments length amount)
</member>
        <member name="F:SkyX.VClouds.Lightning.mLength">
Ray length
</member>
        <member name="F:SkyX.VClouds.Lightning.mDirection">
Ray direction
</member>
        <member name="F:SkyX.VClouds.Lightning.mOrigin">
Ray origin
</member>
        <member name="M:SkyX.VClouds.Lightning._updateData(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update data
		@param alpha Alpha
		@param currentPos Current position
		@param parentTime Parent time

</member>
        <member name="M:SkyX.VClouds.Lightning._updateRenderQueueGroup(System.Byte!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update render queue group
		@param rqg Render queue group
		@remarks Only for internal use. Use VClouds::setRenderQueueGroups(...) instead.

</member>
        <member name="M:SkyX.VClouds.Lightning.isFinished">
Has the ray finished?
		@return true if the ray has finished, false otherwise

</member>
        <member name="M:SkyX.VClouds.Lightning.getSceneNode">
Get scene node
		@return Scene node

</member>
        <member name="M:SkyX.VClouds.Lightning.getBillboardSet">
Get billboard set
		@return Billboard set

</member>
        <member name="M:SkyX.VClouds.Lightning.getIntensity">
Get lightning intensity
		@return Lightning intensity

</member>
        <member name="M:SkyX.VClouds.Lightning.getLength">
Get ray length
		@return Ray length

</member>
        <member name="M:SkyX.VClouds.Lightning.getDirection">
Get ray direction
		@return Ray direction

</member>
        <member name="M:SkyX.VClouds.Lightning.update(System.Single)">
Update
		@param timeSinceLastFrame Time since last frame

</member>
        <member name="M:SkyX.VClouds.Lightning.remove">
Remove

</member>
        <member name="M:SkyX.VClouds.Lightning.create">
Create

</member>
        <member name="M:SkyX.VClouds.Lightning.Dispose">
Destructor

</member>
        <member name="M:SkyX.VClouds.Lightning.#ctor(Ogre.SceneManager*,Ogre.SceneNode*,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServ">
Constructor
		@param sm Scene manager
		@param sn Scene node
		@param or Lighting origin
		@param dir Lighting direction
		@param l Lighting lenth
		@param d Divisions
		@param rec Recursivity level
		@param tm Time multiplier
		@param wm Width multiplier
		@param b Bounds

</member>
        <member name="F:SkyX.VClouds.Lightning.Segment.b">
Segment end
</member>
        <member name="F:SkyX.VClouds.Lightning.Segment.a">
Segment start
</member>
        <member name="M:SkyX.VClouds.Lightning.Segment.#ctor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor
			@param a_ First segment point (Start)
			@param b_ Second segment point (End)

</member>
        <member name="M:SkyX.VClouds.Lightning.Segment.#ctor">
Default constructor

</member>
        <member name="T:SkyX.VClouds.Lightning.Segment">
Segment struct

</member>
        <member name="F:SkyX.VClouds.GeometryManager.mVClouds">
VClouds pointer
</member>
        <member name="F:SkyX.VClouds.GeometryManager.mSceneNode">
Scene node
</member>
        <member name="F:SkyX.VClouds.GeometryManager.mGeometryBlocks">
Geometry blocks
</member>
        <member name="F:SkyX.VClouds.GeometryManager.mWorldOffset">
World coords offset
</member>
        <member name="F:SkyX.VClouds.GeometryManager.mA">
A, B and C radius
</member>
        <member name="F:SkyX.VClouds.GeometryManager.mNa">
Number of slices per geometry zone
</member>
        <member name="F:SkyX.VClouds.GeometryManager.mNumberOfBlocks">
Number of blocks
</member>
        <member name="F:SkyX.VClouds.GeometryManager.mPhi">
Azimutal angle per block
</member>
        <member name="F:SkyX.VClouds.GeometryManager.mRadius">
Radius
</member>
        <member name="F:SkyX.VClouds.GeometryManager.mAlpha">
Angles
</member>
        <member name="F:SkyX.VClouds.GeometryManager.mHeight">
Height: x = Altitude over the camera, y: Field height (both in world coordinates)
</member>
        <member name="F:SkyX.VClouds.GeometryManager.mCreated">
Has been create() already called?
</member>
        <member name="M:SkyX.VClouds.GeometryManager._updateGeometry(Ogre.Camera*,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update geometry
		    @param c Camera
		    @param timeSinceLastFrame Time since last frame

</member>
        <member name="M:SkyX.VClouds.GeometryManager._createGeometry">
Create geometry

</member>
        <member name="M:SkyX.VClouds.GeometryManager._updateRenderQueueGroup(System.Byte!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update render queue group
		    @param rqg Render queue group
		    @remarks Only for internal use. Use VClouds::setRenderQueueGroups(...) instead.

</member>
        <member name="M:SkyX.VClouds.GeometryManager._setMaterialName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set material name
		    @param mn Material name
		    @remarks Only for internal use

</member>
        <member name="M:SkyX.VClouds.GeometryManager.getSceneNode">
Get scene node
		    @return Scene node

</member>
        <member name="M:SkyX.VClouds.GeometryManager.isCreated">
Has been create() already called?
		    @return true if created() have been already called, false if not

</member>
        <member name="M:SkyX.VClouds.GeometryManager.updateGeometry(Ogre.Camera*,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update geoemtry
		    @param c Camera
		    @param timeSinceLastCameraFrame Time since last CAMERA frame

</member>
        <member name="M:SkyX.VClouds.GeometryManager.update(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update, to be invoked per frame
		    @param timeSinceLastFrame Time since last frame

</member>
        <member name="M:SkyX.VClouds.GeometryManager.remove">
Remove

</member>
        <member name="M:SkyX.VClouds.GeometryManager.create(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.Compi">
Create
		    @param Height x = Field altitude, y: Field height (both in world coordinates)
			@param Radius Radius
			@param Alpha Alpha angle
			@param Beta Beta angle
			@param NumberOfBlocks Number of geometry blocks
			@param Na Number of slices in A zone
			@param Nb Number of slices in B zone
			@param Nc Number of slices in C zone

</member>
        <member name="M:SkyX.VClouds.GeometryManager.Dispose">
Destructor

</member>
        <member name="M:SkyX.VClouds.GeometryManager.#ctor(SkyX.VClouds.VClouds*)">
Constructor
			@param vc VClouds pointer

</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mLastFallingDistance">
Last falling distance
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mCamera">
Current rendering camera
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mVClouds">
VClouds pointer
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mWorldOffset">
World coords offset
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mDisplacement">
Displacement
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mBetaSin">
PI - Beta, PI - Alpha Sin
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mV2Cos">
Precomputed Cos/Sin vectors
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mPosition">
Number of block(Position)
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mA">
A, B and C radius
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mNa">
Number of slices per geometry zone
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mPhi">
Acimutal angle
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mRadius">
Radius
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mAlpha">
Angles
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mHeight">
Height
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mVertexCount">
Vertex count
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mNumberOfTriangles">
Current number of triangles
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mVertices">
Vertices pointer
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mIndexBuffer">
Index buffer
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mVertexBuffer">
Vertex buffer
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mEntity">
Ogre::Entity pointer
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mSubMesh">
Ogre::Submesh pointer
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mMesh">
Ogre::MeshPtr
</member>
        <member name="F:SkyX.VClouds.GeometryBlock.mCreated">
Has been create() already called?
</member>
        <member name="M:SkyX.VClouds.GeometryBlock._setVertexData(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set vertex data
			@param index Vertex index
			@param o Slice opacity
			@param p Position

</member>
        <member name="M:SkyX.VClouds.GeometryBlock._updateZoneASlice(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update zone A slice
		    @param n Number of slice

</member>
        <member name="M:SkyX.VClouds.GeometryBlock._updateZoneBSlice(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update zone B slice
		    @param n Number of slice

</member>
        <member name="M:SkyX.VClouds.GeometryBlock._updateZoneCSlice(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update zone C slice
		    @param n Number of slice

</member>
        <member name="M:SkyX.VClouds.GeometryBlock._updateGeometry">
Update geometry

</member>
        <member name="M:SkyX.VClouds.GeometryBlock._createGeometry">
Create geometry

</member>
        <member name="M:SkyX.VClouds.GeometryBlock._calculateDataSize">
Calculate data size

</member>
        <member name="M:SkyX.VClouds.GeometryBlock._buildAABox(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Build axis aligned box
		    @param fd Falling distance (Positive values for falling geometry, negative for reverse falling geometry)

</member>
        <member name="M:SkyX.VClouds.GeometryBlock.isInFrustum(Ogre.Camera*)">
Is the geometry block inside the camera frustum?
		    @param c Camera
			@return true if yes, false if not

</member>
        <member name="M:SkyX.VClouds.GeometryBlock.setWorldOffset(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set world offset
		    @param WorldOffset World offset

</member>
        <member name="M:SkyX.VClouds.GeometryBlock.getHardwareIndexBuffer">
Get hardware index buffer reference
		    @return Ogre::HardwareIndexBufferSharedPtr reference

</member>
        <member name="M:SkyX.VClouds.GeometryBlock.getHardwareVertexBuffer">
Get hardware vertex buffer reference
            @return Ogre::HardwareVertexBufferSharedPtr reference

</member>
        <member name="M:SkyX.VClouds.GeometryBlock.getEntity">
Get entity
            @return Entity

</member>
        <member name="M:SkyX.VClouds.GeometryBlock.getSubMesh">
Get sub mesh
            @return Sub mesh

</member>
        <member name="M:SkyX.VClouds.GeometryBlock.getMesh">
Get mesh
            @return Mesh

</member>
        <member name="M:SkyX.VClouds.GeometryBlock.isCreated">
Has been create() already called?
		    @return true if created() have been already called, false if not

</member>
        <member name="M:SkyX.VClouds.GeometryBlock.updateGeometry(Ogre.Camera*,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update geometry
		    @param c Camera
		    @param displacement Current offset in world units per zone

</member>
        <member name="M:SkyX.VClouds.GeometryBlock.remove">
Remove

</member>
        <member name="M:SkyX.VClouds.GeometryBlock.create">
Create

</member>
        <member name="M:SkyX.VClouds.GeometryBlock.Dispose">
Destructor

</member>
        <member name="M:SkyX.VClouds.GeometryBlock.#ctor(SkyX.VClouds.VClouds*,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!S">
Constructor
			@param vc VClouds pointer
			@param Height Field height (in woorld coordinates)
			@param Alpha Alpha angle
			@param Beta Beta angle
			@param Radius Total radius
			@param Phi Actimutal angle
			@param Na Number of slices in A zone
			@param Nb Number of slices in B zone
			@param Nc Number of slices in C zone
			@param A A radius
			@param B B radius
			@param C C radius

</member>
        <member name="T:SkyX.VClouds.GeometryBlock.VERTEX">
Vertex struct

</member>
        <member name="P:MSkyX.CloudsManager.CloudLayers">
            <summary>Get cloud layers.</summary>
            <returns>Cloud layers.</returns>
        </member>
        <member name="M:MSkyX.CloudsManager.UnregisterAll">
            <summary>Unregister all cloud layers.</summary>
        </member>
        <member name="M:MSkyX.CloudsManager.Unregister(MSkyX.CloudLayer)">
            <summary>Unregister cloud layer.</summary>
            <param name="cl">Cloud layer to be unregistered.</param>
        </member>
        <member name="M:MSkyX.CloudsManager.RegisterAll">
            <summary>Register all.</summary>
        </member>
        <member name="M:MSkyX.CloudsManager.RemoveAll">
            <summary>Remove all cloud layers.</summary>
        </member>
        <member name="M:MSkyX.CloudsManager.Remove(MSkyX.CloudLayer)">
            <summary>Remove the specified cloud layer.</summary>
            <param name="cl">Cloud layer to remove.</param>
        </member>
        <member name="M:MSkyX.CloudsManager.Add(MSkyX.CloudLayer.Options)">
            <summary>Add a cloud layer.</summary>
            <param name="o">Cloud layer options.</param>
            <returns>Cloud layer.</returns>
        </member>
        <member name="M:MSkyX.CloudsManager.Update">
            <summary>Update cloud layers.</summary>
        </member>
        <member name="P:MSkyX.CloudLayer.SunGradient">
            <summary>Get/Set sun gradient.</summary>
            <param name="value">Sun color gradient.</param>
            <returns>Sun color gradient.</returns>
        </member>
        <member name="P:MSkyX.CloudLayer.AmbientGradient">
            <summary>Get/Set ambient gradient.</summary>
            <param name="value">Ambient color gradient.</param>
            <returns>Ambient color gradient.</returns>
        </member>
        <member name="P:MSkyX.CloudLayer.CurrentOptions">
            <summary>Get/Set options.</summary>
            <param name="value">New options.</param>
            <returns>Cloud layer options.</returns>
        </member>
        <member name="M:MSkyX.CloudLayer.#ctor(CLRObject*)">
            <summary>Copy constructor.</summary>
            <param name="obj">SkyX::CloudLayer to copy data from.</param>
        </member>
        <member name="F:MSkyX.CloudLayer.Options.DEFAULT">
            <summary>Default cloud layer options.</summary>
        </member>
        <member name="M:MSkyX.CloudLayer.Options.#ctor(System.Single,System.Single,Mogre.Vector2,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Constructor</summary>
            <param name="_Height">Cloud layer height.</param>
            <param name="_Scale">Cloud scale.</param>
            <param name="_WindDirection">Cloud movement direction.</param>
            <param name="_TimeMultiplier">Time multiplier factor.</param>
            <param name="_DistanceAttenuation">Distance attenuation.</param>
            <param name="_DetailAttenuation">Detail attenuation.</param>
            <param name="_HeightVolume">Height volume(For volumetric effects on the gpu).</param>
            <param name="_VolumetricDisplacement">Volumetric displacement(For volumetric effects on the gpu).</param>
        </member>
        <member name="M:MSkyX.CloudLayer.Options.#ctor(System.Single,System.Single,Mogre.Vector2,System.Single)">
            <summary>Constructor</summary>
            <param name="_Height">Cloud layer height.</param>
            <param name="_Scale">Cloud scale.</param>
            <param name="_WindDirection">Cloud movement direction.</param>
            <param name="_TimeMultiplier">Time multiplier factor.</param>
        </member>
        <member name="F:MSkyX.CloudLayer.Options.VolumetricDisplacement">
            <summary>Volumetric displacement(For volumetric effects on the gpu).</summary>
        </member>
        <member name="F:MSkyX.CloudLayer.Options.HeightVolume">
            <summary>Cloud layer height volume(For volumetric effects on the gpu).</summary>
        </member>
        <member name="F:MSkyX.CloudLayer.Options.DetailAttenuation">
            <summary>Detail attenuation.</summary>
        </member>
        <member name="F:MSkyX.CloudLayer.Options.DistanceAttenuation">
            <summary>Distance attenuation.</summary>
        </member>
        <member name="F:MSkyX.CloudLayer.Options.TimeMultiplier">
            <summary>Time multiplier.</summary>
        </member>
        <member name="F:MSkyX.CloudLayer.Options.WindDirection">
            <summary>Wind direction.</summary>
        </member>
        <member name="F:MSkyX.CloudLayer.Options.Scale">
            <summary>Cloud layer scale.</summary>
        </member>
        <member name="F:MSkyX.CloudLayer.Options.Height">
            <summary>Cloud layer height.</summary>
        </member>
        <member name="T:MSkyX.CloudLayer.Options">
            <summary>
Struct wich contains a render queue groups.
</summary>
        </member>
        <member name="F:SkyX.ColorGradient.CFrameVector">
Color frame vector
</member>
        <member name="F:SkyX.ColorGradient.mMalFormed">
Mal formed color gradient?
</member>
        <member name="M:SkyX.ColorGradient._checkBounds">
Check bounds
		@return false if the Color gradient is mal-formed

</member>
        <member name="M:SkyX.ColorGradient.getColor(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get color value
		@param p The gradient point in [0,1] range
		@return Color at the given gradient position

</member>
        <member name="M:SkyX.ColorGradient.clear">
Clear color gradient

</member>
        <member name="M:SkyX.ColorGradient.addCFrame(std.pair&lt;Ogre.Vector3,System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add color frame
		@param CFrame Color frame

</member>
        <member name="M:SkyX.ColorGradient.Dispose">
Destructor 

</member>
        <member name="M:SkyX.ColorGradient.#ctor">
Constructor

</member>
        <member name="D:SkyX.ColorGradient.ColorFrame">
Color frame type definition
		ColorFrame.first: Colour value
		ColorFrame.second: Position in the gradient [0,1] range

</member>
        <member name="P:MSkyX.MoonManager.IsCreated">
            <summary>Is moon manager created?</summary>
            <returns>True if yes, false if not.</returns>
        </member>
        <member name="P:MSkyX.MoonManager.MoonHaloStrength">
            <summary>Get/Set moon halo strength.</summary>
            <param name="value">Moon halo strength (linear/exponential fading).</param>
            <returns>Moon halo strength (linear/exponential fading).</returns>
        </member>
        <member name="P:MSkyX.MoonManager.MoonHaloIntensity">
            <summary>Get/Set moon halo intensity.</summary>
            <param name="value">Moon halo intensity.</param>
            <returns>Moon halo intensity.</returns>
        </member>
        <member name="P:MSkyX.MoonManager.MoonSize">
            <summary>Get/Set moon size.</summary>
            <param name="value">Moon size.</param>
            <returns>Moon size.</returns>
        </member>
        <member name="P:MSkyX.MoonManager.MoonSceneNode">
            <summary>Get moon scene node.</summary>
            <returns>Moon scene node.</returns>
        </member>
        <member name="P:MSkyX.MoonManager.MoonBillboard">
            <summary>Get moon billboard.</summary>
            <returns>Moon billboard.</returns>
        </member>
        <member name="M:MSkyX.MoonManager.UpdateGeometry(Mogre.Camera)">
            <summary>Update geometry.</summary>
            <param name="c">Camera.</param>
        </member>
        <member name="M:MSkyX.MoonManager.UpdateMoonPhase(System.Single)">
            <summary>Update moon phase.</summary>
            <param name="">Moon phase in [-1,1] range, where -1 means fully covered Moon, 0 clear Moon and 1 fully covered Moon.</param>
        </member>
        <member name="M:MSkyX.MoonManager.Remove">
            <summary>Remove all resources.</summary>
        </member>
        <member name="M:MSkyX.MoonManager.Create">
            <summary>Create all resources.</summary>
        </member>
        <member name="P:MSkyX.GPUManager.MoonMaterialName">
            <summary>Get moon material name.</summary>
            <returns>Moon material name.</returns>
        </member>
        <member name="P:MSkyX.GPUManager.SkydomeMaterialName">
            <summary>Get skydome material name.</summary>
            <returns>Skydome material name.</returns>
        </member>
        <member name="M:MSkyX.GPUManager.SetGpuProgramParameter(MSkyX.GPUManager.GpuProgram,System.String,Mogre.Vector3,System.Boolean)">
            <summary />
            <param name="GpuP">Gpu program type (Vertex/Fragment).</param>
            <param name="Name">Param name.</param>
            <param name="Value">Param value.</param>
            <param name="UpdateGroundPasses">True to update ground passes.</param>
        </member>
        <member name="M:MSkyX.GPUManager.SetGpuProgramParameter(MSkyX.GPUManager.GpuProgram,System.String,Mogre.Vector3)">
            <summary />
            <param name="GpuP">Gpu program type (Vertex/Fragment).</param>
            <param name="Name">Param name.</param>
            <param name="Value">Param value.</param>
        </member>
        <member name="M:MSkyX.GPUManager.SetGpuProgramParameter(MSkyX.GPUManager.GpuProgram,System.String,Mogre.Vector2,System.Boolean)">
            <summary />
            <param name="GpuP">Gpu program type (Vertex/Fragment).</param>
            <param name="Name">Param name.</param>
            <param name="Value">Param value.</param>
            <param name="UpdateGroundPasses">True to update ground passes.</param>
        </member>
        <member name="M:MSkyX.GPUManager.SetGpuProgramParameter(MSkyX.GPUManager.GpuProgram,System.String,Mogre.Vector2)">
            <summary />
            <param name="GpuP">Gpu program type (Vertex/Fragment).</param>
            <param name="Name">Param name.</param>
            <param name="Value">Param value.</param>
        </member>
        <member name="M:MSkyX.GPUManager.SetGpuProgramParameter(MSkyX.GPUManager.GpuProgram,System.String,System.Single,System.Boolean)">
            <summary />
            <param name="GpuP">Gpu program type (Vertex/Fragment).</param>
            <param name="Name">Param name.</param>
            <param name="Value">Param value.</param>
            <param name="UpdateGroundPasses">True to update ground passes.</param>
        </member>
        <member name="M:MSkyX.GPUManager.SetGpuProgramParameter(MSkyX.GPUManager.GpuProgram,System.String,System.Single)">
            <summary />
            <param name="GpuP">Gpu program type (Vertex/Fragment).</param>
            <param name="Name">Param name.</param>
            <param name="Value">Param value.</param>
        </member>
        <member name="M:MSkyX.GPUManager.SetGpuProgramParameter(MSkyX.GPUManager.GpuProgram,System.String,System.Int32,System.Boolean)">
            <summary>Set native program int parameter</summary>
            <param name="GpuP">Gpu program type (Vertex/Fragment).</param>
            <param name="Name">Param name.</param>
            <param name="Value">Param value.</param>
            <param name="UpdateGroundPasses">True to update ground passes.</param>
        </member>
        <member name="M:MSkyX.GPUManager.SetGpuProgramParameter(MSkyX.GPUManager.GpuProgram,System.String,System.Int32)">
            <summary>Set native program int parameter</summary>
            <param name="GpuP">Gpu program type (Vertex/Fragment).</param>
            <param name="Name">Param name.</param>
            <param name="Value">Param value.</param>
        </member>
        <member name="M:MSkyX.GPUManager.AddGroundPass(Mogre.Pass,System.Single,Mogre.SceneBlendType)">
            <summary>Add ground pass (Use for atmospheric scattering effect on the terrain).</summary>
            <param name="GroundPass">Ground pass.</param>
            <param name="AtmosphereRadius">Atmosphere radius (typically far carmera clip plane).</param>
            <param name="SBT">Scene blend type.</param>
        </member>
        <member name="M:MSkyX.GPUManager.AddGroundPass(Mogre.Pass,System.Single)">
            <summary>Add ground pass (Use for atmospheric scattering effect on the terrain).</summary>
            <param name="GroundPass">Ground pass.</param>
            <param name="AtmosphereRadius">Atmosphere radius (typically far carmera clip plane).</param>
        </member>
        <member name="F:MSkyX.GPUManager.GpuProgram.GPUP_FRAGMENT">
            <summary>Fragment program.</summary>
        </member>
        <member name="F:MSkyX.GPUManager.GpuProgram.GPUP_VERTEX">
            <summary>Vertex program.</summary>
        </member>
        <member name="T:MSkyX.GPUManager.GpuProgram">
            <summary>Gpu program enum.</summary>
        </member>
        <member name="M:MSkyX.AtmosphereManager.GetColorAt(Mogre.Vector3)">
            <summary>Get current atmosphere color at the given direction.</summary>
            <param name="Direction">*Normalised* direction.</param>
            <returns>Atmosphere color at the especified direction.</returns>
        </member>
        <member name="P:MSkyX.AtmosphereManager.CurrentOptions">
            <summary>Get/Set options</summary>
            <param name="value">New atmosfere options.</param>
            <returns>Current atmosfere options.</returns>
        </member>
        <member name="M:MSkyX.AtmosphereManager.#ctor(CLRObject*)">
            <summary>Copy constructor.</summary>
            <param name="obj">SkyX::AtmosphereManager to copy data from.</param>
            <remarks>For internal use only.</remarks>
        </member>
        <member name="F:MSkyX.AtmosphereManager.Options.DEFAULT">
            <summary>Default atmosphere options.</summary>
        </member>
        <member name="M:MSkyX.AtmosphereManager.Options.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Mogre.Vector3,System.Single,System.Single,System.Int32)">
            <summary>Constructor</summary>
            <param name="InnerRadius">Inner atmosphere radius.</param>
            <param name="OuterRadius">Outer atmosphere radius.</param>
            <param name="HeightPosition">Height position, in [0, 1] range, 0=InnerRadius, 1=OuterRadius.</param>
            <param name="RayleighMultiplier">Rayleigh multiplier.</param>
            <param name="MieMultiplier">Mie multiplier.</param>
            <param name="SunIntensity">Sun intensity.</param>
            <param name="WaveLength">Wave length for RGB channels.</param>
            <param name="G">Phase function.</param>
            <param name="Exposure">Exposure.</param>
            <param name="NumerOfSamples">Number of samples.</param>
        </member>
        <member name="F:MSkyX.AtmosphereManager.Options.NumberOfSamples">
            <summary>Number of samples</summary>
        </member>
        <member name="F:MSkyX.AtmosphereManager.Options.Exposure">
            <summary>Exposure coeficient</summary>
        </member>
        <member name="F:MSkyX.AtmosphereManager.Options.G">
            <summary>Phase function</summary>
        </member>
        <member name="F:MSkyX.AtmosphereManager.Options.WaveLength">
            <summary>WaveLength for RGB channels</summary>
        </member>
        <member name="F:MSkyX.AtmosphereManager.Options.SunIntensity">
            <summary>Sun intensity</summary>
        </member>
        <member name="F:MSkyX.AtmosphereManager.Options.MieMultiplier">
            <summary>Mie multiplier</summary>
        </member>
        <member name="F:MSkyX.AtmosphereManager.Options.RayleighMultiplier">
            <summary>Rayleigh multiplier</summary>
        </member>
        <member name="F:MSkyX.AtmosphereManager.Options.HeightPosition">
            <summary>Height position, in [0, 1] range, 0=InnerRadius, 1=OuterRadius</summary>
        </member>
        <member name="F:MSkyX.AtmosphereManager.Options.OuterRadius">
            <summary>Outer atmosphere radius</summary>
        </member>
        <member name="F:MSkyX.AtmosphereManager.Options.InnerRadius">
            <summary>Inner atmosphere radius</summary>
        </member>
        <member name="T:MSkyX.AtmosphereManager.Options">
            <summary>Struct wich contains an atmosphere options.</summary>
        </member>
        <member name="T:MSkyX.AtmosphereManager">
            <summary>Atmosphere manager.</summary>
        </member>
        <member name="P:MSkyX.MeshManager.UnderHorizonFadingMultiplier">
            <summary>Get under-horizon fading multiplier.</summary>
            <returns>Under-horizon fading multiplier.</returns>
        </member>
        <member name="P:MSkyX.MeshManager.UnderHorizonFadingExponent">
            <summary>Get under-horizon exponent fading.</summary>
            <returns>under-horizon exponent fading.</returns>
        </member>
        <member name="P:MSkyX.MeshManager.UnderHorizonFading">
            <summary>Get under-horizon fading.</summary>
            <returns>Under-horizon fading.</returns>
        </member>
        <member name="P:MSkyX.MeshManager.UnderHorizonCircles">
            <summary>Get under-horizon circles.</summary>
            <returns>Under-horizon circles.</returns>
        </member>
        <member name="M:MSkyX.MeshManager.SetUnderHorizonParams">
            <summary>Set under-horizon rendering params.</summary>
            <remarks> In an ideal situation, you only must see the avobe horizon sky due to the fact that the terrain/water must be 'infinite' and the under-horizont sky part is hide. But, infinite terrain/water is not always implemented in games and 3d apps in general, so... in order to get a good-looking sky, SkyX provides an approach to render realistic under-horizont sky.</remarks>
        </member>
        <member name="P:MSkyX.MeshManager.Circles">
            <summary>Get number of circles.</summary>
            <returns>Number of circles.</returns>
        </member>
        <member name="P:MSkyX.MeshManager.Steps">
            <summary>Get number of steps.</summary>
            <returns>Number of steps.</returns>
        </member>
        <member name="P:MSkyX.MeshManager.IsCreated">
            <summary>Is _createGeometry() called?</summary>
            <returns>True if created() have been already called.</returns>
        </member>
        <member name="P:MSkyX.MeshManager.SceneNode">
            <summary>Get the Ogre::SceneNode pointer where Hydrax mesh is attached.</summary>
            <returns>Ogre::SceneNode^.</returns>
        </member>
        <member name="P:MSkyX.MeshManager.HardwareIndexBuffer">
            <summary>Get hardware index buffer reference.</summary>
            <returns>Mogre::HardwareIndexBufferShared reference.</returns>
        </member>
        <member name="P:MSkyX.MeshManager.HardwareVertexBuffer">
            <summary>Get hardware vertex buffer reference.</summary>
            <returns>Mogre::HardwareVertexBufferShared reference.</returns>
        </member>
        <member name="P:MSkyX.MeshManager.Entity">
            <summary>Get entity.</summary>
            <returns>Entity.</returns>
        </member>
        <member name="P:MSkyX.MeshManager.SubMesh">
            <summary>Get sub mesh.</summary>
            <returns>Sub mesh.</returns>
        </member>
        <member name="P:MSkyX.MeshManager.Mesh">
            <summary>Get mesh.</summary>
            <returns>Mesh.</returns>
        </member>
        <member name="M:MSkyX.MeshManager.Remove">
            <summary>Remove all resources.</summary>
        </member>
        <member name="M:MSkyX.MeshManager.Create">
            <summary>Create our water mesh, geometry, entity, etc...</summary>
            <remarks>Call it after setting MaterialName.</remarks>
        </member>
        <member name="P:MSkyX.VClouds.Ellipsoid.Position">
            <summary>Get/Set position.</summary>
            <param name="value">New position.</param>
            <returns>Position.</returns>
        </member>
        <member name="P:MSkyX.VClouds.Ellipsoid.Dimensions">
            <summary>Get/Set dimensions.</summary>
            <param name="value">New dimensions.</param>
            <returns>Ellipsoid dimensions.</returns>
        </member>
        <member name="P:MSkyX.VClouds.Ellipsoid.IsOutOfCells">
            <summary>Determines if the ellipsoid is out of the cells domain and needs to be removed.</summary>
            <returns>True if ellipsoid needs to be removed, false otherwise.</returns>
        </member>
        <member name="M:MSkyX.VClouds.Ellipsoid.UpdateProbabilities(MSkyX.VClouds.DataManager.Cell[0:,0:,0:],System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>Update probabilities.</summary>
            <param name="c">Cells.</param>
            <param name="nx">X complexity.</param>
            <param name="ny">Y complexity.</param>
            <param name="nz">Z complexity.</param>
            <param name="delayedResponse">True to get a delayed response, updating only probabilities, false to also set clouds.</param>
        </member>
        <member name="M:MSkyX.VClouds.Ellipsoid.UpdateProbabilities(MSkyX.VClouds.DataManager.Cell[0:,0:,0:],System.Int32,System.Int32,System.Int32)">
            <summary>Update probabilities.</summary>
            <param name="c">Cells.</param>
            <param name="nx">X complexity.</param>
            <param name="ny">Y complexity.</param>
            <param name="nz">Z complexity.</param>
        </member>
        <member name="M:MSkyX.VClouds.Ellipsoid.GetProbabilities(System.Int32,System.Int32,System.Int32)">
            <summary>Get probabilities at a point.</summary>
            <param name="x">X Coord.</param>
            <param name="y">Y Coord.</param>
            <param name="z">Z Coord.</param>
            <returns>Probabilities (Hum, Ext, Act).</returns>
        </member>
        <member name="M:MSkyX.VClouds.Ellipsoid.Move(System.Int32,System.Int32,System.Int32)">
            <summary>Move the ellipsoid.</summary>
            <param name="Ax">X increment.</param>
            <param name="Ay">Y increment.</param>
            <param name="Az">Z increment.</param>
        </member>
        <member name="M:MSkyX.VClouds.Ellipsoid.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
            <summary>Constructor.</summary>
            <param name="a">A constant.</param>
            <param name="b">B constant.</param>
            <param name="c">C constant.</param>
            <param name="nx">X size.</param>
            <param name="ny">Y size.</param>
            <param name="nz">Z size.</param>
            <param name="x">X Coord (position).</param>
            <param name="y">Y Coord (position).</param>
            <param name="z">Z Coord (position).</param>
            <param name="Density">Cloud density.</param>
        </member>
        <member name="M:MSkyX.VClouds.Ellipsoid.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
            <param name="a">A constant.</param>
            <param name="b">B constant.</param>
            <param name="c">C constant.</param>
            <param name="nx">X size.</param>
            <param name="ny">Y size.</param>
            <param name="nz">Z size.</param>
            <param name="x">X Coord (position).</param>
            <param name="y">Y Coord (position).</param>
            <param name="z">Z Coord (position).</param>
        </member>
        <member name="M:MSkyX.VClouds.Ellipsoid.#ctor(CLRObject*)">
            <summary>Copy constructor.</summary>
            <param name="obj">SkyX::Ellipsoid to copy data from.</param>
        </member>
        <member name="T:MSkyX.VClouds.Ellipsoid">
            <summary>Color gradient.</summary>
        </member>
        <member name="M:MSkyX.VClouds.DataManager.ForceToUpdateData">
            <summary>Forces the data manager to calculate the next step right now.</summary>
        </member>
        <member name="M:MSkyX.VClouds.DataManager.AddEllipsoid(MSkyX.VClouds.Ellipsoid,System.Boolean)">
            <summary>Add ellipsoid: clouds are modelled as ellipsoids in our simulation approach, so.. different kind of clouds can be modelled with ellipsoids compositions.</summary>
            <param name="e">Ellipsoid.</param>
            <param name="UpdateProbabilities">Update probabilities?</param>
        </member>
        <member name="M:MSkyX.VClouds.DataManager.AddEllipsoid(MSkyX.VClouds.Ellipsoid)">
            <summary>Add ellipsoid: clouds are modelled as ellipsoids in our simulation approach, so.. different kind of clouds can be modelled with ellipsoids compositions.</summary>
            <param name="e">Ellipsoid.</param>
        </member>
        <member name="M:MSkyX.VClouds.DataManager.SetWheater(System.Single,System.Single,System.Boolean)">
            <summary>Set wheater parameters. Use this funtion to update the cloud field parameters, you'll get a smart and smooth transition from your old setting to your new ones.</summary>
            <param name="Humidity">Humidity, in other words: the percentage of clouds in [0,1] range.</param>
            <param name="AverageCloudsSize">Average clouds size, for example: if previous wheater clouds size parameter was very different from new one(i.e: more little) only the old biggest clouds are going to be keept and the little ones are going to be replaced.</param>
            <param name="delayedResponse ">False to change wheather conditions over several updates, true to change it at the moment.</param>
        </member>
        <member name="M:MSkyX.VClouds.DataManager.SetWheater(System.Single,System.Single)">
            <summary>Set wheater parameters. Use this funtion to update the cloud field parameters, you'll get a smart and smooth transition from your old setting to your new ones.</summary>
            <param name="Humidity">Humidity, in other words: the percentage of clouds in [0,1] range.</param>
            <param name="AverageCloudsSize">Average clouds size, for example: if previous wheater clouds size parameter was very different from new one(i.e: more little) only the old biggest clouds are going to be keept and the little ones are going to be replaced.</param>
        </member>
        <member name="P:MSkyX.VClouds.DataManager.UpdateTime">
            <summary>Get/Set update time</summary>
            <param name="value">Time elapsed between data calculations, a little freeze could be experimented during these calculations on old CPU's.</param>
            <returns>Update time.</returns>
        </member>
        <member name="P:MSkyX.VClouds.DataManager.IsCreated">
            <summary>Has been create(...) already called?</summary>
            <returns>True if created() have been already called.</returns>
        </member>
        <member name="M:MSkyX.VClouds.DataManager.Remove">
            <summary>Remove.</summary>
        </member>
        <member name="M:MSkyX.VClouds.DataManager.Update(System.Single)">
            <summary>Update.</summary>
            <param name="timeSinceLastFrame">Time elapsed since last frame.</param>
        </member>
        <member name="M:MSkyX.VClouds.DataManager.Create(System.Int32,System.Int32,System.Int32)">
            <summary>Create.</summary>
            <param name="nx">X complexity.</param>
            <param name="ny">Y complexity.</param>
            <param name="nz">Z complexity.</param>
        </member>
        <member name="M:MSkyX.VClouds.DataManager.#ctor(CLRObject*)">
            <summary>Copy constructor.</summary>
            <param name="native">SkyX::VClouds::DataManager to copy data from.</param>
        </member>
        <member name="T:MSkyX.VClouds.DataManager.VolTextureId">
            <summary>Volumetric textures enumeration.</summary>
        </member>
        <member name="F:MSkyX.VClouds.DataManager.Cell.LightAbsorcion">
            <summary>Light absorcion.</summary>
        </member>
        <member name="F:MSkyX.VClouds.DataManager.Cell.Density">
            <summary>Continous density.</summary>
        </member>
        <member name="F:MSkyX.VClouds.DataManager.Cell.Pact">
            <summary>Probability.</summary>
        </member>
        <member name="F:MSkyX.VClouds.DataManager.Cell.Pext">
            <summary>Probability.</summary>
        </member>
        <member name="F:MSkyX.VClouds.DataManager.Cell.Phum">
            <summary>Probability.</summary>
        </member>
        <member name="F:MSkyX.VClouds.DataManager.Cell.Cld">
            <summary>Cloud.</summary>
        </member>
        <member name="F:MSkyX.VClouds.DataManager.Cell.Act">
            <summary>Phase.</summary>
        </member>
        <member name="F:MSkyX.VClouds.DataManager.Cell.Hum">
            <summary>Humidity.</summary>
        </member>
        <member name="T:MSkyX.VClouds.DataManager.Cell">
            <summary>Cell struct.</summary>
        </member>
        <member name="T:MSkyX.VClouds.DataManager">
            <summary>Color gradient.</summary>
        </member>
        <member name="F:SkyX.VClouds.DataManager.mVClouds">
SkyX parent pointer
</member>
        <member name="F:SkyX.VClouds.DataManager.mEllipsoids">
Ellipsoids
</member>
        <member name="F:SkyX.VClouds.DataManager.mMaxNumberOfClouds">
Max number of clouds(Ellipsoids)
</member>
        <member name="F:SkyX.VClouds.DataManager.mFFRandom">
Fast fake random
</member>
        <member name="F:SkyX.VClouds.DataManager.mCreated">
Has been create(...) already called?
</member>
        <member name="F:SkyX.VClouds.DataManager.mVolTexToUpdate">
Current texture
</member>
        <member name="F:SkyX.VClouds.DataManager.mVolTextures">
Volumetric textures array
</member>
        <member name="F:SkyX.VClouds.DataManager.mNx">
Complexities
</member>
        <member name="F:SkyX.VClouds.DataManager.mStep">
Current calculation state
</member>
        <member name="F:SkyX.VClouds.DataManager.mUpdateTime">
Update time
</member>
        <member name="F:SkyX.VClouds.DataManager.mCurrentTransition">
Current transition
</member>
        <member name="F:SkyX.VClouds.DataManager.mCellsCurrent">
Simulation data
</member>
        <member name="M:SkyX.VClouds.DataManager._createVolTexture(SkyX.VClouds.DataManager.VolTextureId!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create volumetric texture
		@param TexId Texture Id
		@param nx X size
		@param ny Y size
		@param nz Z size

</member>
        <member name="M:SkyX.VClouds.DataManager._getLightAbsorcionAt(SkyX.VClouds.DataManager.Cell***,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.Co">
Get light absorcion factor at a point
		@param c Cells data
		@param nx X size
		@param ny Y size
		@param nz Z size
		@param x x Coord
		@param y y Coord
		@param z z Coord 
		@param d Light direction
		@param att Attenuation factor

</member>
        <member name="M:SkyX.VClouds.DataManager._updateProbabilities(SkyX.VClouds.DataManager.Cell***,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update probabilities based from the Ellipsoid vector
		@param c Cells data
		@param nx X size
		@param ny Y size
		@param nz Z size
		@param delayedResponse false to change wheather conditions over several updates, true to change it at the moment

</member>
        <member name="M:SkyX.VClouds.DataManager._clearProbabilities(SkyX.VClouds.DataManager.Cell***,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Clear probabilities
		@param c Cells data
		@param nx X size
		@param ny Y size
		@param nz Z size
		@param clearData Clear data?

</member>
        <member name="M:SkyX.VClouds.DataManager._fact(SkyX.VClouds.DataManager.Cell***,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Fact funtion
		@param c Cells data
		@param nx X size
		@param ny Y size
		@param nz Z size
		@param x x Coord
		@param y y Coord
		@param z z Coord 

</member>
        <member name="M:SkyX.VClouds.DataManager._getDensityAt(SkyX.VClouds.DataManager.Cell***,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get discrete density at a point
		@param c Cells data
		@param x x Coord
		@param y y Coord
		@param z z Coord 

</member>
        <member name="M:SkyX.VClouds.DataManager._getDensityAt(SkyX.VClouds.DataManager.Cell***,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerS">
Get continous density at a point
		@param c Cells data
		@param nx X size
		@param ny Y size
		@param nz Z size
		@param x x Coord
		@param y y Coord
		@param z z Coord 
		@param r Radius
		@param sgtrength Strength

</member>
        <member name="M:SkyX.VClouds.DataManager._updateVolTextureData(SkyX.VClouds.DataManager.Cell***,SkyX.VClouds.DataManager.VolTextureId!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update volumetric texture data
		@param c Cells data
		@param TexId Texture Id
		@param nx X size
		@param ny Y size
		@param nz Z size

</member>
        <member name="M:SkyX.VClouds.DataManager._performCalculations(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Perform celullar automata simulation
		@param nx X size
		@param ny Y size
		@param nz Z size
		@param step Calculation step. Valid steps are 0,1,2,3.
		@param xStart x start cell (included)
		@param xEnd x end cell (not included, until xEnd-1)

</member>
        <member name="M:SkyX.VClouds.DataManager._copy3DCellArraysData(SkyX.VClouds.DataManager.Cell***,SkyX.VClouds.DataManager.Cell***,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy 3d cells arrays data
		@param src Source
		@param dest Dest
		@param nx X size
		@param ny Y size
		@param nz Z size

</member>
        <member name="M:SkyX.VClouds.DataManager._delete3DCellArray(SkyX.VClouds.DataManager.Cell***,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Delete tridimensional cell array
		@param c Cell pointer to be deleted
		@param nx X size
		@param ny Y size

</member>
        <member name="M:SkyX.VClouds.DataManager._create3DCellArray(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create tridimensional cell array
		@param nx X size
		@param ny Y size
		@param nz Z size
		@param init Initialize values
		@return Cell 3d pointer

</member>
        <member name="M:SkyX.VClouds.DataManager._initData(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Initialize data
		@param nx X complexity
		@param ny Y complexity
		@param nz Z complexity

</member>
        <member name="M:SkyX.VClouds.DataManager.forceToUpdateData">
Forces the data manager to calculate the next step right now

</member>
        <member name="M:SkyX.VClouds.DataManager.addEllipsoid(SkyX.VClouds.Ellipsoid*,System.Boolean!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add ellipsoid: clouds are modelled as ellipsoids in our simulation approach, so.. different kind of clouds 
		can be modelled with ellipsoids compositions.
		@param e Ellipsoid
		@param UpdateProbabilities Update probabilities?

</member>
        <member name="M:SkyX.VClouds.DataManager.setWheater(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set wheater parameters
		Use this funtion to update the cloud field parameters, you'll get a smart and smooth transition from your old 
		setting to your new ones.
		@param Humidity Humidity, in other words: the percentage of clouds in [0,1] range.
		@param AverageCloudsSize Average clouds size, for example: if previous wheater clouds size parameter was very different from new one(i.e: more little)
		only the old biggest clouds are going to be keept and the little ones are going to be replaced
		@param delayedResponse false to change wheather conditions over several updates, true to change it at the moment

</member>
        <member name="M:SkyX.VClouds.DataManager._getInterpolation">
Get current interpolation factor
		@return Interpolation factor
		@remarks Only for internal use

</member>
        <member name="M:SkyX.VClouds.DataManager.getUpdateTime">
Get update time
		@return Update time

</member>
        <member name="M:SkyX.VClouds.DataManager.setUpdateTime(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set update time
		@param UpdateTime Time elapsed between data calculations, a little freeze could be experimented during these calculations on old CPU's

</member>
        <member name="M:SkyX.VClouds.DataManager.isCreated">
Has been create(...) already called?
		@return true if created() have been already called

</member>
        <member name="M:SkyX.VClouds.DataManager.remove">
Remove

</member>
        <member name="M:SkyX.VClouds.DataManager.update(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update
		@param timeSinceLastFrame Time elapsed since last frame

</member>
        <member name="M:SkyX.VClouds.DataManager.create(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create
		@param nx X complexity
		@param ny Y complexity
		@param nz Z complexity

</member>
        <member name="M:SkyX.VClouds.DataManager.Dispose">
Destructor

</member>
        <member name="M:SkyX.VClouds.DataManager.#ctor(SkyX.VClouds.VClouds*)">
Constructor
		@param vc VClouds parent pointer

</member>
        <member name="T:SkyX.VClouds.DataManager.VolTextureId">
Volumetric textures enumeration

</member>
        <member name="F:SkyX.VClouds.DataManager.Cell.light">
Light absorcion
</member>
        <member name="F:SkyX.VClouds.DataManager.Cell.dens">
Continous density
</member>
        <member name="F:SkyX.VClouds.DataManager.Cell.phum">
Probabilities
</member>
        <member name="F:SkyX.VClouds.DataManager.Cell.hum">
Humidity, phase and cloud
</member>
        <member name="T:SkyX.VClouds.DataManager.Cell">
Cell struct

</member>
        <member name="F:SkyX.VClouds.FastFakeRandom.mIndex">
Index
</member>
        <member name="F:SkyX.VClouds.FastFakeRandom.mCapacity">
Capacity
</member>
        <member name="F:SkyX.VClouds.FastFakeRandom.mData">
Data pointer
</member>
        <member name="M:SkyX.VClouds.FastFakeRandom.get">
Get random number

</member>
        <member name="M:SkyX.VClouds.FastFakeRandom.Dispose">
Destructor

</member>
        <member name="M:SkyX.VClouds.FastFakeRandom.#ctor(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor 
		    @param n Capacity
			@param min Min value
			@param max Max value

</member>
        <member name="M:__Init_CLRObject_AtmosphereManager(CLRObject*)">
Define the dll export qualifier if compiling for Windows
Log macro
SkyX defines
</member>
        <member name="M:Ogre.PSSMShadowCameraSetup.getOptimalAdjustFactor">
Overridden, recommended internal use only since depends on current iteration
</member>
        <member name="M:Ogre.PSSMShadowCameraSetup.getOptimalAdjustFactor(System.UInt32)">
Returns the optimal adjust factor for a given split.
</member>
        <member name="M:Ogre.PSSMShadowCameraSetup.getSplitPoints">
Returns the calculated split points.
</member>
        <member name="M:Ogre.PSSMShadowCameraSetup.getShadowCamera(Ogre.SceneManager!System.Runtime.CompilerServices.IsConst*,Ogre.Camera!System.Runtime.CompilerServices.IsConst*,Ogre.Viewport!System.Runtime.CompilerServices.IsConst*,Ogre.Light!System.Runtime.CompilerServices.IsConst*,Ogre.Camera*,System.UInt32)">
Returns a LiSPSM shadow camera with PSSM splits base on iteration.
</member>
        <member name="M:Ogre.PSSMShadowCameraSetup.getSplitCount">
Get the number of splits. 
</member>
        <member name="M:Ogre.PSSMShadowCameraSetup.setOptimalAdjustFactor(System.UInt32,System.Single)">
Set the LiSPSM optimal adjust factor for a given split (call after
			configuring splits).

</member>
        <member name="M:Ogre.PSSMShadowCameraSetup.setSplitPoints(std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Manually configure a new splitting scheme.
		@param newSplitPoints A list which is splitCount + 1 entries long, containing the
			split points. The first value is the near point, the last value is the
			far point, and each value in between is both a far point of the previous
			split, and a near point for the next one.

</member>
        <member name="M:Ogre.PSSMShadowCameraSetup.calculateSplitPoints(System.UInt32,System.Single,System.Single,System.Single)">
Calculate a new splitting scheme.
		@param splitCount The number of splits to use
		@param nearDist The near plane to use for the first split
		@param farDist The far plane to use for the last split
		@param lambda Factor to use to reduce the split size 

</member>
        <member name="M:Ogre.PSSMShadowCameraSetup.#ctor">
Constructor, defaults to 3 splits
</member>
        <member name="T:Ogre.PSSMShadowCameraSetup">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Parallel Split Shadow Map (PSSM) shadow camera setup. 
	@remarks
		A PSSM shadow system uses multiple shadow maps per light and maps each
		texture into a region of space, progressing away from the camera. As such
		it is most appropriate for directional light setups. This particular version
		also uses LiSPSM projection for each split to maximise the quality. 
	@note
		Because PSSM uses multiple shadow maps per light, you will need to increase
		the number of shadow textures available (via SceneManager) to match the 
		number of shadow maps required (default is 3 per light). 

</member>
        <member name="M:Ogre.PlaneOptimalShadowCameraSetup.getShadowCamera(Ogre.SceneManager!System.Runtime.CompilerServices.IsConst*,Ogre.Camera!System.Runtime.CompilerServices.IsConst*,Ogre.Viewport!System.Runtime.CompilerServices.IsConst*,Ogre.Light!System.Runtime.CompilerServices.IsConst*,Ogre.Camera*,System.UInt32)">
Returns shadow camera configured to get 1-1 homography between screen and shadow map when restricted to plane
</member>
        <member name="M:Ogre.PlaneOptimalShadowCameraSetup.Dispose">
Destructor
</member>
        <member name="M:Ogre.PlaneOptimalShadowCameraSetup.#ctor(Ogre.MovablePlane*)">
Constructor -- requires a plane of interest
</member>
        <member name="M:Ogre.PlaneOptimalShadowCameraSetup.computeConstrainedProjection(Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Ogre.Vector4&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Ogre.Vector2&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
helper function computing projection matrix given constraints
</member>
        <member name="T:Ogre.PlaneOptimalShadowCameraSetup">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Implements the plane optimal shadow camera algorithm.
        @remarks
            Given a plane of interest, it is possible to set up the shadow camera
			matrix such that the mapping between screen and shadow map is the identity
			(when restricted to pixels that view the plane of interest).  Therefore,
			if the shadow map resolution matches the screen space resolution (of the 
			seen planar receiver), we can get pixel perfect shadowing on the plane. 
			Off the plane, the shadowing is not guaranteed to be perfect and will 
			likely exhibit the usual sampling artifacts associated with shadow mapping.
		@note Important: this routine requires double-precision calculations. When you
			are running under Direct3D, you must ensure that you set the floating
			point mode to 'Consistent' rather than 'Fastest' to ensure this precision.
			This does allegedly come with some performance cost but when measuring 
			it appears to be negligible in modern systems for normal usage.
		@note Second important note: this projection also only works for lights with
			a finite position. Therefore you cannot use it for directional lights
			at this time.

</member>
        <member name="M:Ogre.LiSPSMShadowCameraSetup.getCameraLightDirectionThreshold">
Sets the threshold between the camera and the light direction below
		which the LiSPSM projection is 'flattened', since coincident light
		and camera projections cause problems with the perspective skew.

</member>
        <member name="M:Ogre.LiSPSMShadowCameraSetup.setCameraLightDirectionThreshold(Ogre.Degree)">
Sets the threshold between the camera and the light direction below
			which the LiSPSM projection is 'flattened', since coincident light
			and camera projections cause problems with the perspective skew.
			@remarks
			For example, setting this to 20 degrees will mean that as the difference 
			between the light and camera direction reduces from 20 degrees to 0
			degrees, the perspective skew will be proportionately removed.

</member>
        <member name="M:Ogre.LiSPSMShadowCameraSetup.getUseSimpleOptimalAdjust">
Gets whether or not to use a slightly simpler version of the 
		camera near point derivation (default is true)

</member>
        <member name="M:Ogre.LiSPSMShadowCameraSetup.setUseSimpleOptimalAdjust(System.Boolean)">
Sets whether or not to use a slightly simpler version of the 
			camera near point derivation (default is true)

</member>
        <member name="M:Ogre.LiSPSMShadowCameraSetup.getOptimalAdjustFactor">
Get the parameter n used to produce optimal shadows. 
		@see setOptimalAdjustFactor

</member>
        <member name="M:Ogre.LiSPSMShadowCameraSetup.setOptimalAdjustFactor(System.Single)">
Adjusts the parameter n to produce optimal shadows.
		@remarks
		The smaller the parameter n, the stronger the perspective warping effect.
		The consequence of a stronger warping is that the near shadows will gain 
		quality while the far ones will lose it. Depending on your scene and light
		types you may want to tweak this value - for example directional lights
		tend to benefit from higher values of n than other types of light, 
		especially if you expect to see more distant shadows (say if the viewpoint is
		higher above the ground plane). Remember that you can supply separate
		ShadowCameraSetup instances configured differently per light if you wish.
		@param n The adjustment factor - default is 0.1f. 

</member>
        <member name="M:Ogre.LiSPSMShadowCameraSetup.getShadowCamera(Ogre.SceneManager!System.Runtime.CompilerServices.IsConst*,Ogre.Camera!System.Runtime.CompilerServices.IsConst*,Ogre.Viewport!System.Runtime.CompilerServices.IsConst*,Ogre.Light!System.Runtime.CompilerServices.IsConst*,Ogre.Camera*,System.UInt32)">
Returns a LiSPSM shadow camera.
		@remarks
		Builds and returns a LiSPSM shadow camera. 
		More information can be found on the webpage of the TU Wien: 
		http://www.cg.tuwien.ac.at/research/vr/lispsm/

</member>
        <member name="M:Ogre.LiSPSMShadowCameraSetup.Dispose">
Default destructor.
		@remarks
		Nothing done here.

</member>
        <member name="M:Ogre.LiSPSMShadowCameraSetup.#ctor">
Default constructor.
		@remarks
		Nothing done here.

</member>
        <member name="M:Ogre.LiSPSMShadowCameraSetup.buildFrustumProjection(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
Builds a frustum matrix.
		@remarks
		Builds a standard frustum matrix out of the distance infos of the six frustum 
		clipping planes.

</member>
        <member name="M:Ogre.LiSPSMShadowCameraSetup.calculateZ0_ls(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,Ogre.Camera!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the visible point on the near plane for the n_opt calculation
		@remarks
		z0 lies on the parallel plane to the near plane through e and on the near plane of 
		the frustum C (plane z = bodyB_zMax_ls) and on the line x = e.x.
		@param lightSpace: matrix of the light space transformation
		@param e: the LiSPSM parameter e is located near or on the near clipping plane of the 
		LiSPSM frustum C
		@param bodyB_zMax_ls: maximum z-value of the light space bodyB bounding box
		@param cam: currently active camera

</member>
        <member name="M:Ogre.LiSPSMShadowCameraSetup.calculateNOptSimple(Ogre.FocusedShadowCameraSetup.PointListBody!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Camera!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates a simpler version than the one above.

</member>
        <member name="M:Ogre.LiSPSMShadowCameraSetup.calculateNOpt(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.FocusedShadowCameraSetup.PointListBody!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Camera!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the distance between camera position and near clipping plane.
		@remarks
		n_opt determines the distance between light space origin (shadow camera position)
		and	the near clipping plane to achieve an optimal perspective foreshortening effect.
		In this	way the texel distribution over the shadow map is controlled.

		Formula:
		               d
		n_opt = ---------------
		        sqrt(z1/z0) - 1

		Parameters:
		d: distance between the near and the far clipping plane
		z0: located on the near clipping plane of the intersection body b
		z1: located on the far clipping plane with the same x/y values as z0		
		@note
		A positive value is applied as the distance between viewer and near clipping plane.
		In case null is returned uniform shadow mapping will be applied.
		@param lightSpace: matrix of the light space transformation
		@param bodyBABB_ls: bounding box of the tranformed (light space) bodyB
		@param bodyLVS: point list of the bodyLVS which describes the scene space which is in 
		front of the light and the camera
		@param cam: currently active camera

</member>
        <member name="M:Ogre.LiSPSMShadowCameraSetup.calculateLiSPSM(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.FocusedShadowCameraSetup.PointListBody!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.FocusedShadowCameraSetup.PointListBody!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.SceneManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Camera!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Light!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the LiSPSM projection matrix P.
		@remarks
		The LiSPSM projection matrix will be built around the axis aligned bounding box 
		of the intersection body B in light space. The distance between the near plane 
		and the projection center is chosen in such a way (distance is set by the para-
		meter n) that the perspective error is the same on the near and far	plane. In 
		case P equals the identity matrix the algorithm falls back to a uniform shadow
		mapping matrix.
		@param lightSpace: matrix of the light space transformation
		@param bodyB: intersection body B
		@param bodyLVS: intersection body LVS (relevant space in front of the camera)
		@param sm: scene manager
		@param cam: currently active camera
		@param light: currently active light

</member>
        <member name="F:Ogre.LiSPSMShadowCameraSetup.mCosCamLightDirThreshold">
Threshold (cos angle) within which to start increasing the opt adjust as camera direction approaches light direction
</member>
        <member name="F:Ogre.LiSPSMShadowCameraSetup.mOptAdjustFactorTweak">
Extra calculated warp factor
</member>
        <member name="F:Ogre.LiSPSMShadowCameraSetup.mUseSimpleNOpt">
Use simple nopt derivation?
</member>
        <member name="F:Ogre.LiSPSMShadowCameraSetup.mOptAdjustFactor">
Warp factor adjustment
</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.setUseAggressiveFocusRegion(System.Boolean)">
Sets whether or not to use the more aggressive approach to deciding on
			the focus region or not.
		@note
			There are 2 approaches that can  be used to define the focus region,
			the more aggressive way introduced by Wimmer et al, or the original
			way as described in Stamminger et al. Wimmer et al's way tends to 
			come up with a tighter focus region but in rare cases (mostly highly
			glancing angles) can cause some shadow casters to be clipped 
			incorrectly. By default the more aggressive approach is used since it
			leads to significantly better results in most cases, but if you experience
			clipping issues, you can use the less aggressive version.
		@param aggressive True to use the more aggressive approach, false otherwise.

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.getShadowCamera(Ogre.SceneManager!System.Runtime.CompilerServices.IsConst*,Ogre.Camera!System.Runtime.CompilerServices.IsConst*,Ogre.Viewport!System.Runtime.CompilerServices.IsConst*,Ogre.Light!System.Runtime.CompilerServices.IsConst*,Ogre.Camera*,System.UInt32)">
Returns a uniform shadow camera with a focused view.

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.Dispose">
Default destructor.
		@remarks
		Temporary frustum and camera destroyed here.

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.#ctor">
Default constructor.
		@remarks
		Temporary frustum and camera set up here.

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.buildViewMatrix(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Builds a view matrix.
		@remarks
		Builds a standard view matrix out of a given position, direction and up vector.

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.transformToUnitCube(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.FocusedShadowCameraSetup.PointListBody!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Transforms a given body to the unit cube (-1,-1,-1) / (+1,+1,+1) with a specific 
		shadow matrix enabled.
		@remarks
		Transforms a given point list body object with the matrix m and then maps its
		extends to a (-1,-1,-1) / (+1,+1,+1) unit cube
		@param m: transformation matrix applied on the point list body
		@param body: contains the points of the extends of all valid scene elements which 
		are mapped to the unit cube

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.getNearCameraPoint_ws(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.FocusedShadowCameraSetup.PointListBody!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a valid near-point seen by the camera.
		@remarks
		Returns a point that is situated near the camera by analyzing the bodyLVS that
		contains all the relevant scene space in front of the light and the camera in
		a point list array. The view matrix is relevant because the nearest point in
		front of the camera should be determined.
		@param viewMatrix: view matrix of the current camera
		@param bodyLVS: intersection body LVS (relevant space in front of the camera) 

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.getLSProjViewDir(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Camera!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.FocusedShadowCameraSetup.PointListBody!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the projection view direction.
		@remarks
		After the matrix L_p is applied the orientation of the light space may tilt for
		non-identity projections. To prevent a false shadow cast the real view direction
		is evaluated and applied to the light matrix L.
		@param lightSpace: matrix of the light space transformation
		@param cam: current viewer camera
		@param bodyLVS: intersection body LVS (relevant space in front of the camera)

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.calculateLVS(Ogre.SceneManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Camera!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Light!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.FocusedShadowCameraSetup.PointListBody*)">
Calculates the bodyLVS.
		@remarks
		Calculates the bodyLVS which consists of the convex intersection operation 
		affecting the light frustum, the view frustum, and the current scene bounding
		box is used to find suitable positions in the viewer's frustum to build the 
		rotation matrix L_r. This matrix is applied after the projection matrix L_p to 
		avoid an accidental flip of the frustum orientation for views tilted with 
		respect to the shadow map.
		@param scene: holds all potential occluders / receivers as one single bounding box
		of the currently active scene node
		@param cam: current viewer camera
		@param light: current light
		@param out_LVS: intersection body LVS (world coordinates)

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.calculateB(Ogre.SceneManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Camera!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Light!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.FocusedShadowCameraSetup.PointListBody*)">
Calculates the intersection bodyB.
		@remarks
		The intersection bodyB consists of the concatenation the cam frustum clipped 
		by the scene bounding box followed by a convex hullification with the light's 
		position and the clipping with the scene bounding box and the light frustum:
		((V \cap S) + l) \cap S \cap L (\cap: convex intersection, +: convex hull 
		operation).
		For directional lights the bodyB is assembled out of the camera frustum 
		clipped by the scene bounding box followed by the extrusion of all available 
		bodyB points towards the negative light direction. The rays are intersected 
		by a maximum bounding box and added to the bodyB points to form the final 
		intersection bodyB point list.
		@param sm: scene manager
		@param cam: currently active camera
		@param light: currently active light
		@param sceneBB: scene bounding box for clipping operations
		@param receiverAABB: bounding information for just the receivers
		@param out_bodyB: final intersection bodyB point list

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.calculateShadowMappingMatrix(Ogre.SceneManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Camera!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Light!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Matrix4*,Ogre.Matrix4*,Ogre.Camera*)">
Calculates the standard shadow mapping matrix.
		@remarks
		Provides the view and projection matrix for standard shadow mapping.
		@note
		You can choose which things you want to have: view matrix and/or projection 
		matrix and/or shadow camera. Passing a NULL value as parameter ignores the
		generation of this specific value.
		@param sm: scene manager
		@param cam: currently active camera
		@param light: currently active light
		@param out_view: calculated uniform view shadow mapping matrix (may be NULL)
		@param out_proj: calculated uniform projection shadow mapping matrix (may be NULL)
		@param out_cam: calculated uniform shadow camera (may be NULL)

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.PointListBody.reset">
Resets the body.

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.PointListBody.getPointCount">
Returns the point count.

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.PointListBody.getPoint(System.UInt32)">
Returns a point.

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.PointListBody.addAAB(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds all points of an AAB.

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.PointListBody.addPoint(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds a specific point to the body list.

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.PointListBody.getAAB">
Returns the bounding box representation.

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.PointListBody.buildAndIncludeDirection(Ogre.ConvexBody!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Builds a PointListBody from a Body and includes all the space in a given direction.
			@remarks
			Intersects the bounding box with a ray from each available point of the body with the given
			direction. Base and intersection points are stored in a PointListBody structure.
			@note
			Duplicate vertices are not filtered.
			@note
			Body is not checked for correctness.

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.PointListBody.build(Ogre.ConvexBody!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Builds a point list body from a 'real' body.
			@remarks
			Inserts all vertices from a body into the point list with or without adding duplicate vertices.

</member>
        <member name="M:Ogre.FocusedShadowCameraSetup.PointListBody.merge(Ogre.FocusedShadowCameraSetup.PointListBody!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Merges a second PointListBody into this one.

</member>
        <member name="T:Ogre.FocusedShadowCameraSetup.PointListBody">
Internal class holding a point list representation of a convex body.

</member>
        <member name="F:Ogre.FocusedShadowCameraSetup.mUseAggressiveRegion">
Use tighter focus region?
</member>
        <member name="F:Ogre.FocusedShadowCameraSetup.mLightFrustumCamera">
Temporary preallocated camera to set up a light frustum for clipping in ::calculateB.

</member>
        <member name="F:Ogre.FocusedShadowCameraSetup.mTempFrustum">
Temporary preallocated frustum to set up a projection matrix in 
		::calculateShadowMappingMatrix()

</member>
        <member name="F:Ogre.FocusedShadowCameraSetup.msNormalToLightSpace">
Transform to or from light space as defined by Wimmer et al.
		@remarks
		Point and spot lights need to be converted to directional lights to enable a 1:1 
		light mapping. Otherwise a directional light may become a point light or a point 
		sink (opposite of a light source) or point/spot lights may become directional lights
		or light sinks. The light direction is always -y.

</member>
        <member name="M:Ogre.ConvexBody.findAndEraseEdgePair(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.multimap&lt;Ogre.Vector3,Ogre.Vector3,std.less&lt;Ogre.Vector3&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Searches for a pair (an edge) in the intersectionList with an entry
			that equals vec, and removes it from the passed in list.
		@param vec The vertex to search for in intersectionEdges
		@param intersectionEdges A list of edges, which is updated if a match is found
		@param vNext A reference to a vector which will be filled with the other
			vertex at the matching edge, if found.
		@returns True if a match was found

</member>
        <member name="M:Ogre.ConvexBody.allocateSpace(System.UInt32,System.UInt32)">
Allocates space for an specified amount of polygons with
			each of them having a specified number of vertices.
			@note
				Old data (if available) will be erased.

</member>
        <member name="M:Ogre.ConvexBody.storeEdgesOfPolygon(System.UInt32,std.multimap&lt;Ogre.Vector3,Ogre.Vector3,std.less&lt;Ogre.Vector3&gt;&gt;*)">
Stores the edges of a specific polygon in a passed in structure.

</member>
        <member name="M:Ogre.ConvexBody.getSingleEdges">
Returns the single edges in an EdgeMap (= edges where one side is a vertex and the
			other is empty space (a hole in the body)).

</member>
        <member name="M:Ogre.ConvexBody.setVertex(System.UInt32,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Replace a specific vertex of a polygon.
		@note
			No checks are done whether the assembled polygon is (still) planar, 
			the caller must ensure that this is the case.

</member>
        <member name="M:Ogre.ConvexBody.setPolygon(Ogre.Polygon*,System.UInt32)">
Replace a polygon at a particular index.
		@note Again, the passed in polygon is owned by this object after this
			call returns, and this object is resonsible for deleting it.

</member>
        <member name="M:Ogre.ConvexBody.deleteVertex(System.UInt32,System.UInt32)">
Deletes a specific vertex of a specific polygon.

</member>
        <member name="M:Ogre.ConvexBody.moveDataFromBody(Ogre.ConvexBody*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Moves all polygons from the parameter body to this instance.
		@note Both the passed in object and this instance are modified

</member>
        <member name="M:Ogre.ConvexBody.unlinkPolygon(System.UInt32)">
Removes a specific polygon from the body without deleting it.
		@note
			The retrieved polygon needs to be deleted later by the caller.

</member>
        <member name="M:Ogre.ConvexBody.deletePolygon(System.UInt32)">
Deletes a specific polygon.

</member>
        <member name="M:Ogre.ConvexBody.insertVertex(System.UInt32,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Inserts a vertex for a polygon at the end.
		@note
			No checks are done whether the assembled polygon is (still) planar, 
			the caller must ensure that this is the case.

</member>
        <member name="M:Ogre.ConvexBody.insertVertex(System.UInt32,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Inserts a vertex for a polygon at a particular point.
		@note
			No checks are done whether the assembled polygon is (still) planar, 
			the caller must ensure that this is the case.

</member>
        <member name="M:Ogre.ConvexBody.insertPolygon(Ogre.Polygon*)">
Inserts a polygon at the end.
		@note
			After this method is called, the ConvexBody 'owns' this Polygon
			and will be responsible for deleting it.

</member>
        <member name="M:Ogre.ConvexBody.insertPolygon(Ogre.Polygon*,System.UInt32)">
Inserts a polygon at a particular point in the body.
		@note
			After this method is called, the ConvexBody 'owns' this Polygon
			and will be responsible for deleting it.

</member>
        <member name="M:Ogre.ConvexBody.freePolygon(Ogre.Polygon*)">
Release a polygon back tot he pool. 
</member>
        <member name="M:Ogre.ConvexBody.allocatePolygon">
Get a new polygon from the pool.

</member>
        <member name="M:Ogre.ConvexBody._destroyPool">
Tear down the internal polygon pool used to minimise allocations
</member>
        <member name="M:Ogre.ConvexBody._initialisePool">
Initialise the internal polygon pool used to minimise allocations
</member>
        <member name="M:Ogre.ConvexBody.logInfo">
Log details of this body 
</member>
        <member name="M:Ogre.op_LeftShift(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ConvexBody!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Prints out the body with all its polygons.

</member>
        <member name="M:Ogre.ConvexBody.op_Inequality(Ogre.ConvexBody!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Determines if the current object is not equal to the compared one.

</member>
        <member name="M:Ogre.ConvexBody.op_Equality(Ogre.ConvexBody!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Determines if the current object is equal to the compared one.

</member>
        <member name="M:Ogre.ConvexBody.mergePolygons">
Merges all neighboring polygons into one single polygon if they are
			lay in the same plane.

</member>
        <member name="M:Ogre.ConvexBody.hasClosedHull">
Checks if the body has a closed hull.

</member>
        <member name="M:Ogre.ConvexBody.getAABB">
Returns an AABB representation.

</member>
        <member name="M:Ogre.ConvexBody.getNormal(System.UInt32)">
Returns the normal of a specified polygon.

</member>
        <member name="M:Ogre.ConvexBody.getVertex(System.UInt32,System.UInt32)">
Returns a specific vertex of a polygon.

</member>
        <member name="M:Ogre.ConvexBody.getPolygon(System.UInt32)">
Returns a polygon.

</member>
        <member name="M:Ogre.ConvexBody.getVertexCount(System.UInt32)">
Returns the number of vertices for a polygon

</member>
        <member name="M:Ogre.ConvexBody.getPolygonCount">
Returns the current number of polygons.

</member>
        <member name="M:Ogre.ConvexBody.reset">
Resets the object.

</member>
        <member name="M:Ogre.ConvexBody.extend(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Extends the existing body to incorporate the passed in point as a
			convex hull.
		@remarks
			You must already have constructed a basic body using a 'construct' 
			method.

</member>
        <member name="M:Ogre.ConvexBody.clip(Ogre.Plane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Clips the object by the positive half space of a plane

</member>
        <member name="M:Ogre.ConvexBody.clip(Ogre.ConvexBody!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Clips the body with another body.

</member>
        <member name="M:Ogre.ConvexBody.clip(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Clips the body with an AAB. The resulting holes
			are filled with new polygons.

</member>
        <member name="M:Ogre.ConvexBody.clip(Ogre.Frustum!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Clips the body with a frustum. The resulting holes
			are filled with new polygons.

</member>
        <member name="M:Ogre.ConvexBody.define(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Build a new polygon representation from an AAB.

</member>
        <member name="M:Ogre.ConvexBody.define(Ogre.Frustum!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Build a new polygon representation from a frustum.

</member>
        <member name="T:Ogre.ConvexBody">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

Holds a solid representation of a convex body.
		@remarks
			Administers a convex body. All polygons of the body are convex and
			planar. Several operations may be applied, ranging from intersection
			to join where each result it itself a convex body.

</member>
        <member name="M:Ogre.op_LeftShift(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Polygon!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Prints out the polygon data.

</member>
        <member name="M:Ogre.Polygon.op_Inequality(Ogre.Polygon!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Determines if the current object is not equal to the compared one.

</member>
        <member name="M:Ogre.Polygon.op_Equality(Ogre.Polygon!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Determines if the current object is equal to the compared one.

</member>
        <member name="M:Ogre.Polygon.reset">
Resets the object.

</member>
        <member name="M:Ogre.Polygon.storeEdges(std.multimap&lt;Ogre.Vector3,Ogre.Vector3,std.less&lt;Ogre.Vector3&gt;&gt;*)">
Stores the edges of the polygon in ccw order.
			The vertices are copied so the user has to take the 
			deletion into account.

</member>
        <member name="M:Ogre.Polygon.isPointInside(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Determines if a point is inside the polygon.
		@remarks
			A point is inside a polygon if it is both on the polygon's plane, 
			and within the polygon's bounds. Polygons are assumed to be convex
			and planar.

</member>
        <member name="M:Ogre.Polygon.deleteVertex(System.UInt32)">
Deletes a specific vertex.

</member>
        <member name="M:Ogre.Polygon.getNormal">
Returns the polygon normal.

</member>
        <member name="M:Ogre.Polygon.getVertexCount">
Vertex count.

</member>
        <member name="M:Ogre.Polygon.removeDuplicates">
Removes duplicate vertices from a polygon.

</member>
        <member name="M:Ogre.Polygon.setVertex(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Sets a specific vertex of a polygon.
		@note Vertices must be coplanar.

</member>
        <member name="M:Ogre.Polygon.getVertex(System.UInt32)">
Returns a vertex.

</member>
        <member name="M:Ogre.Polygon.insertVertex(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Inserts a vertex at the end of the polygon.
		@note Vertices must be coplanar.

</member>
        <member name="M:Ogre.Polygon.insertVertex(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Inserts a vertex at a specific position.
		@note Vertices must be coplanar.

</member>
        <member name="M:Ogre.Polygon.updateNormal">
Updates the normal.

</member>
        <member name="T:Ogre.Polygon">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

The class represents a polygon in 3D space.
	@remarks
		It is made up of 3 or more vertices in a single plane, listed in 
		counter-clockwise order.

</member>
        <member name="M:Ogre.WindowEventUtilities._removeRenderWindow(Ogre.RenderWindow*)">
@Remarks
	Called by RenderWindows upon creation for Ogre generated windows. You are free to add your
	external windows here too if needed.
@param window
	The RenderWindow to remove from list

</member>
        <member name="M:Ogre.WindowEventUtilities._addRenderWindow(Ogre.RenderWindow*)">
@Remarks
	Called by RenderWindows upon creation for Ogre generated windows. You are free to add your
	external windows here too if needed.
@param window
	The RenderWindow to monitor

</member>
        <member name="M:Ogre.WindowEventUtilities.removeWindowEventListener(Ogre.RenderWindow*,Ogre.WindowEventListener*)">
@Remarks
	Remove previously added listener
@param window
	The RenderWindow you registered with
@param listner
	The listener registered

</member>
        <member name="M:Ogre.WindowEventUtilities.addWindowEventListener(Ogre.RenderWindow*,Ogre.WindowEventListener*)">
@Remarks
	Add a listener to listen to renderwindow events (multiple listener's per renderwindow is fine)
	The same listener can listen to multiple windows, as the Window Pointer is sent along with
	any messages.
@param window
	The RenderWindow you are interested in monitoring
@param listner
	Your callback listener

</member>
        <member name="M:Ogre.WindowEventUtilities.messagePump">
@Remarks
	Call this once per frame if not using Root:startRendering(). This will update all registered
	RenderWindows (If using external Windows, you can optionally register those yourself)

</member>
        <member name="T:Ogre.WindowEventUtilities">
@Remarks
	Utility class to handle Window Events/Pumping/Messages

</member>
        <member name="M:Ogre.WindowEventListener.windowFocusChange(Ogre.RenderWindow*)">
@Remarks
	Window has lost/gained focus
@param rw
	The RenderWindow which created this events

</member>
        <member name="M:Ogre.WindowEventListener.windowClosed(Ogre.RenderWindow*)">
@Remarks
	Window has been closed (Only triggered if user pressed the [X] button)
@param rw
	The RenderWindow which created this events
@note
	The window has not actually close yet when this event triggers. It's only closed after
	all windowClosed events are triggered. This allows apps to deinitialise properly if they
	have services that needs the window to exist when deinitialising.

</member>
        <member name="M:Ogre.WindowEventListener.windowClosing(Ogre.RenderWindow*)">
@Remarks
	Window is closing (Only triggered if user pressed the [X] button)
@param rw
	The RenderWindow which created this events
@return True will close the window(default).

</member>
        <member name="M:Ogre.WindowEventListener.windowResized(Ogre.RenderWindow*)">
@Remarks
	Window has resized
@param rw
	The RenderWindow which created this events

</member>
        <member name="M:Ogre.WindowEventListener.windowMoved(Ogre.RenderWindow*)">
@Remarks
	Window has moved position
@param rw
	The RenderWindow which created this events

</member>
        <member name="T:Ogre.WindowEventListener">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

@Remarks
	Callback class used to send out window events to client app

</member>
        <member name="F:Ogre.CompositionTargetPass.mShadowsEnabled">
Shadows option
</member>
        <member name="F:Ogre.CompositionTargetPass.mMaterialScheme">
Material scheme name
</member>
        <member name="F:Ogre.CompositionTargetPass.mLodBias">
LOD bias of this render
</member>
        <member name="F:Ogre.CompositionTargetPass.mVisibilityMask">
Visibility mask for this render
</member>
        <member name="F:Ogre.CompositionTargetPass.mOnlyInitial">
This target pass is only executed initially after the effect
has been enabled.
</member>
        <member name="F:Ogre.CompositionTargetPass.mPasses">
Passes
</member>
        <member name="F:Ogre.CompositionTargetPass.mOutputName">
(local) output texture
</member>
        <member name="F:Ogre.CompositionTargetPass.mInputMode">
Input name
</member>
        <member name="F:Ogre.CompositionTargetPass.mParent">
Parent technique
</member>
        <member name="M:Ogre.CompositionTargetPass._isSupported">
Determine if this target pass is supported on the current rendering device. 

</member>
        <member name="M:Ogre.CompositionTargetPass.getParent">
Get parent object 
</member>
        <member name="M:Ogre.CompositionTargetPass.getPassIterator">
Get an iterator over the Passes in this TargetPass. 
</member>
        <member name="M:Ogre.CompositionTargetPass.removeAllPasses">
Remove all passes

</member>
        <member name="M:Ogre.CompositionTargetPass.getNumPasses">
Get the number of passes.

</member>
        <member name="M:Ogre.CompositionTargetPass.getPass(System.UInt32)">
Get a pass.

</member>
        <member name="M:Ogre.CompositionTargetPass.removePass(System.UInt32)">
Remove a pass. It will also be destroyed.

</member>
        <member name="M:Ogre.CompositionTargetPass.createPass">
Create a new pass, and return a pointer to it.

</member>
        <member name="M:Ogre.CompositionTargetPass.getLodBias">
Get the scene LOD bias used by this pass 

</member>
        <member name="M:Ogre.CompositionTargetPass.setLodBias(System.Single)">
Set the scene LOD bias used by this pass. The default is 1.0,
            everything below that means lower quality, higher means higher quality.

</member>
        <member name="M:Ogre.CompositionTargetPass.getShadowsEnabled">
Get whether shadows are enabled in this target pass.
		@remarks
			Only applicable to targets that render the scene as
			one of their passes.

</member>
        <member name="M:Ogre.CompositionTargetPass.setShadowsEnabled(System.Boolean)">
Set whether shadows are enabled in this target pass.
		@remarks
			Only applicable to targets that render the scene as
			one of their passes.

</member>
        <member name="M:Ogre.CompositionTargetPass.getMaterialScheme">
Get the material scheme used by this target pass.
		@remarks
			Only applicable to targets that render the scene as
			one of their passes.
			@see Technique::setScheme.

</member>
        <member name="M:Ogre.CompositionTargetPass.setMaterialScheme(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the material scheme used by this target pass.
		@remarks
			Only applicable to targets that render the scene as
			one of their passes.
			@see Technique::setScheme.

</member>
        <member name="M:Ogre.CompositionTargetPass.getVisibilityMask">
Get the scene visibility mask used by this pass 

</member>
        <member name="M:Ogre.CompositionTargetPass.setVisibilityMask(System.UInt32)">
Set the scene visibility mask used by this pass 

</member>
        <member name="M:Ogre.CompositionTargetPass.getOnlyInitial">
Get "only initial" flag.

</member>
        <member name="M:Ogre.CompositionTargetPass.setOnlyInitial(System.Boolean)">
Set "only initial" flag. This makes that this target pass is only executed initially 
            after the effect has been enabled.

</member>
        <member name="M:Ogre.CompositionTargetPass.getOutputName">
Get output local texture name 
</member>
        <member name="M:Ogre.CompositionTargetPass.setOutputName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set output local texture name 
</member>
        <member name="M:Ogre.CompositionTargetPass.getInputMode">
Get input mode 
</member>
        <member name="M:Ogre.CompositionTargetPass.setInputMode(Ogre.CompositionTargetPass.InputMode)">
Set input mode of this TargetPass

</member>
        <member name="T:Ogre.CompositionTargetPass.InputMode">
Input mode of a TargetPass

</member>
        <member name="T:Ogre.CompositionTargetPass">
\addtogroup Core
	*  @{

\addtogroup Effects
	*  @{

Object representing one render to a RenderTarget or Viewport in the Ogre Composition
		framework.

</member>
        <member name="F:Ogre.CompositionPass.mQuadLeft">
quad positions in normalised coordinates [-1;1]x[-1;1] (in case of PT_RENDERQUAD)
</member>
        <member name="F:Ogre.CompositionPass.mQuadCornerModified">
true if quad should not cover whole screen
</member>
        <member name="F:Ogre.CompositionPass.mStencilCheck">
Stencil operation parameters
</member>
        <member name="F:Ogre.CompositionPass.mInputs">
Inputs (for material used for rendering the quad)
An empty string signifies that no input is used
</member>
        <member name="F:Ogre.CompositionPass.mClearStencil">
Clear stencil value (in case of PT_CLEAR)
</member>
        <member name="F:Ogre.CompositionPass.mClearDepth">
Clear depth (in case of PT_CLEAR)
</member>
        <member name="F:Ogre.CompositionPass.mClearColour">
Clear colour (in case of PT_CLEAR)
</member>
        <member name="F:Ogre.CompositionPass.mClearBuffers">
Clear buffers (in case of PT_CLEAR)
</member>
        <member name="F:Ogre.CompositionPass.mMaterialScheme">
Material scheme name
</member>
        <member name="F:Ogre.CompositionPass.mFirstRenderQueue">
[first,last] render queue to render this pass (in case of PT_RENDERSCENE)
</member>
        <member name="F:Ogre.CompositionPass.mMaterial">
Material used for rendering
</member>
        <member name="F:Ogre.CompositionPass.mIdentifier">
Identifier for this pass
</member>
        <member name="F:Ogre.CompositionPass.mType">
Type of composition pass
</member>
        <member name="F:Ogre.CompositionPass.mParent">
Parent technique
</member>
        <member name="M:Ogre.CompositionPass.getCustomType">
Get the type name of this custom composition pass.
			@note applies when PassType is RENDERCUSTOM
			@see CompositorManager::registerCustomCompositionPass

</member>
        <member name="M:Ogre.CompositionPass.setCustomType(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the type name of this custom composition pass.
			@note applies when PassType is RENDERCUSTOM
			@see CompositorManager::registerCustomCompositionPass

</member>
        <member name="M:Ogre.CompositionPass.getQuadFarCornersViewSpace">
Returns true if the far corners provided in the quad are in view space
			@note applies when PassType is RENDERQUAD 

</member>
        <member name="M:Ogre.CompositionPass.getQuadFarCorners">
Returns true if camera frustum far corners are provided in the quad.
			@note applies when PassType is RENDERQUAD 

</member>
        <member name="M:Ogre.CompositionPass.setQuadFarCorners(System.Boolean,System.Boolean)">
Sets the use of camera frustum far corners provided in the quad's normals
			@note applies when PassType is RENDERQUAD 

</member>
        <member name="M:Ogre.CompositionPass.getQuadCorners(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get quad normalised positions [-1;1]x[-1;1]
            @note applies when PassType is RENDERQUAD 

</member>
        <member name="M:Ogre.CompositionPass.setQuadCorners(System.Single,System.Single,System.Single,System.Single)">
Set quad normalised positions [-1;1]x[-1;1]
            @note applies when PassType is RENDERQUAD

</member>
        <member name="M:Ogre.CompositionPass._isSupported">
Determine if this target pass is supported on the current rendering device. 

</member>
        <member name="M:Ogre.CompositionPass.getParent">
Get parent object 
			@note applies when PassType is RENDERQUAD 

</member>
        <member name="M:Ogre.CompositionPass.clearAllInputs">
Clear all inputs.
			@note applies when PassType is RENDERQUAD 

</member>
        <member name="M:Ogre.CompositionPass.getNumInputs">
Get the number of inputs used.
			@note applies when PassType is RENDERQUAD 

</member>
        <member name="M:Ogre.CompositionPass.getInput(System.UInt32)">
Get the value of an input.
            @param id    Input to get. Must be in 0..OGRE_MAX_TEXTURE_LAYERS-1.
			@note applies when PassType is RENDERQUAD 

</member>
        <member name="M:Ogre.CompositionPass.setInput(System.UInt32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Set an input local texture. An empty string clears the input.
            @param id    Input to set. Must be in 0..OGRE_MAX_TEXTURE_LAYERS-1
            @param input Which texture to bind to this input. An empty string clears the input.
			@param mrtIndex Which surface of an MRT to retrieve
			@note applies when PassType is RENDERQUAD 

</member>
        <member name="F:Ogre.CompositionPass.InputTex.mrtIndex">
MRT surface index if applicable
</member>
        <member name="F:Ogre.CompositionPass.InputTex.name">
Name (local) of the input texture (empty == no input)
</member>
        <member name="T:Ogre.CompositionPass.InputTex">
Inputs (for material used for rendering the quad)
</member>
        <member name="M:Ogre.CompositionPass.getStencilTwoSidedOperation">
Get two sided stencil operation.
			@note applies when PassType is STENCIL

</member>
        <member name="M:Ogre.CompositionPass.setStencilTwoSidedOperation(System.Boolean)">
Set two sided stencil operation.
			@note applies when PassType is STENCIL

</member>
        <member name="M:Ogre.CompositionPass.getStencilPassOp">
Get stencil pass operation.
			@note applies when PassType is STENCIL

</member>
        <member name="M:Ogre.CompositionPass.setStencilPassOp(Ogre.StencilOperation)">
Set stencil pass operation.
			@note applies when PassType is STENCIL

</member>
        <member name="M:Ogre.CompositionPass.getStencilDepthFailOp">
Get stencil depth fail operation.
			@note applies when PassType is STENCIL

</member>
        <member name="M:Ogre.CompositionPass.setStencilDepthFailOp(Ogre.StencilOperation)">
Set stencil depth fail operation.
			@note applies when PassType is STENCIL

</member>
        <member name="M:Ogre.CompositionPass.getStencilFailOp">
Get stencil fail operation.
			@note applies when PassType is STENCIL

</member>
        <member name="M:Ogre.CompositionPass.setStencilFailOp(Ogre.StencilOperation)">
Set stencil fail operation.
			@note applies when PassType is STENCIL

</member>
        <member name="M:Ogre.CompositionPass.getStencilMask">
Get stencil mask.
			@note applies when PassType is STENCIL

</member>
        <member name="M:Ogre.CompositionPass.setStencilMask(System.UInt32)">
Set stencil mask.
			@note applies when PassType is STENCIL

</member>
        <member name="M:Ogre.CompositionPass.getStencilRefValue">
Get stencil reference value.
			@note applies when PassType is STENCIL

</member>
        <member name="M:Ogre.CompositionPass.setStencilRefValue(System.UInt32)">
Set stencil reference value.
			@note applies when PassType is STENCIL

</member>
        <member name="M:Ogre.CompositionPass.getStencilFunc">
Get stencil compare function.
			@note applies when PassType is STENCIL

</member>
        <member name="M:Ogre.CompositionPass.setStencilFunc(Ogre.CompareFunction)">
Set stencil compare function.
			@note applies when PassType is STENCIL

</member>
        <member name="M:Ogre.CompositionPass.getStencilCheck">
Get stencil check enable.
			@note applies when PassType is STENCIL

</member>
        <member name="M:Ogre.CompositionPass.setStencilCheck(System.Boolean)">
Set stencil check on or off.
			@note applies when PassType is STENCIL

</member>
        <member name="M:Ogre.CompositionPass.getClearStencil">
Get the viewport clear stencil value (defaults to 0) 
			@note applies when PassType is CLEAR

</member>
        <member name="M:Ogre.CompositionPass.setClearStencil(System.UInt32)">
Set the viewport clear stencil value (defaults to 0) 
			@note applies when PassType is CLEAR

</member>
        <member name="M:Ogre.CompositionPass.getClearDepth">
Get the viewport clear depth (defaults to 1.0) 
			@note applies when PassType is CLEAR

</member>
        <member name="M:Ogre.CompositionPass.setClearDepth(System.Single)">
Set the viewport clear depth (defaults to 1.0) 
			@note applies when PassType is CLEAR

</member>
        <member name="M:Ogre.CompositionPass.getClearColour">
Get the viewport clear colour (defaults to 0,0,0,0)	
			@note applies when PassType is CLEAR

</member>
        <member name="M:Ogre.CompositionPass.setClearColour(Ogre.ColourValue)">
Set the viewport clear colour (defaults to 0,0,0,0) 
			@note applies when PassType is CLEAR

</member>
        <member name="M:Ogre.CompositionPass.getClearBuffers">
Get the viewport clear buffers.
			@note applies when PassType is CLEAR

</member>
        <member name="M:Ogre.CompositionPass.setClearBuffers(System.UInt32)">
Would be nice to have for RENDERSCENE:
			flags to:
				exclude transparents
				override material (at least -- color)

Set the viewport clear buffers  (defaults to FBT_COLOUR|FBT_DEPTH)
            @param val is a combination of FBT_COLOUR, FBT_DEPTH, FBT_STENCIL.
			@note applies when PassType is CLEAR

</member>
        <member name="M:Ogre.CompositionPass.getMaterialScheme">
Get the material scheme used by this pass.
		@remarks
			Only applicable to passes that render the scene.
			@see Technique::setScheme.

</member>
        <member name="M:Ogre.CompositionPass.setMaterialScheme(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the material scheme used by this pass.
		@remarks
			Only applicable to passes that render the scene.
			@see Technique::setScheme.

</member>
        <member name="M:Ogre.CompositionPass.getLastRenderQueue">
Get the last render queue to be rendered in this pass (inclusive) 
			@note applies when PassType is RENDERSCENE

</member>
        <member name="M:Ogre.CompositionPass.setLastRenderQueue(System.Byte)">
Set the last render queue to be rendered in this pass (inclusive) 
			@note applies when PassType is RENDERSCENE

</member>
        <member name="M:Ogre.CompositionPass.getFirstRenderQueue">
Get the first render queue to be rendered in this pass (inclusive) 
			@note applies when PassType is RENDERSCENE

</member>
        <member name="M:Ogre.CompositionPass.setFirstRenderQueue(System.Byte)">
Set the first render queue to be rendered in this pass (inclusive) 
			@note applies when PassType is RENDERSCENE

</member>
        <member name="M:Ogre.CompositionPass.getMaterial">
Get the material used by this pass 
			@note applies when PassType is RENDERQUAD 

</member>
        <member name="M:Ogre.CompositionPass.setMaterialName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the material used by this pass 
			@note applies when PassType is RENDERQUAD 

</member>
        <member name="M:Ogre.CompositionPass.setMaterial(Ogre.MaterialPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the material used by this pass
			@note applies when PassType is RENDERQUAD 

</member>
        <member name="M:Ogre.CompositionPass.getIdentifier">
Get the identifier for this pass 
</member>
        <member name="M:Ogre.CompositionPass.setIdentifier(System.UInt32)">
Set an identifier for this pass. This identifier can be used to
			"listen in" on this pass with an CompositorInstance::Listener. 

</member>
        <member name="M:Ogre.CompositionPass.getType">
Get the type of composition pass 
</member>
        <member name="M:Ogre.CompositionPass.setType(Ogre.CompositionPass.PassType)">
Set the type of composition pass 
</member>
        <member name="T:Ogre.CompositionPass.PassType">
Enumeration that enumerates the various composition pass types.

</member>
        <member name="T:Ogre.CompositionPass">
\addtogroup Core
	*  @{

\addtogroup Effects
	*  @{

Object representing one pass or operation in a composition sequence. This provides a 
		method to conveniently interleave RenderSystem commands between Render Queues.

</member>
        <member name="F:Ogre.CompositorChain.mOldShadowsEnabled">
Store old shadows enabled flag
</member>
        <member name="F:Ogre.CompositorChain.mOldMaterialScheme">
Store old viewport material scheme
</member>
        <member name="F:Ogre.CompositorChain.mOldLodBias">
Store old camera LOD bias      
</member>
        <member name="F:Ogre.CompositorChain.mOldFindVisibleObjects">
Store old find visible objects
</member>
        <member name="F:Ogre.CompositorChain.mOldVisibilityMask">
Store old scene visibility mask
</member>
        <member name="F:Ogre.CompositorChain.mOldClearEveryFrameBuffers">
Old viewport settings
</member>
        <member name="M:Ogre.CompositorChain.RQListener.flushUpTo(System.Byte)">
Flush remaining render system operations 
</member>
        <member name="M:Ogre.CompositorChain.RQListener.notifyViewport(Ogre.Viewport*)">
Notify current destination viewport  
</member>
        <member name="M:Ogre.CompositorChain.RQListener.setOperation(Ogre.CompositorInstance.TargetOperation*,Ogre.SceneManager*,Ogre.RenderSystem*)">
Set current operation and target 
</member>
        <member name="M:Ogre.CompositorChain.RQListener.renderQueueEnded(System.Byte,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc RenderQueueListener::renderQueueEnded

</member>
        <member name="M:Ogre.CompositorChain.RQListener.renderQueueStarted(System.Byte,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc RenderQueueListener::renderQueueStarted

</member>
        <member name="T:Ogre.CompositorChain.RQListener">
Render queue listener used to set up rendering events. 
</member>
        <member name="M:Ogre.CompositorChain.destroyResources">
destroy internal resources
</member>
        <member name="M:Ogre.CompositorChain.postTargetOperation(Ogre.CompositorInstance.TargetOperation*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Viewport*,Ogre.Camera*)">
Restore a viewport, the camera and the scene after a rendering operation

</member>
        <member name="M:Ogre.CompositorChain.preTargetOperation(Ogre.CompositorInstance.TargetOperation*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Viewport*,Ogre.Camera*)">
Prepare a viewport, the camera and the scene for a rendering operation

</member>
        <member name="M:Ogre.CompositorChain.clearCompiledState">
Clear compiled state 
</member>
        <member name="D:Ogre.CompositorChain.RenderSystemOperations">
Render System operations queued by last compile, these are created by this
instance thus managed and deleted by it. The list is cleared with 
clearCompilationState()
</member>
        <member name="F:Ogre.CompositorChain.mCompiledState">
Compiled state (updated with _compile)
</member>
        <member name="F:Ogre.CompositorChain.mAnyCompositorsEnabled">
Any compositors enabled?
</member>
        <member name="F:Ogre.CompositorChain.mDirty">
State needs recompile
</member>
        <member name="F:Ogre.CompositorChain.mInstances">
Postfilter instances in this chain
</member>
        <member name="F:Ogre.CompositorChain.mOriginalScene">
Plainly renders the scene; implicit first compositor in the chain.

</member>
        <member name="F:Ogre.CompositorChain.mViewport">
Viewport affected by this CompositorChain
</member>
        <member name="M:Ogre.CompositorChain.getNextInstance(Ogre.CompositorInstance*,System.Boolean)">
Get the next instance in this chain to the one specified. 

</member>
        <member name="M:Ogre.CompositorChain.getPreviousInstance(Ogre.CompositorInstance*,System.Boolean)">
Get the previous instance in this chain to the one specified. 

</member>
        <member name="M:Ogre.CompositorChain._compile">
Compile this Composition chain into a series of RenderTarget operations.

</member>
        <member name="M:Ogre.CompositorChain._queuedOperation(Ogre.CompositorInstance.RenderSystemOperation*)">
Internal method for registering a queued operation for deletion later *
</member>
        <member name="M:Ogre.CompositorChain._removeInstance(Ogre.CompositorInstance*)">
Remove a compositor by pointer. This is internally used by CompositionTechnique to
			"weak" remove any instanced of a deleted technique.

</member>
        <member name="M:Ogre.CompositorChain._notifyViewport(Ogre.Viewport*)">
Internal method for reconnecting with viewport 
</member>
        <member name="M:Ogre.CompositorChain.getViewport">
Get viewport that is the target of this chain

</member>
        <member name="M:Ogre.CompositorChain._markDirty">
Mark state as dirty, and to be recompiled next frame.

</member>
        <member name="M:Ogre.CompositorChain.viewportRemoved(Ogre.RenderTargetViewportEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@see RenderTargetListener::viewportRemoved 
</member>
        <member name="M:Ogre.CompositorChain.postViewportUpdate(Ogre.RenderTargetViewportEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@see RenderTargetListener::postViewportUpdate 
</member>
        <member name="M:Ogre.CompositorChain.preViewportUpdate(Ogre.RenderTargetViewportEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@see RenderTargetListener::preViewportUpdate 
</member>
        <member name="M:Ogre.CompositorChain.postRenderTargetUpdate(Ogre.RenderTargetEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@see RenderTargetListener::postRenderTargetUpdate 
</member>
        <member name="M:Ogre.CompositorChain.preRenderTargetUpdate(Ogre.RenderTargetEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@see RenderTargetListener::preRenderTargetUpdate 
</member>
        <member name="M:Ogre.CompositorChain.setCompositorEnabled(System.UInt32,System.Boolean)">
Enable or disable a compositor, by position. Disabling a compositor stops it from rendering
            but does not free any resources. This can be more efficient than using removeCompositor and 
			addCompositor in cases the filter is switched on and off a lot.
        @param position    Position in filter chain of filter

</member>
        <member name="M:Ogre.CompositorChain.getCompositors">
Get an iterator over the compositor instances. The first compositor in this list is applied first, the last one is applied last.

</member>
        <member name="M:Ogre.CompositorChain._getOriginalSceneCompositor">
Get the original scene compositor instance for this chain (internal use). 

</member>
        <member name="M:Ogre.CompositorChain.getCompositor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get compositor instance by name. Returns null if not found.

</member>
        <member name="M:Ogre.CompositorChain.getCompositor(System.UInt32)">
Get compositor instance by position.

</member>
        <member name="M:Ogre.CompositorChain.removeAllCompositors">
Remove all compositors.

</member>
        <member name="M:Ogre.CompositorChain.getNumCompositors">
Get the number of compositors.

</member>
        <member name="M:Ogre.CompositorChain.removeCompositor(System.UInt32)">
Remove a compositor.
        @param position    Position in filter chain of filter to remove; defaults to the end (last applied filter)

</member>
        <member name="M:Ogre.CompositorChain.addCompositor(Ogre.CompositorPtr,System.UInt32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Apply a compositor. Initially, the filter is enabled.
        @param filter     Filter to apply
        @param addPosition    Position in filter chain to insert this filter at; defaults to the end (last applied filter)
        @param scheme      Scheme to use (blank means default)

</member>
        <member name="F:Ogre.CompositorChain.BEST">
Identifier for best technique
</member>
        <member name="F:Ogre.CompositorChain.LAST">
Identifier for "last" compositor in chain
</member>
        <member name="D:Ogre.CompositorChain.Instances">
Data types
</member>
        <member name="M:Ogre.CompositorChain.Dispose">
Another gcc warning here, which is no problem because RenderTargetListener is never used
            to delete an object.
            warning: `class Ogre::CompositorChain' has virtual functions but non-virtual destructor

</member>
        <member name="T:Ogre.CompositorChain">
\addtogroup Core
	*  @{

\addtogroup Effects
	*  @{

Chain of compositor effects applying to one viewport.

</member>
        <member name="M:Ogre.CompositorInstance.deriveTextureRenderTargetOptions(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*,System.UInt32*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*)">
Search for options like AA and hardware gamma which we may want to 
			inherit from the main render target to which we're attached. 

</member>
        <member name="M:Ogre.CompositorInstance.getMRTTexLocalName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Util method for assigning a local texture name to a MRT attachment
</member>
        <member name="M:Ogre.CompositorInstance.queueRenderSystemOp(Ogre.CompositorInstance.TargetOperation*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.CompositorInstance.RenderSystemOperation*)">
Queue a render system operation.
			@returns destination pass

</member>
        <member name="M:Ogre.CompositorInstance.getSourceForTex(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Get source texture name for a named local texture.
		@param name The local name of the texture as given to it in the compositor
		@param mrtIndex For MRTs, which attached surface to retrieve

</member>
        <member name="M:Ogre.CompositorInstance.getTargetForTex(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get RenderTarget for a named local texture.

</member>
        <member name="M:Ogre.CompositorInstance.freeResources(System.Boolean,System.Boolean)">
Destroy local rendertextures and other resources.

</member>
        <member name="M:Ogre.CompositorInstance.createResources(System.Boolean)">
Create local rendertextures and other resources. Builds mLocalTextures.

</member>
        <member name="M:Ogre.CompositorInstance.createLocalMaterial(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a local dummy material with one technique but no passes.
            The material is detached from the Material Manager to make sure it is destroyed
			when going out of scope.

</member>
        <member name="M:Ogre.CompositorInstance.collectPasses(Ogre.CompositorInstance.TargetOperation*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.CompositionTargetPass*)">
Collect rendering passes. Here, passes are converted into render target operations
			and queued with queueRenderSystemOp.

</member>
        <member name="F:Ogre.CompositorInstance.mActiveScheme">
The scheme which is being used in this instance
</member>
        <member name="F:Ogre.CompositorInstance.mPreviousInstance">
Previous instance (set by chain)
</member>
        <member name="D:Ogre.CompositorInstance.Listeners">
Vector of listeners
</member>
        <member name="F:Ogre.CompositorInstance.mReserveTextures">
Textures that are not currently in use, but that we want to keep for now,
			for example if we switch techniques but want to keep all textures available
			in case we switch back. 

</member>
        <member name="D:Ogre.CompositorInstance.LocalMRTMap">
Store a list of MRTs we've created
</member>
        <member name="D:Ogre.CompositorInstance.LocalTextureMap">
Map from name-&gt;local texture
</member>
        <member name="F:Ogre.CompositorInstance.mEnabled">
Is this instance enabled?
</member>
        <member name="F:Ogre.CompositorInstance.mChain">
Composition chain of which this instance is part
</member>
        <member name="F:Ogre.CompositorInstance.mTechnique">
Composition technique used by this instance
</member>
        <member name="F:Ogre.CompositorInstance.mCompositor">
Compositor of which this is an instance
</member>
        <member name="M:Ogre.CompositorInstance._fireNotifyResourcesCreated(System.Boolean)">
Notify listeners of a material render.

</member>
        <member name="M:Ogre.CompositorInstance._fireNotifyMaterialRender(System.UInt32,Ogre.MaterialPtr*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Notify listeners of a material render.

</member>
        <member name="M:Ogre.CompositorInstance._fireNotifyMaterialSetup(System.UInt32,Ogre.MaterialPtr*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Notify listeners of a material compilation.

</member>
        <member name="M:Ogre.CompositorInstance.removeListener(Ogre.CompositorInstance.Listener*)">
Remove a listener.
			@see CompositorInstance::Listener

</member>
        <member name="M:Ogre.CompositorInstance.addListener(Ogre.CompositorInstance.Listener*)">
Add a listener. Listeners provide an interface to "listen in" to to render system 
			operations executed by this CompositorInstance so that materials can be 
			programmatically set up.
			@see CompositorInstance::Listener

</member>
        <member name="M:Ogre.CompositorInstance.getChain">
Get Chain that this instance is part of

</member>
        <member name="M:Ogre.CompositorInstance.notifyResized">
Notify this instance that the primary surface has been resized. 
		@remarks
			This will allow the instance to recreate its resources that 
			are dependent on the size. 

</member>
        <member name="M:Ogre.CompositorInstance.getScheme">
Returns the name of the scheme this compositor is using
</member>
        <member name="M:Ogre.CompositorInstance.getTechnique">
Get CompositionTechnique used by this instance

</member>
        <member name="M:Ogre.CompositorInstance.getCompositor">
Get Compositor of which this is an instance

</member>
        <member name="M:Ogre.CompositorInstance._compileOutputOperation(Ogre.CompositorInstance.TargetOperation*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Compile the final (output) operation. This is done separately because this
            is combined with the input in chained filters.

</member>
        <member name="M:Ogre.CompositorInstance._compileTargetOperations(std.vector&lt;Ogre.CompositorInstance.TargetOperation&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Recursively collect target states (except for final Pass).
            @param compiledState    This vector will contain a list of TargetOperation objects

</member>
        <member name="M:Ogre.CompositorInstance.getRenderTarget(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get the render target for a given render texture name. 
		@remarks
			You can use this to add listeners etc, but do not use it to update the
			targets manually or any other modifications, the compositor instance 
			is in charge of this.

</member>
        <member name="M:Ogre.CompositorInstance.getTextureInstance(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Get the instance of a local texture.
		@note Textures are only valid when local textures have been loaded, 
			which in practice means that the compositor instance is active. Calling
			this method at other times will return null pointers. Note that since textures
			are cleaned up aggressively, this pointer is not guaranteed to stay the
			same if you disable and re-enable the compositor instance.
		@param name The name of the texture in the original compositor definition
		@param mrtIndex If name identifies a MRT, which texture attachment to retrieve
		@returns The texture pointer, corresponds to a real texture

</member>
        <member name="M:Ogre.CompositorInstance.getTextureInstanceName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Get the instance name for a local texture.
		@note It is only valid to call this when local textures have been loaded, 
			which in practice means that the compositor instance is active. Calling
			it at other times will cause an exception. Note that since textures
			are cleaned up aggressively, this name is not guaranteed to stay the
			same if you disable and re-enable the compositor instance.
		@param name The name of the texture in the original compositor definition
		@param mrtIndex If name identifies a MRT, which texture attachment to retrieve
		@returns The instance name for the texture, corresponds to a real texture

</member>
        <member name="M:Ogre.CompositorInstance.getEnabled">
Get enabled flag.

</member>
        <member name="M:Ogre.CompositorInstance.setEnabled(System.Boolean)">
Set enabled flag. The compositor instance will only render if it is
            enabled, otherwise it is pass-through.

</member>
        <member name="F:Ogre.CompositorInstance.TargetOperation.shadowsEnabled">
Whether shadows will be enabled 
</member>
        <member name="F:Ogre.CompositorInstance.TargetOperation.materialScheme">
Which material scheme this op will use 
</member>
        <member name="F:Ogre.CompositorInstance.TargetOperation.findVisibleObjects">
Whether this op needs to find visible scene objects or not 

</member>
        <member name="F:Ogre.CompositorInstance.TargetOperation.hasBeenRendered">
"Has been rendered" flag; used in combination with
                onlyInitial to determine whether to skip this target operation.

</member>
        <member name="F:Ogre.CompositorInstance.TargetOperation.onlyInitial">
@see CompositionTargetPass::mOnlyInitial

</member>
        <member name="F:Ogre.CompositorInstance.TargetOperation.renderQueues">
Which renderqueues to render from scene
</member>
        <member name="D:Ogre.CompositorInstance.TargetOperation.RenderQueueBitSet">
A set of render queues to either include or exclude certain render queues.

</member>
        <member name="F:Ogre.CompositorInstance.TargetOperation.lodBias">
LOD offset. This is multiplied with the camera LOD offset
1.0 is default, lower means lower detail, higher means higher detail
</member>
        <member name="F:Ogre.CompositorInstance.TargetOperation.visibilityMask">
Scene visibility mask
If this is 0, the scene is not rendered at all
</member>
        <member name="F:Ogre.CompositorInstance.TargetOperation.renderSystemOperations">
RenderSystem operations to queue into the scene manager, by
uint8
</member>
        <member name="F:Ogre.CompositorInstance.TargetOperation.currentQueueGroupID">
Current group ID
</member>
        <member name="F:Ogre.CompositorInstance.TargetOperation.target">
Target
</member>
        <member name="T:Ogre.CompositorInstance.TargetOperation">
Operation setup for a RenderTarget (collected).

</member>
        <member name="M:Ogre.CompositorInstance.RenderSystemOperation.execute(Ogre.SceneManager*,Ogre.RenderSystem*)">
Set state to SceneManager and RenderSystem
</member>
        <member name="T:Ogre.CompositorInstance.RenderSystemOperation">
Specific render system operation. A render target operation does special operations
		    between render queues like rendering a quad, clearing the frame buffer or 
			setting stencil state.

</member>
        <member name="M:Ogre.CompositorInstance.Listener.notifyResourcesCreated(System.Boolean)">
Notification after resources have been created (or recreated).
				@param resizeOnly Was the creation because the viewport was resized?

</member>
        <member name="M:Ogre.CompositorInstance.Listener.notifyMaterialRender(System.UInt32,Ogre.MaterialPtr*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Notification before a render target operation involving a material (like
				rendering a quad), so that material parameters can be varied.
				@param pass_id	Pass identifier within Compositor instance, this is specified 
								by the user by CompositionPass::setIdentifier().
				@param mat		Material, this may be changed at will and will only affect
								the current instance of the Compositor, not the global material
								it was cloned from.

</member>
        <member name="M:Ogre.CompositorInstance.Listener.notifyMaterialSetup(System.UInt32,Ogre.MaterialPtr*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Notification of when a render target operation involving a material (like
				rendering a quad) is compiled, so that miscellaneous parameters that are different
				per Compositor instance can be set up.
				@param pass_id	Pass identifier within Compositor instance, this is specified 
								by the user by CompositionPass::setIdentifier().
				@param mat		Material, this may be changed at will and will only affect
								the current instance of the Compositor, not the global material
								it was cloned from.

</member>
        <member name="T:Ogre.CompositorInstance.Listener">
Provides an interface to "listen in" to to render system operations executed by this 
			CompositorInstance.

</member>
        <member name="T:Ogre.CompositorInstance">
An instance of a Compositor object for one Viewport. It is part of the CompositorChain
		for a Viewport.

</member>
        <member name="D:Ogre.CompositorManager.CustomCompositionPassMap">
Map of registered custom composition passes
</member>
        <member name="D:Ogre.CompositorManager.CompositorLogicMap">
Map of registered compositor logics
</member>
        <member name="D:Ogre.CompositorManager.Instances">
List of instances
</member>
        <member name="M:Ogre.CompositorManager.freeChains">
Clear composition chains for all viewports

</member>
        <member name="M:Ogre.CompositorManager.getSingletonPtr">
Override standard Singleton retrieval.
		@remarks
		Why do we do this? Well, it's because the Singleton
		implementation is in a .h file, which means it gets compiled
		into anybody who includes it. This is needed for the
		Singleton template to work, but we actually only want it
		compiled into the implementation of the class based on the
		Singleton, not all of them. If we don't change this, we get
		link errors when trying to use the Singleton-based class from
		an outside dll.
		@par
		This method just delegates to the template version anyway,
		but the implementation stays in this single compilation unit,
		preventing link errors.

</member>
        <member name="M:Ogre.CompositorManager.getSingleton">
Override standard Singleton retrieval.
		@remarks
		Why do we do this? Well, it's because the Singleton
		implementation is in a .h file, which means it gets compiled
		into anybody who includes it. This is needed for the
		Singleton template to work, but we actually only want it
		compiled into the implementation of the class based on the
		Singleton, not all of them. If we don't change this, we get
		link errors when trying to use the Singleton-based class from
		an outside dll.
		@par
		This method just delegates to the template version anyway,
		but the implementation stays in this single compilation unit,
		preventing link errors.

</member>
        <member name="M:Ogre.CompositorManager._relocateChain(Ogre.Viewport*,Ogre.Viewport*)">
Relocates a compositor chain from one viewport to another
@param sourceVP The viewport to take the chain from
@param destVP The viewport to connect the chain to

</member>
        <member name="M:Ogre.CompositorManager.getCustomCompositionPass(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get a custom composition pass by its name 

</member>
        <member name="M:Ogre.CompositorManager.registerCustomCompositionPass(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.CustomCompositionPass*)">
Register a custom composition pass.

</member>
        <member name="M:Ogre.CompositorManager.getCompositorLogic(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get a compositor logic by its name

</member>
        <member name="M:Ogre.CompositorManager.registerCompositorLogic(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.CompositorLogic*)">
Register a compositor logic for listening in to expecting composition
			techniques.

</member>
        <member name="M:Ogre.CompositorManager.freePooledTextures(System.Boolean)">
Free pooled textures from the shared pool (compositor instances still 
			using them will keep them in memory though). 

</member>
        <member name="M:Ogre.CompositorManager.getPooledTexture(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.Pixe">
Utility function to get an existing pooled texture matching a given
			definition, or creating one if one doesn't exist. It also takes into
			account whether a pooled texture has already been supplied to this
			same requester already, in which case it won't give the same texture
			twice (this is important for example if you request 2 ping-pong textures, 
			you don't want to get the same texture for both requests!

</member>
        <member name="M:Ogre.CompositorManager._reconstructAllCompositorResources">
Internal method for forcing all active compositors to recreate their resources. 
</member>
        <member name="M:Ogre.CompositorManager.removeAll">
Overridden from ResourceManager since we have to clean up chains too. 
</member>
        <member name="M:Ogre.CompositorManager._getTexturedRectangle2D">
Get a textured fullscreen 2D rectangle, for internal use.

</member>
        <member name="M:Ogre.CompositorManager.setCompositorEnabled(Ogre.Viewport*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Set the state of a compositor on a viewport to enabled or disabled.
			Disabling a compositor stops it from rendering but does not free any resources.
			This can be more efficient than using removeCompositor and addCompositor in cases
			the filter is switched on and off a lot.

</member>
        <member name="M:Ogre.CompositorManager.removeCompositor(Ogre.Viewport*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Remove a compositor from a viewport

</member>
        <member name="M:Ogre.CompositorManager.addCompositor(Ogre.Viewport*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Add a compositor to a viewport. By default, it is added to end of the chain,
			after the other compositors.
			@param vp			Viewport to modify
			@param compositor	The name of the compositor to apply
			@param addPosition	At which position to add, defaults to the end (-1).
			@returns pointer to instance, or 0 if it failed.

</member>
        <member name="M:Ogre.CompositorManager.removeCompositorChain(Ogre.Viewport*)">
Remove the compositor chain from a viewport if exists.

</member>
        <member name="M:Ogre.CompositorManager.hasCompositorChain(Ogre.Viewport*)">
Returns whether exists compositor chain for a viewport.

</member>
        <member name="M:Ogre.CompositorManager.getCompositorChain(Ogre.Viewport*)">
Get the compositor chain for a Viewport. If there is none yet, a new
			compositor chain is registered.
			XXX We need a _notifyViewportRemoved to find out when this viewport disappears,
			so we can destroy its chain as well.

</member>
        <member name="M:Ogre.CompositorManager.parseScript(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@see ScriptLoader::parseScript

</member>
        <member name="M:Ogre.CompositorManager.initialise">
Initialises the Compositor manager, which also triggers it to
            parse all available .compositor scripts. 
</member>
        <member name="M:Ogre.CompositorManager.createImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.ManualRes">
Overridden from ResourceManager
</member>
        <member name="T:Ogre.CompositorManager">
\addtogroup Core
	*  @{

\addtogroup Effects
	*  @{

Class for managing Compositor settings for Ogre. Compositors provide the means
        to flexibly "composite" the final rendering result from multiple scene renders
        and intermediate operations like rendering fullscreen quads. This makes
        it possible to apply postfilter effects, HDRI postprocessing, and shadow
        effects to a Viewport.
        @par
            When loaded from a script, a Compositor is in an 'unloaded' state and only stores the settings
            required. It does not at that stage load any textures. This is because the material settings may be
            loaded 'en masse' from bulk material script files, but only a subset will actually be required.
        @par
            Because this is a subclass of ResourceManager, any files loaded will be searched for in any path or
            archive added to the resource paths/archives. See ResourceManager for details.

</member>
        <member name="F:Ogre.CompositionTechnique.mCompositorLogicName">
Optional compositor logic name
</member>
        <member name="F:Ogre.CompositionTechnique.mSchemeName">
Optional scheme name
</member>
        <member name="F:Ogre.CompositionTechnique.mOutputTarget">
Output target pass (can be only one)
</member>
        <member name="F:Ogre.CompositionTechnique.mTargetPasses">
Intermediate target passes
</member>
        <member name="F:Ogre.CompositionTechnique.mTextureDefinitions">
Local texture definitions
</member>
        <member name="F:Ogre.CompositionTechnique.mParent">
Parent compositor
</member>
        <member name="M:Ogre.CompositionTechnique.getParent">
Get parent object 
</member>
        <member name="M:Ogre.CompositionTechnique.getCompositorLogicName">
Get the compositor logic name assigned to this technique 
</member>
        <member name="M:Ogre.CompositionTechnique.setCompositorLogicName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the name of the compositor logic assigned to this technique.
			Instances of this technique will be auto-coupled with the matching logic.

</member>
        <member name="M:Ogre.CompositionTechnique.getSchemeName">
Get the scheme name assigned to this technique. 
</member>
        <member name="M:Ogre.CompositionTechnique.setSchemeName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assign a scheme name to this technique, used to switch between 
			multiple techniques by choice rather than for hardware compatibility.

</member>
        <member name="M:Ogre.CompositionTechnique.isSupported(System.Boolean)">
Determine if this technique is supported on the current rendering device. 
		@param allowTextureDegradation True to accept a reduction in texture depth

</member>
        <member name="M:Ogre.CompositionTechnique.getOutputTargetPass">
Get output (final) target pass

</member>
        <member name="M:Ogre.CompositionTechnique.getTargetPassIterator">
Get an iterator over the TargetPasses in this Technique. 
</member>
        <member name="M:Ogre.CompositionTechnique.removeAllTargetPasses">
Remove all target passes.

</member>
        <member name="M:Ogre.CompositionTechnique.getNumTargetPasses">
Get the number of target passes.

</member>
        <member name="M:Ogre.CompositionTechnique.getTargetPass(System.UInt32)">
Get a target pass.

</member>
        <member name="M:Ogre.CompositionTechnique.removeTargetPass(System.UInt32)">
Remove a target pass. It will also be destroyed.

</member>
        <member name="M:Ogre.CompositionTechnique.createTargetPass">
Create a new target pass, and return a pointer to it.

</member>
        <member name="M:Ogre.CompositionTechnique.getTextureDefinitionIterator">
Get an iterator over the TextureDefinitions in this Technique. 
</member>
        <member name="M:Ogre.CompositionTechnique.removeAllTextureDefinitions">
Remove all Texture Definitions

</member>
        <member name="M:Ogre.CompositionTechnique.getNumTextureDefinitions">
Get the number of local texture definitions.

</member>
        <member name="M:Ogre.CompositionTechnique.getTextureDefinition(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get a local texture definition with a specific name.

</member>
        <member name="M:Ogre.CompositionTechnique.getTextureDefinition(System.UInt32)">
Get a local texture definition.

</member>
        <member name="M:Ogre.CompositionTechnique.removeTextureDefinition(System.UInt32)">
Remove and destroy a local texture definition.

</member>
        <member name="M:Ogre.CompositionTechnique.createTextureDefinition(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a new local texture definition, and return a pointer to it.
            @param name     Name of the local texture

</member>
        <member name="D:Ogre.CompositionTechnique.TargetPasses">
Typedefs for several iterators
</member>
        <member name="T:Ogre.CompositionTechnique.TextureDefinition">
Local texture definition
</member>
        <member name="T:Ogre.CompositionTechnique">
\addtogroup Core
	*  @{

\addtogroup Effects
	*  @{

Base composition technique, can be subclassed in plugins.

</member>
        <member name="M:Ogre.CompositorPtr.op_Assign(Ogre.SharedPtr&lt;Ogre.Resource&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Operator used to convert a ResourcePtr to a CompositorPtr
</member>
        <member name="D:Ogre.Compositor.GlobalMRTMap">
Store a list of MRTs we've created
</member>
        <member name="D:Ogre.Compositor.GlobalTextureMap">
Map from name-&gt;local texture
</member>
        <member name="M:Ogre.Compositor.freeGlobalTextures">
Destroy global rendertextures.

</member>
        <member name="M:Ogre.Compositor.createGlobalTextures">
Create global rendertextures.

</member>
        <member name="F:Ogre.Compositor.mCompilationRequired">
Compilation required
This is set if the techniques change and the supportedness of techniques has to be
re-evaluated.
</member>
        <member name="M:Ogre.Compositor.compile">
Check supportedness of techniques.

</member>
        <member name="M:Ogre.Compositor.calculateSize">
@copydoc Resource::calculateSize
</member>
        <member name="M:Ogre.Compositor.unloadImpl">
@copydoc Resource::unloadImpl
</member>
        <member name="M:Ogre.Compositor.loadImpl">
@copydoc Resource::loadImpl
</member>
        <member name="M:Ogre.Compositor.getRenderTarget(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get the render target for a given render texture name. 
		@remarks
			You can use this to add listeners etc, but do not use it to update the
			targets manually or any other modifications, the compositor instance 
			is in charge of this.

</member>
        <member name="M:Ogre.Compositor.getTextureInstance(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Get the instance of a global texture.
		@param name The name of the texture in the original compositor definition
		@param mrtIndex If name identifies a MRT, which texture attachment to retrieve
		@returns The texture pointer, corresponds to a real texture

</member>
        <member name="M:Ogre.Compositor.getTextureInstanceName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Get the instance name for a global texture.
		@param name The name of the texture in the original compositor definition
		@param mrtIndex If name identifies a MRT, which texture attachment to retrieve
		@returns The instance name for the texture, corresponds to a real texture

</member>
        <member name="M:Ogre.Compositor.getSupportedTechnique(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get a pointer to a supported technique for a given scheme. 
		@remarks
			If there is no specific supported technique with this scheme name, 
			then the first supported technique with no specific scheme will be returned.
		@param schemeName The scheme name you are looking for. Blank means to 
			look for techniques with no scheme associated

</member>
        <member name="M:Ogre.Compositor.getSupportedTechniqueIterator">
Gets an iterator over all the Techniques which are supported by the current card. 
        @remarks
            The supported technique list is only available after this compositor has been compiled,
            which typically happens on loading it. Therefore, if this method returns
            an empty list, try calling Compositor::load.

</member>
        <member name="M:Ogre.Compositor.getNumSupportedTechniques">
Get the number of supported techniques.
        @remarks
            The supported technique list is only available after this compositor has been compiled,
            which typically happens on loading it. Therefore, if this method returns
            an empty list, try calling Compositor::load.

</member>
        <member name="M:Ogre.Compositor.getSupportedTechnique(System.UInt32)">
Get a supported technique.
        @remarks
            The supported technique list is only available after this compositor has been compiled,
            which typically happens on loading it. Therefore, if this method returns
            an empty list, try calling Compositor::load.

</member>
        <member name="M:Ogre.Compositor.getTechniqueIterator">
Get an iterator over the Techniques in this compositor. 
</member>
        <member name="M:Ogre.Compositor.removeAllTechniques">
Remove all techniques

</member>
        <member name="M:Ogre.Compositor.getNumTechniques">
Get the number of techniques.

</member>
        <member name="M:Ogre.Compositor.getTechnique(System.UInt32)">
Get a technique.

</member>
        <member name="M:Ogre.Compositor.removeTechnique(System.UInt32)">
Remove a technique. It will also be destroyed.

</member>
        <member name="M:Ogre.Compositor.createTechnique">
Create a new technique, and return a pointer to it.

</member>
        <member name="D:Ogre.Compositor.Techniques">
Data types for internal lists
</member>
        <member name="T:Ogre.Compositor">
\addtogroup Core
	*  @{

\addtogroup Effects
	*  @{

Class representing a Compositor object. Compositors provide the means 
        to flexibly "composite" the final rendering result from multiple scene renders
        and intermediate operations like rendering fullscreen quads. This makes 
        it possible to apply postfilter effects, HDRI postprocessing, and shadow 
        effects to a Viewport.

</member>
        <member name="M:Ogre.SubMesh.removeLodLevels">
Internal method for removing LOD data
</member>
        <member name="F:Ogre.SubMesh.mBuildEdgesEnabled">
Is Build Edges Enabled
</member>
        <member name="F:Ogre.SubMesh.mVertexAnimationType">
Type of vertex animation for dedicated vertex data (populated by Mesh)
</member>
        <member name="F:Ogre.SubMesh.mBoneAssignmentsOutOfDate">
Flag indicating that bone assignments need to be recompiled
</member>
        <member name="F:Ogre.SubMesh.mTextureAliases">
paired list of texture aliases and texture names
</member>
        <member name="F:Ogre.SubMesh.mMatInitialised">
Is there a material yet?
</member>
        <member name="F:Ogre.SubMesh.mMaterialName">
Name of the material this SubMesh uses.
</member>
        <member name="M:Ogre.SubMesh.isBuildEdgesEnabled">
Returns true(by default) if the submesh should be included in the mesh EdgeList, otherwise returns false.

</member>
        <member name="M:Ogre.SubMesh.generateExtremes(System.UInt32)">
Generate the submesh extremes (@see extremityPoints).
        @param count
            Number of extreme points to compute for the submesh.

</member>
        <member name="M:Ogre.SubMesh.getVertexAnimationType">
Get the type of any vertex animation used by dedicated geometry.

</member>
        <member name="M:Ogre.SubMesh.updateMaterialUsingTextureAliases">
The current material used by the submesh is copied into a new material
           and the submesh's texture aliases are applied if the current texture alias
           names match those found in the original material.
       @remarks
           The submesh's texture aliases must be setup prior to calling this method.
           If a new material has to be created, the subMesh autogenerates the new name.
           The new name is the old name + "_" + number.
       @return 
           True if texture aliases were applied and a new material was created.

</member>
        <member name="M:Ogre.SubMesh.getTextureAliasCount">
Gets the number of texture aliases assigned to the sub mesh.

</member>
        <member name="M:Ogre.SubMesh.hasTextureAliases">
returns true if the sub mesh has texture aliases

</member>
        <member name="M:Ogre.SubMesh.removeAllTextureAliases">
removes all texture aliases from the sub mesh

</member>
        <member name="M:Ogre.SubMesh.removeTextureAlias(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Remove a specific texture alias name from the sub mesh
        @param
            aliasName is the name of the alias to be removed.  If it is not found 
            then it is ignored.

</member>
        <member name="M:Ogre.SubMesh.addTextureAlias(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds the alias or replaces an existing one and associates the texture name to it.
        @remarks
          The submesh uses the texture alias to replace textures used in the material applied
          to the submesh.
        @param
            aliasName is the name of the alias.
        @param
            textureName is the name of the texture to be associated with the alias


</member>
        <member name="M:Ogre.SubMesh.getAliasTextureIterator">
Gets an constant iterator to access all texture alias names assigned to this submesh. 


</member>
        <member name="M:Ogre.SubMesh._compileBoneAssignments">
Must be called once to compile bone assignments into geometry buffer. 
</member>
        <member name="M:Ogre.SubMesh.getBoneAssignments">
Gets a const reference to the list of bone assignments

</member>
        <member name="M:Ogre.SubMesh.getBoneAssignmentIterator">
Gets an iterator for access all bone assignments. 
        @remarks
            Only valid if this SubMesh has dedicated geometry.

</member>
        <member name="D:Ogre.SubMesh.VertexBoneAssignmentList">
Multimap of verex bone assignments (orders by vertex index)
</member>
        <member name="M:Ogre.SubMesh.clearBoneAssignments">
Removes all bone assignments for this mesh. 
        @par
            This method is for assigning weights to the dedicated geometry of the SubMesh. To assign
            weights to the shared Mesh geometry, see the equivalent methods on Mesh.

</member>
        <member name="M:Ogre.SubMesh.addBoneAssignment(Ogre.VertexBoneAssignment_s!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assigns a vertex to a bone with a given weight, for skeletal animation. 
        @remarks    
            This method is only valid after calling setSkeletonName.
            Since this is a one-off process there exists only 'addBoneAssignment' and
            'clearBoneAssignments' methods, no 'editBoneAssignment'. You should not need
            to modify bone assignments during rendering (only the positions of bones) and OGRE
            reserves the right to do some internal data reformatting of this information, depending
            on render system requirements.
        @par
            This method is for assigning weights to the dedicated geometry of the SubMesh. To assign
            weights to the shared Mesh geometry, see the equivalent methods on Mesh.

</member>
        <member name="M:Ogre.SubMesh._getRenderOperation(Ogre.RenderOperation*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16)">
Returns a RenderOperation structure required to render this mesh.
            @param 
                rend Reference to a RenderOperation structure to populate.
            @param
                lodIndex The index of the LOD to use. 

</member>
        <member name="M:Ogre.SubMesh.isMatInitialised">
Returns true if a material has been assigned to the submesh, otherwise returns false.

</member>
        <member name="M:Ogre.SubMesh.setMaterialName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the name of the Material which this SubMesh will use
</member>
        <member name="F:Ogre.SubMesh.parent">
Reference to parent Mesh (not a smart pointer so child does not keep parent alive).
</member>
        <member name="D:Ogre.SubMesh.PointList">
A list of extreme points on the submesh (optional).
            @remarks
                These points are some arbitrary points on the mesh that are used
                by engine to better sort submeshes by depth. This doesn't matter
                much for non-transparent submeshes, as Z-buffer takes care of invisible
                surface culling anyway, but is pretty useful for semi-transparent
                submeshes because the order in which transparent submeshes must be
                rendered cannot be always correctly deduced from entity position.
            @par
                These points are intelligently chosen from the points that make up
                the submesh, the criteria for choosing them should be that these points
                somewhat characterize the submesh outline, e.g. they should not be
                close to each other, and they should be on the outer hull of the submesh.
                They can be stored in the .mesh file, or generated at runtime
                (see generateExtremes ()).
            @par
                If this array is empty, submesh sorting is done like in older versions -
                by comparing the positions of the owning entity.

</member>
        <member name="D:Ogre.SubMesh.IndexMap">
Dedicated index map for translate blend index to bone index (only valid if useSharedVertices = false).
            @remarks
                This data is completely owned by this submesh.
            @par
                We collect actually used bones of all bone assignments, and build the
                blend index in 'packed' form, then the range of the blend index in vertex
                data VES_BLEND_INDICES element is continuous, with no gaps. Thus, by
                minimising the world matrix array constants passing to GPU, we can support
                more bones for a mesh when hardware skinning is used. The hardware skinning
                support limit is applied to each set of vertex data in the mesh, in other words, the
                hardware skinning support limit is applied only to the actually used bones of each
                SubMeshes, not all bones across the entire Mesh.
            @par
                Because the blend index is different to the bone index, therefore, we use
                the index map to translate the blend index to bone index.
            @par
                The use of shared or non-shared index map is determined when
                model data is converted to the OGRE .mesh format.

</member>
        <member name="F:Ogre.SubMesh.indexData">
Face index data
</member>
        <member name="F:Ogre.SubMesh.vertexData">
Dedicated vertex data (only valid if useSharedVertices = false).
            @remarks
                This data is completely owned by this submesh.
            @par
                The use of shared or non-shared buffers is determined when
                model data is converted to the OGRE .mesh format.

</member>
        <member name="F:Ogre.SubMesh.operationType">
The render operation type used to render this submesh
</member>
        <member name="F:Ogre.SubMesh.useSharedVertices">
Indicates if this submesh shares vertex data with other meshes or whether it has it's own vertices.
</member>
        <member name="T:Ogre.SubMesh">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

Defines a part of a complete mesh.
        @remarks
            Meshes which make up the definition of a discrete 3D object
            are made up of potentially multiple parts. This is because
            different parts of the mesh may use different materials or
            use different vertex formats, such that a rendering state
            change is required between them.
        @par
            Like the Mesh class, instantiations of 3D objects in the scene
            share the SubMesh instances, and have the option of overriding
            their material differences on a per-object basis if required.
            See the SubEntity class for more information.

</member>
        <member name="M:Ogre.SubEntity._invalidateCameraCache">
Invalidate the camera distance cache 
</member>
        <member name="M:Ogre.SubEntity._updateCustomGpuParameter(Ogre.GpuProgramParameters.AutoConstantEntry!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.GpuProgramParameters*)">
Overridden from Renderable to provide some custom behaviour. 
</member>
        <member name="M:Ogre.SubEntity._restoreBuffersForUnusedAnimation(System.Boolean)">
Internal method to copy original vertex data to the morph structures
		should there be no active animation in use.

</member>
        <member name="M:Ogre.SubEntity._getBuffersMarkedForAnimation">
Are buffers already marked as vertex animated? 
</member>
        <member name="M:Ogre.SubEntity._markBuffersUsedForAnimation">
Mark all vertex data as animated. 

</member>
        <member name="M:Ogre.SubEntity._markBuffersUnusedForAnimation">
Mark all vertex data as so far unanimated. 

</member>
        <member name="M:Ogre.SubEntity.getVertexDataForBinding">
Retrieve the VertexData which should be used for GPU binding
</member>
        <member name="M:Ogre.SubEntity._getVertexAnimTempBufferInfo">
Advanced method to get the temp buffer information for software 
		morph animation.

</member>
        <member name="M:Ogre.SubEntity._getSkelAnimTempBufferInfo">
Advanced method to get the temp buffer information for software 
		skeletal animation.

</member>
        <member name="M:Ogre.SubEntity._getHardwareVertexAnimVertexData">
Advanced method to get the hardware morph vertex information
        @note
            The positions/normals of the returned vertex data is in object space.

</member>
        <member name="M:Ogre.SubEntity._getSoftwareVertexAnimVertexData">
Advanced method to get the temporarily blended software morph vertex information
        @remarks
            Internal engine will eliminate software animation if possible, this
            information is unreliable unless added request for software animation
            via Entity::addSoftwareAnimationRequest.
        @note
            The positions/normals of the returned vertex data is in object space.

</member>
        <member name="M:Ogre.SubEntity._getSkelAnimVertexData">
Advanced method to get the temporarily blended vertex information
		for entities which are software skinned. 
        @remarks
            Internal engine will eliminate software animation if possible, this
            information is unreliable unless added request for software animation
            via Entity::addSoftwareAnimationRequest.
        @note
            The positions/normals of the returned vertex data is in object space.

</member>
        <member name="M:Ogre.SubEntity.getCastsShadows">
@copydoc Renderable::getCastsShadows 
</member>
        <member name="M:Ogre.SubEntity.getLights">
@copydoc Renderable::getLights 
</member>
        <member name="M:Ogre.SubEntity.getSquaredViewDepth(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Overridden, see Renderable 
</member>
        <member name="M:Ogre.SubEntity.getNumWorldTransforms">
Overridden - see Renderable.

</member>
        <member name="M:Ogre.SubEntity.getWorldTransforms(Ogre.Matrix4*)">
Overridden - see Renderable.

</member>
        <member name="M:Ogre.SubEntity.getRenderOperation(Ogre.RenderOperation*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Overridden - see Renderable.

</member>
        <member name="M:Ogre.SubEntity.getTechnique">
Overridden - see Renderable.

</member>
        <member name="M:Ogre.SubEntity.getMaterial">
Overridden - see Renderable.

</member>
        <member name="M:Ogre.SubEntity.getParent">
Accessor to get parent Entity 
</member>
        <member name="M:Ogre.SubEntity.getSubMesh">
Accessor method to read mesh data.

</member>
        <member name="M:Ogre.SubEntity.isVisible">
Returns whether or not this SubEntity is supposed to be visible. 
</member>
        <member name="M:Ogre.SubEntity.setVisible(System.Boolean)">
Tells this SubEntity whether to be visible or not. 
</member>
        <member name="M:Ogre.SubEntity.setMaterial(Ogre.MaterialPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets a Material to be used.
			@remarks
				By default a SubEntity uses the default Material that the SubMesh
				uses. This call can alter that so that the Material is different
				for this instance.

</member>
        <member name="M:Ogre.SubEntity.setMaterialName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the name of the Material to be used.
            @remarks
                By default a SubEntity uses the default Material that the SubMesh
                uses. This call can alter that so that the Material is different
                for this instance.

</member>
        <member name="M:Ogre.SubEntity.getMaterialName">
Gets the name of the Material in use by this instance.

</member>
        <member name="M:Ogre.SubEntity.prepareTempBlendBuffers">
Internal method for preparing this Entity for use in animation. 
</member>
        <member name="F:Ogre.SubEntity.mCachedCamera">
The camera for which the cached distance is valid
</member>
        <member name="F:Ogre.SubEntity.mCachedCameraDist">
Cached distance to last camera for getSquaredViewDepth
</member>
        <member name="F:Ogre.SubEntity.mHardwarePoseCount">
Number of hardware blended poses supported by material
</member>
        <member name="F:Ogre.SubEntity.mVertexAnimationAppliedThisFrame">
Have we applied any vertex animation to geometry?
</member>
        <member name="F:Ogre.SubEntity.mHardwareVertexAnimVertexData">
Vertex data details for hardware Vertex anim of shared geometry
- separate since we need to s/w anim for shadows whilst still altering
  the vertex data for hardware morphing (pos2 binding)
</member>
        <member name="F:Ogre.SubEntity.mSoftwareVertexAnimVertexData">
Vertex data details for software Vertex anim of shared geometry
</member>
        <member name="F:Ogre.SubEntity.mTempVertexAnimInfo">
Temp buffer details for software Vertex anim geometry
</member>
        <member name="F:Ogre.SubEntity.mTempSkelAnimInfo">
Quick lookup of buffers
</member>
        <member name="F:Ogre.SubEntity.mSkelAnimVertexData">
blend buffer details for dedicated geometry
</member>
        <member name="F:Ogre.SubEntity.mMaterialLodIndex">
The LOD number of the material to use, calculated by Entity::_notifyCurrentCamera
</member>
        <member name="F:Ogre.SubEntity.mVisible">
Is this SubEntity visible?
</member>
        <member name="F:Ogre.SubEntity.mpMaterial">
Cached pointer to material.
</member>
        <member name="F:Ogre.SubEntity.mMaterialName">
Name of Material in use by this SubEntity.
</member>
        <member name="F:Ogre.SubEntity.mParentEntity">
Pointer to parent.
</member>
        <member name="M:Ogre.SubEntity.Dispose">
Private destructor.

</member>
        <member name="M:Ogre.SubEntity.#ctor(Ogre.Entity*,Ogre.SubMesh*)">
Private constructor - don't allow creation by anybody else.

</member>
        <member name="T:Ogre.SubEntity">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Utility class which defines the sub-parts of an Entity.
        @remarks
            Just as meshes are split into submeshes, an Entity is made up of
            potentially multiple SubMeshes. These are mainly here to provide the
            link between the Material which the SubEntity uses (which may be the
            default Material for the SubMesh or may have been changed for this
            object) and the SubMesh data.
        @par
            The SubEntity also allows the application some flexibility in the
            material properties for this section of a particular instance of this
            Mesh, e.g. tinting the windows on a car model.
        @par
            SubEntity instances are never created manually. They are created at
            the same time as their parent Entity by the SceneManager method
            createEntity.

</member>
        <member name="M:Ogre.StaticGeometry.dump(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Dump the contents of this StaticGeometry to a file for diagnostic
		 	purposes.

</member>
        <member name="M:Ogre.StaticGeometry.getRegionIterator">
Get an iterator over the regions in this geometry
</member>
        <member name="D:Ogre.StaticGeometry.RegionIterator">
Iterator for iterating over contained regions
</member>
        <member name="M:Ogre.StaticGeometry.visitRenderables(Ogre.Renderable.Visitor*,System.Boolean)">
@copydoc MovableObject::visitRenderables
</member>
        <member name="M:Ogre.StaticGeometry.getRenderQueueGroup">
Gets the queue group for this entity, see setRenderQueueGroup for full details. 
</member>
        <member name="M:Ogre.StaticGeometry.setRenderQueueGroup(System.Byte)">
Sets the render queue group this object will be rendered through.
        @remarks
            Render queues are grouped to allow you to more tightly control the ordering
            of rendered objects. If you do not call this method, all  objects default
            to the default queue (RenderQueue::getDefaultQueueGroup), which is fine for 
			most objects. You may want to alter this if you want to perform more complex
			rendering.
        @par
            See RenderQueue for more details.
        @param queueID Enumerated value of the queue group to use.

</member>
        <member name="M:Ogre.StaticGeometry.getVisibilityFlags">
Returns the visibility flags of the regions
</member>
        <member name="M:Ogre.StaticGeometry.setVisibilityFlags(System.UInt32)">
Sets the visibility flags of all the regions at once
</member>
        <member name="M:Ogre.StaticGeometry.getOrigin">
Gets the origin of this geometry. 
</member>
        <member name="M:Ogre.StaticGeometry.setOrigin(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the origin of the geometry.
		@remarks
			This method allows you to configure the world centre of the geometry,
			thus the place which all regions surround. You probably don't need 
			to mess with this unless you have a seriously large world, since the
			default set up can handle an area 1024 * mRegionDimensions, and 
			the sparseness of population is no issue when it comes to rendering.
			The default is Vector3(0,0,0).
		@note Must be called before 'build'.
		@param size Vector3 expressing the 3D origin of the geometry.

</member>
        <member name="M:Ogre.StaticGeometry.getRegionDimensions">
Gets the size of a single batch of geometry. 
</member>
        <member name="M:Ogre.StaticGeometry.setRegionDimensions(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the size of a single region of geometry.
		@remarks
			This method allows you to configure the physical world size of 
			each region, so you can balance culling against batch size. Entities
			will be fitted within the batch they most closely fit, and the 
			eventual bounds of each batch may well be slightly larger than this
			if they overlap a little. The default is Vector3(1000, 1000, 1000).
		@note Must be called before 'build'.
		@param size Vector3 expressing the 3D size of each region.

</member>
        <member name="M:Ogre.StaticGeometry.getCastShadows">
Will the geometry from this object cast shadows?
</member>
        <member name="M:Ogre.StaticGeometry.setCastShadows(System.Boolean)">
Sets whether this geometry should cast shadows.
		@remarks
			No matter what the settings on the original entities,
			the StaticGeometry class defaults to not casting shadows. 
			This is because, being static, unless you have moving lights
			you'd be better to use precalculated shadows of some sort.
			However, if you need them, you can enable them using this
			method. If the SceneManager is set up to use stencil shadows,
			edge lists will be copied from the underlying meshes on build.
			It is essential that all meshes support stencil shadows in this
			case.
		@note If you intend to use stencil shadows, you must set this to 
			true before calling 'build' as well as making sure you set the
			scene's shadow type (that should always be the first thing you do
			anyway). You can turn shadows off temporarily but they can never 
			be turned on if they were not at the time of the build. 

</member>
        <member name="M:Ogre.StaticGeometry.isVisible">
Are the batches visible? 
</member>
        <member name="M:Ogre.StaticGeometry.setVisible(System.Boolean)">
Hides or shows all the batches. 
</member>
        <member name="M:Ogre.StaticGeometry.getSquaredRenderingDistance">
Gets the squared distance at which batches are no longer rendered. 
</member>
        <member name="M:Ogre.StaticGeometry.getRenderingDistance">
Gets the distance at which batches are no longer rendered. 
</member>
        <member name="M:Ogre.StaticGeometry.setRenderingDistance(System.Single)">
Sets the distance at which batches are no longer rendered.
		@remarks
			This lets you turn off batches at a given distance. This can be 
			useful for things like detail meshes (grass, foliage etc) and could
			be combined with a shader which fades the geometry out beforehand 
			to lessen the effect.
		@param dist Distance beyond which the batches will not be rendered 
			(the default is 0, which means batches are always rendered).

</member>
        <member name="M:Ogre.StaticGeometry.reset">
Clears any of the entities / nodes added to this geometry and 
			destroys anything which has already been built.

</member>
        <member name="M:Ogre.StaticGeometry.destroy">
Destroys all the built geometry state (reverse of build). 
		@remarks
			You can call build() again after this and it will pick up all the
			same entities / nodes you queued last time.

</member>
        <member name="M:Ogre.StaticGeometry.build">
Build the geometry. 
		@remarks
			Based on all the entities which have been added, and the batching 
			options which have been set, this method constructs	the batched 
			geometry structures required. The batches are added to the scene 
			and will be rendered unless you specifically hide them.
		@note
			Once you have called this method, you can no longer add any more 
			entities.

</member>
        <member name="M:Ogre.StaticGeometry.addSceneNode(Ogre.SceneNode!System.Runtime.CompilerServices.IsConst*)">
Adds all the Entity objects attached to a SceneNode and all it's
			children to the static geometry.
		@remarks
			This method performs just like addEntity, except it adds all the 
			entities attached to an entire sub-tree to the geometry. 
			The position / orientation / scale parameters are taken from the
			node structure instead of being specified manually. 
		@note
			The SceneNode you pass in will not be automatically detached from 
			it's parent, so if you have this node already attached to the scene
			graph, you will need to remove it if you wish to avoid the overhead
			of rendering <i>both</i> the original objects and their new static
			versions! We don't do this for you incase you are preparing this 
			in advance and so don't want the originals detached yet. 
		@note Must be called before 'build'.
		@param node Pointer to the node to use to provide a set of Entity 
			templates

</member>
        <member name="M:Ogre.StaticGeometry.addEntity(Ogre.Entity*,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds an Entity to the static geometry.
		@remarks
			This method takes an existing Entity and adds its details to the 
			list of	elements to include when building. Note that the Entity
			itself is not copied or referenced in this method; an Entity is 
			passed simply so that you can change the materials of attached 
			SubEntity objects if you want. You can add the same Entity 
			instance multiple times with different material settings 
			completely safely, and destroy the Entity before destroying 
			this StaticGeometry if you like. The Entity passed in is simply 
			used as a definition.
		@note Must be called before 'build'.
		@param ent The Entity to use as a definition (the Mesh and Materials 
			referenced will be recorded for the build call).
		@param position The world position at which to add this Entity
		@param orientation The world orientation at which to add this Entity
		@param scale The scale at which to add this entity

</member>
        <member name="M:Ogre.StaticGeometry.getName">
Get the name of this object
</member>
        <member name="M:Ogre.StaticGeometry.Dispose">
Destructor
</member>
        <member name="M:Ogre.StaticGeometry.#ctor(Ogre.SceneManager*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor; do not use directly (@see SceneManager::createStaticGeometry)
</member>
        <member name="M:Ogre.StaticGeometry.splitGeometry(Ogre.VertexData*,Ogre.IndexData*,Ogre.StaticGeometry.SubMeshLodGeometryLink*)">
Split some shared geometry into dedicated geometry. 
</member>
        <member name="M:Ogre.StaticGeometry.determineGeometry(Ogre.SubMesh*)">
Look up or calculate the geometry data to use for this SubMesh 
</member>
        <member name="M:Ogre.StaticGeometry.calculateBounds(Ogre.VertexData*,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculate world bounds from a set of vertex data. 
</member>
        <member name="M:Ogre.StaticGeometry.getRegionCentre(System.UInt16,System.UInt16,System.UInt16)">
Get the centre of an indexed region.

</member>
        <member name="M:Ogre.StaticGeometry.getRegionBounds(System.UInt16,System.UInt16,System.UInt16)">
Get the bounds of an indexed region.

</member>
        <member name="M:Ogre.StaticGeometry.getVolumeIntersection(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16,System.UInt16,System.UInt16)">
Get the volume intersection for an indexed region with some bounds.

</member>
        <member name="M:Ogre.StaticGeometry.packIndex(System.UInt16,System.UInt16,System.UInt16)">
Pack 3 indexes into a single index value

</member>
        <member name="M:Ogre.StaticGeometry.getRegionIndexes(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get the region indexes for a point.

</member>
        <member name="M:Ogre.StaticGeometry.getRegion(System.UInt32)">
Get the region using a packed index, returns null if it doesn't exist. 
</member>
        <member name="M:Ogre.StaticGeometry.getRegion(System.UInt16,System.UInt16,System.UInt16,System.Boolean)">
Get the region using indexes 
</member>
        <member name="M:Ogre.StaticGeometry.getRegion(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Get the region within which a point lies 
</member>
        <member name="M:Ogre.StaticGeometry.getRegion(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Virtual method for getting a region most suitable for the
			passed in bounds. Can be overridden by subclasses.

</member>
        <member name="F:Ogre.StaticGeometry.mRegionMap">
Map of regions
</member>
        <member name="F:Ogre.StaticGeometry.mSubMeshGeometryLookup">
Cached links from SubMeshes to (potentially optimised) geometry
			This is not used for deletion since the lookup may reference
			original vertex data

</member>
        <member name="F:Ogre.StaticGeometry.mOptimisedSubMeshGeometryList">
List of geometry which has been optimised for SubMesh use
This is the primary storage used for cleaning up later
</member>
        <member name="F:Ogre.StaticGeometry.mVisibilityFlags">
Stores the visibility flags for the regions
</member>
        <member name="F:Ogre.StaticGeometry.mRenderQueueIDSet">
Flags whether the RenderQueue's default should be used.
</member>
        <member name="F:Ogre.StaticGeometry.mRenderQueueID">
The render queue to use when rendering this object
</member>
        <member name="D:Ogre.StaticGeometry.RegionMap">
Indexed region map based on packed x/y/z region index, 10 bits for
			each axis.
		@remarks
			Regions are indexed 0-1023 in all axes, where for example region 
			0 in the x axis begins at mOrigin.x + (mRegionDimensions.x * -512), 
			and region 1023 ends at mOrigin + (mRegionDimensions.x * 512).

</member>
        <member name="M:Ogre.StaticGeometry.Region.dump(std.basic_ofstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Dump contents for diagnostics
</member>
        <member name="M:Ogre.StaticGeometry.Region.hasEdgeList">
Overridden member from ShadowCaster. 
</member>
        <member name="M:Ogre.StaticGeometry.Region.getEdgeList">
Overridden from MovableObject
</member>
        <member name="M:Ogre.StaticGeometry.Region.getShadowVolumeRenderableIterator(Ogre.ShadowTechnique,Ogre.Light!System.Runtime.CompilerServices.IsConst*,Ogre.HardwareIndexBufferSharedPtr*,System.Boolean,System.Single,System.UInt32!System.Runtime.CompilerServices.IsLong)">
@copydoc ShadowCaster::getShadowVolumeRenderableIterator
</member>
        <member name="M:Ogre.StaticGeometry.Region.getLODIterator">
Get an iterator over the LODs in this region
</member>
        <member name="M:Ogre.StaticGeometry.Region.visitRenderables(Ogre.Renderable.Visitor*,System.Boolean)">
@copydoc MovableObject::visitRenderables
</member>
        <member name="M:Ogre.StaticGeometry.Region.getCentre">
Get the centre point of the region
</member>
        <member name="M:Ogre.StaticGeometry.Region.getID">
Get the region ID of this region
</member>
        <member name="M:Ogre.StaticGeometry.Region.build(System.Boolean)">
Build this region
</member>
        <member name="M:Ogre.StaticGeometry.Region.assign(Ogre.StaticGeometry.QueuedSubMesh*)">
Assign a queued mesh to this region, read for final build
</member>
        <member name="F:Ogre.StaticGeometry.Region.mSquaredViewDepth">
Cached squared view depth value to avoid recalculation by GeometryBucket
</member>
        <member name="F:Ogre.StaticGeometry.Region.mCamera">
Current camera
</member>
        <member name="F:Ogre.StaticGeometry.Region.mLodStrategy">
Lod strategy reference
</member>
        <member name="F:Ogre.StaticGeometry.Region.mLightListUpdated">
The last frame that this light list was updated in
</member>
        <member name="F:Ogre.StaticGeometry.Region.mLightList">
List of lights for this region
</member>
        <member name="F:Ogre.StaticGeometry.Region.mLodBucketList">
List of LOD buckets			
</member>
        <member name="F:Ogre.StaticGeometry.Region.mLodValue">
Current lod value, passed on to do material lod later
</member>
        <member name="F:Ogre.StaticGeometry.Region.mCurrentLod">
The current lod level, as determined from the last camera
</member>
        <member name="F:Ogre.StaticGeometry.Region.mBoundingRadius">
Local bounding radius
</member>
        <member name="F:Ogre.StaticGeometry.Region.mAABB">
Local AABB relative to region centre
</member>
        <member name="F:Ogre.StaticGeometry.Region.mLodValues">
Lod values as built up - use the max at each level
</member>
        <member name="F:Ogre.StaticGeometry.Region.mCentre">
Center of the region
</member>
        <member name="F:Ogre.StaticGeometry.Region.mRegionID">
Unique identifier for the region
</member>
        <member name="F:Ogre.StaticGeometry.Region.mQueuedSubMeshes">
Local list of queued meshes (not used for deallocation)
</member>
        <member name="F:Ogre.StaticGeometry.Region.mNode">
Scene node
</member>
        <member name="F:Ogre.StaticGeometry.Region.mSceneMgr">
Scene manager link
</member>
        <member name="F:Ogre.StaticGeometry.Region.mParent">
Parent static geometry
</member>
        <member name="D:Ogre.StaticGeometry.Region.LODBucketList">
list of LOD Buckets in this region
</member>
        <member name="M:Ogre.StaticGeometry.LODBucket.dump(std.basic_ofstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Dump contents for diagnostics
</member>
        <member name="M:Ogre.StaticGeometry.LODBucket.getMaterialIterator">
Get an iterator over the materials in this LOD
</member>
        <member name="D:Ogre.StaticGeometry.LODBucket.MaterialIterator">
Iterator over the materials in this LOD
</member>
        <member name="M:Ogre.StaticGeometry.LODBucket.addRenderables(Ogre.RenderQueue*,System.Byte,System.Single)">
Add children to the render queue
</member>
        <member name="M:Ogre.StaticGeometry.LODBucket.build(System.Boolean)">
Build
</member>
        <member name="M:Ogre.StaticGeometry.LODBucket.assign(Ogre.StaticGeometry.QueuedSubMesh*,System.UInt16)">
Assign a queued submesh to this bucket, using specified mesh LOD
</member>
        <member name="M:Ogre.StaticGeometry.LODBucket.getLodValue">
Get the lod value
</member>
        <member name="M:Ogre.StaticGeometry.LODBucket.getLod">
Get the lod index
</member>
        <member name="F:Ogre.StaticGeometry.LODBucket.mShadowRenderables">
List of shadow renderables
</member>
        <member name="F:Ogre.StaticGeometry.LODBucket.mVertexProgramInUse">
Is a vertex program in use somewhere in this group?
</member>
        <member name="F:Ogre.StaticGeometry.LODBucket.mEdgeList">
Edge list, used if stencil shadow casting is enabled 
</member>
        <member name="F:Ogre.StaticGeometry.LODBucket.mQueuedGeometryList">
Geometry queued for a single LOD (deallocated here)
</member>
        <member name="F:Ogre.StaticGeometry.LODBucket.mMaterialBucketMap">
Lookup of Material Buckets in this region
</member>
        <member name="F:Ogre.StaticGeometry.LODBucket.mLodValue">
lod value at which this LOD starts to apply (squared)
</member>
        <member name="F:Ogre.StaticGeometry.LODBucket.mLod">
LOD level (0 == full LOD)
</member>
        <member name="F:Ogre.StaticGeometry.LODBucket.mParent">
Pointer to parent region
</member>
        <member name="M:Ogre.StaticGeometry.LODBucket.LODShadowRenderable.getWorldTransforms(Ogre.Matrix4*)">
Overridden from ShadowRenderable
</member>
        <member name="T:Ogre.StaticGeometry.LODBucket.LODShadowRenderable">
Nested class to allow shadows. 
</member>
        <member name="D:Ogre.StaticGeometry.LODBucket.MaterialBucketMap">
Lookup of Material Buckets in this region
</member>
        <member name="T:Ogre.StaticGeometry.LODBucket">
A LODBucket is a collection of smaller buckets with the same LOD. 
		@remarks
			LOD refers to Mesh LOD here. Material LOD can change separately
			at the next bucket down from this.

</member>
        <member name="M:Ogre.StaticGeometry.MaterialBucket.dump(std.basic_ofstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Dump contents for diagnostics
</member>
        <member name="M:Ogre.StaticGeometry.MaterialBucket.getCurrentTechnique">
Get the current Technique
</member>
        <member name="M:Ogre.StaticGeometry.MaterialBucket.getGeometryIterator">
Get an iterator over the contained geometry
</member>
        <member name="D:Ogre.StaticGeometry.MaterialBucket.GeometryIterator">
Iterator over geometry
</member>
        <member name="M:Ogre.StaticGeometry.MaterialBucket.getMaterial">
Get the material for this bucket
</member>
        <member name="M:Ogre.StaticGeometry.MaterialBucket.addRenderables(Ogre.RenderQueue*,System.Byte,System.Single)">
Add children to the render queue
</member>
        <member name="M:Ogre.StaticGeometry.MaterialBucket.build(System.Boolean)">
Build
</member>
        <member name="M:Ogre.StaticGeometry.MaterialBucket.assign(Ogre.StaticGeometry.QueuedGeometry*)">
Assign geometry to this bucket
</member>
        <member name="M:Ogre.StaticGeometry.MaterialBucket.getMaterialName">
Get the material name
</member>
        <member name="M:Ogre.StaticGeometry.MaterialBucket.getGeometryFormatString(Ogre.StaticGeometry.SubMeshLodGeometryLink*)">
Get a packed string identifying the geometry format
</member>
        <member name="F:Ogre.StaticGeometry.MaterialBucket.mGeometryBucketList">
list of Geometry Buckets in this region
</member>
        <member name="F:Ogre.StaticGeometry.MaterialBucket.mTechnique">
Active technique
</member>
        <member name="F:Ogre.StaticGeometry.MaterialBucket.mMaterial">
Pointer to material being used
</member>
        <member name="F:Ogre.StaticGeometry.MaterialBucket.mMaterialName">
Material being used
</member>
        <member name="F:Ogre.StaticGeometry.MaterialBucket.mParent">
Pointer to parent LODBucket
</member>
        <member name="D:Ogre.StaticGeometry.MaterialBucket.GeometryBucketList">
list of Geometry Buckets in this region
</member>
        <member name="T:Ogre.StaticGeometry.MaterialBucket">
A MaterialBucket is a collection of smaller buckets with the same 
			Material (and implicitly the same LOD). 
</member>
        <member name="M:Ogre.StaticGeometry.GeometryBucket.dump(std.basic_ofstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Dump contents for diagnostics
</member>
        <member name="M:Ogre.StaticGeometry.GeometryBucket.build(System.Boolean)">
Build
</member>
        <member name="M:Ogre.StaticGeometry.GeometryBucket.assign(Ogre.StaticGeometry.QueuedGeometry*)">
Try to assign geometry to this bucket.
			@returns false if there is no room left in this bucket

</member>
        <member name="M:Ogre.StaticGeometry.GeometryBucket.getMaterial">
@copydoc Renderable::getMaterial
</member>
        <member name="M:Ogre.StaticGeometry.GeometryBucket.getIndexData">
Get the index data for this geometry 
</member>
        <member name="M:Ogre.StaticGeometry.GeometryBucket.getVertexData">
Get the vertex data for this geometry 
</member>
        <member name="F:Ogre.StaticGeometry.GeometryBucket.mMaxVertexIndex">
Maximum vertex indexable
</member>
        <member name="F:Ogre.StaticGeometry.GeometryBucket.mIndexType">
Size of indexes
</member>
        <member name="F:Ogre.StaticGeometry.GeometryBucket.mIndexData">
Index information, includes index type which limits the max
number of vertices which are allowed in one bucket
</member>
        <member name="F:Ogre.StaticGeometry.GeometryBucket.mVertexData">
Vertex information, includes current number of vertices
committed to be a part of this bucket
</member>
        <member name="F:Ogre.StaticGeometry.GeometryBucket.mFormatString">
String identifying the vertex / index format
</member>
        <member name="F:Ogre.StaticGeometry.GeometryBucket.mParent">
Pointer to parent bucket
</member>
        <member name="F:Ogre.StaticGeometry.GeometryBucket.mQueuedGeometry">
Geometry which has been queued up pre-build (not for deallocation)
</member>
        <member name="T:Ogre.StaticGeometry.QueuedGeometry">
Structure recording a queued geometry for low level builds
</member>
        <member name="F:Ogre.StaticGeometry.QueuedSubMesh.worldBounds">
Pre-transformed world AABB 
</member>
        <member name="F:Ogre.StaticGeometry.QueuedSubMesh.geometryLodList">
Link to LOD list of geometry, potentially optimised
</member>
        <member name="T:Ogre.StaticGeometry.QueuedSubMesh">
Structure recording a queued submesh for the build
</member>
        <member name="T:Ogre.StaticGeometry.SubMeshLodGeometryLink">
Saved link between SubMesh at a LOD and vertex/index data
May point to original or optimised geometry
</member>
        <member name="T:Ogre.StaticGeometry.OptimisedSubMeshGeometry">
Struct holding geometry optimised per SubMesh / lod level, ready
			for copying to instances. 
		@remarks
			Since we're going to be duplicating geometry lots of times, it's
			far more important that we don't have redundant vertex data. If a 
			SubMesh uses shared geometry, or we're looking at a lower LOD, not
			all the vertices are being referenced by faces on that submesh.
			Therefore to duplicate them, potentially hundreds or even thousands
			of times, would be extremely wasteful. Therefore, if a SubMesh at
			a given LOD has wastage, we create an optimised version of it's
			geometry which is ready for copying with no wastage.

</member>
        <member name="T:Ogre.StaticGeometry">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Pre-transforms and batches up meshes for efficient use as static
		geometry in a scene.
	@remarks
		Modern graphics cards (GPUs) prefer to receive geometry in large
		batches. It is orders of magnitude faster to render 10 batches
		of 10,000 triangles than it is to render 10,000 batches of 10 
		triangles, even though both result in the same number of on-screen
		triangles.
	@par
		Therefore it is important when you are rendering a lot of geometry to 
		batch things up into as few rendering calls as possible. This
		class allows you to build a batched object from a series of entities 
		in order to benefit from this behaviour.
		Batching has implications of it's own though:
		@li Batched geometry cannot be subdivided; that means that the whole
			group will be displayed, or none of it will. This obivously has
			culling issues.
		@li A single world transform must apply to the entire batch. Therefore
			once you have batched things, you can't move them around relative to
			each other. That's why this class is most useful when dealing with 
			static geometry (hence the name). In addition, geometry is 
			effectively duplicated, so if you add 3 entities based on the same 
			mesh in different positions, they will use 3 times the geometry 
			space than the movable version (which re-uses the same geometry). 
			So you trade memory	and flexibility of movement for pure speed when
			using this class.
		@li A single material must apply for each batch. In fact this class 
			allows you to use multiple materials, but you should be aware that 
			internally this means that there is one batch per material. 
			Therefore you won't gain as much benefit from the batching if you 
			use many different materials; try to keep the number down.
	@par
		In order to retain some sort of culling, this class will batch up 
		meshes in localised regions. The size and shape of these blocks is
		controlled by the SceneManager which constructs this object, since it
		makes sense to batch things up in the most appropriate way given the 
		existing partitioning of the scene. 
	@par
		The LOD settings of both the Mesh and the Materials used in 
		constructing this static geometry will be respected. This means that 
		if you use meshes/materials which have LOD, batches in the distance 
		will have a lower polygon count or material detail to those in the 
		foreground. Since each mesh might have different LOD distances, during 
		build the furthest distance at each LOD level from all meshes  
		in that region is used. This means all the LOD levels change at the 
		same time, but at the furthest distance of any of them (so quality is 
		not degraded). Be aware that using Mesh LOD in this class will 
		further increase the memory required. Only generated LOD
		is supported for meshes.
	@par
		There are 2 ways you can add geometry to this class; you can add
		Entity objects directly with predetermined positions, scales and 
		orientations, or you can add an entire SceneNode and it's subtree, 
		including all the objects attached to it. Once you've added everthing
		you need to, you have to call build() the fix the geometry in place. 
	@note
		This class is not a replacement for world geometry (@see 
		SceneManager::setWorldGeometry). The single most efficient way to 
		render large amounts of static geometry is to use a SceneManager which 
		is specialised for dealing with that particular world structure. 
		However, this class does provide you with a good 'halfway house'
		between generalised movable geometry (Entity) which works with all 
		SceneManagers but isn't efficient when using very large numbers, and 
		highly specialised world geometry which is extremely fast but not 
		generic and typically requires custom world editors.
	@par
		You should not construct instances of this class directly; instead, cal 
		SceneManager::createStaticGeometry, which gives the SceneManager the 
		option of providing you with a specialised version of this class if it
		wishes, and also handles the memory management for you like other 
		classes.
	@note
		Warning: this class only works with indexed triangle lists at the moment,
		do not pass it triangle strips, fans or lines / points, or unindexed geometry.

</member>
        <member name="M:Ogre.SkeletonSerializer.importSkeleton(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Skeleton*)">
Imports Skeleton and animation data from a .skeleton file DataStream.
        @remarks
            This method imports data from a DataStream opened from a .skeleton file and places it's
            contents into the Skeleton object which is passed in. 
        @param stream The DataStream holding the .skeleton data. Must be initialised (pos at the start of the buffer).
        @param pDest Weak reference to the Skeleton object which will receive the data. Should be blank already.

</member>
        <member name="M:Ogre.SkeletonSerializer.exportSkeleton(Ogre.Skeleton!System.Runtime.CompilerServices.IsConst*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Serializer.Endian)">
Exports a skeleton to the file specified. 
        @remarks
            This method takes an externally created Skeleton object, and exports both it
            and animations it uses to a .skeleton file.
        @param pSkeleton Weak reference to the Skeleton to export
        @param filename The destination filename
		@param endianMode The endian mode to write in

</member>
        <member name="T:Ogre.SkeletonSerializer">
\addtogroup Core
	*  @{

\addtogroup Animation
	*  @{

Class for serialising skeleton data to/from an OGRE .skeleton file.
    @remarks
        This class allows exporters to write OGRE .skeleton files easily, and allows the
        OGRE engine to import .skeleton files into instantiated OGRE Skeleton objects.
        Note that a .skeleton file includes not only the Skeleton, but also definitions of
        any Animations it uses.
    @par
        To export a Skeleton:<OL><LI>Create a Skeleton object and populate it using it's methods.</LI><LI>Call the exportSkeleton method</LI></OL></member>
        <member name="M:Ogre.SkeletonManager.createImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.ManualResou">
@copydoc ResourceManager::createImpl
</member>
        <member name="M:Ogre.SkeletonManager.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.SkeletonManager.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.SkeletonManager.#ctor">
Constructor
</member>
        <member name="T:Ogre.SkeletonManager">
\addtogroup Core
	*  @{

\addtogroup Animation
	*  @{

Handles the management of skeleton resources.
        @remarks
            This class deals with the runtime management of
            skeleton data; like other resource managers it handles
            the creation of resources (in this case skeleton data),
            working within a fixed memory budget.

</member>
        <member name="M:Ogre.Root.setWorkQueue(Ogre.WorkQueue*)">
Replace the current work queue with an alternative. 
			You can use this method to replace the internal implementation of
			WorkQueue with  your own, e.g. to externalise the processing of 
			background events. Doing so will delete the existing queue and
			replace it with this one. 
		@param queue The new WorkQueue instance. Root will delete this work queue
			at shutdown, so do not destroy it yourself.

</member>
        <member name="M:Ogre.Root.getWorkQueue">
Get the WorkQueue for processing background tasks.
			You are free to add new requests and handlers to this queue to
			process your custom background tasks using the shared thread pool. 
			However, you must remember to assign yourself a new channel through 
			which to process your tasks.

</member>
        <member name="M:Ogre.Root.getDisplayMonitorCount">
Gets the number of display monitors.

</member>
        <member name="M:Ogre.Root.getMovableObjectFactoryIterator">
Return an iterator over all the MovableObjectFactory instances currently
			registered.

</member>
        <member name="M:Ogre.Root._allocateNextMovableObjectTypeFlag">
Allocate the next MovableObject type flag.
		@remarks
			This is done automatically if MovableObjectFactory::requestTypeFlags
			returns true; don't call this manually unless you're sure you need to.

</member>
        <member name="M:Ogre.Root.getMovableObjectFactory(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get a MovableObjectFactory for the given type
</member>
        <member name="M:Ogre.Root.hasMovableObjectFactory(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Checks whether a factory is registered for a given MovableObject type
</member>
        <member name="M:Ogre.Root.removeMovableObjectFactory(Ogre.MovableObjectFactory*)">
Removes a previously registered MovableObjectFactory.
		@remarks
			All instances of objects created by this factory will be destroyed
			before removing the factory (by calling back the factories 
			'destroyInstance' method). The plugin writer is responsible for actually
			destroying the factory.

</member>
        <member name="M:Ogre.Root.addMovableObjectFactory(Ogre.MovableObjectFactory*,System.Boolean)">
Register a new MovableObjectFactory which will create new MovableObject
			instances of a particular type, as identified by the getType() method.
		@remarks
			Plugin creators can create subclasses of MovableObjectFactory which 
			construct custom subclasses of MovableObject for insertion in the 
			scene. This is the primary way that plugins can make custom objects
			available.
		@param fact Pointer to the factory instance
		@param overrideExisting Set this to true to override any existing 
			factories which are registered for the same type. You should only
			change this if you are very sure you know what you're doing. 

</member>
        <member name="M:Ogre.Root.getFrameSmoothingPeriod">
Gets the period over which OGRE smooths out fluctuations in frame times. 
</member>
        <member name="M:Ogre.Root.setFrameSmoothingPeriod(System.Single)">
Sets the period over which OGRE smooths out fluctuations in frame times.
		@remarks
			OGRE by default gives you the raw frame time, but can optionally
			smooths it out over several frames, in order to reduce the 
			noticeable effect of occasional hiccups in framerate.
			These smoothed values are passed back as parameters to FrameListener
			calls.
		@par
			This method allow you to tweak the smoothing period, and is expressed
			in seconds. Setting it to 0 will result in completely unsmoothed
			frame times (the default).

</member>
        <member name="M:Ogre.Root.clearEventTimes">
Clears the history of all event times. 
		@remarks
			OGRE stores a history of the last few event times in order to smooth
			out any inaccuracies and temporary fluctuations. However, if you 
			pause or don't render for a little while this can cause a lurch, so
			if you're resuming rendering after a break, call this method to reset
			the stored times

</member>
        <member name="M:Ogre.Root.getSingletonPtr">
Override standard Singleton retrieval.
            @remarks
                Why do we do this? Well, it's because the Singleton
                implementation is in a .h file, which means it gets compiled
                into anybody who includes it. This is needed for the
                Singleton template to work, but we actually only want it
                compiled into the implementation of the class based on the
                Singleton, not all of them. If we don't change this, we get
                link errors when trying to use the Singleton-based class from
                an outside dll.
            @par
                This method just delegates to the template version anyway,
                but the implementation stays in this single compilation unit,
                preventing link errors.

</member>
        <member name="M:Ogre.Root.getSingleton">
Override standard Singleton retrieval.
            @remarks
                Why do we do this? Well, it's because the Singleton
                implementation is in a .h file, which means it gets compiled
                into anybody who includes it. This is needed for the
                Singleton template to work, but we actually only want it
                compiled into the implementation of the class based on the
                Singleton, not all of them. If we don't change this, we get
                link errors when trying to use the Singleton-based class from
                an outside dll.
            @par
                This method just delegates to the template version anyway,
                but the implementation stays in this single compilation unit,
                preventing link errors.

</member>
        <member name="M:Ogre.Root.destroyAllRenderQueueInvocationSequences">
Destroy all RenderQueueInvocationSequences. 
		@remarks
			You must ensure that no Viewports are using custom sequences.
		@param name The name to identify the sequence

</member>
        <member name="M:Ogre.Root.destroyRenderQueueInvocationSequence(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroy a RenderQueueInvocationSequence. 
		@remarks
			You must ensure that no Viewports are using this sequence.
		@param name The name to identify the sequence

</member>
        <member name="M:Ogre.Root.getRenderQueueInvocationSequence(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get a RenderQueueInvocationSequence. 
		@param name The name to identify the sequence

</member>
        <member name="M:Ogre.Root.createRenderQueueInvocationSequence(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a new RenderQueueInvocationSequence, useful for linking to
			Viewport instances to perform custom rendering.
		@param name The name to give the new sequence

</member>
        <member name="M:Ogre.Root._updateAllRenderTargets(Ogre.FrameEvent*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method used for updating all RenderTarget objects (windows, 
            renderable textures etc) which are set to auto-update, with a custom time
			passed to the frameRenderingQueued events.
        @remarks
            You don't need to use this method if you're using Ogre's own internal
            rendering loop (Root::startRendering). If you're running your own loop
            you may wish to call it to update all the render targets which are
            set to auto update (RenderTarget::setAutoUpdated). You can also update
            individual RenderTarget instances using their own update() method.
		@returns false if a FrameListener indicated it wishes to exit the render loop

</member>
        <member name="M:Ogre.Root._updateAllRenderTargets">
Internal method used for updating all RenderTarget objects (windows, 
            renderable textures etc) which are set to auto-update.
        @remarks
            You don't need to use this method if you're using Ogre's own internal
            rendering loop (Root::startRendering). If you're running your own loop
            you may wish to call it to update all the render targets which are
            set to auto update (RenderTarget::setAutoUpdated). You can also update
            individual RenderTarget instances using their own update() method.
		@returns false if a FrameListener indicated it wishes to exit the render loop

</member>
        <member name="M:Ogre.Root._popCurrentSceneManager(Ogre.SceneManager*)">
Pops the scene manager currently being used to render.
		@remarks
		This is only intended for internal use.

</member>
        <member name="M:Ogre.Root._pushCurrentSceneManager(Ogre.SceneManager*)">
Pushes the scene manager currently being used to render.
        @remarks
            This is only intended for internal use.

</member>
        <member name="M:Ogre.Root._getCurrentSceneManager">
Returns the scene manager currently being used to render a frame.
        @remarks
            This is only intended for internal use; it is only valid during the
            rendering of a frame.

</member>
        <member name="M:Ogre.Root.getNextFrameNumber">
Gets the number of the next frame to be rendered. 
		@remarks
			Note that this is 'next frame' rather than 'current frame' because
			it indicates the frame number that current changes made to the scene
			will take effect. It is incremented after all rendering commands for
			the current frame have been queued, thus reflecting that if you 
			start performing changes then, you will actually see them in the 
			next frame. 
</member>
        <member name="M:Ogre.Root._fireFrameEnded">
Method for raising frame ended events. 
        @remarks
            This method is only for internal use when you use OGRE's inbuilt rendering
            loop (Root::startRendering). However, if you run your own rendering loop then
            you should call this method to ensure that FrameListener objects are notified
            of frame events; processes like texture animation and particle systems rely on 
            this.
        @note
            This method calculates the frame timing information for you based on the elapsed
            time. If you want to specify elapsed times yourself you should call the other 
            version of this method which takes event details as a parameter.
        @returns False if one or more frame listeners elected that the rendering loop should
            be terminated, true otherwise.

</member>
        <member name="M:Ogre.Root._fireFrameRenderingQueued">
Method for raising frame rendering queued events. 
        @remarks
            This method is only for internal use when you use OGRE's inbuilt rendering
            loop (Root::startRendering). However, if you run your own rendering loop then
            you you may want to call this method too, although nothing in OGRE relies on this
			particular event. Really if you're running your own rendering loop at
			this level of detail then you can get the same effect as doing your
			updates in a frameRenderingQueued callback by just calling 
			RenderWindow::update with the 'swapBuffers' option set to false. 

</member>
        <member name="M:Ogre.Root._fireFrameStarted">
Method for raising frame started events. 
        @remarks
            This method is only for internal use when you use OGRE's inbuilt rendering
            loop (Root::startRendering). However, if you run your own rendering loop then
            you should call this method to ensure that FrameListener objects are notified
            of frame events; processes like texture animation and particle systems rely on 
            this.
        @par
            Calling this method also increments the frame number, which is
            important for keeping some elements of the engine up to date.
        @note
            This method calculates the frame timing information for you based on the elapsed
            time. If you want to specify elapsed times yourself you should call the other 
            version of this method which takes event details as a parameter.
        @returns False if one or more frame listeners elected that the rendering loop should
            be terminated, true otherwise.

</member>
        <member name="M:Ogre.Root._fireFrameEnded(Ogre.FrameEvent*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method for raising frame ended events. 
        @remarks
            This method is only for internal use when you use OGRE's inbuilt rendering
            loop (Root::startRendering). However, if you run your own rendering loop then
            you should call this method to ensure that FrameListener objects are notified
            of frame events; processes like texture animation and particle systems rely on 
            this.
        @note
            This method takes an event object as a parameter, so you can specify the times
            yourself. If you are happy for OGRE to automatically calculate the frame time
            for you, then call the other version of this method with no parameters.
        @param evt Event object which includes all the timing information which you have 
            calculated for yourself
        @returns False if one or more frame listeners elected that the rendering loop should
            be terminated, true otherwise.

</member>
        <member name="M:Ogre.Root._fireFrameRenderingQueued(Ogre.FrameEvent*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method for raising frame rendering queued events. 
        @remarks
            This method is only for internal use when you use OGRE's inbuilt rendering
            loop (Root::startRendering). However, if you run your own rendering loop then
            you should call this method too, to ensure that all state is updated
			correctly. You should call it after the windows have been updated
			but before the buffers are swapped, or if you are not separating the
			update and buffer swap, then after the update just before _fireFrameEnded.

</member>
        <member name="M:Ogre.Root._fireFrameStarted(Ogre.FrameEvent*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method for raising frame started events. 
        @remarks
            This method is only for internal use when you use OGRE's inbuilt rendering
            loop (Root::startRendering). However, if you run your own rendering loop then
            you should call this method to ensure that FrameListener objects are notified
            of frame events; processes like texture animation and particle systems rely on 
            this.
        @par
            Calling this method also increments the frame number, which is
            important for keeping some elements of the engine up to date.
        @note
            This method takes an event object as a parameter, so you can specify the times
            yourself. If you are happy for OGRE to automatically calculate the frame time
            for you, then call the other version of this method with no parameters.
        @param evt Event object which includes all the timing information which you have 
            calculated for yourself
        @returns False if one or more frame listeners elected that the rendering loop should
            be terminated, true otherwise.

</member>
        <member name="M:Ogre.Root.getTimer">
Gets a pointer to the central timer used for all OGRE timings 
</member>
        <member name="M:Ogre.Root.getInstalledPlugins">
Gets a read-only list of the currently installed plugins. 
</member>
        <member name="M:Ogre.Root.uninstallPlugin(Ogre.Plugin*)">
Uninstall an existing plugin.
		@remarks
			This uninstalls an extension to OGRE. Plugins are automatically 
			uninstalled at shutdown but this lets you remove them early. 
			If the plugin was loaded from a DLL / DSO you should call unloadPlugin
			which should result in this method getting called anyway (if the DLL
			is well behaved).

</member>
        <member name="M:Ogre.Root.installPlugin(Ogre.Plugin*)">
Install a new plugin.
		@remarks
			This installs a new extension to OGRE. The plugin itself may be loaded
			from a DLL / DSO, or it might be statically linked into your own 
			application. Either way, something has to call this method to get
			it registered and functioning. You should only call this method directly
			if your plugin is not in a DLL that could otherwise be loaded with 
			loadPlugin, since the DLL function dllStartPlugin should call this
			method when the DLL is loaded. 

</member>
        <member name="M:Ogre.Root.unloadPlugin(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Manually unloads a Plugin contained in a DLL / DSO.
		 @remarks
		 	Plugin DLLs are unloaded at shutdown automatically. This method 
			allows you to unload plugins in code, but make sure their 
			dependencies are decoupled first. This method will call the 
			dllStopPlugin method defined in the DLL, which in turn should call
			Root::uninstallPlugin.
		@param pluginName Name of the plugin library to unload

</member>
        <member name="M:Ogre.Root.loadPlugin(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Manually load a Plugin contained in a DLL / DSO.
		 @remarks
		 	Plugins embedded in DLLs can be loaded at startup using the plugin 
			configuration file specified when you create Root (default: plugins.cfg).
			This method allows you to load plugin DLLs directly in code.
			The DLL in question is expected to implement a dllStartPlugin 
			method which instantiates a Plugin subclass and calls Root::installPlugin.
			It should also implement dllStopPlugin (see Root::unloadPlugin)
		@param pluginName Name of the plugin library to load

</member>
        <member name="M:Ogre.Root.getRenderTarget(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves a pointer to the a named render window.

</member>
        <member name="M:Ogre.Root.detachRenderTarget(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroys a named rendering window.

</member>
        <member name="M:Ogre.Root.detachRenderTarget(Ogre.RenderTarget*)">
Destroys a rendering window.

</member>
        <member name="M:Ogre.Root.createRenderWindows(std.vector&lt;Ogre.RenderWindowDescription&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Ogre.RenderWindow**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc RenderSystem::_createRenderWindows

</member>
        <member name="M:Ogre.Root.createRenderWindow(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_tr">
@copydoc RenderSystem::_createRenderWindow

</member>
        <member name="M:Ogre.Root.getAutoCreatedWindow">
Retrieves a pointer to the window that was created automatically
            @remarks
                When Root is initialised an optional window is created. This
                method retreives a pointer to that window.
            @note
                returns a null pointer when Root has not been initialised with
                the option of creating a window.

</member>
        <member name="M:Ogre.Root.convertColourValue(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*)">
Generates a packed data version of the passed in ColourValue suitable for
            use with the current RenderSystem.
        @remarks
            Since different render systems have different colour data formats (eg
            RGBA for GL, ARGB for D3D) this method allows you to use 1 method for all.
        @param colour The colour to convert
        @param pDest Pointer to location to put the result.

</member>
        <member name="M:Ogre.Root.openFileStream(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.Compile">
Helper method to assist you in accessing readable file streams.
		@remarks
			This is a high-level utility method which you can use to find a place to 
			open a file more easily. It checks the resource system first, and if
			that fails falls back on accessing the file system directly.
		@param filename The name of the file to open. 
		@param groupName The name of the group in which to create the file, if the 
			resource system is used
		@param locationPattern If the resource group contains multiple locations, 
			then usually the file will be created in the first writable location. If you 
			want to be more specific, you can include a location pattern here and 
			only locations which match that pattern (as determined by StringUtil::match)
			will be considered candidates for creation.

</member>
        <member name="M:Ogre.Root.createFileStream(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,std.basic_string&lt;System.SByte!Syste">
Helper method to assist you in creating writeable file streams.
		@remarks
			This is a high-level utility method which you can use to find a place to 
			save a file more easily. If the filename you specify is either an
			absolute or relative filename (ie it includes path separators), then
			the file will be created in the normal filesystem using that specification.
			If it doesn't, then the method will look for a writeable resource location
			via ResourceGroupManager::createResource using the other params provided.
		@param filename The name of the file to create. If it includes path separators, 
			the filesystem will be accessed direct. If no path separators are
			present the resource system is used, falling back on the raw filesystem after.
		@param groupName The name of the group in which to create the file, if the 
			resource system is used
		@param overwrite If true, an existing file will be overwritten, if false
			an error will occur if the file already exists
		@param locationPattern If the resource group contains multiple locations, 
			then usually the file will be created in the first writable location. If you 
			want to be more specific, you can include a location pattern here and 
			only locations which match that pattern (as determined by StringUtil::match)
			will be considered candidates for creation.

</member>
        <member name="M:Ogre.Root.removeResourceLocation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Removes a resource location from the list.
		@see addResourceLocation
		@param name The name of the resource location as specified in addResourceLocation
		@param groupName The name of the resource group to which this location 
			was assigned.

</member>
        <member name="M:Ogre.Root.addResourceLocation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.Co">
Adds a location to the list of searchable locations for a
            Resource type.
            @remarks
                Resource files (textures, models etc) need to be loaded from
                specific locations. By calling this method, you add another 
				search location to the list. Locations added first are preferred
				over locations added later.
            @par
                Locations can be folders, compressed archives, even perhaps
                remote locations. Facilities for loading from different
                locations are provided by plugins which provide
                implementations of the Archive class.
                All the application user has to do is specify a 'loctype'
                string in order to indicate the type of location, which
                should map onto one of the provided plugins. Ogre comes
                configured with the 'FileSystem' (folders) and 'Zip' (archive
                compressed with the pkzip / WinZip etc utilities) types.
            @par
				You can also supply the name of a resource group which should
				have this location applied to it. The 
				ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME group is the
				default, and one resource group which will always exist. You
				should consider defining resource groups for your more specific
				resources (e.g. per level) so that you can control loading /
				unloading better.
            @param
                name The name of the location, e.g. './data' or
                '/compressed/gamedata.zip'
            @param
                locType A string identifying the location type, e.g.
                'FileSystem' (for folders), 'Zip' etc. Must map to a
                registered plugin which deals with this type (FileSystem and
                Zip should always be available)
            @param
                groupName Type of name of the resource group which this location
				should apply to; defaults to the General group which applies to
				all non-specific resources.
			@param
				recursive If the resource location has a concept of recursive
				directory traversal, enabling this option will mean you can load
				resources in subdirectories using only their unqualified name.
				The default is to disable this so that resources in subdirectories
				with the same name are still unique.
            @see
                Archive

</member>
        <member name="M:Ogre.Root.shutdown">
Shuts down the system manually.
            @remarks
                This is normally done by Ogre automatically so don't think
                you have to call this yourself. However this is here for
                convenience, especially for dealing with unexpected errors or
                for systems which need to shut down Ogre on demand.

</member>
        <member name="M:Ogre.Root.renderOneFrame(System.Single)">
Render one frame, with custom frame time information. 
		@remarks
		Updates all the render targets automatically and then returns,
		raising frame events before and after - all per-frame times are based on
		the time value you pass in.

</member>
        <member name="M:Ogre.Root.renderOneFrame">
Render one frame. 
        @remarks
            Updates all the render targets automatically and then returns,
            raising frame events before and after.

</member>
        <member name="M:Ogre.Root.queueEndRendering">
Queues the end of rendering.
            @remarks
                This method will do nothing unless startRendering() has
                been called, in which case before the next frame is rendered
                the rendering loop will bail out.
            @see
                Root, Root::startRendering

</member>
        <member name="M:Ogre.Root.removeFrameListener(Ogre.FrameListener*)">
Removes a FrameListener from the list of listening classes.
            @see
                FrameListener, Root::addFrameListener

</member>
        <member name="M:Ogre.Root.getErrorDescription(System.Int32!System.Runtime.CompilerServices.IsLong)">
Utility function for getting a better description of an error
            code.

</member>
        <member name="M:Ogre.Root.getMeshManager">
Retrieves a reference to the current MeshManager.
            @remarks
                This performs the same function as MeshManager::getSingleton
                and is provided for convenience to scripting engines.

</member>
        <member name="M:Ogre.Root.getTextureManager">
Retrieves a reference to the current TextureManager.
            @remarks
                This performs the same function as
                TextureManager::getSingleton, but is provided for convenience
                particularly to scripting engines.
            @par
                Note that a TextureManager will NOT be available until the
                Ogre system has been initialised by selecting a RenderSystem,
                calling Root::initialise and a window having been created
                (this may have been done by initialise if required). This is
                because the exact runtime subclass which will be implementing
                the calls will differ depending on the rendering engine
                selected, and these typically require a window upon which to
                base texture format decisions.

</member>
        <member name="M:Ogre.Root.getSceneManagerIterator">
Get an iterator over all the existing SceneManager instances. 
</member>
        <member name="M:Ogre.Root.hasSceneManager(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Determines if a given SceneManager already exists
		@param instanceName The name of the instance to retrieve.

</member>
        <member name="M:Ogre.Root.getSceneManager(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get an existing SceneManager instance that has already been created,
			identified by the instance name.
		@param instanceName The name of the instance to retrieve.

</member>
        <member name="M:Ogre.Root.destroySceneManager(Ogre.SceneManager*)">
Destroy an instance of a SceneManager. 
</member>
        <member name="M:Ogre.Root.createSceneManager(System.UInt16,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a SceneManager instance based on scene type support.
		@remarks
			Creates an instance of a SceneManager which supports the scene types
			identified in the parameter. If more than one type of SceneManager 
			has been registered as handling that combination of scene types, 
			in instance of the last one registered is returned.
		@note This method always succeeds, if a specific scene manager is not
			found, the default implementation is always returned.
		@param typeMask A mask containing one or more SceneType flags
		@param instanceName Optional name to given the new instance that is
			created. If you leave this blank, an auto name will be assigned.

</member>
        <member name="M:Ogre.Root.createSceneManager(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a SceneManager instance of a given type.
		@remarks
			You can use this method to create a SceneManager instance of a 
			given specific type. You may know this type already, or you may
			have discovered it by looking at the results from getMetaDataIterator.
		@note
			This method throws an exception if the named type is not found.
		@param typeName String identifying a unique SceneManager type
		@param instanceName Optional name to given the new instance that is
			created. If you leave this blank, an auto name will be assigned.

</member>
        <member name="M:Ogre.Root.getSceneManagerMetaDataIterator">
Iterate over all types of SceneManager available for construction, 
			providing some information about each one.

</member>
        <member name="M:Ogre.Root.getSceneManagerMetaData(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get more information about a given type of SceneManager.
		@remarks
			The metadata returned tells you a few things about a given type 
			of SceneManager, which can be created using a factory that has been
			registered already. 
		@param typeName The type name of the SceneManager you want to enquire on.
			If you don't know the typeName already, you can iterate over the 
			metadata for all types using getMetaDataIterator.

</member>
        <member name="M:Ogre.Root.removeSceneManagerFactory(Ogre.SceneManagerFactory*)">
Unregister a SceneManagerFactory.

</member>
        <member name="M:Ogre.Root.addSceneManagerFactory(Ogre.SceneManagerFactory*)">
Register a new SceneManagerFactory, a factory object for creating instances
			of specific SceneManagers. 
		@remarks
			Plugins should call this to register as new SceneManager providers.

</member>
        <member name="M:Ogre.Root.setRemoveRenderQueueStructuresOnClear(System.Boolean)">
Set whether the entire render queue structure should be emptied on clearing, 
		or whether just the objects themselves should be cleared.

</member>
        <member name="M:Ogre.Root.getRemoveRenderQueueStructuresOnClear">
Get whether the entire render queue structure should be emptied on clearing, 
			or whether just the objects themselves should be cleared.

</member>
        <member name="M:Ogre.Root.useCustomRenderSystemCapabilities(Ogre.RenderSystemCapabilities*)">
Requests active RenderSystem to use custom RenderSystemCapabilities
        @remarks
            This is useful for testing how the RenderSystem would behave on a machine with
            less advanced GPUs. This method MUST be called before creating the first RenderWindow

</member>
        <member name="M:Ogre.Root.isInitialised">
Returns whether the system is initialised or not. 
</member>
        <member name="M:Ogre.Root.initialise(System.Boolean,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Initialises the renderer.
            @remarks
                This method can only be called after a renderer has been
                selected with Root::setRenderSystem, and it will initialise
                the selected rendering system ready for use.
            @param
                autoCreateWindow If true, a rendering window will
                automatically be created (saving a call to
                Root::createRenderWindow). The window will be
                created based on the options currently set on the render
                system.
            @returns
                A pointer to the automatically created window, if
                requested, otherwise <b>NULL</b>.

</member>
        <member name="M:Ogre.Root.getRenderSystem">
Retrieve a pointer to the currently selected render system.

</member>
        <member name="M:Ogre.Root.setRenderSystem(Ogre.RenderSystem*)">
Sets the rendering subsystem to be used.
            @remarks
                This method indicates to OGRE which rendering system is to be
                used (e.g. Direct3D, OpenGL etc). This is called
                automatically by the default config dialog, and when settings
                are restored from a previous configuraion. If used manually
                it could be used to set the renderer from a custom settings
                dialog. Once this has been done, the renderer can be
                initialised using Root::initialise.
            @par
                This method is also called by render systems if they are
                initialised directly.
            @param
                system Pointer to the render system to use.
            @see
                RenderSystem

</member>
        <member name="M:Ogre.Root.getRenderSystemByName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieve a pointer to the render system by the given name
            @param
                name Name of the render system intend to retrieve.
            @returns
                A pointer to the render system, <b>NULL</b> if no found.

</member>
        <member name="M:Ogre.Root.getAvailableRenderers">
Retrieve a list of the available render systems.
            @remarks
                Retrieves a pointer to the list of available renderers as a
                list of RenderSystem subclasses. Can be used to build a
                custom settings dialog.

</member>
        <member name="M:Ogre.Root.showConfigDialog">
Displays a dialog asking the user to choose system settings.
            @remarks
                This method displays the default dialog allowing the user to
                choose the rendering system, video mode etc. If there is are
                any settings saved already, they will be restored automatically
                before displaying the dialogue. When the user accepts a group of
                settings, this will automatically call Root::setRenderSystem,
                RenderSystem::setConfigOption and Root::saveConfig with the
                user's choices. This is the easiest way to get the system
                configured.
            @returns
                If the user clicked 'Ok', <b>true</b> is returned.
            @par
                If they clicked 'Cancel' (in which case the app should
                strongly consider terminating), <b>false</b> is returned.

</member>
        <member name="M:Ogre.Root.restoreConfig">
Checks for saved video/sound/etc settings
            @remarks
                This method checks to see if there is a valid saved configuration
                from a previous run. If there is, the state of the system will
                be restored to that configuration.

            @returns
                If a valid configuration was found, <b>true</b> is returned.
            @par
                If there is no saved configuration, or if the system failed
                with the last config settings, <b>false</b> is returned.

</member>
        <member name="M:Ogre.Root.saveConfig">
Saves the details of the current configuration
            @remarks
                Stores details of the current configuration so it may be
                restored later on.

</member>
        <member name="M:Ogre.Root.populateFrameEvent(Ogre.Root.FrameEventTimeType,Ogre.FrameEvent*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update a set of event times (note, progressive, only call once for each type per frame) 
</member>
        <member name="M:Ogre.Root.calculateEventTime(System.UInt32!System.Runtime.CompilerServices.IsLong,Ogre.Root.FrameEventTimeType)">
Internal method for calculating the average time between recently fired events.
        @param now The current time in ms.
        @param type The type of event to be considered.

</member>
        <member name="D:Ogre.Root.EventTimesQueue">
Contains the times of recently fired events
</member>
        <member name="T:Ogre.Root.FrameEventTimeType">
Indicates the type of event to be considered by calculateEventTime(). 
</member>
        <member name="F:Ogre.Root.mRemovedFrameListeners">
Set of frame listeners marked for removal
</member>
        <member name="F:Ogre.Root.mFrameListeners">
Set of registered frame listeners 
</member>
        <member name="M:Ogre.Root.unloadPlugins">
Unloads all loaded plugins.

</member>
        <member name="M:Ogre.Root.shutdownPlugins">
Shuts down all loaded plugins - allows things to be tidied up whilst
			all plugins are still loaded.

</member>
        <member name="M:Ogre.Root.initialisePlugins">
Initialise all loaded plugins - allows plugins to perform actions
			once the renderer is initialised.

</member>
        <member name="M:Ogre.Root.loadPlugins(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method reads a plugins configuration file and instantiates all
            plugins.
            @param
                pluginsfile The file that contains plugins information.
                Defaults to "plugins.cfg".

</member>
        <member name="F:Ogre.Root.mIsInitialised">
Are we initialised yet?
</member>
        <member name="F:Ogre.Root.mPlugins">
List of Plugin instances registered
</member>
        <member name="F:Ogre.Root.mPluginLibs">
List of plugin DLLs loaded
</member>
        <member name="T:Ogre.Root">
The root class of the Ogre system.
        @remarks
            The Ogre::Root class represents a starting point for the client
            application. From here, the application can gain access to the
            fundamentals of the system, namely the rendering systems
            available, management of saved configurations, logging, and
            access to other classes in the system. Acts as a hub from which
            all other objects may be reached. An instance of Root must be
            created before any other Ogre operations are called. Once an
            instance has been created, the same instance is accessible
            throughout the life of that object by using Root::getSingleton
            (as a reference) or Root::getSingletonPtr (as a pointer).

</member>
        <member name="D:Ogre.RenderSystemList">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

</member>
        <member name="M:Ogre.LodStrategyManager.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.LodStrategyManager.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.LodStrategyManager.getIterator">
Get an iterator for all contained strategies. 
</member>
        <member name="M:Ogre.LodStrategyManager.getDefaultStrategy">
Get the current default strategy. 
</member>
        <member name="M:Ogre.LodStrategyManager.setDefaultStrategy(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the default strategy by name. 
</member>
        <member name="M:Ogre.LodStrategyManager.setDefaultStrategy(Ogre.LodStrategy*)">
Set the default strategy. 
</member>
        <member name="M:Ogre.LodStrategyManager.getStrategy(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get the strategy with the specified name. 
</member>
        <member name="M:Ogre.LodStrategyManager.removeAllStrategies">
Remove and delete all strategies from the manager.
        @remarks
            All strategies are deleted.  If finer control is required
            over strategy destruction, use removeStrategy.

</member>
        <member name="M:Ogre.LodStrategyManager.removeStrategy(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Remove a strategy from the manager with a specified name.
        @remarks
            The removed strategy is returned so the user can control
            how it is destroyed.

</member>
        <member name="M:Ogre.LodStrategyManager.addStrategy(Ogre.LodStrategy*)">
Add a strategy to the manager. 
</member>
        <member name="M:Ogre.LodStrategyManager.Dispose">
Destructor. 
</member>
        <member name="M:Ogre.LodStrategyManager.#ctor">
Default constructor. 
</member>
        <member name="F:Ogre.LodStrategyManager.mDefaultStrategy">
Default strategy. 
</member>
        <member name="F:Ogre.LodStrategyManager.mStrategies">
Internal map of strategies. 
</member>
        <member name="D:Ogre.LodStrategyManager.StrategyMap">
Map of strategies. 
</member>
        <member name="T:Ogre.LodStrategyManager">
\addtogroup Core
	*  @{

\addtogroup LOD
	*  @{

Manager for lod strategies. 
</member>
        <member name="M:Ogre.LodStrategy.getIndexDescending(System.Single,std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Implementation of getIndex suitable for descending values. 
</member>
        <member name="M:Ogre.LodStrategy.getIndexAscending(System.Single,std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Implementation of getIndex suitable for ascending values. 
</member>
        <member name="M:Ogre.LodStrategy.getIndexDescending(System.Single,std.vector&lt;Ogre.MeshLodUsage&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Implementation of getIndex suitable for descending values. 
</member>
        <member name="M:Ogre.LodStrategy.getIndexAscending(System.Single,std.vector&lt;Ogre.MeshLodUsage&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Implementation of getIndex suitable for ascending values. 
</member>
        <member name="M:Ogre.LodStrategy.sortDescending(std.vector&lt;Ogre.MeshLodUsage&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Implementation of sort suitable for descending values. 
</member>
        <member name="M:Ogre.LodStrategy.sortAscending(std.vector&lt;Ogre.MeshLodUsage&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Implementation of sort suitable for ascending values. 
</member>
        <member name="M:Ogre.LodStrategy.isSortedDescending(std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Implementation of isSorted suitable for descending values. 
</member>
        <member name="M:Ogre.LodStrategy.isSortedAscending(std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Implementation of isSorted suitable for ascending values. 
</member>
        <member name="M:Ogre.LodStrategy.getName">
Get the name of this strategy. 
</member>
        <member name="M:Ogre.LodStrategy.assertSorted(std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assert that the lod values are sorted from greatest detail to least detail. 
</member>
        <member name="M:Ogre.LodStrategy.isSorted(std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Determine if the lod values are sorted from greatest detail to least detail. 
</member>
        <member name="M:Ogre.LodStrategy.sort(std.vector&lt;Ogre.MeshLodUsage&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sort mesh lod usage list from greatest to least detail 
</member>
        <member name="M:Ogre.LodStrategy.getIndex(System.Single,std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get the index of the lod usage which applies to a given value. 
</member>
        <member name="M:Ogre.LodStrategy.getIndex(System.Single,std.vector&lt;Ogre.MeshLodUsage&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get the index of the lod usage which applies to a given value. 
</member>
        <member name="M:Ogre.LodStrategy.getValue(Ogre.MovableObject!System.Runtime.CompilerServices.IsConst*,Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Compute the lod value for a given movable object relative to a given camera. 
</member>
        <member name="M:Ogre.LodStrategy.transformUserValue(System.Single)">
Transforum user supplied value to internal value.
        @remarks
            By default, performs no transformation.
        @remarks
            Do not throw exceptions for invalid values here, as the lod strategy
            may be changed such that the values become valid.

</member>
        <member name="M:Ogre.LodStrategy.transformBias(System.Single)">
Transform lod bias so it only needs to be multiplied by the lod value. 
</member>
        <member name="M:Ogre.LodStrategy.getBaseValue">
Get the value of the first (highest) level of detail. 
</member>
        <member name="M:Ogre.LodStrategy.Dispose">
Virtual destructor. 
</member>
        <member name="M:Ogre.LodStrategy.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor accepting name. 
</member>
        <member name="M:Ogre.LodStrategy.getValueImpl(Ogre.MovableObject!System.Runtime.CompilerServices.IsConst*,Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Compute the lod value for a given movable object relative to a given camera. 
</member>
        <member name="F:Ogre.LodStrategy.mName">
Name of this strategy. 
</member>
        <member name="T:Ogre.LodStrategy">
\addtogroup Core
	*  @{

\addtogroup LOD
	*  @{

Strategy for determining level of detail.
    @remarks
        Generally, to create a new lod strategy, all of the following will
        need to be implemented: getValueImpl, getBaseValue, transformBias,
        getIndex, sort, and isSorted.
        In addition, transformUserValue may be overridden.

</member>
        <member name="M:Ogre.SceneManagerEnumerator.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.SceneManagerEnumerator.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.SceneManagerEnumerator.shutdownAll">
Utility method to control shutdown of the managers
</member>
        <member name="M:Ogre.SceneManagerEnumerator.setRenderSystem(Ogre.RenderSystem*)">
Notifies all SceneManagers of the destination rendering system.

</member>
        <member name="M:Ogre.SceneManagerEnumerator.getSceneManagerIterator">
Get an iterator over all the existing SceneManager instances. 
</member>
        <member name="M:Ogre.SceneManagerEnumerator.hasSceneManager(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Identify if a SceneManager instance already exists.
		@param instanceName The name of the instance to retrieve.

</member>
        <member name="M:Ogre.SceneManagerEnumerator.getSceneManager(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get an existing SceneManager instance that has already been created,
			identified by the instance name.
		@param instanceName The name of the instance to retrieve.

</member>
        <member name="M:Ogre.SceneManagerEnumerator.destroySceneManager(Ogre.SceneManager*)">
Destroy an instance of a SceneManager. 
</member>
        <member name="M:Ogre.SceneManagerEnumerator.createSceneManager(System.UInt16,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a SceneManager instance based on scene type support.
		@remarks
			Creates an instance of a SceneManager which supports the scene types
			identified in the parameter. If more than one type of SceneManager 
			has been registered as handling that combination of scene types, 
			in instance of the last one registered is returned.
		@note This method always succeeds, if a specific scene manager is not
			found, the default implementation is always returned.
		@param typeMask A mask containing one or more SceneType flags
		@param instanceName Optional name to given the new instance that is
			created. If you leave this blank, an auto name will be assigned.

</member>
        <member name="M:Ogre.SceneManagerEnumerator.createSceneManager(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a SceneManager instance of a given type.
		@remarks
			You can use this method to create a SceneManager instance of a 
			given specific type. You may know this type already, or you may
			have discovered it by looking at the results from getMetaDataIterator.
		@note
			This method throws an exception if the named type is not found.
		@param typeName String identifying a unique SceneManager type
		@param instanceName Optional name to given the new instance that is
			created. If you leave this blank, an auto name will be assigned.

</member>
        <member name="M:Ogre.SceneManagerEnumerator.getMetaDataIterator">
Iterate over all types of SceneManager available for construction, 
			providing some information about each one.

</member>
        <member name="M:Ogre.SceneManagerEnumerator.getMetaData(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get more information about a given type of SceneManager.
		@remarks
			The metadata returned tells you a few things about a given type 
			of SceneManager, which can be created using a factory that has been
			registered already. 
		@param typeName The type name of the SceneManager you want to enquire on.
			If you don't know the typeName already, you can iterate over the 
			metadata for all types using getMetaDataIterator.

</member>
        <member name="M:Ogre.SceneManagerEnumerator.removeFactory(Ogre.SceneManagerFactory*)">
Remove a SceneManagerFactory. 

</member>
        <member name="M:Ogre.SceneManagerEnumerator.addFactory(Ogre.SceneManagerFactory*)">
Register a new SceneManagerFactory. 
		@remarks
			Plugins should call this to register as new SceneManager providers.

</member>
        <member name="F:Ogre.SceneManagerEnumerator.mCurrentRenderSystem">
Currently assigned render system
</member>
        <member name="F:Ogre.SceneManagerEnumerator.mInstanceCreateCount">
Count of creations for auto-naming
</member>
        <member name="F:Ogre.SceneManagerEnumerator.mDefaultFactory">
Factory for default scene manager
</member>
        <member name="F:Ogre.SceneManagerEnumerator.mMetaDataList">
Stored separately to allow iteration
</member>
        <member name="D:Ogre.SceneManagerEnumerator.Factories">
Scene manager factories
</member>
        <member name="D:Ogre.SceneManagerEnumerator.MetaDataList">
List of available scene manager types as meta data
</member>
        <member name="D:Ogre.SceneManagerEnumerator.Instances">
Scene manager instances, indexed by instance name
</member>
        <member name="T:Ogre.SceneManagerEnumerator">
Enumerates the SceneManager classes available to applications.
        @remarks
            As described in the SceneManager class, SceneManagers are responsible
            for organising the scene and issuing rendering commands to the
            RenderSystem. Certain scene types can benefit from different
            rendering approaches, and it is intended that subclasses will
            be created to special case this.
        @par
            In order to give applications easy access to these implementations,
            this class has a number of methods to create or retrieve a SceneManager
            which is appropriate to the scene type. 
		@par
			SceneManagers are created by SceneManagerFactory instances. New factories
			for new types of SceneManager can be registered with this class to make
			them available to clients.
		@par
			Note that you can still plug in your own custom SceneManager without
			using a factory, should you choose, it's just not as flexible that way.
			Just instantiate your own SceneManager manually and use it directly.

</member>
        <member name="T:Ogre.DefaultSceneManager">
Default scene manager
</member>
        <member name="F:Ogre.DefaultSceneManagerFactory.FACTORY_TYPE_NAME">
Factory type name
</member>
        <member name="T:Ogre.DefaultSceneManagerFactory">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Factory for default scene manager
</member>
        <member name="M:Ogre.SceneManagerFactory.destroyInstance(Ogre.SceneManager*)">
Destroy an instance of a SceneManager. 
</member>
        <member name="M:Ogre.SceneManagerFactory.createInstance(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a new instance of a SceneManager.
		@remarks
		Don't call directly, use SceneManagerEnumerator::createSceneManager.

</member>
        <member name="M:Ogre.SceneManagerFactory.getMetaData">
Get information about the SceneManager type created by this factory. 
</member>
        <member name="M:Ogre.SceneManagerFactory.initMetaData">
Internal method to initialise the metadata, must be implemented
</member>
        <member name="T:Ogre.SceneManagerFactory">
Class which will create instances of a given SceneManager. 
</member>
        <member name="F:Ogre.SceneManagerMetaData.worldGeometrySupported">
Flag indicating whether world geometry is supported
</member>
        <member name="F:Ogre.SceneManagerMetaData.sceneTypeMask">
A mask describing which sorts of scenes this manager can handle
</member>
        <member name="F:Ogre.SceneManagerMetaData.description">
A text description of the scene manager
</member>
        <member name="F:Ogre.SceneManagerMetaData.typeName">
A globally unique string identifying the scene manager type
</member>
        <member name="T:Ogre.SceneManagerMetaData">
Structure containing information about a scene manager. 
</member>
        <member name="T:Ogre.SceneType">
Classification of a scene to allow a decision of what type of
	SceenManager to provide back to the application.

</member>
        <member name="D:Ogre.SceneTypeMask">
Bitmask containing scene types
</member>
        <member name="M:Ogre.DefaultAxisAlignedBoxSceneQuery.execute(Ogre.SceneQueryListener*)">
See RayScenQuery. 
</member>
        <member name="T:Ogre.DefaultAxisAlignedBoxSceneQuery">
Default implementation of AxisAlignedBoxSceneQuery. 
</member>
        <member name="M:Ogre.DefaultPlaneBoundedVolumeListSceneQuery.execute(Ogre.SceneQueryListener*)">
See SceneQuery. 
</member>
        <member name="T:Ogre.DefaultPlaneBoundedVolumeListSceneQuery">
Default implementation of PlaneBoundedVolumeListSceneQuery. 
</member>
        <member name="M:Ogre.DefaultSphereSceneQuery.execute(Ogre.SceneQueryListener*)">
See SceneQuery. 
</member>
        <member name="T:Ogre.DefaultSphereSceneQuery">
Default implementation of SphereSceneQuery. 
</member>
        <member name="M:Ogre.DefaultRaySceneQuery.execute(Ogre.RaySceneQueryListener*)">
See RayScenQuery. 
</member>
        <member name="T:Ogre.DefaultRaySceneQuery">
Default implementation of RaySceneQuery. 
</member>
        <member name="M:Ogre.DefaultIntersectionSceneQuery.execute(Ogre.IntersectionSceneQueryListener*)">
See IntersectionSceneQuery. 
</member>
        <member name="T:Ogre.DefaultIntersectionSceneQuery">
Default implementation of IntersectionSceneQuery. 
</member>
        <member name="M:Ogre.SceneManager._handleLodEvents">
Handle lod events. 
</member>
        <member name="M:Ogre.SceneManager._notifyEntityMaterialLodChanged(Ogre.EntityMaterialLodChangedEvent*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Notify that an entity material lod change event has occurred. 
</member>
        <member name="M:Ogre.SceneManager._notifyEntityMeshLodChanged(Ogre.EntityMeshLodChangedEvent*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Notify that an entity mesh lod change event has occurred. 
</member>
        <member name="M:Ogre.SceneManager._notifyMovableObjectLodChanged(Ogre.MovableObjectLodChangedEvent*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Notify that a movable object lod change event has occurred. 
</member>
        <member name="M:Ogre.SceneManager.removeLodListener(Ogre.LodListener*)">
Remove a level of detail listener.
@remarks
    Do not call from inside an LodListener callback method.

</member>
        <member name="M:Ogre.SceneManager.addLodListener(Ogre.LodListener*)">
Add a level of detail listener. 
</member>
        <member name="M:Ogre.SceneManager.getCameraRelativeRendering">
Get whether to use camera-relative co-ordinates when rendering, ie
			to always place the camera at the origin and move the world around it.

</member>
        <member name="M:Ogre.SceneManager.setCameraRelativeRendering(System.Boolean)">
Set whether to use camera-relative co-ordinates when rendering, ie
			to always place the camera at the origin and move the world around it.
		@remarks
			This is a technique to alleviate some of the precision issues associated with 
			rendering far from the origin, where single-precision floats as used in most
			GPUs begin to lose their precision. Instead of including the camera
			translation in the view matrix, it only includes the rotation, and
			the world matrices of objects must be expressed relative to this.
		@note
			If you need this option, you will probably also need to enable double-precision
			mode in Ogre (OGRE_DOUBLE_PRECISION), since even though this will 
			alleviate the rendering precision, the source camera and object positions will still 
			suffer from precision issues leading to jerky movement. 

</member>
        <member name="M:Ogre.SceneManager.getShadowCasterBoundsInfo(Ogre.Light!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Returns the shadow caster AAB for a specific light-camera combination 
</member>
        <member name="M:Ogre.SceneManager.getVisibleObjectsBoundsInfo(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Returns a visibility boundary box for a specific camera. 
</member>
        <member name="M:Ogre.SceneManager.getCurrentViewport">
Gets the current viewport being rendered (advanced use only, only 
			valid during viewport update. 
</member>
        <member name="M:Ogre.SceneManager.getDestinationRenderSystem">
Get the rendersystem subclass to which the output of this Scene Manager
			gets sent

</member>
        <member name="M:Ogre.SceneManager.getQueuedRenderableVisitor">
Gets the current visitor object which processes queued renderables. 
</member>
        <member name="M:Ogre.SceneManager.setQueuedRenderableVisitor(Ogre.SceneManager.SceneMgrQueuedRenderableVisitor*)">
Advanced method for supplying an alternative visitor, used for parsing the
			render queues and sending the results to the renderer.
		@remarks
			You can use this method to insert your own implementation of the 
			QueuedRenderableVisitor interface, which receives calls as the queued
			renderables are parsed in a given order (determined by RenderQueueInvocationSequence)
			and are sent to the renderer. If you provide your own implementation of
			this visitor, you are responsible for either calling the rendersystem, 
			or passing the calls on to the base class implementation.
		@note
			Ownership is not taken of this pointer, you are still required to 
			delete it yourself once you're finished.
		@param visitor Your implementation of SceneMgrQueuedRenderableVisitor. 
			If you pass 0, the default implementation will be used.

</member>
        <member name="M:Ogre.SceneManager._renderQueueGroupObjects(Ogre.RenderQueueGroup*,Ogre.QueuedRenderableCollection.OrganisationMode)">
Render the objects in a given queue group 
		@remarks You should only call this from a RenderQueueInvocation implementation

</member>
        <member name="M:Ogre.SceneManager._areShadowsSuppressed">
Are shadows suppressed? 
		@see _suppressShadows

</member>
        <member name="M:Ogre.SceneManager._suppressShadows(System.Boolean)">
Indicates to the SceneManager whether it should suppress the 
			active shadow rendering technique until told otherwise.
		@remarks
			This is a temporary alternative to setShadowTechnique to suppress
			the rendering of shadows and forcing all processing down the 
			standard rendering path. This is intended for internal use only.
		@param suppress If true, no shadow rendering will occur until this
			method is called again with a parameter of false.

</member>
        <member name="M:Ogre.SceneManager._setPass(Ogre.Pass!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean)">
Internal method for setting up the renderstate for a rendering pass.
            @param pass The Pass details to set.
			@param evenIfSuppressed Sets the pass details even if render state
				changes are suppressed; if you are using this to manually set state
				when render state changes are suppressed, you should set this to 
				true.
			@param shadowDerivation If false, disables the derivation of shadow
				passes from original passes
            @returns
                A Pass object that was used instead of the one passed in, can
                happen when rendering shadow passes

</member>
        <member name="M:Ogre.SceneManager._areRenderStateChangesSuppressed">
Are render state changes suppressed? 
		@see _suppressRenderStateChanges

</member>
        <member name="M:Ogre.SceneManager._suppressRenderStateChanges(System.Boolean)">
Indicates to the SceneManager whether it should suppress changing
			the RenderSystem states when rendering objects.
		@remarks
			This method allows you to tell the SceneManager not to change any
			RenderSystem state until you tell it to. This method is only 
			intended for advanced use, don't use it if you're unsure of the 
			effect. The only RenderSystems calls made are to set the world 
			matrix for each object (note - view an projection matrices are NOT
			SET - they are under your control) and to render the object; it is up to 
			the caller to do everything else, including enabling any vertex / 
			fragment programs and updating their parameter state, and binding
			parameters to the RenderSystem.
		@note
			Calling this implicitly disables shadow processing since no shadows
			can be rendered without changing state.
		@param suppress If true, no RenderSystem state changes will be issued
			until this method is called again with a parameter of false.

</member>
        <member name="M:Ogre.SceneManager._injectRenderWithPass(Ogre.Pass*,Ogre.Renderable*,System.Boolean,System.Boolean,Ogre.HashedVector&lt;Ogre.Light**&gt;!System.Runtime.CompilerServices.IsConst*)">
Render something as if it came from the current queue.
			@param pass		Material pass to use for setting up this quad.
			@param rend		Renderable to render
			@param shadowDerivation Whether passes should be replaced with shadow caster / receiver passes

</member>
        <member name="M:Ogre.SceneManager.getFlipCullingOnNegativeScale">
Get whether to automatically flip the culling mode on objects whenever they
			are negatively scaled.

</member>
        <member name="M:Ogre.SceneManager.setFlipCullingOnNegativeScale(System.Boolean)">
Set whether to automatically flip the culling mode on objects whenever they
			are negatively scaled.
		@remarks
			Negativelyl scaling an object has the effect of flipping the triangles, 
			so the culling mode should probably be inverted to deal with this. 
			If you would prefer to manually manage this, set this option to 'false' 
			and use different materials with Pass::setCullingMode set manually as needed.

</member>
        <member name="M:Ogre.SceneManager.getNormaliseNormalsOnScale">
Get whether to automatically normalise normals on objects whenever they
			are scaled.

</member>
        <member name="M:Ogre.SceneManager.setNormaliseNormalsOnScale(System.Boolean)">
Set whether to automatically normalise normals on objects whenever they
			are scaled.
		@remarks
			Scaling can distort normals so the default behaviour is to compensate
			for this, but it has a cost. If you would prefer to manually manage 
			this, set this option to 'false' and use Pass::setNormaliseNormals
			only when needed.

</member>
        <member name="M:Ogre.SceneManager.getFindVisibleObjects">
Gets whether the SceneManager should search for visible objects, or
            whether they are being manually handled.

</member>
        <member name="M:Ogre.SceneManager.setFindVisibleObjects(System.Boolean)">
Sets whether the SceneManager should search for visible objects, or
            whether they are being manually handled.
        @remarks
            This is an advanced function, you should not use this unless you know
            what you are doing.

</member>
        <member name="M:Ogre.SceneManager._getCombinedVisibilityMask">
Internal method for getting the combination between the global visibility
			mask and the per-viewport visibility mask.

</member>
        <member name="M:Ogre.SceneManager.getVisibilityMask">
Gets a mask which is bitwise 'and'ed with objects own visibility masks
			to determine if the object is visible.

</member>
        <member name="M:Ogre.SceneManager.setVisibilityMask(System.UInt32)">
Sets a mask which is bitwise 'and'ed with objects own visibility masks
			to determine if the object is visible.
		@remarks
			Note that this is combined with any per-viewport visibility mask
			through an 'and' operation. @see Viewport::setVisibilityMask

</member>
        <member name="M:Ogre.SceneManager.extractAllMovableObjectsByType(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Extract all injected MovableObjects of a given type.
		@remarks
			Essentially this does the same as destroyAllMovableObjectsByType, 
			but only removes the instances from the internal lists, it does not 
			attempt to destroy them.

</member>
        <member name="M:Ogre.SceneManager.extractMovableObject(Ogre.MovableObject*)">
Extract a previously injected MovableObject.
		@remarks
			Essentially this does the same as destroyMovableObject, but only
			removes the instance from the internal lists, it does not attempt
			to destroy it.

</member>
        <member name="M:Ogre.SceneManager.extractMovableObject(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Extract a previously injected MovableObject.
		@remarks
			Essentially this does the same as destroyMovableObject, but only
			removes the instance from the internal lists, it does not attempt
			to destroy it.

</member>
        <member name="M:Ogre.SceneManager.injectMovableObject(Ogre.MovableObject*)">
Inject a MovableObject instance created externally.
		@remarks
			This method 'injects' a MovableObject instance created externally into
			the MovableObject instance registry held in the SceneManager. You
			might want to use this if you have a MovableObject which you don't
			want to register a factory for; for example a MovableObject which 
			cannot be generally constructed by clients. 
		@note
			It is important that the MovableObject has a unique name for the type,
			and that its getMovableType() method returns a proper type name.

</member>
        <member name="M:Ogre.SceneManager.getMovableObjectIterator(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get an iterator over all MovableObect instances of a given type. 
		@note
			The iterator returned from this method is not thread safe, do not use this
			if you are creating or deleting objects of this type in another thread.

</member>
        <member name="M:Ogre.SceneManager.hasMovableObject(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether a movable object instance with the given name exists. 
</member>
        <member name="M:Ogre.SceneManager.getMovableObject(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get a reference to a previously created MovableObject. 
		@note Throws an exception if the named instance does not exist

</member>
        <member name="M:Ogre.SceneManager.destroyAllMovableObjects">
Destroy all MovableObjects. 
</member>
        <member name="M:Ogre.SceneManager.destroyAllMovableObjectsByType(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroy all MovableObjects of a given type. 
</member>
        <member name="M:Ogre.SceneManager.destroyMovableObject(Ogre.MovableObject*)">
Destroys a MovableObject.
		@remarks
			The MovableObject will automatically detach itself from any nodes
			on destruction.

</member>
        <member name="M:Ogre.SceneManager.destroyMovableObject(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroys a MovableObject with the name specified, of the type specified.
		@remarks
			The MovableObject will automatically detach itself from any nodes
			on destruction.

</member>
        <member name="M:Ogre.SceneManager.createMovableObject(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.C">
Create a movable object of the type specified without a name.
		@remarks
		This is the generalised form of MovableObject creation where you can
		create a MovableObject of any specialised type generically, including
		any new types registered using plugins. The name is generated automatically.
		@param typeName The type of object to create
		@param params Optional name/value pair list to give extra parameters to
		the created object.

</member>
        <member name="M:Ogre.SceneManager.createMovableObject(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map&lt;std.basic_string&lt;System.SByte!S">
Create a movable object of the type specified.
		@remarks
			This is the generalised form of MovableObject creation where you can
			create a MovableObject of any specialised type generically, including
			any new types registered using plugins.
		@param name The name to give the object. Must be unique within type.
		@param typeName The type of object to create
		@param params Optional name/value pair list to give extra parameters to
			the created object.

</member>
        <member name="M:Ogre.SceneManager.getInstancedGeometry(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieve a previously created InstancedGeometry instance. 
</member>
        <member name="M:Ogre.SceneManager.createInstancedGeometry(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a InstancedGeometry instance suitable for use with this
			SceneManager.
		@remarks
			InstancedGeometry is a way of batching up geometry into a more 
			efficient form, and still be able to move it. Please 
			read the InstancedGeometry class documentation for full information.
		@param name The name to give the new object
		@returns The new InstancedGeometry instance

</member>
        <member name="M:Ogre.SceneManager.hasStaticGeometry(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether a static geometry instance with the given name exists. 
</member>
        <member name="M:Ogre.SceneManager.getStaticGeometry(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieve a previously created StaticGeometry instance. 
		@note Throws an exception if the named instance does not exist

</member>
        <member name="M:Ogre.SceneManager.createStaticGeometry(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a StaticGeometry instance suitable for use with this
			SceneManager.
		@remarks
			StaticGeometry is a way of batching up geometry into a more 
			efficient form at the expense of being able to move it. Please 
			read the StaticGeometry class documentation for full information.
		@param name The name to give the new object
		@returns The new StaticGeometry instance

</member>
        <member name="M:Ogre.SceneManager.removeListener(Ogre.SceneManager.Listener*)">
Remove a listener

</member>
        <member name="M:Ogre.SceneManager.addListener(Ogre.SceneManager.Listener*)">
Add a listener which will get called back on scene manager events.

</member>
        <member name="M:Ogre.SceneManager._getActiveCompositorChain">
Gets the active compositor chain of the current scene being rendered 
</member>
        <member name="M:Ogre.SceneManager.isLateMaterialResolving">
Gets whether using late material resolving or not.
			@see setLateMaterialResolving 
</member>
        <member name="M:Ogre.SceneManager.setLateMaterialResolving(System.Boolean)">
Sets whether to use late material resolving or not. If set, materials will be resolved
			from the materials at the pass-setting stage and not at the render queue building stage.
			This is useful when the active material scheme during the render queue building stage
			is different from the one during the rendering stage.

</member>
        <member name="M:Ogre.SceneManager._setActiveCompositorChain(Ogre.CompositorChain*)">
Sets the active compositor chain of the current scene being rendered.
			@note CompositorChain does this automatically, no need to call manually.

</member>
        <member name="M:Ogre.SceneManager.getShadowUseLightClipPlanes">
Gets whether when using a built-in additive shadow mode, user clip
		planes should be used to restrict light rendering.

</member>
        <member name="M:Ogre.SceneManager.setShadowUseLightClipPlanes(System.Boolean)">
Sets whether when using a built-in additive shadow mode, user clip
			planes should be used to restrict light rendering.

</member>
        <member name="M:Ogre.SceneManager.isShadowTechniqueInUse">
Is there any shadowing technique in use? 
</member>
        <member name="M:Ogre.SceneManager.isShadowTechniqueIntegrated">
Is the shadow technique integrated into primary materials? 
</member>
        <member name="M:Ogre.SceneManager.isShadowTechniqueAdditive">
Is there an additive shadowing technique in use? 
</member>
        <member name="M:Ogre.SceneManager.isShadowTechniqueModulative">
Is there a modulative shadowing technique in use? 
</member>
        <member name="M:Ogre.SceneManager.isShadowTechniqueTextureBased">
Is there a texture shadow based shadowing technique in use? 
</member>
        <member name="M:Ogre.SceneManager.isShadowTechniqueStencilBased">
Is there a stencil shadow based shadowing technique in use? 
</member>
        <member name="M:Ogre.SceneManager.getShadowCameraSetup">
Get the shadow camera setup in use for all lights which don't have
			their own shadow camera setup.
		@see ShadowCameraSetup

</member>
        <member name="M:Ogre.SceneManager.setShadowCameraSetup(Ogre.SharedPtr&lt;Ogre.ShadowCameraSetup&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the shadow camera setup to use for all lights which don't have
			their own shadow camera setup.
		@see ShadowCameraSetup

</member>
        <member name="M:Ogre.SceneManager.getShadowCasterRenderBackFaces">
Gets whether or not shadow casters should be rendered into shadow
			textures using their back faces rather than their front faces. 

</member>
        <member name="M:Ogre.SceneManager.setShadowCasterRenderBackFaces(System.Boolean)">
Sets whether or not shadow casters should be rendered into shadow
			textures using their back faces rather than their front faces. 
		@remarks
			Rendering back faces rather than front faces into a shadow texture
			can help minimise depth comparison issues, if you're using depth
			shadowmapping. You will probably still need some biasing but you
			won't need as much. For solid objects the result is the same anyway,
			if you have objects with holes you may want to turn this option off.
			The default is to enable this option.

</member>
        <member name="M:Ogre.SceneManager.setShadowTextureReceiverMaterial(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the default material to use for rendering shadow receivers.
		@remarks
			By default shadow receivers are rendered as a post-pass using basic
			modulation. This allows basic projective texture shadows, but it's 
			possible to use more advanced shadow techniques by overriding the 
			caster and receiver materials, for example providing vertex and 
			fragment programs to implement shadow maps.
		@par
			You can rely on texture unit 0 containing the shadow texture, and 
			for the unit to be set to use projective texturing from the light 
			(only useful if you're using fixed-function, which is unlikely; 
			otherwise you should rely on the texture_viewproj_matrix auto binding)
		@note
			Individual objects may also override the vertex program in
			your default material if their materials include 
			shadow_caster_vertex_program_ref shadow_receiver_vertex_program_ref
			shadow_receiver_material entries, so if you use both make sure they are compatible.
		@note
			Only a single pass is allowed in your material, although multiple
			techniques may be used for hardware fallback.

</member>
        <member name="M:Ogre.SceneManager.setShadowTextureCasterMaterial(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the default material to use for rendering shadow casters.
		@remarks
			By default shadow casters are rendered into the shadow texture using
			an automatically generated fixed-function pass. This allows basic
			projective texture shadows, but it's possible to use more advanced
			shadow techniques by overriding the caster and receiver materials, for
			example providing vertex and fragment programs to implement shadow
			maps.
		@par
			You can rely on the ambient light in the scene being set to the 
			requested texture shadow colour, if that's useful. 
		@note
			Individual objects may also override the vertex program in
			your default material if their materials include 
			shadow_caster_vertex_program_ref, shadow_receiver_vertex_program_ref
			shadow_caster_material entries, so if you use both make sure they are compatible.			
		@note
			Only a single pass is allowed in your material, although multiple
			techniques may be used for hardware fallback.

</member>
        <member name="M:Ogre.SceneManager.getShadowTextureSelfShadow">
Gets whether or not texture shadows attempt to self-shadow.
</member>
        <member name="M:Ogre.SceneManager.setShadowTextureSelfShadow(System.Boolean)">
Sets whether or not texture shadows should attempt to self-shadow.
		@remarks
			The default implementation of texture shadows uses a fixed-function 
			colour texture projection approach for maximum compatibility, and 
			as such cannot support self-shadowing. However, if you decide to 
			implement a more complex shadowing technique using the 
			setShadowTextureCasterMaterial and setShadowTextureReceiverMaterial 
			there is a possibility you may be able to support 
			self-shadowing (e.g by implementing a shader-based shadow map). In 
			this case you might want to enable this option.
		@param selfShadow Whether to attempt self-shadowing with texture shadows

</member>
        <member name="M:Ogre.SceneManager.setShadowTextureFadeEnd(System.Single)">
Sets the proportional distance at which texture shadows finish to fading out.
        @remarks
        To hide the edges where texture shadows end (in directional lights)
        Ogre will fade out the shadow in the distance. This value is a proportional
        distance of the entire shadow visibility distance at which the shadow
        is completely invisible. The default is 0.9.

</member>
        <member name="M:Ogre.SceneManager.setShadowTextureFadeStart(System.Single)">
Sets the proportional distance at which texture shadows begin to fade out.
        @remarks
            To hide the edges where texture shadows end (in directional lights)
            Ogre will fade out the shadow in the distance. This value is a proportional
            distance of the entire shadow visibility distance at which the shadow
            begins to fade out. The default is 0.7

</member>
        <member name="M:Ogre.SceneManager.getShadowDirLightTextureOffset">
Gets the proportional distance which a texture shadow which is generated from a
		directional light will be offset into the camera view to make best use of texture space.

</member>
        <member name="M:Ogre.SceneManager.setShadowDirLightTextureOffset(System.Single)">
Sets the proportional distance which a texture shadow which is generated from a
            directional light will be offset into the camera view to make best use of texture space.
        @remarks
            When generating a shadow texture from a directional light, an approximation is used
            since it is not possible to render the entire scene to one texture. 
            The texture is projected onto an area centred on the camera, and is
            the shadow far distance * 2 in length (it is square). This wastes
            a lot of texture space outside the frustum though, so this offset allows
            you to move the texture in front of the camera more. However, be aware
            that this can cause a little shadow 'jittering' during rotation, and
            that if you move it too far then you'll start to get artefacts close 
            to the camera. The value is represented as a proportion of the shadow
            far distance, and the default is 0.6.

</member>
        <member name="M:Ogre.SceneManager.getShadowTexture(System.UInt32)">
Get a reference to the shadow texture currently in use at the given index.
		@note
			If you change shadow settings, this reference may no longer
			be correct, so be sure not to hold the returned reference over 
			texture shadow configuration changes.

</member>
        <member name="M:Ogre.SceneManager.setShadowTextureSettings(System.UInt16,System.UInt16,Ogre.PixelFormat)">
Sets the size and count of textures used in texture-based shadows. 
        @remarks
            @see setShadowTextureSize and setShadowTextureCount for details, this
            method just allows you to change both at once, which can save on 
            reallocation if the textures have already been created.
		@note This is the simple form, see setShadowTextureConfig for the more 
			complex form.

</member>
        <member name="M:Ogre.SceneManager.getShadowTextureCountPerLightType(Ogre.Light.LightTypes)">
Get the number of shadow textures is assigned for the given light type.
</member>
        <member name="M:Ogre.SceneManager.setShadowTextureCountPerLightType(Ogre.Light.LightTypes,System.UInt32)">
Set the number of shadow textures a light type uses.
		@remarks
			The default for all light types is 1. This means that each light uses only 1 shadow
			texture. Call this if you need more than 1 shadow texture per light, E.G. PSSM. 
		@note
			This feature only works with the Integrated shadow technique.
			Also remember to increase the total number of shadow textures you request
			appropriately (e.g. via setShadowTextureCount)!!

</member>
        <member name="M:Ogre.SceneManager.getShadowTextureCount">
Get the number of the textures allocated for texture based shadows
</member>
        <member name="M:Ogre.SceneManager.setShadowTextureCount(System.UInt32)">
Set the number of textures allocated for texture-based shadows.
        @remarks
            The default number of textures assigned to deal with texture based
            shadows is 1; however this means you can only have one light casting
            shadows at the same time. You can increase this number in order to 
            make this more flexible, but be aware of the texture memory it will use.

</member>
        <member name="M:Ogre.SceneManager.setShadowTexturePixelFormat(Ogre.PixelFormat)">
Set the pixel format of the textures used for texture-based shadows.
        @remarks
			By default, a colour texture is used (PF_X8R8G8B8) for texture shadows,
			but if you want to use more advanced texture shadow types you can 
			alter this. If you do, you will have to also call
			setShadowTextureCasterMaterial and setShadowTextureReceiverMaterial
			to provide shader-based materials to use these customised shadow
			texture formats.
		@note This is the simple form, see setShadowTextureConfig for the more 
			complex form.

</member>
        <member name="M:Ogre.SceneManager.getShadowTextureConfigIterator">
Get an iterator over the current shadow texture settings. 
</member>
        <member name="M:Ogre.SceneManager.setShadowTextureSize(System.UInt16)">
Set the size of the texture used for all texture-based shadows.
        @remarks
            The larger the shadow texture, the better the detail on 
            texture based shadows, but obviously this takes more memory.
            The default size is 512. Sizes must be a power of 2.
		@note This is the simple form, see setShadowTextureConfig for the more 
			complex form.

</member>
        <member name="M:Ogre.SceneManager.getShadowIndexBufferSize">
Get the size of the shadow index buffer
</member>
        <member name="M:Ogre.SceneManager.setShadowIndexBufferSize(System.UInt32)">
Sets the maximum size of the index buffer used to render shadow
		 	primitives.
		@remarks
			This method allows you to tweak the size of the index buffer used
			to render shadow primitives (including stencil shadow volumes). The
			default size is 51,200 entries, which is 100k of GPU memory, or
			enough to render approximately 17,000 triangles. You can reduce this
			as long as you do not have any models / world geometry chunks which 
			could require more than the amount you set.
		@par
			The maximum number of triangles required to render a single shadow 
			volume (including light and dark caps when needed) will be 3x the 
			number of edges on the light silhouette, plus the number of 
			light-facing triangles.	On average, half the 
			triangles will be facing toward the light, but the number of 
			triangles in the silhouette entirely depends on the mesh - 
			angular meshes will have a higher silhouette tris/mesh tris
			ratio than a smooth mesh. You can estimate the requirements for
			your particular mesh by rendering it alone in a scene with shadows
			enabled and a single light - rotate it or the light and make a note
			of how high the triangle count goes (remembering to subtract the 
			mesh triangle count)
		@param size The number of indexes; divide this by 3 to determine the
			number of triangles.

</member>
        <member name="M:Ogre.SceneManager.getShadowFarDistance">
Gets the default maximum distance away from the camera that shadows
        will be visible.

</member>
        <member name="M:Ogre.SceneManager.setShadowFarDistance(System.Single)">
Sets the default maximum distance away from the camera that shadows
        will be visible. You have to call this function before you create lights
        or the default distance of zero will be used.
        @remarks
        Shadow techniques can be expensive, therefore it is a good idea
        to limit them to being rendered close to the camera if possible,
        and to skip the expense of rendering shadows for distance objects.
        This method allows you to set the distance at which shadows will no
        longer be rendered.
        @note
        Each shadow technique can interpret this subtely differently.
        For example, one technique may use this to eliminate casters,
        another might use it to attenuate the shadows themselves.
        You should tweak this value to suit your chosen shadow technique
        and scene setup.

</member>
        <member name="M:Ogre.SceneManager.getShadowDirectionalLightExtrusionDistance">
Gets the distance a shadow volume is extruded for a directional light.

</member>
        <member name="M:Ogre.SceneManager.setShadowDirectionalLightExtrusionDistance(System.Single)">
Sets the distance a shadow volume is extruded for a directional light.
        @remarks
            Although directional lights are essentially infinite, there are many
            reasons to limit the shadow extrusion distance to a finite number, 
            not least of which is compatibility with older cards (which do not
            support infinite positions), and shadow caster elimination.
        @par
            The default value is 10,000 world units. This does not apply to
            point lights or spotlights, since they extrude up to their 
            attenuation range.

</member>
        <member name="M:Ogre.SceneManager.getShadowColour">
Get the colour used to modulate areas in shadow. 
        @remarks This is only applicable for shadow techniques which involve 
        darkening the area in shadow, as opposed to masking out the light. 
        This colour provided is used as a modulative value to darken the
        areas.

</member>
        <member name="M:Ogre.SceneManager.setShadowColour(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the colour used to modulate areas in shadow. 
        @remarks This is only applicable for shadow techniques which involve 
            darkening the area in shadow, as opposed to masking out the light. 
            This colour provided is used as a modulative value to darken the
            areas.

</member>
        <member name="M:Ogre.SceneManager.getShowDebugShadows">
Are debug shadows shown? 
</member>
        <member name="M:Ogre.SceneManager.setShowDebugShadows(System.Boolean)">
Enables / disables the rendering of debug information for shadows. 
</member>
        <member name="M:Ogre.SceneManager.getShadowTechnique">
Gets the current shadow technique. 
</member>
        <member name="M:Ogre.SceneManager.setShadowTechnique(Ogre.ShadowTechnique)">
Sets the general shadow technique to be used in this scene.
        @remarks   
            There are multiple ways to generate shadows in a scene, and each has 
            strengths and weaknesses. 
            <ul><li>Stencil-based approaches can be used to 
            draw very long, extreme shadows without loss of precision and the 'additive'
            version can correctly show the shadowing of complex effects like bump mapping
            because they physically exclude the light from those areas. However, the edges
            are very sharp and stencils cannot handle transparency, and they involve a 
            fair amount of CPU work in order to calculate the shadow volumes, especially
            when animated objects are involved.</li><li>Texture-based approaches are good for handling transparency (they can, for
            example, correctly shadow a mesh which uses alpha to represent holes), and they
            require little CPU overhead, and can happily shadow geometry which is deformed
            by a vertex program, unlike stencil shadows. However, they have a fixed precision 
            which can introduce 'jaggies' at long range and have fillrate issues of their own.</li></ul>
        @par
            We support 2 kinds of stencil shadows, and 2 kinds of texture-based shadows, and one
            simple decal approach. The 2 stencil approaches differ in the amount of multipass work 
            that is required - the modulative approach simply 'darkens' areas in shadow after the 
            main render, which is the least expensive, whilst the additive approach has to perform 
            a render per light and adds the cumulative effect, whcih is more expensive but more 
            accurate. The texture based shadows both work in roughly the same way, the only difference is
            that the shadowmap approach is slightly more accurate, but requires a more recent
            graphics card.
        @par
            Note that because mixing many shadow techniques can cause problems, only one technique
            is supported at once. Also, you should call this method at the start of the 
            scene setup. 
        @param technique The shadowing technique to use for the scene.

</member>
        <member name="M:Ogre.SceneManager.getAnimationStateIterator">
Returns a specialised MapIterator over all animation states in the scene. 
</member>
        <member name="M:Ogre.SceneManager.getAnimations">
Returns a const version of the animation list. 

</member>
        <member name="M:Ogre.SceneManager.getAnimationIterator">
Returns a specialised MapIterator over all animations in the scene. 
</member>
        <member name="M:Ogre.SceneManager.getCameras">
Returns a const version of the camera list. 

</member>
        <member name="M:Ogre.SceneManager.getCameraIterator">
Returns a specialised MapIterator over all cameras in the scene. 

</member>
        <member name="M:Ogre.SceneManager.destroyQuery(Ogre.SceneQuery*)">
Destroys a scene query of any type. 
</member>
        <member name="M:Ogre.SceneManager.createIntersectionQuery(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Creates an IntersectionSceneQuery for this scene manager. 
        @remarks
            This method creates a new instance of a query object for locating
            intersecting objects. See SceneQuery and IntersectionSceneQuery
            for full details.
        @par
            The instance returned from this method must be destroyed by calling
            SceneManager::destroyQuery when it is no longer required.
        @param mask The query mask to apply to this query; can be used to filter out
            certain objects; see SceneQuery for details.

</member>
        <member name="M:Ogre.SceneManager.createRayQuery(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Creates a RaySceneQuery for this scene manager. 
        @remarks
            This method creates a new instance of a query object for this scene manager, 
            looking for objects which fall along a ray. See SceneQuery and RaySceneQuery 
            for full details.
        @par
            The instance returned from this method must be destroyed by calling
            SceneManager::destroyQuery when it is no longer required.
        @param ray Details of the ray which describes the region for this query.
        @param mask The query mask to apply to this query; can be used to filter out
            certain objects; see SceneQuery for details.

</member>
        <member name="M:Ogre.SceneManager.createPlaneBoundedVolumeQuery(std.vector&lt;Ogre.PlaneBoundedVolume&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Creates a PlaneBoundedVolumeListSceneQuery for this scene manager. 
        @remarks
        This method creates a new instance of a query object for this scene manager, 
        for a region enclosed by a set of planes (normals pointing inwards). 
        See SceneQuery and PlaneBoundedVolumeListSceneQuery for full details.
        @par
        The instance returned from this method must be destroyed by calling
        SceneManager::destroyQuery when it is no longer required.
        @param volumes Details of the volumes which describe the region for this query.
        @param mask The query mask to apply to this query; can be used to filter out
        certain objects; see SceneQuery for details.

</member>
        <member name="M:Ogre.SceneManager.createSphereQuery(Ogre.Sphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Creates a SphereSceneQuery for this scene manager. 
        @remarks
            This method creates a new instance of a query object for this scene manager, 
            for a spherical region. See SceneQuery and SphereSceneQuery 
            for full details.
        @par
            The instance returned from this method must be destroyed by calling
            SceneManager::destroyQuery when it is no longer required.
        @param sphere Details of the sphere which describes the region for this query.
        @param mask The query mask to apply to this query; can be used to filter out
            certain objects; see SceneQuery for details.

</member>
        <member name="M:Ogre.SceneManager.createAABBQuery(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Creates an AxisAlignedBoxSceneQuery for this scene manager. 
        @remarks
            This method creates a new instance of a query object for this scene manager, 
            for an axis aligned box region. See SceneQuery and AxisAlignedBoxSceneQuery 
            for full details.
        @par
            The instance returned from this method must be destroyed by calling
            SceneManager::destroyQuery when it is no longer required.
        @param box Details of the box which describes the region for this query.
        @param mask The query mask to apply to this query; can be used to filter out
            certain objects; see SceneQuery for details.

</member>
        <member name="M:Ogre.SceneManager._notifyAutotrackingSceneNode(Ogre.SceneNode*,System.Boolean)">
Internal method for notifying the manager that a SceneNode is autotracking. 
</member>
        <member name="M:Ogre.SceneManager.getShowBoundingBoxes">
Returns if all bounding boxes of scene nodes are to be displayed 
</member>
        <member name="M:Ogre.SceneManager.showBoundingBoxes(System.Boolean)">
Allows all bounding boxes of scene nodes to be displayed. 
</member>
        <member name="M:Ogre.SceneManager.getWorldGeometryRenderQueue">
Gets the render queue that the world geometry (if any) this SceneManager
			renders will be associated with.
		@remarks
			SceneManagers which provide 'world geometry' should place it in a 
			specialised render queue in order to make it possible to enable / 
			disable it easily using the addSpecialCaseRenderQueue method. Even 
			if the SceneManager does not use the render queues to render the 
			world geometry, it should still pick a queue to represent it's manual
			rendering, and check isRenderQueueToBeProcessed before rendering.

</member>
        <member name="M:Ogre.SceneManager.setWorldGeometryRenderQueue(System.Byte)">
Sets the render queue that the world geometry (if any) this SceneManager
			renders will be associated with.
		@remarks
			SceneManagers which provide 'world geometry' should place it in a 
			specialised render queue in order to make it possible to enable / 
			disable it easily using the addSpecialCaseRenderQueue method. Even 
			if the SceneManager does not use the render queues to render the 
			world geometry, it should still pick a queue to represent it's manual
			rendering, and check isRenderQueueToBeProcessed before rendering.
		@note
			Setting this may not affect the actual ordering of rendering the
			world geometry, if the world geometry is being rendered manually
			by the SceneManager. If the SceneManager feeds world geometry into
			the queues, however, the ordering will be affected. 

</member>
        <member name="M:Ogre.SceneManager.isRenderQueueToBeProcessed(System.Byte)">
Returns whether or not the named queue will be rendered based on the
			current 'special case' render queue list and mode.
		@see SceneManager::addSpecialCaseRenderQueue
		@param qid The identifier of the queue which should be tested
		@returns true if the queue will be rendered, false otherwise

</member>
        <member name="M:Ogre.SceneManager.getSpecialCaseRenderQueueMode">
Gets the way the special case render queue list is processed. 
</member>
        <member name="M:Ogre.SceneManager.setSpecialCaseRenderQueueMode(Ogre.SceneManager.SpecialCaseRenderQueueMode)">
Sets the way the special case render queue list is processed.
		@see SceneManager::addSpecialCaseRenderQueue
		@param mode The mode of processing

</member>
        <member name="M:Ogre.SceneManager.clearSpecialCaseRenderQueues">
Clears the 'special case' render queue list.
		@see SceneManager::addSpecialCaseRenderQueue

</member>
        <member name="M:Ogre.SceneManager.removeSpecialCaseRenderQueue(System.Byte)">
Removes an item to the 'special case' render queue list.
		@see SceneManager::addSpecialCaseRenderQueue
		@param qid The identifier of the queue which should be removed from the
			special case list. Nothing happens if the queue is not in the list.

</member>
        <member name="M:Ogre.SceneManager.addSpecialCaseRenderQueue(System.Byte)">
Adds an item to the 'special case' render queue list.
		@remarks
			Normally all render queues are rendered, in their usual sequence, 
			only varying if a RenderQueueListener nominates for the queue to be 
			repeated or skipped. This method allows you to add a render queue to 
			a 'special case' list, which varies the behaviour. The effect of this
			list depends on the 'mode' in which this list is in, which might be
			to exclude these render queues, or to include them alone (excluding
			all other queues). This allows you to perform broad selective
			rendering without requiring a RenderQueueListener.
		@param qid The identifier of the queue which should be added to the
			special case list. Nothing happens if the queue is already in the list.

</member>
        <member name="M:Ogre.SceneManager.removeRenderObjectListener(Ogre.RenderObjectListener*)">
Removes a listener previously added with addRenderObjectListener. 
</member>
        <member name="M:Ogre.SceneManager.addRenderObjectListener(Ogre.RenderObjectListener*)">
Registers a new Render Object Listener which will be notified when rendering an object.		

</member>
        <member name="M:Ogre.SceneManager.removeRenderQueueListener(Ogre.RenderQueueListener*)">
Removes a listener previously added with addRenderQueueListener. 
</member>
        <member name="M:Ogre.SceneManager.addRenderQueueListener(Ogre.RenderQueueListener*)">
Registers a new RenderQueueListener which will be notified when render queues
            are processed.

</member>
        <member name="M:Ogre.SceneManager.getRenderQueue">
Retrieves the internal render queue, for advanced users only.
        @remarks
            The render queue is mainly used internally to manage the scene object 
			rendering queue, it also exports some methods to allow advanced users 
			to configure the behavior of rendering process.
            Most methods provided by RenderQueue are supposed to be used 
			internally only, you should reference to the RenderQueue API for 
			more information. Do not access this directly unless you know what 
			you are doing.

</member>
        <member name="M:Ogre.SceneManager.manualRender(Ogre.Renderable*,Ogre.Pass!System.Runtime.CompilerServices.IsConst*,Ogre.Viewport*,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean,System.Boolean,Ogre.HashedVector&lt;Ogre.Light**&gt;!System.Runtime.CompilerServices.IsConst*)">
Manual rendering method for rendering a single object. 
		@remarks
		@param rend The renderable to issue to the pipeline
		@param pass The pass to use
		@param vp Pointer to the viewport to render to, or 0 to use the existing viewport
		@param doBeginEndFrame If true, beginFrame() and endFrame() are called, 
		otherwise not. You should leave this as false if you are calling
		this within the main render loop.
        @param viewMatrix The transform to apply from world to view space
        @param projMatrix The transform to apply from view to screen space
		@param lightScissoringClipping If true, passes that have the getLightScissorEnabled
		and/or getLightClipPlanesEnabled flags will cause calculation and setting of 
		scissor rectangle and user clip planes. 
		@param doLightIteration If true, this method will issue the renderable to
		the pipeline possibly multiple times, if the pass indicates it should be
		done once per light
		@param manualLightList Only applicable if doLightIteration is false, this
		method allows you to pass in a previously determined set of lights
		which will be used for a single render of this object.

</member>
        <member name="M:Ogre.SceneManager.manualRender(Ogre.RenderOperation*,Ogre.Pass*,Ogre.Viewport*,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Manual rendering method, for advanced users only.
        @remarks
            This method allows you to send rendering commands through the pipeline on
            demand, bypassing OGRE's normal world processing. You should only use this if you
            really know what you're doing; OGRE does lots of things for you that you really should
            let it do. However, there are times where it may be useful to have this manual interface,
            for example overlaying something on top of the scene rendered by OGRE.
        @par
            Because this is an instant rendering method, timing is important. The best 
            time to call it is from a RenderTargetListener event handler.
        @par
            Don't call this method a lot, it's designed for rare (1 or 2 times per frame) use. 
            Calling it regularly per frame will cause frame rate drops!
        @param rend A RenderOperation object describing the rendering op
        @param pass The Pass to use for this render
        @param vp Pointer to the viewport to render to, or 0 to use the current viewport
        @param worldMatrix The transform to apply from object to world space
        @param viewMatrix The transform to apply from world to view space
        @param projMatrix The transform to apply from view to screen space
        @param doBeginEndFrame If true, beginFrame() and endFrame() are called, 
            otherwise not. You should leave this as false if you are calling
            this within the main render loop.

</member>
        <member name="M:Ogre.SceneManager.destroyAllAnimationStates">
Removes all animation states created using this SceneManager. 
</member>
        <member name="M:Ogre.SceneManager.destroyAnimationState(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroys an AnimationState. 
        @remarks
            You should ensure that none of your code is referencing this animation 
            state object since the memory will be freed.

</member>
        <member name="M:Ogre.SceneManager.hasAnimationState(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether an animation state with the given name exists.

</member>
        <member name="M:Ogre.SceneManager.getAnimationState(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves animation state as previously created using createAnimationState. 
		@note Throws an exception if the named instance does not exist

</member>
        <member name="M:Ogre.SceneManager.destroyAllAnimations">
Removes all animations created using this SceneManager. 
</member>
        <member name="M:Ogre.SceneManager.destroyAnimation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroys an Animation. 
        @remarks
            You should ensure that none of your code is referencing this animation objects since the 
            memory will be freed.

</member>
        <member name="M:Ogre.SceneManager.hasAnimation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether an animation with the given name exists.

</member>
        <member name="M:Ogre.SceneManager.getAnimation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Looks up an Animation object previously created with createAnimation. 
		@note Throws an exception if the named instance does not exist

</member>
        <member name="M:Ogre.SceneManager.createAnimation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Creates an animation which can be used to animate scene nodes.
        @remarks
            An animation is a collection of 'tracks' which over time change the position / orientation
            of Node objects. In this case, the animation will likely have tracks to modify the position
            / orientation of SceneNode objects, e.g. to make objects move along a path.
        @par
            You don't need to use an Animation object to move objects around - you can do it yourself
            using the methods of the Node in your FrameListener class. However, when you need relatively
            complex scripted animation, this is the class to use since it will interpolate between
            keyframes for you and generally make the whole process easier to manage.
        @par
            A single animation can affect multiple Node objects (each AnimationTrack affects a single Node).
            In addition, through animation blending a single Node can be affected by multiple animations,
            athough this is more useful when performing skeletal animation (see Skeleton::createAnimation).
        @par
            Note that whilst it uses the same classes, the animations created here are kept separate from the
            skeletal animations of meshes (each Skeleton owns those animations).
        @param name The name of the animation, must be unique within this SceneManager.
        @param length The total length of the animation.

</member>
        <member name="M:Ogre.SceneManager.getDisplaySceneNodes">
Returns true if all scene nodes axis are to be displayed 
</member>
        <member name="M:Ogre.SceneManager.setDisplaySceneNodes(System.Boolean)">
Tells the SceneManager whether it should render the SceneNodes which 
            make up the scene as well as the objects in the scene.
        @remarks
            This method is mainly for debugging purposes. If you set this to 'true',
            each node will be rendered as a set of 3 axes to allow you to easily see
            the orientation of the nodes.

</member>
        <member name="M:Ogre.SceneManager.hasBillboardSet(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether a billboardset with the given name exists.

</member>
        <member name="M:Ogre.SceneManager.getBillboardSet(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves a pointer to the named BillboardSet.
		@note Throws an exception if the named instance does not exist

</member>
        <member name="M:Ogre.SceneManager.createBillboardSet(System.UInt32)">
Creates a new BillboardSet for use with this scene manager, with a generated name.
            @param
                poolSize The initial size of the pool of billboards (see BillboardSet for more information)
            @see
                BillboardSet

</member>
        <member name="M:Ogre.SceneManager.createBillboardSet(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Creates a new BillboardSet for use with this scene manager.
            @remarks
                This method creates a new BillboardSet which is registered with
                the SceneManager. The SceneManager will destroy this object when
                it shuts down or when the SceneManager::clearScene method is
                called, so the caller does not have to worry about destroying
                this object (in fact, it definitely should not do this).
            @par
                See the BillboardSet documentations for full details of the
                returned class.
            @param
                name The name to give to this billboard set. Must be unique.
            @param
                poolSize The initial size of the pool of billboards (see BillboardSet for more information)
            @see
                BillboardSet

</member>
        <member name="M:Ogre.SceneManager.getFogDensity">
Returns the fog density for the scene.

</member>
        <member name="M:Ogre.SceneManager.getFogEnd">
Returns the fog end distance for the scene.

</member>
        <member name="M:Ogre.SceneManager.getFogStart">
Returns the fog start distance for the scene.

</member>
        <member name="M:Ogre.SceneManager.getFogColour">
Returns the fog colour for the scene.

</member>
        <member name="M:Ogre.SceneManager.getFogMode">
Returns the fog mode for the scene.

</member>
        <member name="M:Ogre.SceneManager.setFog(Ogre.FogMode,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single)">
Sets the fogging mode applied to the scene.
            @remarks
                This method sets up the scene-wide fogging effect. These settings
                apply to all geometry rendered, UNLESS the material with which it
                is rendered has it's own fog settings (see Material::setFog).
            @param
                mode Set up the mode of fog as described in the FogMode
                enum, or set to FOG_NONE to turn off.
            @param
                colour The colour of the fog. Either set this to the same
                as your viewport background colour, or to blend in with a
                skydome or skybox.
            @param
                expDensity The density of the fog in FOG_EXP or FOG_EXP2
                mode, as a value between 0 and 1. The default is 0.001. 
            @param
                linearStart Distance in world units at which linear fog starts to
                encroach. Only applicable if mode is
                FOG_LINEAR.
            @param
                linearEnd Distance in world units at which linear fog becomes completely
                opaque. Only applicable if mode is
                FOG_LINEAR.

</member>
        <member name="M:Ogre.SceneManager.getSkyDomeGenParameters">
Get the parameters used to generate the current SkyDome, if any 
</member>
        <member name="M:Ogre.SceneManager.getSkyDomeNode">
Get the sky dome node, if enabled. 
</member>
        <member name="M:Ogre.SceneManager.isSkyDomeEnabled">
Return whether a skydome is enabled 
</member>
        <member name="M:Ogre.SceneManager._setSkyDome(System.Boolean,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single,System.Byte,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.al">
Enables / disables a 'sky dome' i.e. an illusion of a curved sky.
            @remarks
                A sky dome is actually formed by 5 sides of a cube, but with
                texture coordinates generated such that the surface appears
                curved like a dome. Sky domes are appropriate where you need a
                realistic looking sky where the scene is not going to be
                'fogged', and there is always a 'floor' of some sort to prevent
                the viewer looking below the horizon (the distortion effect below
                the horizon can be pretty horrible, and there is never anyhting
                directly below the viewer). If you need a complete wrap-around
                background, use the setSkyBox method instead. You can actually
                combine a sky box and a sky dome if you want, to give a positional
                backdrop with an overlayed curved cloud layer.
            @par
                Sky domes work well with 2D repeating textures like clouds. You
                can change the apparant 'curvature' of the sky depending on how
                your scene is viewed - lower curvatures are better for 'open'
                scenes like landscapes, whilst higher curvatures are better for
                say FPS levels where you don't see a lot of the sky at once and
                the exaggerated curve looks good.
            @param
                enable True to enable the skydome, false to disable it
            @param
                materialName The name of the material the dome will use
            @param
                curvature The curvature of the dome. Good values are
                between 2 and 65. Higher values are more curved leading to
                a smoother effect, lower values are less curved meaning
                more distortion at the horizons but a better distance effect.
            @param
                tiling How many times to tile the texture(s) across the
                dome.
            @param
                distance Distance in world coorinates from the camera to
                each plane of the box the dome is rendered on. The default
                is normally OK.
            @param
                renderQueue The render queue to use when rendering this object
            @param
                orientation Optional parameter to specify the orientation
                of the dome. By default the 'top' of the dome is deemed to
                be in the +y direction, and the 'front' at the -z direction.
                You can use this parameter to rotate the sky if you want.
            @param groupName
                The name of the resource group to which to assign the plane mesh.

</member>
        <member name="M:Ogre.SceneManager.setSkyDome(System.Boolean,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single,System.Boolean,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.">
Enables / disables a 'sky dome' i.e. an illusion of a curved sky.
            @remarks
                A sky dome is actually formed by 5 sides of a cube, but with
                texture coordinates generated such that the surface appears
                curved like a dome. Sky domes are appropriate where you need a
                realistic looking sky where the scene is not going to be
                'fogged', and there is always a 'floor' of some sort to prevent
                the viewer looking below the horizon (the distortion effect below
                the horizon can be pretty horrible, and there is never anyhting
                directly below the viewer). If you need a complete wrap-around
                background, use the setSkyBox method instead. You can actually
                combine a sky box and a sky dome if you want, to give a positional
                backdrop with an overlayed curved cloud layer.
            @par
                Sky domes work well with 2D repeating textures like clouds. You
                can change the apparant 'curvature' of the sky depending on how
                your scene is viewed - lower curvatures are better for 'open'
                scenes like landscapes, whilst higher curvatures are better for
                say FPS levels where you don't see a lot of the sky at once and
                the exaggerated curve looks good.
            @param
                enable True to enable the skydome, false to disable it
            @param
                materialName The name of the material the dome will use
            @param
                curvature The curvature of the dome. Good values are
                between 2 and 65. Higher values are more curved leading to
                a smoother effect, lower values are less curved meaning
                more distortion at the horizons but a better distance effect.
            @param
                tiling How many times to tile the texture(s) across the
                dome.
            @param
                distance Distance in world coorinates from the camera to
                each plane of the box the dome is rendered on. The default
                is normally OK.
            @param
                drawFirst If true, the dome is drawn before all other
                geometry in the scene, without updating the depth buffer.
                This is the safest rendering method since all other objects
                will always appear in front of the sky. However this is not
                the most efficient way if most of the sky is often occluded
                by other objects. If this is the case, you can set this
                parameter to false meaning it draws <em>after</em> all other
                geometry which can be an optimisation - however you must
                ensure that the distance value is large enough that no
                objects will 'poke through' the sky when it is rendered.
            @param
                orientation Optional parameter to specify the orientation
                of the dome. By default the 'top' of the dome is deemed to
                be in the +y direction, and the 'front' at the -z direction.
                You can use this parameter to rotate the sky if you want.
            @param groupName
                The name of the resource group to which to assign the plane mesh.

</member>
        <member name="M:Ogre.SceneManager.getSkyBoxGenParameters">
Get the parameters used to generate the current SkyBox, if any 
</member>
        <member name="M:Ogre.SceneManager.getSkyBoxNode">
Get the skybox node, if enabled. 
</member>
        <member name="M:Ogre.SceneManager.isSkyBoxEnabled">
Return whether a skybox is enabled 
</member>
        <member name="M:Ogre.SceneManager._setSkyBox(System.Boolean,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Byte,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifi">
Enables / disables a 'sky box' i.e. a 6-sided box at constant
            distance from the camera representing the sky.
            @remarks
                You could create a sky box yourself using the standard mesh and
                entity methods, but this creates a plane which the camera can
                never get closer or further away from - it moves with the camera.
                (NB you could create this effect by creating a world box which
                was attached to the same SceneNode as the Camera too, but this
                would only apply to a single camera whereas this skybox applies
                to any camera using this scene manager).
            @par
                The material you use for the skybox can either contain layers
                which are single textures, or they can be cubic textures, i.e.
                made up of 6 images, one for each plane of the cube. See the
                TextureUnitState class for more information.
            @param
                enable True to enable the skybox, false to disable it
            @param
                materialName The name of the material the box will use
            @param
                distance Distance in world coorinates from the camera to
                each plane of the box. The default is normally OK.
            @param
                renderQueue The render queue to use when rendering this object
            @param
                orientation Optional parameter to specify the orientation
                of the box. By default the 'top' of the box is deemed to be
                in the +y direction, and the 'front' at the -z direction.
                You can use this parameter to rotate the sky if you want.
            @param groupName
                The name of the resource group to which to assign the plane mesh.

</member>
        <member name="M:Ogre.SceneManager.setSkyBox(System.Boolean,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Boolean,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspeci">
Enables / disables a 'sky box' i.e. a 6-sided box at constant
            distance from the camera representing the sky.
            @remarks
                You could create a sky box yourself using the standard mesh and
                entity methods, but this creates a plane which the camera can
                never get closer or further away from - it moves with the camera.
                (NB you could create this effect by creating a world box which
                was attached to the same SceneNode as the Camera too, but this
                would only apply to a single camera whereas this skybox applies
                to any camera using this scene manager).
            @par
                The material you use for the skybox can either contain layers
                which are single textures, or they can be cubic textures, i.e.
                made up of 6 images, one for each plane of the cube. See the
                TextureUnitState class for more information.
            @param
                enable True to enable the skybox, false to disable it
            @param
                materialName The name of the material the box will use
            @param
                distance Distance in world coorinates from the camera to
                each plane of the box. The default is normally OK.
            @param
                drawFirst If true, the box is drawn before all other
                geometry in the scene, without updating the depth buffer.
                This is the safest rendering method since all other objects
                will always appear in front of the sky. However this is not
                the most efficient way if most of the sky is often occluded
                by other objects. If this is the case, you can set this
                parameter to false meaning it draws <em>after</em> all other
                geometry which can be an optimisation - however you must
                ensure that the distance value is large enough that no
                objects will 'poke through' the sky box when it is rendered.
            @param
                orientation Optional parameter to specify the orientation
                of the box. By default the 'top' of the box is deemed to be
                in the +y direction, and the 'front' at the -z direction.
                You can use this parameter to rotate the sky if you want.
            @param groupName
                The name of the resource group to which to assign the plane mesh.

</member>
        <member name="M:Ogre.SceneManager.getSkyPlaneGenParameters">
Get the parameters used to construct the SkyPlane, if any *
</member>
        <member name="M:Ogre.SceneManager.getSkyPlaneNode">
Get the sky plane node, if enabled. 
</member>
        <member name="M:Ogre.SceneManager.isSkyPlaneEnabled">
Return whether a key plane is enabled 
</member>
        <member name="M:Ogre.SceneManager._setSkyPlane(System.Boolean,Ogre.Plane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Byte,System.Single,System.Int32,System.Int32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SB">
Enables / disables a 'sky plane' i.e. a plane at constant
            distance from the camera representing the sky.
            @remarks
                You can create sky planes yourself using the standard mesh and
                entity methods, but this creates a plane which the camera can
                never get closer or further away from - it moves with the camera.
                (NB you could create this effect by creating a world plane which
                was attached to the same SceneNode as the Camera too, but this
                would only apply to a single camera whereas this plane applies to
                any camera using this scene manager).
            @note
                To apply scaling, scrolls etc to the sky texture(s) you
                should use the TextureUnitState class methods.
            @param
                enable True to enable the plane, false to disable it
            @param
                plane Details of the plane, i.e. it's normal and it's
                distance from the camera.
            @param
                materialName The name of the material the plane will use
            @param
                scale The scaling applied to the sky plane - higher values
                mean a bigger sky plane - you may want to tweak this
                depending on the size of plane.d and the other
                characteristics of your scene
            @param
                tiling How many times to tile the texture across the sky.
                Applies to all texture layers. If you need finer control use
                the TextureUnitState texture coordinate transformation methods.
            @param
                renderQueue The render queue to use when rendering this object
			@param
				bow If zero, the plane will be completely flat (like previous
				versions.  If above zero, the plane will be curved, allowing
				the sky to appear below camera level.  Curved sky planes are 
				simular to skydomes, but are more compatable with fog.
            @param xsegments, ysegments
                Determines the number of segments the plane will have to it. This
                is most important when you are bowing the plane, but may also be useful
                if you need tesselation on the plane to perform per-vertex effects.
            @param groupName
                The name of the resource group to which to assign the plane mesh.

</member>
        <member name="M:Ogre.SceneManager.setSkyPlane(System.Boolean,Ogre.Plane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Boolean,System.Single,System.Int32,System.Int32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.">
Enables / disables a 'sky plane' i.e. a plane at constant
            distance from the camera representing the sky.
            @remarks
                You can create sky planes yourself using the standard mesh and
                entity methods, but this creates a plane which the camera can
                never get closer or further away from - it moves with the camera.
                (NB you could create this effect by creating a world plane which
                was attached to the same SceneNode as the Camera too, but this
                would only apply to a single camera whereas this plane applies to
                any camera using this scene manager).
            @note
                To apply scaling, scrolls etc to the sky texture(s) you
                should use the TextureUnitState class methods.
            @param
                enable True to enable the plane, false to disable it
            @param
                plane Details of the plane, i.e. it's normal and it's
                distance from the camera.
            @param
                materialName The name of the material the plane will use
            @param
                scale The scaling applied to the sky plane - higher values
                mean a bigger sky plane - you may want to tweak this
                depending on the size of plane.d and the other
                characteristics of your scene
            @param
                tiling How many times to tile the texture across the sky.
                Applies to all texture layers. If you need finer control use
                the TextureUnitState texture coordinate transformation methods.
            @param
                drawFirst If true, the plane is drawn before all other
                geometry in the scene, without updating the depth buffer.
                This is the safest rendering method since all other objects
                will always appear in front of the sky. However this is not
                the most efficient way if most of the sky is often occluded
                by other objects. If this is the case, you can set this
                parameter to false meaning it draws <em>after</em> all other
                geometry which can be an optimisation - however you must
                ensure that the plane.d value is large enough that no objects
                will 'poke through' the sky plane when it is rendered.
			@param
				bow If zero, the plane will be completely flat (like previous
				versions.  If above zero, the plane will be curved, allowing
				the sky to appear below camera level.  Curved sky planes are 
				simular to skydomes, but are more compatable with fog.
            @param xsegments, ysegments
                Determines the number of segments the plane will have to it. This
                is most important when you are bowing the plane, but may also be useful
                if you need tesselation on the plane to perform per-vertex effects.
            @param groupName
                The name of the resource group to which to assign the plane mesh.

</member>
        <member name="M:Ogre.SceneManager._setDestinationRenderSystem(Ogre.RenderSystem*)">
Notifies the scene manager of its destination render system
            @remarks
                Called automatically by RenderSystem::addSceneManager
                this method simply notifies the manager of the render
                system to which its output must be directed.
            @param
                sys Pointer to the RenderSystem subclass to be used as a render target.

</member>
        <member name="M:Ogre.SceneManager._queueSkiesForRendering(Ogre.Camera*)">
Internal method for queueing the sky objects with the params as 
            previously set through setSkyBox, setSkyPlane and setSkyDome.

</member>
        <member name="M:Ogre.SceneManager._renderScene(Ogre.Camera*,Ogre.Viewport*,System.Boolean)">
Prompts the class to send its contents to the renderer.
            @remarks
                This method prompts the scene manager to send the
                contents of the scene it manages to the rendering
                pipeline, possibly preceded by some sorting, culling
                or other scene management tasks. Note that this method is not normally called
                directly by the user application; it is called automatically
                by the Ogre rendering loop.
            @param camera Pointer to a camera from whose viewpoint the scene is to
                be rendered.
            @param vp The target viewport
            @param includeOverlays Whether or not overlay objects should be rendered

</member>
        <member name="M:Ogre.SceneManager._renderVisibleObjects">
Sends visible objects found in _findVisibleObjects to the rendering engine.

</member>
        <member name="M:Ogre.SceneManager._applySceneAnimations">
Internal method for applying animations to scene nodes.
        @remarks
            Uses the internally stored AnimationState objects to apply animation to SceneNodes.

</member>
        <member name="M:Ogre.SceneManager._findVisibleObjects(Ogre.Camera*,Ogre.VisibleObjectsBoundsInfo*,System.Boolean)">
Internal method which parses the scene to find visible objects to render.
            @remarks
                If you're implementing a custom scene manager, this is the most important method to
                override since it's here you can apply your custom world partitioning scheme. Once you
                have added the appropriate objects to the render queue, you can let the default
                SceneManager objects _renderVisibleObjects handle the actual rendering of the objects
                you pick.
            @par
                Any visible objects will be added to a rendering queue, which is indexed by material in order
                to ensure objects with the same material are rendered together to minimise render state changes.

</member>
        <member name="M:Ogre.SceneManager._updateSceneGraph(Ogre.Camera*)">
Internal method for updating the scene graph ie the tree of SceneNode instances managed by this class.
            @remarks
                This must be done before issuing objects to the rendering pipeline, since derived transformations from
                parent nodes are not updated until required. This SceneManager is a basic implementation which simply
                updates all nodes from the root. This ensures the scene is up to date but requires all the nodes
                to be updated even if they are not visible. Subclasses could trim this such that only potentially visible
                nodes are updated.

</member>
        <member name="M:Ogre.SceneManager.getOptionKeys(std.vector&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method for getting all the implementation-specific options of the scene manager.
            @param
                refKeys A reference to a list that will be filled with all the available options.
            @return
                On success, true is returned. On failiure, false is returned.

</member>
        <member name="M:Ogre.SceneManager.getOptionValues(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method for getting all possible values for a specific option. When this list is too large
            (i.e. the option expects, for example, a float), the return value will be true, but the
            list will contain just one element whose size will be set to 0.
            Otherwise, the list will be filled with all the possible values the option can
            accept.
            @param
                strKey The name of the option to get the values for.
            @param
                refValueList A reference to a list that will be filled with the available values.
            @return
                On success (the option exists), true is returned.
            @par
                On failure, false is returned.

</member>
        <member name="M:Ogre.SceneManager.hasOption(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method for verifying wether the scene manager has an implementation-specific
            option.
            @param
                strKey The name of the option to check for.
            @return
                If the scene manager contains the given option, true is returned.
            @remarks
                If it does not, false is returned.

</member>
        <member name="M:Ogre.SceneManager.getOption(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void*)">
Method for getting the value of an implementation-specific Scene Manager option.
            @param
                strKey The name of the option
            @param
                pDestValue A pointer to a memory location where the value will
                be copied. Currently, the memory will be allocated by the
                scene manager, but this may change
            @return
                On success, true is returned and pDestValue points to the value of the given
                option.
            @par
                On failiure, false is returned and pDestValue is set to NULL.

</member>
        <member name="M:Ogre.SceneManager.setOption(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void!System.Runtime.CompilerServices.IsConst*)">
Method for setting a specific option of the Scene Manager. These options are usually
            specific for a certain implemntation of the Scene Manager class, and may (and probably
            will) not exist across different implementations.
            @param
                strKey The name of the option to set
            @param
                pValue A pointer to the value - the size should be calculated by the scene manager
                based on the key
            @return
                On success, true is returned.
            @par
                On failiure, false is returned.

</member>
        <member name="M:Ogre.SceneManager.getSuggestedViewpoint(System.Boolean)">
Asks the SceneManager to provide a suggested viewpoint from which the scene should be viewed.
            @remarks
                Typically this method returns the origin unless a) world geometry has been loaded using
                SceneManager::setWorldGeometry and b) that world geometry has suggested 'start' points.
                If there is more than one viewpoint which the scene manager can suggest, it will always suggest
                the first one unless the random parameter is true.
            @param
                random If true, and there is more than one possible suggestion, a random one will be used. If false
                the same one will always be suggested.
            @return
                On success, true is returned.
            @par
                On failiure, false is returned.

</member>
        <member name="M:Ogre.SceneManager.estimateWorldGeometry(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Estimate the number of loading stages required to load the named
            world geometry. 
        @remarks
			Operates just like the version of this method which takes a
			filename, but operates on a stream instead. Note that since the
			stream is updated, you'll need to reset the stream or reopen it
			when it comes to loading it for real.
		@param stream Data stream containing data to load
		@param typeName String identifying the type of world geometry
			contained in the stream - not required if this manager only 
			supports one type of world geometry.

</member>
        <member name="M:Ogre.SceneManager.estimateWorldGeometry(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Estimate the number of loading stages required to load the named
            world geometry. 
        @remarks
            This method should be overridden by SceneManagers that provide
            custom world geometry that can take some time to load. They should
            return from this method a count of the number of stages of progress
            they can report on whilst loading. During real loading (setWorldGeometry),
            they should call ResourceGroupManager::_notifyWorldGeometryProgress exactly
            that number of times when loading the geometry for real.
        @note 
            The default is to return 0, ie to not report progress. 

</member>
        <member name="M:Ogre.SceneManager.setWorldGeometry(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the source of the 'world' geometry, i.e. the large, mainly 
			static geometry making up the world e.g. rooms, landscape etc.
            @remarks
                Depending on the type of SceneManager (subclasses will be 
				specialised for particular world geometry types) you have 
				requested via the Root or SceneManagerEnumerator classes, you 
				can pass a stream to this method and it will attempt to load 
				the world-level geometry for use. If the manager can only 
				handle one input format the typeName parameter is not required.
				The stream passed will be read (and it's state updated). 
			@param stream Data stream containing data to load
			@param typeName String identifying the type of world geometry
				contained in the stream - not required if this manager only 
				supports one type of world geometry.

</member>
        <member name="M:Ogre.SceneManager.setWorldGeometry(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the source of the 'world' geometry, i.e. the large, mainly static geometry
            making up the world e.g. rooms, landscape etc.
            @remarks
                Depending on the type of SceneManager (subclasses will be specialised
                for particular world geometry types) you have requested via the Root or
                SceneManagerEnumerator classes, you can pass a filename to this method and it
                will attempt to load the world-level geometry for use. If you try to load
                an inappropriate type of world data an exception will be thrown. The default
                SceneManager cannot handle any sort of world geometry and so will always
                throw an exception. However subclasses like BspSceneManager can load
                particular types of world geometry e.g. "q3dm1.bsp".

</member>
        <member name="M:Ogre.SceneManager.prepareWorldGeometry(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the source of the 'world' geometry, i.e. the large, mainly 
			static geometry making up the world e.g. rooms, landscape etc.
            This function can be called before setWorldGeometry in a background thread, do to
            some slow tasks (e.g. IO) that do not involve the backend render system.
            @remarks
                Depending on the type of SceneManager (subclasses will be 
				specialised for particular world geometry types) you have 
				requested via the Root or SceneManagerEnumerator classes, you 
				can pass a stream to this method and it will attempt to load 
				the world-level geometry for use. If the manager can only 
				handle one input format the typeName parameter is not required.
				The stream passed will be read (and it's state updated). 
			@param stream Data stream containing data to load
			@param typeName String identifying the type of world geometry
				contained in the stream - not required if this manager only 
				supports one type of world geometry.

</member>
        <member name="M:Ogre.SceneManager.prepareWorldGeometry(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the source of the 'world' geometry, i.e. the large, mainly static geometry
            making up the world e.g. rooms, landscape etc.
            This function can be called before setWorldGeometry in a background thread, do to
            some slow tasks (e.g. IO) that do not involve the backend render system.
            @remarks
                Depending on the type of SceneManager (subclasses will be specialised
                for particular world geometry types) you have requested via the Root or
                SceneManagerEnumerator classes, you can pass a filename to this method and it
                will attempt to load the world-level geometry for use. If you try to load
                an inappropriate type of world data an exception will be thrown. The default
                SceneManager cannot handle any sort of world geometry and so will always
                throw an exception. However subclasses like BspSceneManager can load
                particular types of world geometry e.g. "q3dm1.bsp".


</member>
        <member name="M:Ogre.SceneManager.getAmbientLight">
Returns the ambient light level to be used for the scene.

</member>
        <member name="M:Ogre.SceneManager.setAmbientLight(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the ambient light level to be used for the scene.
            @remarks
                This sets the colour and intensity of the ambient light in the scene, i.e. the
                light which is 'sourceless' and illuminates all objects equally.
                The colour of an object is affected by a combination of the light in the scene,
                and the amount of light that object reflects (in this case based on the Material::ambient
                property).
            @remarks
                By default the ambient light in the scene is ColourValue::Black, i.e. no ambient light. This
                means that any objects rendered with a Material which has lighting enabled (see Material::setLightingEnabled)
                will not be visible unless you have some dynamic lights in your scene.

</member>
        <member name="M:Ogre.SceneManager.clearScene">
Empties the entire scene, inluding all SceneNodes, Entities, Lights, 
            BillboardSets etc. Cameras are not deleted at this stage since
            they are still referenced by viewports, which are not destroyed during
            this process.

</member>
        <member name="M:Ogre.SceneManager.hasParticleSystem(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether a particle system with the given name exists.

</member>
        <member name="M:Ogre.SceneManager.getParticleSystem(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves a pointer to the named ParticleSystem. 
		@note Throws an exception if the named instance does not exist

</member>
        <member name="M:Ogre.SceneManager.createParticleSystem(System.UInt32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a blank particle system with a generated name.
        @remarks
            This method creates a new, blank ParticleSystem instance and returns a pointer to it.
            The caller should not delete this object, it will be freed at system shutdown, or can
            be released earlier using the destroyParticleSystem method.
        @par
            The instance returned from this method won't actually do anything because on creation a
            particle system has no emitters. The caller should manipulate the instance through it's 
            ParticleSystem methods to actually create a real particle effect. 
        @par
            Creating a particle system does not make it a part of the scene. As with other MovableObject
            subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode. 
        @param 
            quota The maximum number of particles to allow in this system. 
        @param
            resourceGroup The resource group which will be used to load dependent resources

</member>
        <member name="M:Ogre.SceneManager.createParticleSystem(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a blank particle system.
        @remarks
            This method creates a new, blank ParticleSystem instance and returns a pointer to it.
            The caller should not delete this object, it will be freed at system shutdown, or can
            be released earlier using the destroyParticleSystem method.
        @par
            The instance returned from this method won't actually do anything because on creation a
            particle system has no emitters. The caller should manipulate the instance through it's 
            ParticleSystem methods to actually create a real particle effect. 
        @par
            Creating a particle system does not make it a part of the scene. As with other MovableObject
            subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode. 
        @param
            name The name to give the ParticleSystem.
        @param 
            quota The maximum number of particles to allow in this system. 
        @param
            resourceGroup The resource group which will be used to load dependent resources

</member>
        <member name="M:Ogre.SceneManager.createParticleSystem(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a particle system based on a template.
        @remarks
            This method creates a new ParticleSystem instance based on the named template
			(defined through ParticleSystemManager::createTemplate) and returns a 
            pointer to the caller. The caller should not delete this object, it will be freed at system shutdown, 
            or can be released earlier using the destroyParticleSystem method.
        @par
            Each system created from a template takes the template's settings at the time of creation, 
            but is completely separate from the template from there on. 
        @par
            Creating a particle system does not make it a part of the scene. As with other MovableObject
            subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode. 
        @par
            This is probably the more useful particle system creation method since it does not require manual
            setup of the system. Note that the initial quota is based on the template but may be changed later.
        @param 
            name The name to give the new particle system instance.
        @param 
            templateName The name of the template to base the new instance on.

</member>
        <member name="M:Ogre.SceneManager.hasRibbonTrail(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether a ribbon trail with the given name exists.

</member>
        <member name="M:Ogre.SceneManager.getRibbonTrail(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves a pointer to the named RibbonTrail. 
		@note Throws an exception if the named instance does not exist

</member>
        <member name="M:Ogre.SceneManager.createRibbonTrail">
Create a RibbonTrail, an object which you can use to render
		a linked chain of billboards which follows one or more nodes, generating the name.

</member>
        <member name="M:Ogre.SceneManager.createRibbonTrail(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a RibbonTrail, an object which you can use to render
            a linked chain of billboards which follows one or more nodes.
        @param
            name The name to be given to the object (must be unique).

</member>
        <member name="M:Ogre.SceneManager.hasBillboardChain(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether a billboard chain with the given name exists.

</member>
        <member name="M:Ogre.SceneManager.getBillboardChain(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves a pointer to the named BillboardChain. 
		@note Throws an exception if the named instance does not exist

</member>
        <member name="M:Ogre.SceneManager.createBillboardChain">
Create a BillboardChain, an object which you can use to render
		a linked chain of billboards, with a generated name.

</member>
        <member name="M:Ogre.SceneManager.createBillboardChain(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a BillboardChain, an object which you can use to render
            a linked chain of billboards.
        @param
            name The name to be given to the object (must be unique).

</member>
        <member name="M:Ogre.SceneManager.hasManualObject(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether a manual object with the given name exists.

</member>
        <member name="M:Ogre.SceneManager.getManualObject(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves a pointer to the named ManualObject. 
		@note Throws an exception if the named instance does not exist

</member>
        <member name="M:Ogre.SceneManager.createManualObject">
Create a ManualObject, an object which you populate with geometry
		manually through a GL immediate-mode style interface, generating the name.

</member>
        <member name="M:Ogre.SceneManager.createManualObject(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a ManualObject, an object which you populate with geometry
			manually through a GL immediate-mode style interface.
        @param
            name The name to be given to the object (must be unique).

</member>
        <member name="M:Ogre.SceneManager.hasEntity(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether an entity with the given name exists.

</member>
        <member name="M:Ogre.SceneManager.getEntity(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves a pointer to the named Entity. 
		@note Throws an exception if the named instance does not exist

</member>
        <member name="M:Ogre.SceneManager.createEntity(Ogre.SceneManager.PrefabType)">
Create an Entity (instance of a discrete mesh) from a range of prefab shapes, generating the name.
            @param ptype The prefab type.

</member>
        <member name="M:Ogre.SceneManager.createEntity(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.SceneManager.PrefabType)">
Create an Entity (instance of a discrete mesh) from a range of prefab shapes.
            @param
                entityName The name to be given to the entity (must be unique).
            @param
                ptype The prefab type.

</member>
        <member name="T:Ogre.SceneManager.PrefabType">
Prefab shapes available without loading a model.
            @note
                Minimal implementation at present.
            @todo
                Add more prefabs (teapots, teapots!!!)

</member>
        <member name="M:Ogre.SceneManager.createEntity(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create an Entity (instance of a discrete mesh) with an autogenerated name.
            @param
                meshName The name of the Mesh it is to be based on (e.g. 'knot.oof'). The
                mesh will be loaded if it is not already.

</member>
        <member name="M:Ogre.SceneManager.createEntity(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.C">
Create an Entity (instance of a discrete mesh).
            @param
                entityName The name to be given to the entity (must be unique).
            @param
                meshName The name of the Mesh it is to be based on (e.g. 'knot.oof'). The
                mesh will be loaded if it is not already.

</member>
        <member name="M:Ogre.SceneManager.hasSceneNode(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether a scene node with the given name exists.

</member>
        <member name="M:Ogre.SceneManager.getSceneNode(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves a named SceneNode from the scene graph.
        @remarks
            If you chose to name a SceneNode as you created it, or if you
            happened to make a note of the generated name, you can look it
            up wherever it is in the scene graph using this method.
			@note Throws an exception if the named instance does not exist

</member>
        <member name="M:Ogre.SceneManager.getRootSceneNode">
Gets the SceneNode at the root of the scene hierarchy.
            @remarks
                The entire scene is held as a hierarchy of nodes, which
                allows things like relative transforms, general changes in
                rendering state etc (See the SceneNode class for more info).
                In this basic SceneManager class, the application using
                Ogre is free to structure this hierarchy however it likes,
                since it has no real significance apart from making transforms
                relative to each node (more specialised subclasses will
                provide utility methods for building specific node structures
                e.g. loading a BSP tree).
            @par
                However, in all cases there is only ever one root node of
                the hierarchy, and this method returns a pointer to it.

</member>
        <member name="M:Ogre.SceneManager.destroySceneNode(Ogre.SceneNode*)">
Destroys a SceneNode.
        @remarks
            This allows you to physically delete an individual SceneNode if you want to.
            Note that this is not normally recommended, it's better to allow SceneManager
            to delete the nodes when the scene is cleared.

</member>
        <member name="M:Ogre.SceneManager.destroySceneNode(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroys a SceneNode with a given name.
        @remarks
            This allows you to physically delete an individual SceneNode if you want to.
            Note that this is not normally recommended, it's better to allow SceneManager
            to delete the nodes when the scene is cleared.

</member>
        <member name="M:Ogre.SceneManager.createSceneNode(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates an instance of a SceneNode with a given name.
            @remarks
                Note that this does not add the SceneNode to the scene hierarchy.
                This method is for convenience, since it allows an instance to
                be created for which the SceneManager is responsible for
                allocating and releasing memory, which is convenient in complex
                scenes.
            @par
                To include the returned SceneNode in the scene, use the addChild
                method of the SceneNode which is to be it's parent.
            @par
                Note that this method takes a name parameter, which makes the node easier to
                retrieve directly again later.

</member>
        <member name="M:Ogre.SceneManager.createSceneNode">
Creates an instance of a SceneNode.
            @remarks
                Note that this does not add the SceneNode to the scene hierarchy.
                This method is for convenience, since it allows an instance to
                be created for which the SceneManager is responsible for
                allocating and releasing memory, which is convenient in complex
                scenes.
            @par
                To include the returned SceneNode in the scene, use the addChild
                method of the SceneNode which is to be it's parent.
            @par
                Note that this method takes no parameters, and the node created is unnamed (it is
                actually given a generated name, which you can retrieve if you want).
                If you wish to create a node with a specific name, call the alternative method
                which takes a name parameter.

</member>
        <member name="M:Ogre.SceneManager._populateLightList(Ogre.SceneNode!System.Runtime.CompilerServices.IsConst*,System.Single,Ogre.HashedVector&lt;Ogre.Light**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Populates a light list with an ordered set of the lights which are closest
        to the position of the SceneNode given.
        @remarks
            Note that since directional lights have no position, they are always considered
            closer than any point lights and as such will always take precedence. 
			This overloaded version will take the SceneNode's position and use the second method
			to populate the list.
        @par
            Subclasses of the default SceneManager may wish to take into account other issues
            such as possible visibility of the light if that information is included in their
            data structures. This basic scenemanager simply orders by distance, eliminating 
            those lights which are out of range or could not be affecting the frustum (i.e.
            only the lights returned by SceneManager::_getLightsAffectingFrustum are take into
            account). 
		@par   
			Also note that subclasses of the SceneNode might be used here to provide cached
			scene related data, accelerating the list population (for example light lists for
			SceneNodes could be cached inside subclassed SceneNode objects).
        @par
            The number of items in the list may exceed the maximum number of lights supported
            by the renderer, but the extraneous ones will never be used. In fact the limit will
            be imposed by Pass::getMaxSimultaneousLights.
        @param sn The SceneNode for which to evaluate the list of lights
        @param radius The bounding radius to test
        @param destList List to be populated with ordered set of lights; will be cleared by 
            this method before population.
		@param lightMask The mask with which to include / exclude lights

</member>
        <member name="M:Ogre.SceneManager._populateLightList(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,Ogre.HashedVector&lt;Ogre.Light**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Populate a light list with an ordered set of the lights which are closest
        to the position specified.
        @remarks
            Note that since directional lights have no position, they are always considered
            closer than any point lights and as such will always take precedence. 
        @par
            Subclasses of the default SceneManager may wish to take into account other issues
            such as possible visibility of the light if that information is included in their
            data structures. This basic scenemanager simply orders by distance, eliminating 
            those lights which are out of range or could not be affecting the frustum (i.e.
            only the lights returned by SceneManager::_getLightsAffectingFrustum are take into
            account).
        @par
            The number of items in the list max exceed the maximum number of lights supported
            by the renderer, but the extraneous ones will never be used. In fact the limit will
            be imposed by Pass::getMaxSimultaneousLights.
        @param position The position at which to evaluate the list of lights
        @param radius The bounding radius to test
        @param destList List to be populated with ordered set of lights; will be cleared by 
            this method before population.
		@param lightMask The mask with which to include / exclude lights

</member>
        <member name="M:Ogre.SceneManager._getLightsAffectingFrustum">
Get the list of lights which could be affecting the frustum.
        @remarks
            Note that default implementation of this method returns a cached light list,
            which is populated when rendering the scene. So by default the list of lights 
			is only available during scene rendering.

</member>
        <member name="M:Ogre.SceneManager._getLightsDirtyCounter">
Advance method to gets the lights dirty counter.
        @remarks
            Scene manager tracking lights that affecting the frustum, if changes
            detected (the changes includes light list itself and the light's position
            and attenuation range), then increase the lights dirty counter.
        @par
            When implementing customise lights finding algorithm relied on either
            SceneManager::_getLightsAffectingFrustum or SceneManager::_populateLightList,
            might check this value for sure that the light list are really need to
            re-populate, otherwise, returns cached light list (if exists) for better
            performance.

</member>
        <member name="M:Ogre.SceneManager._notifyLightsDirty">
Advance method to increase the lights dirty counter due lights changed.
        @remarks
            Scene manager tracking lights that affecting the frustum, if changes
            detected (the changes includes light list itself and the light's position
            and attenuation range), then increase the lights dirty counter.
        @par
            For some reason, you can call this method to force whole scene objects
            re-populate their light list. But near in mind, call to this method
            will harm performance, so should avoid if possible.

</member>
        <member name="M:Ogre.SceneManager.destroyAllLights">
Removes and destroys all lights in the scene.

</member>
        <member name="M:Ogre.SceneManager.destroyLight(Ogre.Light*)">
Removes the light from the scene and destroys it based on a pointer.
            @remarks
                Any pointers held to this light after calling this method will be invalid.

</member>
        <member name="M:Ogre.SceneManager.destroyLight(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Removes the named light from the scene and destroys it.
            @remarks
                Any pointers held to this light after calling this method will be invalid.

</member>
        <member name="M:Ogre.SceneManager.getLightScissorRect(Ogre.Light*,Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Retrieve a scissor rectangle for a given light and camera. 

</member>
        <member name="M:Ogre.SceneManager.getLightClippingPlanes(Ogre.Light*)">
Retrieve a set of clipping planes for a given light. 

</member>
        <member name="M:Ogre.SceneManager.hasLight(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether a light with the given name exists.

</member>
        <member name="M:Ogre.SceneManager.getLight(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a pointer to the named Light which has previously been added to the scene.
		@note Throws an exception if the named instance does not exist

</member>
        <member name="M:Ogre.SceneManager.createLight">
Creates a light with a generated name. 
</member>
        <member name="M:Ogre.SceneManager.createLight(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a light for use in the scene.
            @remarks
                Lights can either be in a fixed position and independent of the
                scene graph, or they can be attached to SceneNodes so they derive
                their position from the parent node. Either way, they are created
                using this method so that the SceneManager manages their
                existence.
            @param
                name The name of the new light, to identify it later.

</member>
        <member name="M:Ogre.SceneManager.destroyAllCameras">
Removes (and destroys) all cameras from the scene.
            @remarks
                Some cameras are internal created to dealing with texture shadow,
                their aren't supposed to destroy outside. So, while you are using
                texture shadow, don't call this method, or you can set the shadow
                technique other than texture-based, which will destroy all internal
                created shadow cameras and textures.

</member>
        <member name="M:Ogre.SceneManager.destroyCamera(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Removes a camera from the scene.
            @remarks
                This method removes an camera from the scene based on the
                camera's name rather than a pointer.

</member>
        <member name="M:Ogre.SceneManager.destroyCamera(Ogre.Camera*)">
Removes a camera from the scene.
            @remarks
                This method removes a previously added camera from the scene.
                The camera is deleted so the caller must ensure no references
                to it's previous instance (e.g. in a SceneNode) are used.
            @param
                cam Pointer to the camera to remove

</member>
        <member name="M:Ogre.SceneManager.hasCamera(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether a camera with the given name exists.

</member>
        <member name="M:Ogre.SceneManager.getCamera(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves a pointer to the named camera.
		@note Throws an exception if the named instance does not exist

</member>
        <member name="M:Ogre.SceneManager.createCamera(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a camera to be managed by this scene manager.
            @remarks
                This camera must be added to the scene at a later time using
                the attachObject method of the SceneNode class.
            @param
                name Name to give the new camera.

</member>
        <member name="M:Ogre.SceneManager.getTypeName">
Retrieve the type name of this scene manager.
		@remarks
			This method has to be implemented by subclasses. It should
			return the type name of this SceneManager which agrees with 
			the type name of the SceneManagerFactory which created it.

</member>
        <member name="M:Ogre.SceneManager.getName">
Mutex to protect the scene graph from simultaneous access from
			multiple threads.
		@remarks
			If you are updating the scene in a separate thread from the rendering
			thread, then you should lock this mutex before making any changes to 
			the scene graph - that means creating, modifying or deleting a
			scene node, or attaching / detaching objects. It is <b>your</b> 
			responsibility to take out this lock, the detail methods on the nodes
			will not do it for you (for the reasons discussed below).
		@par
			Note that locking this mutex will prevent the scene being rendered until 
			it is unlocked again. Therefore you should do this sparingly. Try
			to create any objects you need separately and fully prepare them
			before doing all your scene graph work in one go, thus keeping this
			lock for the shortest time possible.
		@note
			A single global lock is used rather than a per-node lock since 
			it keeps the number of locks required during rendering down to a 
			minimum. Obtaining a lock, even if there is no contention, is not free
			so for performance it is good to do it as little as possible. 
			Since modifying the scene in a separate thread is a fairly
			rare occurrence (relative to rendering), it is better to keep the 
			locking required during rendering lower than to make update locks
			more granular.

Return the instance name of this SceneManager. 
</member>
        <member name="M:Ogre.SceneManager.Dispose">
Default destructor.

</member>
        <member name="M:Ogre.SceneManager.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor.

</member>
        <member name="D:Ogre.SceneManager.EntityMaterialLodChangedEventList">
List of entity material lod changed events
</member>
        <member name="D:Ogre.SceneManager.EntityMeshLodChangedEventList">
List of entity mesh lod changed events
</member>
        <member name="D:Ogre.SceneManager.MovableObjectLodChangedEventList">
List of movable object lod changed events
</member>
        <member name="D:Ogre.SceneManager.LodListenerSet">
Set of registered lod listeners
</member>
        <member name="F:Ogre.SceneManager.mGpuParamsDirty">
Gpu params that need rebinding (mask of GpuParamVariability)
</member>
        <member name="F:Ogre.SceneManager.mLastLightHash">
Last light sets
</member>
        <member name="F:Ogre.SceneManager.mCameraRelativeRendering">
Whether to use camera-relative rendering
</member>
        <member name="F:Ogre.SceneManager.mDefaultQueuedRenderableVisitor">
Storage for default renderable visitor
</member>
        <member name="F:Ogre.SceneManager.mActiveQueuedRenderableVisitor">
The active renderable visitor class - subclasses could override this
</member>
        <member name="M:Ogre.SceneManager.buildAndSetLightClip(Ogre.HashedVector&lt;Ogre.Light**&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Build a set of user clip planes from a single non-directional light
</member>
        <member name="M:Ogre.SceneManager.buildScissor(Ogre.Light!System.Runtime.CompilerServices.IsConst*,Ogre.Camera!System.Runtime.CompilerServices.IsConst*,Ogre.TRect&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update a scissor rectangle from a single light
</member>
        <member name="M:Ogre.SceneManager.buildAndSetScissor(Ogre.HashedVector&lt;Ogre.Light**&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Set up a scissor rectangle from a group of lights
</member>
        <member name="M:Ogre.SceneManager.updateRenderQueueGroupSplitOptions(Ogre.RenderQueueGroup*,System.Boolean,System.Boolean)">
Update the state of the render queue group splitting based on a shadow
		option change. 
</member>
        <member name="M:Ogre.SceneManager.updateRenderQueueSplitOptions">
Update the state of the global render queue splitting based on a shadow
		option change. 
</member>
        <member name="M:Ogre.SceneManager.renderTransparentShadowCasterObjects(Ogre.QueuedRenderableCollection!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.QueuedRenderableCollection.OrganisationMode,System.Boolean,System.Boolean,Ogre.HashedVector&lt;Ogre.Light**&gt;!System.Runtime.CompilerServices.IsConst*)">
Render those objects in the transparent pass list which have shadow casting forced on
		@remarks
			This function is intended to be used to render the shadows of transparent objects which have
			transparency_casts_shadows set to 'on' in their material

</member>
        <member name="M:Ogre.SceneManager.renderObjects(Ogre.QueuedRenderableCollection!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.QueuedRenderableCollection.OrganisationMode,System.Boolean,System.Boolean,Ogre.HashedVector&lt;Ogre.Light**&gt;!System.Runtime.CompilerServices.IsConst*)">
Render a set of objects, see renderSingleObject for param definitions 
</member>
        <member name="M:Ogre.SceneManager.renderAdditiveTextureShadowedQueueGroupObjects(Ogre.RenderQueueGroup*,Ogre.QueuedRenderableCollection.OrganisationMode)">
Render a group with additive texture shadows. 
</member>
        <member name="M:Ogre.SceneManager.renderModulativeTextureShadowedQueueGroupObjects(Ogre.RenderQueueGroup*,Ogre.QueuedRenderableCollection.OrganisationMode)">
Render a group with the added complexity of modulative texture shadows. 
</member>
        <member name="M:Ogre.SceneManager.renderTextureShadowReceiverQueueGroupObjects(Ogre.RenderQueueGroup*,Ogre.QueuedRenderableCollection.OrganisationMode)">
Render a group rendering only shadow receivers. 
</member>
        <member name="M:Ogre.SceneManager.renderTextureShadowCasterQueueGroupObjects(Ogre.RenderQueueGroup*,Ogre.QueuedRenderableCollection.OrganisationMode)">
Render a group rendering only shadow casters. 
</member>
        <member name="M:Ogre.SceneManager.renderModulativeStencilShadowedQueueGroupObjects(Ogre.RenderQueueGroup*,Ogre.QueuedRenderableCollection.OrganisationMode)">
Render a group with the added complexity of modulative stencil shadows. 
</member>
        <member name="M:Ogre.SceneManager.renderAdditiveStencilShadowedQueueGroupObjects(Ogre.RenderQueueGroup*,Ogre.QueuedRenderableCollection.OrganisationMode)">
Render a group with the added complexity of additive stencil shadows. 
</member>
        <member name="M:Ogre.SceneManager.renderBasicQueueGroupObjects(Ogre.RenderQueueGroup*,Ogre.QueuedRenderableCollection.OrganisationMode)">
Render a group in the ordinary way 
</member>
        <member name="M:Ogre.SceneManager.findShadowCastersForLight(Ogre.Light!System.Runtime.CompilerServices.IsConst*,Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Internal method for locating a list of shadow casters which 
            could be affecting the frustum for a given light. 
        @remarks
            Custom scene managers are encouraged to override this method to add optimisations, 
            and to add their own custom shadow casters (perhaps for world geometry)

</member>
        <member name="T:Ogre.SceneManager.ShadowCasterSceneQueryListener">
Inner class to use as callback for shadow caster scene query
</member>
        <member name="F:Ogre.SceneManager.mSuppressShadows">
Suppress shadows?
</member>
        <member name="F:Ogre.SceneManager.mSuppressRenderStateChanges">
Suppress render state changes?
</member>
        <member name="F:Ogre.SceneManager.mVisibilityMask">
Visibility mask used to show / hide objects
</member>
        <member name="M:Ogre.SceneManager.renderShadowVolumeObjects(Ogre.VectorIterator&lt;std.vector&lt;Ogre.ShadowRenderable**&gt;&gt;,Ogre.Pass*,Ogre.HashedVector&lt;Ogre.Light**&gt;!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Boolean,System.Boolean,System.Boolean)">
Render a set of shadow renderables. 
</member>
        <member name="M:Ogre.SceneManager.setShadowVolumeStencilState(System.Boolean,System.Boolean,System.Boolean)">
Internal utility method for setting stencil state for rendering shadow volumes. 
        @param secondpass Is this the second pass?
        @param zfail Should we be using the zfail method?
        @param twosided Should we use a 2-sided stencil?

</member>
        <member name="M:Ogre.SceneManager.renderShadowVolumesToStencil(Ogre.Light!System.Runtime.CompilerServices.IsConst*,Ogre.Camera!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Internal method for rendering all the objects for a given light into the 
            stencil buffer.
        @param light The light source
        @param cam The camera being viewed from
		@param calcScissor Whether the method should set up any scissor state, or
			false if that's already been done

</member>
        <member name="M:Ogre.SceneManager._resumeRendering(Ogre.SceneManager.RenderContext*)">
Resume rendering of the frame. This has to be called after a _pauseRendering call
		@param context The rendring context, as returned by the _pauseRendering call

</member>
        <member name="M:Ogre.SceneManager._pauseRendering">
Pause rendering of the frame. This has to be called when inside a renderScene call
			(Usually using a listener of some sort)

</member>
        <member name="M:Ogre.SceneManager.prepareShadowTextures(Ogre.Camera*,Ogre.Viewport*,Ogre.HashedVector&lt;Ogre.Light**&gt;!System.Runtime.CompilerServices.IsConst*)">
Method for preparing shadow textures ready for use in a regular render
Do not call manually unless before frame start or rendering is paused
If lightList is not supplied, will render all lights in frustum
</member>
        <member name="M:Ogre.SceneManager.destroyShadowTextures">
Internal method for destroying shadow textures (texture-based shadows)
</member>
        <member name="M:Ogre.SceneManager.ensureShadowTexturesCreated">
Internal method for creating shadow textures (texture-based shadows)
</member>
        <member name="M:Ogre.SceneManager.initShadowVolumeMaterials">
Internal method for setting up materials for shadows
</member>
        <member name="M:Ogre.SceneManager.findLightsAffectingFrustum(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Internal method for locating a list of lights which could be affecting the frustum. 
        @remarks
            Custom scene managers are encouraged to override this method to make use of their
            scene partitioning scheme to more efficiently locate lights, and to eliminate lights
            which may be occluded by word geometry.

</member>
        <member name="T:Ogre.SceneManager.lightsForShadowTextureLess">
Default sorting routine which sorts lights which cast shadows
			to the front of a list, sub-sorting by distance.
		@remarks
			Since shadow textures are generated from lights based on the
			frustum rather than individual objects, a shadow and camera-wise sort is
			required to pick the best lights near the start of the list. Up to 
			the number of shadow textures will be generated from this.

</member>
        <member name="F:Ogre.SceneManager.mDefaultShadowCameraSetup">
default shadow camera setup
</member>
        <member name="T:Ogre.SceneManager.LightClippingInfo">
Struct for cacheing light clipping information for re-use in a frame
</member>
        <member name="F:Ogre.SceneManager.mAutoParamDataSource">
Utility class for calculating automatic parameters for gpu programs
</member>
        <member name="M:Ogre.SceneManager.createAutoParamDataSource">
Internal method for creating the AutoParamDataSource instance. 
</member>
        <member name="M:Ogre.SceneManager.renderSingleObject(Ogre.Renderable*,Ogre.Pass!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean,Ogre.HashedVector&lt;Ogre.Light**&gt;!System.Runtime.CompilerServices.IsConst*)">
Internal utility method for rendering a single object. 
        @remarks
            Assumes that the pass has already been set up.
        @param rend The renderable to issue to the pipeline
        @param pass The pass which is being used
		@param lightScissoringClipping If true, passes that have the getLightScissorEnabled
			and/or getLightClipPlanesEnabled flags will cause calculation and setting of 
			scissor rectangle and user clip planes. 
        @param doLightIteration If true, this method will issue the renderable to
            the pipeline possibly multiple times, if the pass indicates it should be
            done once per light
        @param manualLightList Only applicable if doLightIteration is false, this
            method allows you to pass in a previously determined set of lights
            which will be used for a single render of this object.

</member>
        <member name="M:Ogre.SceneManager.prepareRenderQueue">
Internal method for preparing the render queue for use with each render. 
</member>
        <member name="M:Ogre.SceneManager.renderVisibleObjectsCustomSequence(Ogre.RenderQueueInvocationSequence*)">
Internal method for rendering all objects using a custom queue sequence. 
</member>
        <member name="M:Ogre.SceneManager.renderVisibleObjectsDefaultSequence">
Internal method for rendering all objects using the default queue sequence. 
</member>
        <member name="F:Ogre.SceneManager.mShowBoundingBoxes">
Flag that indicates if all of the scene node's bounding boxes should be shown as a wireframe. 
</member>
        <member name="M:Ogre.SceneManager.setViewport(Ogre.Viewport*)">
Internal method for setting the destination viewport for the next render. 
</member>
        <member name="M:Ogre.SceneManager.fireSceneManagerDestroyed">
Internal method for firing destruction event
</member>
        <member name="M:Ogre.SceneManager.firePostFindVisibleObjects(Ogre.Viewport*)">
Internal method for firing find visible objects event
</member>
        <member name="M:Ogre.SceneManager.firePreFindVisibleObjects(Ogre.Viewport*)">
Internal method for firing find visible objects event
</member>
        <member name="M:Ogre.SceneManager.fireShadowTexturesPreReceiver(Ogre.Light*,Ogre.Frustum*)">
Internal method for firing the pre receiver texture shadows event
</member>
        <member name="M:Ogre.SceneManager.fireShadowTexturesPreCaster(Ogre.Light*,Ogre.Camera*,System.UInt32)">
Internal method for firing the pre caster texture shadows event
</member>
        <member name="M:Ogre.SceneManager.fireShadowTexturesUpdated(System.UInt32)">
Internal method for firing the texture shadows updated event
</member>
        <member name="M:Ogre.SceneManager.fireRenderSingleObject(Ogre.Renderable*,Ogre.Pass!System.Runtime.CompilerServices.IsConst*,Ogre.AutoParamDataSource!System.Runtime.CompilerServices.IsConst*,Ogre.HashedVector&lt;Ogre.Light**&gt;!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Internal method for firing when rendering a single object.
</member>
        <member name="M:Ogre.SceneManager.fireRenderQueueEnded(System.Byte,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for firing the queue end event, returns true if queue is to be repeated
</member>
        <member name="M:Ogre.SceneManager.fireRenderQueueStarted(System.Byte,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for firing the queue start event, returns true if queue is to be skipped
</member>
        <member name="M:Ogre.SceneManager.firePostRenderQueues">
Internal method for firing the queue end event
</member>
        <member name="M:Ogre.SceneManager.firePreRenderQueues">
Internal method for firing the queue start event
</member>
        <member name="M:Ogre.SceneManager.resetViewProjMode(System.Boolean)">
Internal method used by _renderSingleObject to deal with renderables
            which override the camera's own view / projection matrices. 
</member>
        <member name="M:Ogre.SceneManager.useRenderableViewProjMode(Ogre.Renderable!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Internal method used by _renderSingleObject to deal with renderables
            which override the camera's own view / projection materices. 
</member>
        <member name="D:Ogre.SceneManager.AnimationList">
Storage of animations, lookup by name
</member>
        <member name="M:Ogre.SceneManager.validateRenderableForRendering(Ogre.Pass!System.Runtime.CompilerServices.IsConst*,Ogre.Renderable!System.Runtime.CompilerServices.IsConst*)">
Internal method to validate whether a Renderable should be allowed to render.
        @remarks
        Called just before a pass is about to be used for rendering a Renderable to
        allow the SceneManager to omit it if required. A return value of false
        skips it. 

</member>
        <member name="M:Ogre.SceneManager.validatePassForRendering(Ogre.Pass!System.Runtime.CompilerServices.IsConst*)">
Internal method to validate whether a Pass should be allowed to render.
        @remarks
            Called just before a pass is about to be used for rendering a group to
            allow the SceneManager to omit it if required. A return value of false
            skips this pass. 

</member>
        <member name="M:Ogre.SceneManager.deriveShadowReceiverPass(Ogre.Pass!System.Runtime.CompilerServices.IsConst*)">
Internal method for turning a regular pass into a shadow receiver pass.
        @remarks
        This is only used for texture shadows, basically we're trying to
        ensure that objects are rendered with a projective texture.
        This method will usually return a standard single-texture pass for
        all fixed function passes, but will merge in a vertex program
        for passes with vertex programs. 

</member>
        <member name="M:Ogre.SceneManager.deriveShadowCasterPass(Ogre.Pass!System.Runtime.CompilerServices.IsConst*)">
Internal method for turning a regular pass into a shadow caster pass.
        @remarks
            This is only used for texture shadows, basically we're trying to
            ensure that objects are rendered solid black.
            This method will usually return the standard solid black pass for
            all fixed function passes, but will merge in a vertex program
            and fudge the AutpoParamDataSource to set black lighting for
            passes with vertex programs. 

</member>
        <member name="F:Ogre.SceneManager.mShadowReceiverPass">
A pass designed to let us render shadow receivers for texture shadows
</member>
        <member name="F:Ogre.SceneManager.mShadowCasterPlainBlackPass">
A pass designed to let us render shadow colour on white for texture shadows
</member>
        <member name="M:Ogre.SceneManager.initRenderQueue">
Mutex over the collection of MovableObject types
Internal method for initialising the render queue.
        @remarks
            Subclasses can use this to install their own RenderQueue implementation.

</member>
        <member name="M:Ogre.SceneManager.getMovableObjectCollection(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the movable object collection for the given type name.
		@remarks
			This method create new collection if the collection does not exist.


Gets the movable object collection for the given type name.
		@remarks
			This method throw exception if the collection does not exist.

</member>
        <member name="T:Ogre.SceneManager.MovableObjectCollection">
Simple structure to hold MovableObject map and a mutex to go with it.
</member>
        <member name="T:Ogre.SceneManager.LightInfo">
Cached light information, used to tracking light's changes
</member>
        <member name="F:Ogre.SceneManager.mShadowTextureIndexLightList">
Array defining shadow texture index in light list.
</member>
        <member name="F:Ogre.SceneManager.mShadowTextureCountPerType">
Array defining shadow count per light type.
</member>
        <member name="D:Ogre.SceneManager.ShadowCamLightMapping">
ShadowCamera to light mapping 
</member>
        <member name="D:Ogre.SceneManager.CamVisibleObjectsMap">
Visible objects bounding box list.
			@remarks
				Holds an ABB for each camera that contains the physical extends of the visible
				scene elements by each camera. The map is crucial for shadow algorithms which
				have a focus step to limit the shadow sample distribution to only valid visible
				scene elements.

</member>
        <member name="D:Ogre.SceneManager.AutoTrackingSceneNodes">
Autotracking scene nodes
</member>
        <member name="F:Ogre.SceneManager.mSceneRoot">
Root scene node
</member>
        <member name="F:Ogre.SceneManager.mCurrentViewport">
Current Viewport
</member>
        <member name="F:Ogre.SceneManager.mCameraInProgress">
Camera in progress
</member>
        <member name="F:Ogre.SceneManager.mSceneNodes">
Central list of SceneNodes - for easy memory management.
            @note
                Note that this list is used only for memory management; the structure of the scene
                is held using the hierarchy of SceneNodes starting with the root node. However you
                can look up nodes this way.

</member>
        <member name="F:Ogre.SceneManager.mCameras">
Central list of cameras - for easy memory management and lookup.

</member>
        <member name="F:Ogre.SceneManager.mDestRenderSystem">
The rendering system to send the scene to
</member>
        <member name="F:Ogre.SceneManager.mAmbientLight">
Current ambient light, cached for RenderSystem
</member>
        <member name="F:Ogre.SceneManager.mRenderQueue">
Queue of objects for rendering
</member>
        <member name="F:Ogre.SceneManager.mName">
Instance name
</member>
        <member name="M:Ogre.SceneManager.createSceneNodeImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Subclasses can override this to ensure their specialised SceneNode is used.
</member>
        <member name="M:Ogre.SceneManager.createSceneNodeImpl">
Subclasses can override this to ensure their specialised SceneNode is used.
</member>
        <member name="F:Ogre.SceneManager.SceneMgrQueuedRenderableVisitor.scissoring">
Scissoring if requested?
</member>
        <member name="F:Ogre.SceneManager.SceneMgrQueuedRenderableVisitor.manualLightList">
Manual light list
</member>
        <member name="F:Ogre.SceneManager.SceneMgrQueuedRenderableVisitor.autoLights">
Automatic light handling?
</member>
        <member name="F:Ogre.SceneManager.SceneMgrQueuedRenderableVisitor.transparentShadowCastersMode">
Are we in transparent shadow caster mode?
</member>
        <member name="F:Ogre.SceneManager.SceneMgrQueuedRenderableVisitor.targetSceneMgr">
Target SM to send renderables to
</member>
        <member name="F:Ogre.SceneManager.SceneMgrQueuedRenderableVisitor.mUsedPass">
Pass that was actually used at the grouping level
</member>
        <member name="T:Ogre.SceneManager.SceneMgrQueuedRenderableVisitor">
Inner helper class to implement the visitor pattern for rendering objects
			in a queue. 


Allow visitor helper to access protected methods
</member>
        <member name="M:Ogre.SceneManager.Listener.sceneManagerDestroyed(Ogre.SceneManager*)">
Event notifying the listener of the SceneManager's destruction. 
</member>
        <member name="M:Ogre.SceneManager.Listener.sortLightsAffectingFrustum(Ogre.HashedVector&lt;Ogre.Light**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Hook to allow the listener to override the ordering of lights for
				the entire frustum.
			@remarks
				Whilst ordinarily lights are sorted per rendered object 
				(@see MovableObject::queryLights), texture shadows adds another issue
				in that, given there is a finite number of shadow textures, we must
				choose which lights to render texture shadows from based on the entire
				frustum. These lights should always be listed first in every objects
				own list, followed by any other lights which will not cast texture 
				shadows (either because they have shadow casting off, or there aren't
				enough shadow textures to service them).
			@par
				This hook allows you to override the detailed ordering of the lights
				per frustum. The default ordering is shadow casters first (which you 
				must also respect if you override this method), and ordered
				by distance from the camera within those 2 groups. Obviously the closest
				lights with shadow casting enabled will be listed first. Only lights 
				within the range of the frustum will be in the list.
			@param lightList The list of lights within range of the frustum which you
				may sort.
			@returns true if you sorted the list, false otherwise.

</member>
        <member name="M:Ogre.SceneManager.Listener.shadowTexturesUpdated(System.UInt32)">
Event raised after all shadow textures have been rendered into for 
				all queues / targets but before any other geometry has been rendered
				(including main scene geometry and any additional shadow receiver 
				passes). 
			@remarks
				This callback is useful for those that wish to perform some 
				additional processing on shadow textures before they are used to 
				render shadows. For example you could perform some filtering by 
				rendering the existing shadow textures into another alternative 
				shadow texture with a shader.]
			@note
				This event will only be fired when texture shadows are in use.
			@param numberOfShadowTextures The number of shadow textures in use

</member>
        <member name="M:Ogre.SceneManager.Listener.postFindVisibleObjects(Ogre.SceneManager*,Ogre.SceneManager.IlluminationRenderStage,Ogre.Viewport*)">
Called after searching for visible objects in this SceneManager.
			@remarks
				Note that the render queue at this stage will be full of the current
				scenes contents, ready for rendering. You may manually add renderables
				to this queue if you wish.
			@param source The SceneManager instance raising this event.
			@param irs The stage of illumination being dealt with. IRS_NONE for 
				a regular render, IRS_RENDER_TO_TEXTURE for a shadow caster render.
			@param v The viewport being updated. You can get the camera from here.

</member>
        <member name="M:Ogre.SceneManager.Listener.preFindVisibleObjects(Ogre.SceneManager*,Ogre.SceneManager.IlluminationRenderStage,Ogre.Viewport*)">
Called prior to searching for visible objects in this SceneManager.
			@remarks
				Note that the render queue at this stage will be full of the last
				render's contents and will be cleared after this method is called.
			@param source The SceneManager instance raising this event.
			@param irs The stage of illumination being dealt with. IRS_NONE for 
				a regular render, IRS_RENDER_TO_TEXTURE for a shadow caster render.
			@param v The viewport being updated. You can get the camera from here.

</member>
        <member name="T:Ogre.SceneManager.Listener">
Class that allows listening in on the various stages of SceneManager
			processing, so that custom behaviour can be implemented from outside.

</member>
        <member name="F:SCRQM_EXCLUDE">
Render all except the queues in the special case list
</member>
        <member name="F:SCRQM_INCLUDE">
Render only the queues in the special case list
</member>
        <member name="T:Ogre.SceneManager.SpecialCaseRenderQueueMode">
Enumeration of the possible modes allowed for processing the special case
		render queue list.
		@see SceneManager::setSpecialCaseRenderQueueMode

</member>
        <member name="F:IRS_RENDER_RECEIVER_PASS">
Render from shadow texture to receivers stage
</member>
        <member name="F:IRS_RENDER_TO_TEXTURE">
Render to texture stage, used for texture based shadows
</member>
        <member name="F:IRS_NONE">
No special illumination stage
</member>
        <member name="T:Ogre.SceneManager.IlluminationRenderStage">
Describes the stage of rendering when performing complex illumination
</member>
        <member name="T:Ogre.SceneManager.lightLess">
Comparator for sorting lights relative to a point
</member>
        <member name="T:Ogre.SceneManager.materialLess">
Comparator for material map, for sorting materials into render order (e.g. transparent last).

</member>
        <member name="F:Ogre.SceneManager.USER_TYPE_MASK_LIMIT">
User type mask limit
</member>
        <member name="F:Ogre.SceneManager.FRUSTUM_TYPE_MASK">
Query type mask which will be used for frusta and cameras @see SceneQuery
</member>
        <member name="F:Ogre.SceneManager.LIGHT_TYPE_MASK">
Query type mask which will be used for lights  @see SceneQuery
</member>
        <member name="F:Ogre.SceneManager.STATICGEOMETRY_TYPE_MASK">
Query type mask which will be used for StaticGeometry  @see SceneQuery
</member>
        <member name="F:Ogre.SceneManager.FX_TYPE_MASK">
Query type mask which will be used for effects like billboardsets / particle systems @see SceneQuery
</member>
        <member name="F:Ogre.SceneManager.ENTITY_TYPE_MASK">
Query type mask which will be used for entities @see SceneQuery
</member>
        <member name="F:Ogre.SceneManager.WORLD_GEOMETRY_TYPE_MASK">
Query type mask which will be used for world geometry @see SceneQuery
</member>
        <member name="T:Ogre.SceneManager">
Manages the organisation and rendering of a 'scene' i.e. a collection 
		of objects and potentially world geometry.
    @remarks
		This class defines the interface and the basic behaviour of a 
		'Scene Manager'. A SceneManager organises the culling and rendering of
		the scene, in conjunction with the RenderQueue. This class is designed 
		to be extended through subclassing in order to provide more specialised
		scene organisation structures for particular needs. The default 
		SceneManager culls based on a hierarchy of node bounding boxes, other
		implementations can use an octree (@see OctreeSceneManager), a BSP
		tree (@see BspSceneManager), and many other options. New SceneManager
		implementations can be added at runtime by plugins, see 
		SceneManagerEnumerator for the interfaces for adding new SceneManager
		types.
	@par
		There is a distinction between 'objects' (which subclass MovableObject, 
		and are movable, discrete objects in the world), and 'world geometry',
		which is large, generally static geometry. World geometry tends to 
		influence the SceneManager organisational structure (e.g. lots of indoor
		static geometry might result in a spatial tree structure) and as such
		world geometry is generally tied to a given SceneManager implementation,
		whilst MovableObject instances can be used with any SceneManager.
		Subclasses are free to define world geometry however they please.
	@par
		Multiple SceneManager instances can exist at one time, each one with 
		a distinct scene. Which SceneManager is used to render a scene is
		dependent on the Camera, which will always call back the SceneManager
		which created it to render the scene. 

</member>
        <member name="M:Ogre.VisibleObjectsBoundsInfo.mergeNonRenderedButInFrustum(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Sphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Merge an object that is not being rendered because it's not a shadow caster, 
			but is a shadow receiver so should be included in the range.

</member>
        <member name="F:Ogre.VisibleObjectsBoundsInfo.maxDistanceInFrustum">
The farthest object in the frustum regardless of visibility / shadow caster flags
</member>
        <member name="F:Ogre.VisibleObjectsBoundsInfo.minDistanceInFrustum">
The closest a object in the frustum regardless of visibility / shadow caster flags
</member>
        <member name="F:Ogre.VisibleObjectsBoundsInfo.maxDistance">
The farthest a visible objects is from the camera
</member>
        <member name="F:Ogre.VisibleObjectsBoundsInfo.minDistance">
The closest a visible object is to the camera
</member>
        <member name="F:Ogre.VisibleObjectsBoundsInfo.receiverAabb">
The axis-aligned bounds of the visible shadow receiver objects
</member>
        <member name="F:Ogre.VisibleObjectsBoundsInfo.aabb">
The axis-aligned bounds of the visible objects
</member>
        <member name="T:Ogre.VisibleObjectsBoundsInfo">
Structure collecting together information about the visible objects
	that have been discovered in a scene.

</member>
        <member name="M:Ogre.LodListener.postqueueEntityMaterialLodChanged(Ogre.EntityMaterialLodChangedEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called after an entity's material lod has changed.
@remarks
    May be called even if not requested from prequeueEntityMaterialLodChanged
    as only one event queue is maintained per SceneManger instance.

</member>
        <member name="M:Ogre.LodListener.prequeueEntityMaterialLodChanged(Ogre.EntityMaterialLodChangedEvent*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Called before an entity's material lod has changed.
        @remarks
            Do not change the Ogre state from this method, 
            instead return true and perform changes in 
            postqueueMaterialLodChanged.

            It is possible to change the event notification 
            and even alter the newLodIndex field (possibly to 
            prevent the lod from changing, or to skip an 
            index).
        @return
            True to indicate the event should be queued and
            postqueueMaterialLodChanged called after
            rendering is complete.

</member>
        <member name="M:Ogre.LodListener.postqueueEntityMeshLodChanged(Ogre.EntityMeshLodChangedEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called after an entity's mesh lod has changed.
@remarks
    May be called even if not requested from prequeueEntityMeshLodChanged
    as only one event queue is maintained per SceneManger instance.

</member>
        <member name="M:Ogre.LodListener.prequeueEntityMeshLodChanged(Ogre.EntityMeshLodChangedEvent*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Called before an entity's mesh lod has changed.
        @remarks
            Do not change the Ogre state from this method, 
            instead return true and perform changes in 
            postqueueEntityMeshLodChanged.

            It is possible to change the event notification 
            and even alter the newLodIndex field (possibly to 
            prevent the lod from changing, or to skip an 
            index).
        @return
            True to indicate the event should be queued and
            postqueueEntityMeshLodChanged called after
            rendering is complete.

</member>
        <member name="M:Ogre.LodListener.postqueueMovableObjectLodChanged(Ogre.MovableObjectLodChangedEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called after a movable object's lod has changed.
@remarks
    May be called even if not requested from prequeueMovableObjectLodChanged
    as only one event queue is maintained per SceneManger instance.

</member>
        <member name="M:Ogre.LodListener.prequeueMovableObjectLodChanged(Ogre.MovableObjectLodChangedEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called before a movable object's lod has changed.
@remarks
    Do not change the Ogre state from this method, 
    instead return true and perform changes in 
    postqueueMovableObjectLodChanged.
@return
    True to indicate the event should be queued and
    postqueueMovableObjectLodChanged called after
    rendering is complete.

</member>
        <member name="T:Ogre.LodListener">
A interface class defining a listener which can be used to receive
        notifications of lod events.
        @remarks
            A 'listener' is an interface designed to be called back when
            particular events are called. This class defines the
            interface relating to lod events. In order to receive
            notifications of lod events, you should create a subclass of
            LodListener and override the methods for which you would like
            to customise the resulting processing. You should then call
            SceneManager::addLodListener passing an instance of this class.
            There is no limit to the number of lod listeners you can register,
            allowing you to register multiple listeners for different purposes.

            For some uses, it may be advantageous to also subclass
            RenderQueueListener as this interface makes available information
            regarding render queue invocations.

            It is important not to modify the scene graph during rendering, so,
            for each event, there are two methods, a prequeue method and a
            postqueue method.  The prequeue method is invoked during rendering,
            and as such should not perform any changes, but if the event is
            relevant, it may return true indicating the postqueue method should
            also be called.  The postqueue method is invoked at an appropriate
            time after rendering and scene changes may be safely made there.

</member>
        <member name="F:Ogre.EntityMaterialLodChangedEvent.newLodIndex">
New level of detail index.
</member>
        <member name="F:Ogre.EntityMaterialLodChangedEvent.previousLodIndex">
Previous level of detail index.
</member>
        <member name="F:Ogre.EntityMaterialLodChangedEvent.lodValue">
Lod value as determined by lod strategy.
</member>
        <member name="F:Ogre.EntityMaterialLodChangedEvent.camera">
The camera with respect to which the level of detail has changed.
</member>
        <member name="F:Ogre.EntityMaterialLodChangedEvent.subEntity">
The sub-entity whose material's level of detail has changed.
</member>
        <member name="T:Ogre.EntityMaterialLodChangedEvent">
Struct containing information about a material lod change event for entities.
</member>
        <member name="F:Ogre.EntityMeshLodChangedEvent.newLodIndex">
New level of detail index.
</member>
        <member name="F:Ogre.EntityMeshLodChangedEvent.previousLodIndex">
Previous level of detail index.
</member>
        <member name="F:Ogre.EntityMeshLodChangedEvent.lodValue">
Lod value as determined by lod strategy.
</member>
        <member name="F:Ogre.EntityMeshLodChangedEvent.camera">
The camera with respect to which the level of detail has changed.
</member>
        <member name="F:Ogre.EntityMeshLodChangedEvent.entity">
The entity whose level of detail has changed.
</member>
        <member name="T:Ogre.EntityMeshLodChangedEvent">
Struct containing information about a mesh lod change event for entities.
</member>
        <member name="F:Ogre.MovableObjectLodChangedEvent.camera">
The camera with respect to which the level of detail has changed.
</member>
        <member name="F:Ogre.MovableObjectLodChangedEvent.movableObject">
The movable object whose level of detail has changed.
</member>
        <member name="T:Ogre.MovableObjectLodChangedEvent">
\addtogroup Core
	*  @{

\addtogroup LOD
	*  @{

Struct containing information about a lod change event for movable objects.
</member>
        <member name="M:Ogre.InstancedGeometry.getProvideWorldInverses">
@remarks
Returns the toggle state indicating whether the World Transform INVERSE matrices would
be passed to the shaders.

</member>
        <member name="M:Ogre.InstancedGeometry.setProvideWorldInverses(System.Boolean)">
        @remarks
        Allows World Transform Inverse matrices to be passed as shader constants along with the world
        transform matrix list. Reduces the number of usable geometries in an instance to 40 instead of 80.
		The inverse matrices are interleaved with the world matrices at n+1.

</member>
        <member name="M:Ogre.InstancedGeometry.getObjectCount">
@remarks
return the total number of object that are in all the batches

</member>
        <member name="M:Ogre.InstancedGeometry.getBaseAnimationState">
@remarks
Return the animation state that will be cloned each time an InstancedObject is made

</member>
        <member name="M:Ogre.InstancedGeometry.getBaseSkeleton">
@remarks
Return the skeleton that is shared by all instanced objects.

</member>
        <member name="M:Ogre.InstancedGeometry.getBaseSkeletonInstance">
@remarks
Return the skeletonInstance that will be used 

</member>
        <member name="M:Ogre.InstancedGeometry.dump(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Dump the contents of this InstancedGeometry to a file for diagnostic
		 	purposes.

</member>
        <member name="M:Ogre.InstancedGeometry.visitRenderables(Ogre.Renderable.Visitor*,System.Boolean)">
@copydoc MovableObject::visitRenderables
</member>
        <member name="M:Ogre.InstancedGeometry.getRenderOperationVector">
get the mRenderOps vector.
</member>
        <member name="M:Ogre.InstancedGeometry.getBatchInstanceIterator">
Get an iterator over the BatchInstances in this geometry
</member>
        <member name="D:Ogre.InstancedGeometry.BatchInstanceIterator">
Iterator for iterating over contained BatchInstances
</member>
        <member name="M:Ogre.InstancedGeometry.getRenderQueueGroup">
Gets the queue group for this entity, see setRenderQueueGroup for full details. 
</member>
        <member name="M:Ogre.InstancedGeometry.setRenderQueueGroup(System.Byte)">
Sets the render queue group this object will be rendered through.
        @remarks
            Render queues are grouped to allow you to more tightly control the ordering
            of rendered objects. If you do not call this method, all  objects default
            to the default queue (RenderQueue::getDefaultQueueGroup), which is fine for 
			most objects. You may want to alter this if you want to perform more complex
			rendering.
        @par
            See RenderQueue for more details.
        @param queueID Enumerated value of the queue group to use.

</member>
        <member name="M:Ogre.InstancedGeometry.getOrigin">
Gets the origin of this geometry. 
</member>
        <member name="M:Ogre.InstancedGeometry.setOrigin(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the origin of the geometry.
		@remarks
			This method allows you to configure the world centre of the geometry,
			thus the place which all BatchInstances surround. You probably don't need 
			to mess with this unless you have a seriously large world, since the
			default set up can handle an area 1024 * mBatchInstanceDimensions, and 
			the sparseness of population is no issue when it comes to rendering.
			The default is Vector3(0,0,0).
		@note Must be called before 'build'.
		@param size Vector3 expressing the 3D origin of the geometry.

</member>
        <member name="M:Ogre.InstancedGeometry.getBatchInstanceDimensions">
Gets the size of a single batch of geometry. 
</member>
        <member name="M:Ogre.InstancedGeometry.setBatchInstanceDimensions(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the size of a single BatchInstance of geometry.
		@remarks
			This method allows you to configure the physical world size of 
			each BatchInstance, so you can balance culling against batch size. Entities
			will be fitted within the batch they most closely fit, and the 
			eventual bounds of each batch may well be slightly larger than this
			if they overlap a little. The default is Vector3(1000, 1000, 1000).
		@note Must be called before 'build'.
		@param size Vector3 expressing the 3D size of each BatchInstance.

</member>
        <member name="M:Ogre.InstancedGeometry.getCastShadows">
Will the geometry from this object cast shadows?
</member>
        <member name="M:Ogre.InstancedGeometry.setCastShadows(System.Boolean)">
Sets whether this geometry should cast shadows.
		@remarks
			No matter what the settings on the original entities,
			the InstancedGeometry class defaults to not casting shadows. 
			This is because, being static, unless you have moving lights
			you'd be better to use precalculated shadows of some sort.
			However, if you need them, you can enable them using this
			method. If the SceneManager is set up to use stencil shadows,
			edge lists will be copied from the underlying meshes on build.
			It is essential that all meshes support stencil shadows in this
			case.
		@note If you intend to use stencil shadows, you must set this to 
			true before calling 'build' as well as making sure you set the
			scene's shadow type (that should always be the first thing you do
			anyway). You can turn shadows off temporarily but they can never 
			be turned on if they were not at the time of the build. 

</member>
        <member name="M:Ogre.InstancedGeometry.isVisible">
Are the batches visible? 
</member>
        <member name="M:Ogre.InstancedGeometry.setVisible(System.Boolean)">
Hides or shows all the batches. 
</member>
        <member name="M:Ogre.InstancedGeometry.getSquaredRenderingDistance">
Gets the squared distance at which batches are no longer rendered. 
</member>
        <member name="M:Ogre.InstancedGeometry.getRenderingDistance">
Gets the distance at which batches are no longer rendered. 
</member>
        <member name="M:Ogre.InstancedGeometry.setRenderingDistance(System.Single)">
Sets the distance at which batches are no longer rendered.
		@remarks
			This lets you turn off batches at a given distance. This can be 
			useful for things like detail meshes (grass, foliage etc) and could
			be combined with a shader which fades the geometry out beforehand 
			to lessen the effect.
		@param dist Distance beyond which the batches will not be rendered 
			(the default is 0, which means batches are always rendered).

</member>
        <member name="M:Ogre.InstancedGeometry.reset">
Clears any of the entities / nodes added to this geometry and 
			destroys anything which has already been built.

</member>
        <member name="M:Ogre.InstancedGeometry.destroy">
Destroys all the built geometry state (reverse of build). 
		@remarks
			You can call build() again after this and it will pick up all the
			same entities / nodes you queued last time.

</member>
        <member name="M:Ogre.InstancedGeometry.addBatchInstance">
Add a new batch instance
		@remarks
				This method add a new instance of the whole batch, by creating a new 
				BatchInstance, containing new lod buckets, material buckets and geometry buckets.
				The new geometry buckets will use the same buffers as the base bucket.
		@note
			no note

</member>
        <member name="M:Ogre.InstancedGeometry.build">
Build the geometry. 
		@remarks
			Based on all the entities which have been added, and the batching 
			options which have been set, this method constructs	the batched 
			geometry structures required. The batches are added to the scene 
			and will be rendered unless you specifically hide them.
		@note
			Once you have called this method, you can no longer add any more 
			entities.

</member>
        <member name="M:Ogre.InstancedGeometry.addSceneNode(Ogre.SceneNode!System.Runtime.CompilerServices.IsConst*)">
Adds all the Entity objects attached to a SceneNode and all it's
			children to the static geometry.
		@remarks
			This method performs just like addEntity, except it adds all the 
			entities attached to an entire sub-tree to the geometry. 
			The position / orientation / scale parameters are taken from the
			node structure instead of being specified manually. 
		@note
			The SceneNode you pass in will not be automatically detached from 
			it's parent, so if you have this node already attached to the scene
			graph, you will need to remove it if you wish to avoid the overhead
			of rendering <i>both</i> the original objects and their new static
			versions! We don't do this for you incase you are preparing this 
			in advance and so don't want the originals detached yet. 
		@note Must be called before 'build'.
        @note All added entities must use the same lod strategy.
		@param node Pointer to the node to use to provide a set of Entity 
			templates

</member>
        <member name="M:Ogre.InstancedGeometry.addEntity(Ogre.Entity*,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds an Entity to the static geometry.
		@remarks
			This method takes an existing Entity and adds its details to the 
			list of	elements to include when building. Note that the Entity
			itself is not copied or referenced in this method; an Entity is 
			passed simply so that you can change the materials of attached 
			SubEntity objects if you want. You can add the same Entity 
			instance multiple times with different material settings 
			completely safely, and destroy the Entity before destroying 
			this InstancedGeometry if you like. The Entity passed in is simply 
			used as a definition.
		@note Must be called before 'build'.
        @note All added entities must use the same lod strategy.
		@param ent The Entity to use as a definition (the Mesh and Materials 
			referenced will be recorded for the build call).
		@param position The world position at which to add this Entity
		@param orientation The world orientation at which to add this Entity
		@param scale The scale at which to add this entity

</member>
        <member name="M:Ogre.InstancedGeometry.getName">
Get the name of this object
</member>
        <member name="M:Ogre.InstancedGeometry.Dispose">
Destructor
</member>
        <member name="M:Ogre.InstancedGeometry.#ctor(Ogre.SceneManager*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor; do not use directly (@see SceneManager::createInstancedGeometry)
</member>
        <member name="M:Ogre.InstancedGeometry.splitGeometry(Ogre.VertexData*,Ogre.IndexData*,Ogre.InstancedGeometry.SubMeshLodGeometryLink*)">
Split some shared geometry into dedicated geometry. 
</member>
        <member name="M:Ogre.InstancedGeometry.determineGeometry(Ogre.SubMesh*)">
Look up or calculate the geometry data to use for this SubMesh 
</member>
        <member name="M:Ogre.InstancedGeometry.calculateBounds(Ogre.VertexData*,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculate world bounds from a set of vertex data. 
</member>
        <member name="M:Ogre.InstancedGeometry.getBatchInstanceCentre(System.UInt16,System.UInt16,System.UInt16)">
Get the centre of an indexed BatchInstance.

</member>
        <member name="M:Ogre.InstancedGeometry.getBatchInstanceBounds(System.UInt16,System.UInt16,System.UInt16)">
Get the bounds of an indexed BatchInstance.

</member>
        <member name="M:Ogre.InstancedGeometry.getVolumeIntersection(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16,System.UInt16,System.UInt16)">
Get the volume intersection for an indexed BatchInstance with some bounds.

</member>
        <member name="M:Ogre.InstancedGeometry.packIndex(System.UInt16,System.UInt16,System.UInt16)">
Pack 3 indexes into a single index value

</member>
        <member name="M:Ogre.InstancedGeometry.getInstancedGeometryInstance">
get the first BatchInstance or create on if it does not exists.

</member>
        <member name="M:Ogre.InstancedGeometry.getBatchInstanceIndexes(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get the BatchInstance indexes for a point.

</member>
        <member name="M:Ogre.InstancedGeometry.getBatchInstance(System.UInt32)">
Get the BatchInstance using a packed index, returns null if it doesn't exist. 
</member>
        <member name="M:Ogre.InstancedGeometry.getBatchInstance(System.UInt16,System.UInt16,System.UInt16,System.Boolean)">
Get the BatchInstance using indexes 
</member>
        <member name="M:Ogre.InstancedGeometry.getBatchInstance(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Get the BatchInstance within which a point lies 
</member>
        <member name="M:Ogre.InstancedGeometry.getBatchInstance(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Virtual method for getting a BatchInstance most suitable for the
			passed in bounds. Can be overridden by subclasses.

</member>
        <member name="F:Ogre.InstancedGeometry.mRenderOps">
This vector stores all the renderOperation used in the batch. 
		See the type definition for more details.

</member>
        <member name="F:Ogre.InstancedGeometry.mBatchInstanceMap">
Map of BatchInstances
</member>
        <member name="F:Ogre.InstancedGeometry.mSubMeshGeometryLookup">
Cached links from SubMeshes to (potentially optimised) geometry
			This is not used for deletion since the lookup may reference
			original vertex data

</member>
        <member name="F:Ogre.InstancedGeometry.mOptimisedSubMeshGeometryList">
List of geometry which has been optimised for SubMesh use
This is the primary storage used for cleaning up later
</member>
        <member name="F:Ogre.InstancedGeometry.mAnimationState">
This is the main animation state. All "objects" in the batch will use an instance of this animation
		state

</member>
        <member name="F:Ogre.InstancedGeometry.mBaseSkeleton">
this is just a pointer to the base skeleton that will be used for each animated object in the batches
		This pointer has a value only during the creation of the InstancedGeometry

</member>
        <member name="F:Ogre.InstancedGeometry.mObjectCount">
number of objects in the batch
</member>
        <member name="F:Ogre.InstancedGeometry.mRenderQueueIDSet">
Flags whether the RenderQueue's default should be used.
</member>
        <member name="F:Ogre.InstancedGeometry.mRenderQueueID">
The render queue to use when rendering this object
</member>
        <member name="F:Ogre.InstancedGeometry.mProvideWorldInverses">
Flags to indicate whether the World Transform Inverse matrices are passed to the shaders
</member>
        <member name="D:Ogre.InstancedGeometry.RenderOperationVector">
Simple vectors where are stored all the renderoperations of the Batch.
			This vector is used when we want to delete the batch, in order to delete only one time each
			render operation.


</member>
        <member name="D:Ogre.InstancedGeometry.BatchInstanceMap">
Indexed BatchInstance map based on packed x/y/z BatchInstance index, 10 bits for
			each axis.

</member>
        <member name="M:Ogre.InstancedGeometry.BatchInstance.attachToScene">
attach the BatchInstance to the scene
</member>
        <member name="M:Ogre.InstancedGeometry.BatchInstance.updateContainers(Ogre.InstancedGeometry.LODBucket*)">
fill in the list 
</member>
        <member name="M:Ogre.InstancedGeometry.BatchInstance.dump(std.basic_ofstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Dump contents for diagnostics
</member>
        <member name="M:Ogre.InstancedGeometry.BatchInstance.updateBoundingBox">
update the bounding box of the BatchInstance according to the positions of the objects
</member>
        <member name="M:Ogre.InstancedGeometry.BatchInstance.getLights">
Shared set of lights for all GeometryBuckets
</member>
        <member name="M:Ogre.InstancedGeometry.BatchInstance.getLODIterator">
Get an iterator over the LODs in this BatchInstance
</member>
        <member name="M:Ogre.InstancedGeometry.BatchInstance.visitRenderables(Ogre.Renderable.Visitor*,System.Boolean)">
@copydoc MovableObject::visitRenderables
</member>
        <member name="M:Ogre.InstancedGeometry.BatchInstance.getMovableType">
Get the centre point of the BatchInstance
</member>
        <member name="M:Ogre.InstancedGeometry.BatchInstance.getID">
Get the BatchInstance ID of this BatchInstance
</member>
        <member name="M:Ogre.InstancedGeometry.BatchInstance.build">
Build this BatchInstance
</member>
        <member name="M:Ogre.InstancedGeometry.BatchInstance.assign(Ogre.InstancedGeometry.QueuedSubMesh*)">
Assign a queued mesh to this BatchInstance, read for final build
</member>
        <member name="F:Ogre.InstancedGeometry.BatchInstance.mLodStrategy">
Lod strategy reference
</member>
        <member name="F:Ogre.InstancedGeometry.BatchInstance.mLodBucketList">
List of LOD buckets			
</member>
        <member name="F:Ogre.InstancedGeometry.BatchInstance.mSquaredViewDepth">
Cached squared view depth value to avoid recalculation by GeometryBucket
</member>
        <member name="F:Ogre.InstancedGeometry.BatchInstance.mCamera">
Current camera, passed on to do material lod later
</member>
        <member name="F:Ogre.InstancedGeometry.BatchInstance.mLodValue">
Current lod value, passed on to do material lod later
</member>
        <member name="F:Ogre.InstancedGeometry.BatchInstance.mCurrentLod">
The current lod level, as determined from the last camera
</member>
        <member name="F:Ogre.InstancedGeometry.BatchInstance.mBoundingRadius">
Local bounding radius
</member>
        <member name="F:Ogre.InstancedGeometry.BatchInstance.mAABB">
Local AABB relative to BatchInstance centre
</member>
        <member name="F:Ogre.InstancedGeometry.BatchInstance.mLodValues">
Lod values as built up - use the max at each level
</member>
        <member name="F:Ogre.InstancedGeometry.BatchInstance.mBatchInstanceID">
Unique identifier for the BatchInstance
</member>
        <member name="F:Ogre.InstancedGeometry.BatchInstance.mQueuedSubMeshes">
Local list of queued meshes (not used for deallocation)
</member>
        <member name="F:Ogre.InstancedGeometry.BatchInstance.mNode">
Scene node
</member>
        <member name="F:Ogre.InstancedGeometry.BatchInstance.mSceneMgr">
Scene manager link
</member>
        <member name="F:Ogre.InstancedGeometry.BatchInstance.mParent">
Parent static geometry
</member>
        <member name="D:Ogre.InstancedGeometry.BatchInstance.LODBucketList">
list of LOD Buckets in this BatchInstance
</member>
        <member name="M:Ogre.InstancedGeometry.LODBucket.updateContainers(Ogre.InstancedGeometry.MaterialBucket*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
fill the map
</member>
        <member name="M:Ogre.InstancedGeometry.LODBucket.dump(std.basic_ofstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Dump contents for diagnostics
</member>
        <member name="M:Ogre.InstancedGeometry.LODBucket.getMaterialIterator">
Get an iterator over the materials in this LOD
</member>
        <member name="D:Ogre.InstancedGeometry.LODBucket.MaterialIterator">
Iterator over the materials in this LOD
</member>
        <member name="M:Ogre.InstancedGeometry.LODBucket.addRenderables(Ogre.RenderQueue*,System.Byte,System.Single)">
Add children to the render queue
</member>
        <member name="M:Ogre.InstancedGeometry.LODBucket.build">
Build
</member>
        <member name="M:Ogre.InstancedGeometry.LODBucket.assign(Ogre.InstancedGeometry.QueuedSubMesh*,System.UInt16)">
Assign a queued submesh to this bucket, using specified mesh LOD
</member>
        <member name="M:Ogre.InstancedGeometry.LODBucket.getLodValue">
Get the lod value
</member>
        <member name="M:Ogre.InstancedGeometry.LODBucket.getLod">
Get the lod index
</member>
        <member name="F:Ogre.InstancedGeometry.LODBucket.mQueuedGeometryList">
Geometry queued for a single LOD (deallocated here)
</member>
        <member name="F:Ogre.InstancedGeometry.LODBucket.mMaterialBucketMap">
Lookup of Material Buckets in this BatchInstance
</member>
        <member name="F:Ogre.InstancedGeometry.LODBucket.mLodValue">
lod value at which this LOD starts to apply (squared)
</member>
        <member name="F:Ogre.InstancedGeometry.LODBucket.mLod">
LOD level (0 == full LOD)
</member>
        <member name="F:Ogre.InstancedGeometry.LODBucket.mParent">
Pointer to parent BatchInstance
</member>
        <member name="D:Ogre.InstancedGeometry.LODBucket.MaterialBucketMap">
Lookup of Material Buckets in this BatchInstance
</member>
        <member name="T:Ogre.InstancedGeometry.LODBucket">
A LODBucket is a collection of smaller buckets with the same LOD. 
		@remarks
			LOD refers to Mesh LOD here. Material LOD can change separately
			at the next bucket down from this.

</member>
        <member name="M:Ogre.InstancedGeometry.MaterialBucket.updateContainers(Ogre.InstancedGeometry.GeometryBucket*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
fill in the map and the list
</member>
        <member name="M:Ogre.InstancedGeometry.MaterialBucket.getGeometryBucketList">
Return the geometry list
</member>
        <member name="M:Ogre.InstancedGeometry.MaterialBucket.getMaterialBucketMap">
Return the geometry map
</member>
        <member name="M:Ogre.InstancedGeometry.MaterialBucket.dump(std.basic_ofstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Dump contents for diagnostics
</member>
        <member name="M:Ogre.InstancedGeometry.MaterialBucket.getCurrentTechnique">
Get the current Technique
</member>
        <member name="M:Ogre.InstancedGeometry.MaterialBucket.getGeometryIterator">
Get an iterator over the contained geometry
</member>
        <member name="D:Ogre.InstancedGeometry.MaterialBucket.GeometryIterator">
Iterator over geometry
</member>
        <member name="M:Ogre.InstancedGeometry.MaterialBucket.getMaterial">
Get the material for this bucket
</member>
        <member name="M:Ogre.InstancedGeometry.MaterialBucket.addRenderables(Ogre.RenderQueue*,System.Byte,System.Single)">
Add children to the render queue
</member>
        <member name="M:Ogre.InstancedGeometry.MaterialBucket.build">
Build
</member>
        <member name="M:Ogre.InstancedGeometry.MaterialBucket.assign(Ogre.InstancedGeometry.QueuedGeometry*)">
Assign geometry to this bucket
</member>
        <member name="M:Ogre.InstancedGeometry.MaterialBucket.getMaterialName">
Get the material name
</member>
        <member name="M:Ogre.InstancedGeometry.MaterialBucket.getGeometryFormatString(Ogre.InstancedGeometry.SubMeshLodGeometryLink*)">
Get a packed string identifying the geometry format
</member>
        <member name="F:Ogre.InstancedGeometry.MaterialBucket.mGeometryBucketList">
list of Geometry Buckets in this BatchInstance
</member>
        <member name="F:Ogre.InstancedGeometry.MaterialBucket.mTechnique">
Active technique
</member>
        <member name="F:Ogre.InstancedGeometry.MaterialBucket.mMaterial">
Pointer to material being used
</member>
        <member name="F:Ogre.InstancedGeometry.MaterialBucket.mMaterialName">
Material being used
</member>
        <member name="F:Ogre.InstancedGeometry.MaterialBucket.mParent">
Pointer to parent LODBucket
</member>
        <member name="D:Ogre.InstancedGeometry.MaterialBucket.GeometryBucketList">
list of Geometry Buckets in this BatchInstance
</member>
        <member name="T:Ogre.InstancedGeometry.MaterialBucket">
A MaterialBucket is a collection of smaller buckets with the same 
			Material (and implicitly the same LOD). 
</member>
        <member name="F:Ogre.InstancedGeometry.InstancedObject.mFrameAnimationLastUpdated">
Records the last frame in which animation was updated
</member>
        <member name="F:Ogre.InstancedGeometry.InstancedObject.mAnimationState">
State of animation for animable meshes
</member>
        <member name="F:Ogre.InstancedGeometry.InstancedObject.mBoneMatrices">
Cached bone matrices in skeleton local space
</member>
        <member name="F:Ogre.InstancedGeometry.InstancedObject.mBoneWorldMatrices">
Cached bone matrices, including any world transform
</member>
        <member name="D:Ogre.InstancedGeometry.InstancedObject.GeometryBucketList">
list of Geometry Buckets that contains the instanced object
</member>
        <member name="M:Ogre.InstancedGeometry.GeometryBucket.visitRenderables(Ogre.Renderable.Visitor*,System.Boolean)">
@copydoc MovableObject::visitRenderables
</member>
        <member name="M:Ogre.InstancedGeometry.GeometryBucket.getAABB">
retun the BoundingBox information. Usefull when cloning the batch instance.
</member>
        <member name="M:Ogre.InstancedGeometry.GeometryBucket.dump(std.basic_ofstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Dump contents for diagnostics
</member>
        <member name="M:Ogre.InstancedGeometry.GeometryBucket.build">
Build
</member>
        <member name="M:Ogre.InstancedGeometry.GeometryBucket.assign(Ogre.InstancedGeometry.QueuedGeometry*)">
Try to assign geometry to this bucket.
			@returns false if there is no room left in this bucket

</member>
        <member name="M:Ogre.InstancedGeometry.GeometryBucket.getMaterial">
@copydoc Renderable::getMaterial
</member>
        <member name="M:Ogre.InstancedGeometry.GeometryBucket.getIndexData">
Get the index data for this geometry 
</member>
        <member name="M:Ogre.InstancedGeometry.GeometryBucket.getVertexData">
Get the vertex data for this geometry 
</member>
        <member name="F:Ogre.InstancedGeometry.GeometryBucket.mTexCoordIndex">
Index of the Texcoord where the index is stored
</member>
        <member name="F:Ogre.InstancedGeometry.GeometryBucket.mMaxVertexIndex">
Maximum vertex indexable
</member>
        <member name="F:Ogre.InstancedGeometry.GeometryBucket.mIndexType">
Size of indexes
</member>
        <member name="F:Ogre.InstancedGeometry.GeometryBucket.mIndexData">
Index information, includes index type which limits the max
number of vertices which are allowed in one bucket
</member>
        <member name="F:Ogre.InstancedGeometry.GeometryBucket.mVertexData">
Vertex information, includes current number of vertices
committed to be a part of this bucket
</member>
        <member name="F:Ogre.InstancedGeometry.GeometryBucket.mFormatString">
String identifying the vertex / index format
</member>
        <member name="F:Ogre.InstancedGeometry.GeometryBucket.mParent">
Pointer to parent bucket
</member>
        <member name="F:Ogre.InstancedGeometry.GeometryBucket.mBatch">
Pointer to the Batch
</member>
        <member name="F:Ogre.InstancedGeometry.GeometryBucket.mQueuedGeometry">
Geometry which has been queued up pre-build (not for deallocation)
</member>
        <member name="T:Ogre.InstancedGeometry.QueuedGeometry">
Structure recording a queued geometry for low level builds
</member>
        <member name="F:Ogre.InstancedGeometry.QueuedSubMesh.worldBounds">
Pre-transformed world AABB 
</member>
        <member name="F:Ogre.InstancedGeometry.QueuedSubMesh.geometryLodList">
Link to LOD list of geometry, potentially optimised
</member>
        <member name="T:Ogre.InstancedGeometry.QueuedSubMesh">
Structure recording a queued submesh for the build
</member>
        <member name="T:Ogre.InstancedGeometry.SubMeshLodGeometryLink">
Saved link between SubMesh at a LOD and vertex/index data
May point to original or optimised geometry
</member>
        <member name="T:Ogre.InstancedGeometry.OptimisedSubMeshGeometry">
Struct holding geometry optimised per SubMesh / lod level, ready
			for copying to instances. 
		@remarks
			Since we're going to be duplicating geometry lots of times, it's
			far more important that we don't have redundant vertex data. If a 
			SubMesh uses shared geometry, or we're looking at a lower LOD, not
			all the vertices are being referenced by faces on that submesh.
			Therefore to duplicate them, potentially hundreds or even thousands
			of times, would be extremely wasteful. Therefore, if a SubMesh at
			a given LOD has wastage, we create an optimised version of it's
			geometry which is ready for copying with no wastage.

</member>
        <member name="T:Ogre.InstancedGeometry">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Pre-transforms and batches up meshes for efficient use as instanced geometry
		in a scene
	@remarks
		Shader instancing allows to save both memory and draw calls. While 
		StaticGeometry stores 500 times the same object in a batch to display 500 
		objects, this shader instancing implementation stores only 80 times the object, 
		and then re-uses the vertex data with different shader parameter.
		Although you save memory, you make more draw call. However, you still 
		make less draw calls than if you were rendering each object independently.
		Plus, you can move the batched objects independently of one another which 
		you cannot do with StaticGeometry.
	@par
		Therefore it is important when you are rendering a lot of geometry to 
		batch things up into as few rendering calls as possible. This
		class allows you to build a batched object from a series of entities 
		in order to benefit from this behaviour.
		Batching has implications of it's own though:
		@li Batched geometry cannot be subdivided; that means that the whole
			group will be displayed, or none of it will. This obivously has
			culling issues.
		@li A single material must apply for each batch. In fact this class 
			allows you to use multiple materials, but you should be aware that 
			internally this means that there is one batch per material. 
			Therefore you won't gain as much benefit from the batching if you 
			use many different materials; try to keep the number down.
	@par
		The bounding box information is computed whith object position only. 
		It doesn't take account of the object orientation. 
	@par
		The LOD settings of both the Mesh and the Materials used in 
		constructing this instanced geometry will be respected. This means that 
		if you use meshes/materials which have LOD, batches in the distance 
		will have a lower polygon count or material detail to those in the 
		foreground. Since each mesh might have different LOD distances, during 
		build the furthest distance at each LOD level from all meshes  
		in that BatchInstance is used. This means all the LOD levels change at the 
		same time, but at the furthest distance of any of them (so quality is 
		not degraded). Be aware that using Mesh LOD in this class will 
		further increase the memory required. Only generated LOD
		is supported for meshes.
	@par
		There are 2 ways you can add geometry to this class; you can add
		Entity objects directly with predetermined positions, scales and 
		orientations, or you can add an entire SceneNode and it's subtree, 
		including all the objects attached to it. Once you've added everthing
		you need to, you have to call build() the fix the geometry in place. 
	@par
		You should not construct instances of this class directly; instead, call 
		SceneManager::createInstancedGeometry, which gives the SceneManager the 
		option of providing you with a specialised version of this class if it
		wishes, and also handles the memory management for you like other 
		classes.
    @note
		Warning: this class only works with indexed triangle lists at the moment,		do not pass it triangle strips, fans or lines / points, or unindexed geometry.

</member>
        <member name="M:Ogre.SkeletonInstance.unloadImpl">
Overridden from Skeleton

</member>
        <member name="M:Ogre.SkeletonInstance.loadImpl">
Overridden from Skeleton

</member>
        <member name="F:Ogre.SkeletonInstance.mNextTagPointAutoHandle">
TagPoint automatic handles
</member>
        <member name="F:Ogre.SkeletonInstance.mFreeTagPoints">
Free tag point list.
        @remarks
            This contains a list of the tag points free for use as new instances
            as required by the set. When a TagPoint instance is deactivated, there will be a reference on this
            list. As they get used this list reduces, as they get released back to to the set they get added
            back to the list.

</member>
        <member name="F:Ogre.SkeletonInstance.mSkeleton">
Pointer back to master Skeleton
</member>
        <member name="M:Ogre.SkeletonInstance.getGroup">
@copydoc Resource::getGroup
</member>
        <member name="M:Ogre.SkeletonInstance.getHandle">
@copydoc Resource::getHandle
</member>
        <member name="M:Ogre.SkeletonInstance.getName">
@copydoc Resource::getName
</member>
        <member name="M:Ogre.SkeletonInstance._refreshAnimationState(Ogre.AnimationStateSet*)">
@copydoc Skeleton::_refreshAnimationState
</member>
        <member name="M:Ogre.SkeletonInstance._initAnimationState(Ogre.AnimationStateSet*)">
@copydoc Skeleton::_initAnimationState
</member>
        <member name="M:Ogre.SkeletonInstance.getLinkedSkeletonAnimationSourceIterator">
@copydoc Skeleton::getLinkedSkeletonAnimationSourceIterator
</member>
        <member name="M:Ogre.SkeletonInstance.removeAllLinkedSkeletonAnimationSources">
@copydoc Skeleton::removeAllLinkedSkeletonAnimationSources
</member>
        <member name="M:Ogre.SkeletonInstance.addLinkedSkeletonAnimationSource(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
@copydoc Skeleton::addLinkedSkeletonAnimationSource
</member>
        <member name="M:Ogre.SkeletonInstance.freeTagPoint(Ogre.TagPoint*)">
Frees a TagPoint that already attached to a bone 
</member>
        <member name="M:Ogre.SkeletonInstance.createTagPointOnBone(Ogre.Bone*,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a TagPoint ready to be attached to a bone 
</member>
        <member name="M:Ogre.SkeletonInstance.removeAnimation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Removes an Animation from this skeleton. 
        @remarks
            This method updates the reference skeleton, not just this instance!

</member>
        <member name="M:Ogre.SkeletonInstance.getAnimation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.LinkedSkeletonAnimationSource!System.Runtime.CompilerServices.IsConst**)">
Returns the named Animation object. 
</member>
        <member name="M:Ogre.SkeletonInstance.createAnimation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Creates a new Animation object for animating this skeleton. 
        @remarks
            This method updates the reference skeleton, not just this instance!
        @param name The name of this animation
        @param length The length of the animation in seconds

</member>
        <member name="M:Ogre.SkeletonInstance._getAnimationImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.LinkedSkeletonAnimationSource!System.Runtime.CompilerServices.IsConst**)">
Internal accessor for animations (returns null if animation does not exist)
</member>
        <member name="M:Ogre.SkeletonInstance.getAnimation(System.UInt16)">
Gets a single animation by index. 
</member>
        <member name="M:Ogre.SkeletonInstance.getNumAnimations">
Gets the number of animations on this skeleton. 
</member>
        <member name="M:Ogre.SkeletonInstance.#ctor(Ogre.SkeletonPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor, don't call directly, this will be created automatically
        when you create an Entity based on a skeletally animated Mesh.

</member>
        <member name="T:Ogre.SkeletonInstance">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

A SkeletonInstance is a single instance of a Skeleton used by a world object.
    @remarks
        The difference between a Skeleton and a SkeletonInstance is that the
        Skeleton is the 'master' version much like Mesh is a 'master' version of
        Entity. Many SkeletonInstance objects can be based on a single Skeleton, 
        and are copies of it when created. Any changes made to this are not
        reflected in the master copy. The exception is animations; these are
        shared on the Skeleton itself and may not be modified here.

</member>
        <member name="M:Ogre.ShadowTextureManager.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.ShadowTextureManager.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.ShadowTextureManager.clear">
Dereference all the shadow textures kept in this class and remove them
			from TextureManager; note that it is up to the SceneManagers to clear 
			their local references.

</member>
        <member name="M:Ogre.ShadowTextureManager.clearUnused">
Remove any shadow textures that are no longer being referenced.
		@remarks
			This should be called fairly regularly since references may take a 
			little while to disappear in some cases (if referenced by materials)

</member>
        <member name="M:Ogre.ShadowTextureManager.getNullShadowTexture(Ogre.PixelFormat)">
Get an appropriately defined 'null' texture, i.e. one which will always
			result in no shadows.

</member>
        <member name="M:Ogre.ShadowTextureManager.getShadowTextures(std.vector&lt;Ogre.ShadowTextureConfig&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Ogre.TexturePtr&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Populate an incoming list with shadow texture references as requested
			in the configuration list.

</member>
        <member name="T:Ogre.ShadowTextureManager">
Class to manage the available shadow textures which may be shared between
		many SceneManager instances if formats agree.
	@remarks
		The management of the list of shadow textures has been separated out into
		a dedicated class to enable the clean management of shadow textures
		across many scene manager instances. Where multiple scene managers are
		used with shadow textures, the configuration of those shadows may or may
		not be consistent - if it is, it is good to centrally manage the textures
		so that creation and destruction responsibility is clear.

</member>
        <member name="T:Ogre.ShadowTextureConfig">
Structure containing the configuration for one shadow texture. 
</member>
        <member name="D:Ogre.ShadowTextureList">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

</member>
        <member name="M:Ogre.Rectangle2D.setNormals(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the normals of the rectangle

</member>
        <member name="M:Ogre.Rectangle2D.setCorners(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
Sets the corners of the rectangle, in relative coordinates.
        @param
        left Left position in screen relative coordinates, -1 = left edge, 1.0 = right edge
        @param top Top position in screen relative coordinates, 1 = top edge, -1 = bottom edge
        @param right Right position in screen relative coordinates
        @param bottom Bottom position in screen relative coordinates
		@param updateAABB Tells if you want to recalculate the AABB according to 
		the new corners. If false, the axis aligned bounding box will remain identical.

</member>
        <member name="M:Ogre.Rectangle2D.getWorldTransforms(Ogre.Matrix4*)">
Override this method to prevent parent transforms (rotation,translation,scale)

</member>
        <member name="T:Ogre.Rectangle2D">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Allows the rendering of a simple 2D rectangle
    This class renders a simple 2D rectangle; this rectangle has no depth and
    therefore is best used with specific render queue and depth settings,
    like RENDER_QUEUE_BACKGROUND and 'depth_write off' for backdrops, and 
    RENDER_QUEUE_OVERLAY and 'depth_check off' for fullscreen quads.

</member>
        <member name="M:Ogre.SimpleRenderable.getLights">
@copydoc Renderable::getLights 
</member>
        <member name="M:Ogre.SimpleRenderable.getMovableType">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.SimpleRenderable.visitRenderables(Ogre.Renderable.Visitor*,System.Boolean)">
@copydoc MovableObject::visitRenderables
</member>
        <member name="F:Ogre.SimpleRenderable.ms_uGenNameCount">
Static member used to automatically generate names for SimpleRendaerable objects.
</member>
        <member name="F:Ogre.SimpleRenderable.m_pCamera">
The camera for the current frame.
</member>
        <member name="F:Ogre.SimpleRenderable.m_pParentSceneManager">
The scene manager for the current frame.
</member>
        <member name="T:Ogre.SimpleRenderable">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Simple implementation of MovableObject and Renderable for single-part custom objects. 
	@see ManualObject for a simpler interface with more flexibility

</member>
        <member name="M:Ogre.AutoParamDataSource.getLightNumber(System.UInt32)">
Get the light which is 'index'th closest to the current object 
</member>
        <member name="M:Ogre.AutoParamDataSource.setCurrentPass(Ogre.Pass!System.Runtime.CompilerServices.IsConst*)">
Sets the current pass 
</member>
        <member name="M:Ogre.AutoParamDataSource.setCurrentSceneManager(Ogre.SceneManager!System.Runtime.CompilerServices.IsConst*)">
Set the current scene manager for enquiring on demand 
</member>
        <member name="M:Ogre.AutoParamDataSource.setMainCamBoundsInfo(Ogre.VisibleObjectsBoundsInfo*)">
Sets the main camera's scene bounding information 
</member>
        <member name="M:Ogre.AutoParamDataSource.setShadowDirLightExtrusionDistance(System.Single)">
Sets the shadow extrusion distance to be used for point lights. 
</member>
        <member name="M:Ogre.AutoParamDataSource.setCurrentViewport(Ogre.Viewport!System.Runtime.CompilerServices.IsConst*)">
Sets the current viewport 
</member>
        <member name="M:Ogre.AutoParamDataSource.setCurrentRenderTarget(Ogre.RenderTarget!System.Runtime.CompilerServices.IsConst*)">
Sets the current render target 
</member>
        <member name="M:Ogre.AutoParamDataSource.setTextureProjector(Ogre.Frustum!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Sets the current texture projector for a index 
</member>
        <member name="M:Ogre.AutoParamDataSource.setCurrentLightList(Ogre.HashedVector&lt;Ogre.Light**&gt;!System.Runtime.CompilerServices.IsConst*)">
Sets the light list that should be used, and it's base index from the global list 
</member>
        <member name="M:Ogre.AutoParamDataSource.setCurrentCamera(Ogre.Camera!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Updates the current camera 
</member>
        <member name="M:Ogre.AutoParamDataSource.setWorldMatrices(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Sets the world matrices, avoid query from renderable again 
</member>
        <member name="M:Ogre.AutoParamDataSource.setCurrentRenderable(Ogre.Renderable!System.Runtime.CompilerServices.IsConst*)">
Updates the current renderable 
</member>
        <member name="T:Ogre.AutoParamDataSource">
\addtogroup Core
	*  @{

\addtogroup Materials
	*  @{

This utility class is used to hold the information used to generate the matrices
    and other information required to automatically populate GpuProgramParameters.
    @remarks
        This class exercises a lazy-update scheme in order to avoid having to update all
        the information a GpuProgramParameters class could possibly want all the time. 
        It relies on the SceneManager to update it when the base data has changed, and
        will calculate concatenated matrices etc only when required, passing back precalculated
        matrices when they are requested more than once when the underlying information has
        not altered.

</member>
        <member name="M:Ogre.IntersectionSceneQuery.queryResult(Ogre.MovableObject*,Ogre.SceneQuery.WorldFragment*)">
Self-callback in order to deal with execute which returns collection. 
</member>
        <member name="M:Ogre.IntersectionSceneQuery.queryResult(Ogre.MovableObject*,Ogre.MovableObject*)">
Self-callback in order to deal with execute which returns collection. 
</member>
        <member name="M:Ogre.IntersectionSceneQuery.clearResults">
Clears the results of the last query execution.
        @remarks
            You only need to call this if you specifically want to free up the memory
            used by this object to hold the last query results. This object clears the
            results itself when executing and when destroying itself.

</member>
        <member name="M:Ogre.IntersectionSceneQuery.getLastResults">
Gets the results of the last query that was run using this object, provided
            the query was executed using the collection-returning version of execute. 

</member>
        <member name="M:Ogre.IntersectionSceneQuery.execute(Ogre.IntersectionSceneQueryListener*)">
Executes the query and returns each match through a listener interface. 
        @remarks
            Note that this method does not store the results of the query internally 
            so does not update the 'last result' value. This means that this version of
            execute is more lightweight and therefore more efficient than the version 
            which returns the results as a collection.

</member>
        <member name="M:Ogre.IntersectionSceneQuery.execute">
Executes the query, returning the results back in one list.
        @remarks
            This method executes the scene query as configured, gathers the results
            into one structure and returns a reference to that structure. These
            results will also persist in this query object until the next query is
            executed, or clearResults() is called. An more lightweight version of
            this method that returns results through a listener is also available.

</member>
        <member name="T:Ogre.IntersectionSceneQuery">
Separate SceneQuery class to query for pairs of objects which are
        possibly intersecting one another.
    @remarks
        This SceneQuery subclass considers the whole world and returns pairs of objects
        which are close enough to each other that they may be intersecting. Because of
        this slightly different focus, the return types and listener interface are
        different for this class.

</member>
        <member name="F:Ogre.IntersectionSceneQueryResult.movables2world">
List of movable / world intersections
</member>
        <member name="F:Ogre.IntersectionSceneQueryResult.movables2movables">
List of movable / movable intersections (entities, particle systems etc)
</member>
        <member name="T:Ogre.IntersectionSceneQueryResult">
Holds the results of an intersection scene query (pair values). 
</member>
        <member name="M:Ogre.IntersectionSceneQueryListener.queryResult(Ogre.MovableObject*,Ogre.SceneQuery.WorldFragment*)">
Called when a movable intersects a world fragment. 
        @remarks
            As with SceneQueryListener, the implementor of this method should return 'true'
            if further results are required, or 'false' to abandon any further results from
            the current query.

</member>
        <member name="M:Ogre.IntersectionSceneQueryListener.queryResult(Ogre.MovableObject*,Ogre.MovableObject*)">
Called when 2 movable objects intersect one another.
        @remarks
            As with SceneQueryListener, the implementor of this method should return 'true'
            if further results are required, or 'false' to abandon any further results from
            the current query.

</member>
        <member name="T:Ogre.IntersectionSceneQueryListener">
Alternative listener class for dealing with IntersectionSceneQuery.
    @remarks
        Because the IntersectionSceneQuery returns results in pairs, rather than singularly,
        the listener interface must be customised from the standard SceneQueryListener.

</member>
        <member name="M:Ogre.RaySceneQuery.queryResult(Ogre.SceneQuery.WorldFragment*,System.Single)">
Self-callback in order to deal with execute which returns collection. 
</member>
        <member name="M:Ogre.RaySceneQuery.queryResult(Ogre.MovableObject*,System.Single)">
Self-callback in order to deal with execute which returns collection. 
</member>
        <member name="M:Ogre.RaySceneQuery.clearResults">
Clears the results of the last query execution.
        @remarks
            You only need to call this if you specifically want to free up the memory
            used by this object to hold the last query results. This object clears the
            results itself when executing and when destroying itself.

</member>
        <member name="M:Ogre.RaySceneQuery.getLastResults">
Gets the results of the last query that was run using this object, provided
            the query was executed using the collection-returning version of execute. 

</member>
        <member name="M:Ogre.RaySceneQuery.execute(Ogre.RaySceneQueryListener*)">
Executes the query and returns each match through a listener interface. 
        @remarks
            Note that this method does not store the results of the query internally 
            so does not update the 'last result' value. This means that this version of
            execute is more lightweight and therefore more efficient than the version 
            which returns the results as a collection.

</member>
        <member name="M:Ogre.RaySceneQuery.execute">
Executes the query, returning the results back in one list.
        @remarks
            This method executes the scene query as configured, gathers the results
            into one structure and returns a reference to that structure. These
            results will also persist in this query object until the next query is
            executed, or clearResults() is called. An more lightweight version of
            this method that returns results through a listener is also available.

</member>
        <member name="M:Ogre.RaySceneQuery.getMaxResults">
Gets the maximum number of results returned from the query (only relevant if 
        results are being sorted) 
</member>
        <member name="M:Ogre.RaySceneQuery.getSortByDistance">
Gets whether the results are sorted by distance. 
</member>
        <member name="M:Ogre.RaySceneQuery.setSortByDistance(System.Boolean,System.UInt16)">
Sets whether the results of this query will be sorted by distance along the ray.
        @remarks
            Often you want to know what was the first object a ray intersected with, and this 
            method allows you to ask the query to sort the results so that the nearest results
            are listed first.
        @par
            Note that because the query returns results based on bounding volumes, the ray may not
            actually intersect the detail of the objects returned from the query, just their 
            bounding volumes. For this reason the caller is advised to use more detailed 
            intersection tests on the results if a more accurate result is required; OGRE uses 
            bounds checking in order to give the most speedy results since not all applications 
            need extreme accuracy.
        @param sort If true, results will be sorted.
        @param maxresults If sorting is enabled, this value can be used to constrain the maximum number
            of results that are returned. Please note (as above) that the use of bounding volumes mean that
            accuracy is not guaranteed; if in doubt, allow more results and filter them in more detail.
            0 means unlimited results.

</member>
        <member name="M:Ogre.RaySceneQuery.getRay">
Gets the ray which is to be used for this query. 
</member>
        <member name="M:Ogre.RaySceneQuery.setRay(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the ray which is to be used for this query. 
</member>
        <member name="T:Ogre.RaySceneQuery">
Specialises the SceneQuery class for querying along a ray. 
</member>
        <member name="M:Ogre.RaySceneQueryResultEntry.op_LessThan(Ogre.RaySceneQueryResultEntry!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Comparison operator for sorting
</member>
        <member name="F:Ogre.RaySceneQueryResultEntry.worldFragment">
The world fragment, or NULL if this is not a fragment result
</member>
        <member name="F:Ogre.RaySceneQueryResultEntry.movable">
The movable, or NULL if this is not a movable result
</member>
        <member name="F:Ogre.RaySceneQueryResultEntry.distance">
Distance along the ray
</member>
        <member name="T:Ogre.RaySceneQueryResultEntry">
This struct allows a single comparison of result data no matter what the type 
</member>
        <member name="M:Ogre.RaySceneQueryListener.queryResult(Ogre.SceneQuery.WorldFragment*,System.Single)">
Called when a world fragment is intersected by the ray. 
        @remarks
            As with SceneQueryListener, the implementor of this method should return 'true'
            if further results are required, or 'false' to abandon any further results from
            the current query.

</member>
        <member name="M:Ogre.RaySceneQueryListener.queryResult(Ogre.MovableObject*,System.Single)">
Called when a movable objects intersects the ray.
        @remarks
            As with SceneQueryListener, the implementor of this method should return 'true'
            if further results are required, or 'false' to abandon any further results from
            the current query.

</member>
        <member name="T:Ogre.RaySceneQueryListener">
Alternative listener class for dealing with RaySceneQuery.
    @remarks
        Because the RaySceneQuery returns results in an extra bit of information, namely
        distance, the listener interface must be customised from the standard SceneQueryListener.

</member>
        <member name="M:Ogre.PlaneBoundedVolumeListSceneQuery.getVolumes">
Gets the volume which is being used for this query. 
</member>
        <member name="M:Ogre.PlaneBoundedVolumeListSceneQuery.setVolumes(std.vector&lt;Ogre.PlaneBoundedVolume&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the volume which is to be used for this query. 
</member>
        <member name="T:Ogre.PlaneBoundedVolumeListSceneQuery">
Specialises the SceneQuery class for querying within a plane-bounded volume. 

</member>
        <member name="M:Ogre.SphereSceneQuery.getSphere">
Gets the sphere which is being used for this query. 
</member>
        <member name="M:Ogre.SphereSceneQuery.setSphere(Ogre.Sphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the sphere which is to be used for this query. 
</member>
        <member name="T:Ogre.SphereSceneQuery">
Specialises the SceneQuery class for querying within a sphere. 
</member>
        <member name="M:Ogre.AxisAlignedBoxSceneQuery.getBox">
Gets the box which is being used for this query. 
</member>
        <member name="M:Ogre.AxisAlignedBoxSceneQuery.setBox(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the size of the box you wish to query. 
</member>
        <member name="T:Ogre.AxisAlignedBoxSceneQuery">
Specialises the SceneQuery class for querying within an axis aligned box. 
</member>
        <member name="M:Ogre.RegionSceneQuery.queryResult(Ogre.SceneQuery.WorldFragment*)">
Self-callback in order to deal with execute which returns collection. 
</member>
        <member name="M:Ogre.RegionSceneQuery.queryResult(Ogre.MovableObject*)">
Self-callback in order to deal with execute which returns collection. 
</member>
        <member name="M:Ogre.RegionSceneQuery.clearResults">
Clears the results of the last query execution.
        @remarks
            You only need to call this if you specifically want to free up the memory
            used by this object to hold the last query results. This object clears the
            results itself when executing and when destroying itself.

</member>
        <member name="M:Ogre.RegionSceneQuery.getLastResults">
Gets the results of the last query that was run using this object, provided
            the query was executed using the collection-returning version of execute. 

</member>
        <member name="M:Ogre.RegionSceneQuery.execute(Ogre.SceneQueryListener*)">
Executes the query and returns each match through a listener interface. 
        @remarks
            Note that this method does not store the results of the query internally 
            so does not update the 'last result' value. This means that this version of
            execute is more lightweight and therefore more efficient than the version 
            which returns the results as a collection.

</member>
        <member name="M:Ogre.RegionSceneQuery.execute">
Executes the query, returning the results back in one list.
        @remarks
            This method executes the scene query as configured, gathers the results
            into one structure and returns a reference to that structure. These
            results will also persist in this query object until the next query is
            executed, or clearResults() is called. An more lightweight version of
            this method that returns results through a listener is also available.

</member>
        <member name="M:Ogre.RegionSceneQuery.#ctor(Ogre.SceneManager*)">
Standard constructor, should be called by SceneManager. 
</member>
        <member name="T:Ogre.RegionSceneQuery">
Abstract class defining a query which returns single results from a region. 
    @remarks
        This class is simply a generalisation of the subtypes of query that return 
        a set of individual results in a region. See the SceneQuery class for abstract
        information, and subclasses for the detail of each query type.

</member>
        <member name="F:Ogre.SceneQueryResult.worldFragments">
List of world fragments
</member>
        <member name="F:Ogre.SceneQueryResult.movables">
List of movable objects in the query (entities, particle systems etc)
</member>
        <member name="T:Ogre.SceneQueryResult">
Holds the results of a scene query. 
</member>
        <member name="M:Ogre.SceneQueryListener.queryResult(Ogre.SceneQuery.WorldFragment*)">
Called when a WorldFragment is returned by a query.
        @remarks
            The implementor should return 'true' to continue returning objects,
            or 'false' to abandon any further results from this query.

</member>
        <member name="M:Ogre.SceneQueryListener.queryResult(Ogre.MovableObject*)">
Called when a MovableObject is returned by a query.
        @remarks
            The implementor should return 'true' to continue returning objects,
            or 'false' to abandon any further results from this query.

</member>
        <member name="T:Ogre.SceneQueryListener">
This optional class allows you to receive per-result callbacks from
        SceneQuery executions instead of a single set of consolidated results.
    @remarks
        You should override this with your own subclass. Note that certain query
        classes may refine this listener interface.

</member>
        <member name="M:Ogre.SceneQuery.getSupportedWorldFragmentTypes">
Returns the types of world fragments this query supports. 
</member>
        <member name="M:Ogre.SceneQuery.getWorldFragmentType">
Gets the current world fragment types to be returned from the query. 
</member>
        <member name="M:Ogre.SceneQuery.setWorldFragmentType(Ogre.SceneQuery.WorldFragmentType)">
Tells the query what kind of world geometry to return from queries;
            often the full renderable geometry is not what is needed. 
        @remarks
            The application receiving the world geometry is expected to know 
            what to do with it; inevitably this means that the application must 
            have knowledge of at least some of the structures
            used by the custom SceneManager.
        @par
            The default setting is WFT_NONE.

</member>
        <member name="M:Ogre.SceneQuery.getQueryTypeMask">
Returns the current mask for this query. 
</member>
        <member name="M:Ogre.SceneQuery.setQueryTypeMask(System.UInt32)">
Sets the type mask for results of this query.
        @remarks
            This method allows you to set a 'type mask' to limit the results of this
            query to certain types of objects. Whilst setQueryMask deals with flags
			set per instance of object, this method deals with setting a mask on 
			flags set per type of object. Both may exclude an object from query
			results.

</member>
        <member name="M:Ogre.SceneQuery.getQueryMask">
Returns the current mask for this query. 
</member>
        <member name="M:Ogre.SceneQuery.setQueryMask(System.UInt32)">
Sets the mask for results of this query.
        @remarks
            This method allows you to set a 'mask' to limit the results of this
            query to certain types of result. The actual meaning of this value is
            up to the application; basically MovableObject instances will only be returned
            from this query if a bitwise AND operation between this mask value and the
            MovableObject::getQueryFlags value is non-zero. The application will
            have to decide what each of the bits means.

</member>
        <member name="M:Ogre.SceneQuery.#ctor(Ogre.SceneManager*)">
Standard constructor, should be called by SceneManager. 
</member>
        <member name="F:Ogre.SceneQuery.WorldFragment.renderOp">
General render operation structure, fallback if nothing else is available
</member>
        <member name="F:Ogre.SceneQuery.WorldFragment.geometry">
Custom geometry block, only applicable for WFT_CUSTOM_GEOMETRY
</member>
        <member name="F:Ogre.SceneQuery.WorldFragment.planes">
Planes bounding a convex region, only applicable for WFT_PLANE_BOUNDED_REGION
</member>
        <member name="F:Ogre.SceneQuery.WorldFragment.singleIntersection">
Single intersection point, only applicable for WFT_SINGLE_INTERSECTION
</member>
        <member name="F:Ogre.SceneQuery.WorldFragment.fragmentType">
The type of this world fragment
</member>
        <member name="T:Ogre.SceneQuery.WorldFragment">
Represents part of the world geometry that is a result of a SceneQuery. 
        @remarks
            Since world geometry is normally vast and sprawling, we need a way of
            retrieving parts of it based on a query. That is what this struct is for;
            note there are potentially as many data structures for world geometry as there
            are SceneManagers, however this structure includes a few common abstractions as 
            well as a more general format.
        @par
            The type of world fragment that is returned from a query depends on the
            SceneManager, and the option set using SceneQuery::setWorldFragmentType. 
            You can see what fragment types are supported on the query in question by
            calling SceneQuery::getSupportedWorldFragmentTypes().

</member>
        <member name="F:WFT_RENDER_OPERATION">
General RenderOperation structure
</member>
        <member name="F:WFT_CUSTOM_GEOMETRY">
Custom geometry as defined by the SceneManager
</member>
        <member name="F:WFT_SINGLE_INTERSECTION">
Return a single intersection point (typically RaySceneQuery only)
</member>
        <member name="F:WFT_PLANE_BOUNDED_REGION">
Return pointers to convex plane-bounded regions
</member>
        <member name="F:WFT_NONE">
Return no world geometry hits at all
</member>
        <member name="T:Ogre.SceneQuery">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

A class for performing queries on a scene.
    @remarks
        This is an abstract class for performing a query on a scene, i.e. to retrieve
        a list of objects and/or world geometry sections which are potentially intersecting a
        given region. Note the use of the word 'potentially': the results of a scene query
        are generated based on bounding volumes, and as such are not correct at a triangle
        level; the user of the SceneQuery is expected to filter the results further if
        greater accuracy is required.
    @par
        Different SceneManagers will implement these queries in different ways to
        exploit their particular scene organisation, and thus will provide their own
        concrete subclasses. In fact, these subclasses will be derived from subclasses
        of this class rather than directly because there will be region-type classes
        in between.
    @par
        These queries could have just been implemented as methods on the SceneManager,
        however, they are wrapped up as objects to allow 'compilation' of queries
        if deemed appropriate by the implementation; i.e. each concrete subclass may
        precalculate information (such as fixed scene partitions involved in the query)
        to speed up the repeated use of the query.
    @par
        You should never try to create a SceneQuery object yourself, they should be created
        using the SceneManager interfaces for the type of query required, e.g.
        SceneManager::createSphereSceneQuery.

</member>
        <member name="T:Ogre.RibbonTrailFactory">
Factory object for creating RibbonTrail instances 
</member>
        <member name="M:Ogre.RibbonTrail.resetAllTrails">
Reset all tracked chains to initial state
</member>
        <member name="M:Ogre.RibbonTrail.resetTrail(System.UInt32,Ogre.Node!System.Runtime.CompilerServices.IsConst*)">
Reset the tracked chain to initial state
</member>
        <member name="M:Ogre.RibbonTrail.updateTrail(System.UInt32,Ogre.Node!System.Runtime.CompilerServices.IsConst*)">
Node has changed position, update
</member>
        <member name="M:Ogre.RibbonTrail.manageController">
Manage updates to the time controller
</member>
        <member name="F:Ogre.RibbonTrail.mTimeControllerValue">
controller value for hooking up frame time to fader
</member>
        <member name="F:Ogre.RibbonTrail.mFadeController">
controller used to hook up frame time to fader
</member>
        <member name="F:Ogre.RibbonTrail.mDeltaWidth">
Delta width of the ribbon
</member>
        <member name="F:Ogre.RibbonTrail.mInitialWidth">
Initial width of the ribbon
</member>
        <member name="F:Ogre.RibbonTrail.mDeltaColour">
fade amount per second
</member>
        <member name="F:Ogre.RibbonTrail.mInitialColour">
Initial colour of the ribbon
</member>
        <member name="F:Ogre.RibbonTrail.mSquaredElemLength">
Squared length of each element
</member>
        <member name="F:Ogre.RibbonTrail.mElemLength">
length of each element
</member>
        <member name="F:Ogre.RibbonTrail.mTrailLength">
Total length of trail in world units
</member>
        <member name="F:Ogre.RibbonTrail.mNodeToChainSegment">
Ordered like mNodeList, contains chain index
</member>
        <member name="D:Ogre.RibbonTrail.IndexVector">
Mapping of nodes to chain segments
</member>
        <member name="F:Ogre.RibbonTrail.mNodeList">
List of nodes being trailed
</member>
        <member name="M:Ogre.RibbonTrail.getMovableType">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.RibbonTrail._timeUpdate(System.Single)">
Perform any fading / width delta required; internal method
</member>
        <member name="M:Ogre.RibbonTrail.nodeDestroyed(Ogre.Node!System.Runtime.CompilerServices.IsConst*)">
@see Node::Listener::nodeDestroyed
</member>
        <member name="M:Ogre.RibbonTrail.nodeUpdated(Ogre.Node!System.Runtime.CompilerServices.IsConst*)">
@see Node::Listener::nodeUpdated
</member>
        <member name="M:Ogre.RibbonTrail.getColourChange(System.UInt32)">
Get the per-second fading amount 
</member>
        <member name="M:Ogre.RibbonTrail.setColourChange(System.UInt32,System.Single,System.Single,System.Single,System.Single)">
Enables / disables fading the trail using colour. 
		@param chainIndex The index of the chain
		@param r,g,b,a The amount to subtract from each colour channel per second

</member>
        <member name="M:Ogre.RibbonTrail.getWidthChange(System.UInt32)">
Get the change in ribbon width per second. 
</member>
        <member name="M:Ogre.RibbonTrail.setWidthChange(System.UInt32,System.Single)">
Set the change in ribbon width per second. 
		@param chainIndex The index of the chain
		@param widthDeltaPerSecond The amount the width will reduce by per second

</member>
        <member name="M:Ogre.RibbonTrail.getInitialWidth(System.UInt32)">
Get the starting ribbon width in world units. 
</member>
        <member name="M:Ogre.RibbonTrail.setInitialWidth(System.UInt32,System.Single)">
Set the starting ribbon width in world units. 
		@param chainIndex The index of the chain
		@param width The initial width of the ribbon

</member>
        <member name="M:Ogre.RibbonTrail.setColourChange(System.UInt32,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Enables / disables fading the trail using colour. 
		@param chainIndex The index of the chain
		@param valuePerSecond The amount to subtract from colour each second

</member>
        <member name="M:Ogre.RibbonTrail.getInitialColour(System.UInt32)">
Get the starting ribbon colour. 
</member>
        <member name="M:Ogre.RibbonTrail.setInitialColour(System.UInt32,System.Single,System.Single,System.Single,System.Single)">
Set the starting ribbon colour. 
		@param chainIndex The index of the chain
		@param r,b,g,a The initial colour
		@note
			Only used if this instance is using vertex colours.

</member>
        <member name="M:Ogre.RibbonTrail.setInitialColour(System.UInt32,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the starting ribbon colour for a given segment. 
		@param chainIndex The index of the chain
		@param col The initial colour
		@note
			Only used if this instance is using vertex colours.

</member>
        <member name="M:Ogre.RibbonTrail.clearChain(System.UInt32)">
@copydoc BillboardChain::clearChain 
</member>
        <member name="M:Ogre.RibbonTrail.setNumberOfChains(System.UInt32)">
@copydoc BillboardChain::setNumberOfChains 
</member>
        <member name="M:Ogre.RibbonTrail.setMaxChainElements(System.UInt32)">
@copydoc BillboardChain::setMaxChainElements 
</member>
        <member name="M:Ogre.RibbonTrail.getTrailLength">
Get the length of the trail. 
</member>
        <member name="M:Ogre.RibbonTrail.setTrailLength(System.Single)">
Set the length of the trail. 
		@remarks
			This sets the length of the trail, in world units. It also sets how
			far apart each segment will be, ie length / max_elements. 
		@param len The length of the trail in world units

</member>
        <member name="M:Ogre.RibbonTrail.getChainIndexForNode(Ogre.Node!System.Runtime.CompilerServices.IsConst*)">
Get the chain index for a given Node being tracked. 
</member>
        <member name="M:Ogre.RibbonTrail.getNodeIterator">
Get an iterator over the nodes which are being tracked. 
</member>
        <member name="M:Ogre.RibbonTrail.removeNode(Ogre.Node*)">
Remove tracking on a given node. 
</member>
        <member name="M:Ogre.RibbonTrail.addNode(Ogre.Node*)">
Add a node to be tracked.
		@param n The node that will be tracked.

</member>
        <member name="M:Ogre.RibbonTrail.Dispose">
destructor
</member>
        <member name="M:Ogre.RibbonTrail.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,System.Boolean)">
Constructor (don't use directly, use factory) 
		@param name The name to give this object
		@param maxElements The maximum number of elements per chain
		@param numberOfChains The number of separate chain segments contained in this object,
			ie the maximum number of nodes that can have trails attached
		@param useTextureCoords If true, use texture coordinates from the chain elements
		@param useVertexColours If true, use vertex colours from the chain elements (must
			be true if you intend to use fading)

</member>
        <member name="T:Ogre.RibbonTrail">
\addtogroup Core
	*  @{

\addtogroup Effects
	*  @{

Subclass of BillboardChain which automatically leaves a trail behind
		one or more Node instances.
	@remarks
		An instance of this class will watch one or more Node instances, and
		automatically generate a trail behind them as they move. Because this
		class can monitor multiple modes, it generates its own geometry in 
		world space and thus, even though it has to be attached to a SceneNode
		to be visible, changing the position of the scene node it is attached to
		makes no difference to the geometry rendered.
	@par
		The 'head' element grows smoothly in size until it reaches the required size,
		then a new element is added. If the segment is full, the tail element
		shrinks by the same proportion as the head grows before disappearing.
	@par
		Elements can be faded out on a time basis, either by altering their colour
		or altering their alpha. The width can also alter over time.
	@par
		'v' texture coordinates are fixed at 0.0 if used, meaning that you can
		use a 1D texture to 'smear' a colour pattern along the ribbon if you wish.
		The 'u' coordinates are by default (0.0, 1.0), but you can alter this 
		using setOtherTexCoordRange if you wish.

</member>
        <member name="M:Ogre.ResourceBackgroundQueue.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.ResourceBackgroundQueue.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.ResourceBackgroundQueue.handleResponse(Ogre.WorkQueue.Response!System.Runtime.CompilerServices.IsConst*,Ogre.WorkQueue!System.Runtime.CompilerServices.IsConst*)">
Implementation for WorkQueue::ResponseHandler
</member>
        <member name="M:Ogre.ResourceBackgroundQueue.canHandleResponse(Ogre.WorkQueue.Response!System.Runtime.CompilerServices.IsConst*,Ogre.WorkQueue!System.Runtime.CompilerServices.IsConst*)">
Implementation for WorkQueue::ResponseHandler
</member>
        <member name="M:Ogre.ResourceBackgroundQueue.handleRequest(Ogre.WorkQueue.Request!System.Runtime.CompilerServices.IsConst*,Ogre.WorkQueue!System.Runtime.CompilerServices.IsConst*)">
Implementation for WorkQueue::RequestHandler
</member>
        <member name="M:Ogre.ResourceBackgroundQueue.canHandleRequest(Ogre.WorkQueue.Request!System.Runtime.CompilerServices.IsConst*,Ogre.WorkQueue!System.Runtime.CompilerServices.IsConst*)">
Implementation for WorkQueue::RequestHandler
</member>
        <member name="M:Ogre.ResourceBackgroundQueue.abortRequest(System.UInt64)">
Aborts background process.

</member>
        <member name="M:Ogre.ResourceBackgroundQueue.isProcessComplete(System.UInt64)">
Returns whether a previously queued process has completed or not. 
		@remarks
			This method of checking that a background process has completed is
			the 'polling' approach. Each queued method takes an optional listener
			parameter to allow you to register a callback instead, which is
			arguably more efficient.
		@param ticket The ticket which was returned when the process was queued
		@returns true if process has completed (or if the ticket is 
			unrecognised), false otherwise
		@note Tickets are not stored once complete so do not accumulate over 
			time.
		This is why a non-existent ticket will return 'true'.

</member>
        <member name="M:Ogre.ResourceBackgroundQueue.load(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtim">
Load a single resource in the background. 
		@see ResourceManager::load
		@param resType The type of the resource 
			(from ResourceManager::getResourceType())
		@param name The name of the Resource
		@param group The resource group to which this resource will belong
		@param isManual Is the resource to be manually loaded? If so, you should
			provide a value for the loader parameter
		@param loader The manual loader which is to perform the required actions
			when this resource is loaded; only applicable when you specify true
			for the previous parameter. NOTE: must be thread safe!!
        @param loadParams Optional pointer to a list of name/value pairs 
            containing loading parameters for this type of resource. Remember 
			that this must have a lifespan longer than the return of this call!

</member>
        <member name="M:Ogre.ResourceBackgroundQueue.prepare(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Run">
Prepare a single resource in the background. 
		@see ResourceManager::prepare
		@param resType The type of the resource 
			(from ResourceManager::getResourceType())
		@param name The name of the Resource
		@param group The resource group to which this resource will belong
		@param isManual Is the resource to be manually loaded? If so, you should
			provide a value for the loader parameter
		@param loader The manual loader which is to perform the required actions
			when this resource is loaded; only applicable when you specify true
			for the previous parameter. NOTE: must be thread safe!!
        @param loadParams Optional pointer to a list of name/value pairs 
            containing loading parameters for this type of resource. Remember 
			that this must have a lifespan longer than the return of this call!

</member>
        <member name="M:Ogre.ResourceBackgroundQueue.unloadResourceGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ResourceBackgroundQueue.Listener*)">
Unloads a resource group in the background.
		@see ResourceGroupManager::unloadResourceGroup
		@param name The name of the resource group to load
		@returns Ticket identifying the request, use isProcessComplete() to 
			determine if completed if not using listener

</member>
        <member name="M:Ogre.ResourceBackgroundQueue.unload(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,Ogre.ResourceBackgroundQueue.Listener*)">
Unload a single resource in the background. 
		@see ResourceManager::unload
		@param resType The type of the resource 
			(from ResourceManager::getResourceType())
		@param handle Handle to the resource 

</member>
        <member name="M:Ogre.ResourceBackgroundQueue.unload(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ResourceBackgroundQueue.Listener*)">
Unload a single resource in the background. 
		@see ResourceManager::unload
		@param resType The type of the resource 
			(from ResourceManager::getResourceType())
		@param name The name of the Resource

</member>
        <member name="M:Ogre.ResourceBackgroundQueue.loadResourceGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ResourceBackgroundQueue.Listener*)">
Loads a resource group in the background.
		@see ResourceGroupManager::loadResourceGroup
		@param name The name of the resource group to load
		@param listener Optional callback interface, take note of warnings in 
			the header and only use if you understand them.
		@returns Ticket identifying the request, use isProcessComplete() to 
			determine if completed if not using listener

</member>
        <member name="M:Ogre.ResourceBackgroundQueue.prepareResourceGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ResourceBackgroundQueue.Listener*)">
Prepares a resource group in the background.
		@see ResourceGroupManager::prepareResourceGroup
		@param name The name of the resource group to prepare
		@param listener Optional callback interface, take note of warnings in 
			the header and only use if you understand them.
		@returns Ticket identifying the request, use isProcessComplete() to 
			determine if completed if not using listener

</member>
        <member name="M:Ogre.ResourceBackgroundQueue.initialiseAllResourceGroups(Ogre.ResourceBackgroundQueue.Listener*)">
Initialise all resource groups which are yet to be initialised in 
			the background.
		@see ResourceGroupManager::intialiseResourceGroup
		@param listener Optional callback interface, take note of warnings in 
			the header and only use if you understand them.
		@returns Ticket identifying the request, use isProcessComplete() to 
			determine if completed if not using listener

</member>
        <member name="M:Ogre.ResourceBackgroundQueue.initialiseResourceGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ResourceBackgroundQueue.Listener*)">
Initialise a resource group in the background.
		@see ResourceGroupManager::initialiseResourceGroup
		@param name The name of the resource group to initialise
		@param listener Optional callback interface, take note of warnings in 
			the header and only use if you understand them.
		@returns Ticket identifying the request, use isProcessComplete() to 
			determine if completed if not using listener

</member>
        <member name="M:Ogre.ResourceBackgroundQueue.shutdown">
Shut down the background queue system. 
		@note Called automatically by Root::shutdown.

</member>
        <member name="M:Ogre.ResourceBackgroundQueue.initialise">
Initialise the background queue system. 
		@note Called automatically by Root::initialise.

</member>
        <member name="T:Ogre.ResourceBackgroundQueue.ResourceResponse">
Struct that holds details of queued notifications
</member>
        <member name="T:Ogre.ResourceBackgroundQueue.ResourceRequest">
Encapsulates a queued request for the background queue 
</member>
        <member name="T:Ogre.ResourceBackgroundQueue.RequestType">
Enumerates the type of requests 
</member>
        <member name="M:Ogre.ResourceBackgroundQueue.Listener.Dispose">
Need virtual destructor in case subclasses use it
</member>
        <member name="M:Ogre.ResourceBackgroundQueue.Listener.operationCompleted(System.UInt64,Ogre.BackgroundProcessResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when a requested operation completes, queued into main thread. 
			@note
				For simplicity, this callback is not issued direct from the background
				loading thread, it is queued to be sent from the main thread
				so that you don't have to be concerned about thread safety. 

</member>
        <member name="T:Ogre.ResourceBackgroundQueue.Listener">
This abstract listener interface lets you get notifications of
		completed background processes instead of having to poll ticket 
		statuses.
		@note
		For simplicity, these callbacks are not issued direct from the background
		loading thread, they are queued themselves to be sent from the main thread
		so that you don't have to be concerned about thread safety. 

</member>
        <member name="T:Ogre.ResourceBackgroundQueue">
This class is used to perform Resource operations in a
		background thread. 
	@remarks
		All these requests are now queued via Root::getWorkQueue in order
		to share the thread pool amongst all background tasks. You should therefore
		refer to that class for configuring the behaviour of the threads
		themselves, this class merely provides an interface that is specific
		to resource loading around this common functionality.
	@par
		The general approach here is that on requesting a background resource
		process, your request is placed on a queue ready for the background
		thread to be picked up, and you will get a 'ticket' back, identifying
		the request. Your call will then return and your thread can
		proceed, knowing that at some point in the background the operation will 
		be performed. In it's own thread, the resource operation will be 
		performed, and once finished the ticket will be marked as complete. 
		You can check the status of tickets by calling isProcessComplete() 
		from your queueing thread. 

</member>
        <member name="F:Ogre.BackgroundProcessResult.message">
Any messages from the process
</member>
        <member name="F:Ogre.BackgroundProcessResult.error">
Whether an error occurred
</member>
        <member name="T:Ogre.BackgroundProcessResult">
Encapsulates the result of a background queue request 
</member>
        <member name="D:Ogre.BackgroundProcessTicket">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

Identifier of a background process
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.addRequestWithRID(System.UInt64,System.UInt16,System.UInt16,Ogre.Any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte)">
Put a Request on the queue with a specific RequestID.
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.notifyWorkers">
Notify workers about a new request. 
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.RequestHandlerHolder.handleRequest(Ogre.WorkQueue.Request!System.Runtime.CompilerServices.IsConst*,Ogre.WorkQueue!System.Runtime.CompilerServices.IsConst*)">
Process a request if possible.
			@return Valid response if processed, null otherwise

</member>
        <member name="M:Ogre.DefaultWorkQueueBase.RequestHandlerHolder.getHandler">
Get handler pointer - note, only use this for == comparison or similar,
				do not attempt to call it as it is not thread safe. 

</member>
        <member name="T:Ogre.DefaultWorkQueueBase.RequestHandlerHolder">
Intermediate structure to hold a pointer to a request handler which 
			provides insurance against the handler itself being disconnected
			while the list remains unchanged.

</member>
        <member name="T:Ogre.DefaultWorkQueueBase.WorkerFunc">
Thread function
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.setResponseProcessingTimeLimit(System.UInt32!System.Runtime.CompilerServices.IsLong)">
@copydoc WorkQueue::setResponseProcessingTimeLimit
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.getResponseProcessingTimeLimit">
@copydoc WorkQueue::getResponseProcessingTimeLimit
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.processResponses">
@copydoc WorkQueue::processResponses
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.getRequestsAccepted">
@copydoc WorkQueue::getRequestsAccepted
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.setRequestsAccepted(System.Boolean)">
@copydoc WorkQueue::setRequestsAccepted
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.isPaused">
@copydoc WorkQueue::isPaused
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.setPaused(System.Boolean)">
@copydoc WorkQueue::setPaused
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.abortAllRequests">
@copydoc WorkQueue::abortAllRequests
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.abortRequestsByChannel(System.UInt16)">
@copydoc WorkQueue::abortRequestsByChannel
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.abortRequest(System.UInt64)">
@copydoc WorkQueue::abortRequest
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.addRequest(System.UInt16,System.UInt16,Ogre.Any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte,System.Boolean)">
@copydoc WorkQueue::addRequest
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.removeResponseHandler(System.UInt16,Ogre.WorkQueue.ResponseHandler*)">
@copydoc WorkQueue::removeResponseHandler
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.addResponseHandler(System.UInt16,Ogre.WorkQueue.ResponseHandler*)">
@copydoc WorkQueue::addResponseHandler
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.removeRequestHandler(System.UInt16,Ogre.WorkQueue.RequestHandler*)">
@copydoc WorkQueue::removeRequestHandler
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.addRequestHandler(System.UInt16,Ogre.WorkQueue.RequestHandler*)">
@copydoc WorkQueue::addRequestHandler
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.isShuttingDown">
Returns whether the queue is trying to shut down. 
</member>
        <member name="M:Ogre.DefaultWorkQueueBase._threadMain">
Main function for each thread spawned.
</member>
        <member name="M:Ogre.DefaultWorkQueueBase._processNextRequest">
Process the next request on the queue. 
		@remarks
			This method is public, but only intended for advanced users to call. 
			The only reason you would call this, is if you were using your 
			own thread to drive the worker processing. The thread calling this
			method will be the thread used to call the RequestHandler.

</member>
        <member name="M:Ogre.DefaultWorkQueueBase.setWorkersCanAccessRenderSystem(System.Boolean)">
Set whether worker threads will be allowed to access render system
			resources. 
			Accessing render system resources from a separate thread can require that
			a context is maintained for that thread. Also, it requires that the
			render system is running in threadsafe mode, which only happens
			when OGRE_THREAD_SUPPORT=1. This option defaults to false, which means
			that threads can not use GPU resources, and the render system can 
			work in non-threadsafe mode, which is more efficient.
			Calling this will have no effect unless the queue is shut down and
			restarted.

</member>
        <member name="M:Ogre.DefaultWorkQueueBase.getWorkersCanAccessRenderSystem">
Get whether worker threads will be allowed to access render system
			resources. 
			Accessing render system resources from a separate thread can require that
			a context is maintained for that thread. Also, it requires that the
			render system is running in threadsafe mode, which only happens
			when OGRE_THREAD_SUPPORT=1. This option defaults to false, which means
			that threads can not use GPU resources, and the render system can 
			work in non-threadsafe mode, which is more efficient.

</member>
        <member name="M:Ogre.DefaultWorkQueueBase.setWorkerThreadCount(System.UInt32)">
Set the number of worker threads that this queue will start
			when startup() is called (default 1).
			Calling this will have no effect unless the queue is shut down and
			restarted.

</member>
        <member name="M:Ogre.DefaultWorkQueueBase.getWorkerThreadCount">
Get the number of worker threads that this queue will start when 
			startup() is called. 

</member>
        <member name="M:Ogre.DefaultWorkQueueBase.getName">
Get the name of the work queue
</member>
        <member name="M:Ogre.DefaultWorkQueueBase.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor.
			Call startup() to initialise.
		@param name Optional name, just helps to identify logging output

</member>
        <member name="T:Ogre.DefaultWorkQueueBase">
Base for a general purpose request / response style background work queue.

</member>
        <member name="M:Ogre.WorkQueue.getChannel(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get a channel ID for a given channel name. 
		@remarks
			Channels are assigned on a first-come, first-served basis and are
			not persistent across application instances. This method allows 
			applications to not worry about channel clashes through manually
			assigned channel numbers.

</member>
        <member name="M:Ogre.WorkQueue.shutdown">
Shut down the queue.

</member>
        <member name="M:Ogre.WorkQueue.setResponseProcessingTimeLimit(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set the time limit imposed on the processing of responses in a
			single frame, in milliseconds (0 indicates no limit).
			This sets the maximum time that will be spent in processResponses() in 
			a single frame. The default is 8ms.

</member>
        <member name="M:Ogre.WorkQueue.getResponseProcessingTimeLimit">
Get the time limit imposed on the processing of responses in a
			single frame, in milliseconds (0 indicates no limit).

</member>
        <member name="M:Ogre.WorkQueue.processResponses">
Process the responses in the queue.
		@remarks
			This method is public, and must be called from the main render
			thread to 'pump' responses through the system. The method will usually
			try to clear all responses before returning = 0; however, you can specify
			a time limit on the response processing to limit the impact of
			spikes in demand by calling setResponseProcessingTimeLimit.

</member>
        <member name="M:Ogre.WorkQueue.getRequestsAccepted">
Returns whether requests are being accepted right now
</member>
        <member name="M:Ogre.WorkQueue.setRequestsAccepted(System.Boolean)">
Set whether to accept new requests or not. 
		If true, requests are added to the queue as usual. If false, requests
		are silently ignored until setRequestsAccepted(true) is called. 

</member>
        <member name="M:Ogre.WorkQueue.isPaused">
Return whether the queue is paused ie not sending more work to workers
</member>
        <member name="M:Ogre.WorkQueue.setPaused(System.Boolean)">
Set whether to pause further processing of any requests. 
		If true, any further requests will simply be queued and not processed until
		setPaused(false) is called. Any requests which are in the process of being
		worked on already will still continue. 

</member>
        <member name="M:Ogre.WorkQueue.abortAllRequests">
Abort all previously issued requests.
		Any requests still waiting to be processed will be removed from the queue.
		Any requests that are being processed will still complete.

</member>
        <member name="M:Ogre.WorkQueue.abortRequestsByChannel(System.UInt16)">
Abort all previously issued requests in a given channel.
		Any requests still waiting to be processed of the given channel, will be 
		removed from the queue.
		@param channel The type of request to be aborted

</member>
        <member name="M:Ogre.WorkQueue.abortRequest(System.UInt64)">
Abort a previously issued request.
		If the request is still waiting to be processed, it will be 
		removed from the queue.
		@param id The ID of the previously issued request.

</member>
        <member name="M:Ogre.WorkQueue.addRequest(System.UInt16,System.UInt16,Ogre.Any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte,System.Boolean)">
Add a new request to the queue.
		@param channel The channel this request will go into = 0; the channel is the top-level
			categorisation of the request
		@param requestType An identifier that's unique within this queue which
			identifies the type of the request (user decides the actual value)
		@param rData The data required by the request process. 
		@param retryCount The number of times the request should be retried
			if it fails.
		@param forceSynchronous Forces the request to be processed immediately
			even if threading is enabled.
		@returns The ID of the request that has been added

</member>
        <member name="M:Ogre.WorkQueue.removeResponseHandler(System.UInt16,Ogre.WorkQueue.ResponseHandler*)">
Remove a Response handler. 
</member>
        <member name="M:Ogre.WorkQueue.addResponseHandler(System.UInt16,Ogre.WorkQueue.ResponseHandler*)">
Add a response handler instance to the queue. 
		@remarks
			Every queue must have at least one response handler instance for each 
			channel in which requests are raised. If you add more than one, then you 
			must implement canHandleResponse differently in each if you wish them 
			to respond to different responses.
		@param channel The channel for responses you want to handle
		@param rh Your handler

</member>
        <member name="M:Ogre.WorkQueue.removeRequestHandler(System.UInt16,Ogre.WorkQueue.RequestHandler*)">
Remove a request handler. 
</member>
        <member name="M:Ogre.WorkQueue.addRequestHandler(System.UInt16,Ogre.WorkQueue.RequestHandler*)">
Add a request handler instance to the queue. 
		@remarks
			Every queue must have at least one request handler instance for each 
			channel in which requests are raised. If you 
			add more than one handler per channel, then you must implement canHandleRequest 
			differently	in each if you wish them to respond to different requests.
		@param channel The channel for requests you want to handle
		@param rh Your handler

</member>
        <member name="M:Ogre.WorkQueue.startup(System.Boolean)">
Start up the queue with the options that have been set.
		@param forceRestart If the queue is already running, whether to shut it
			down and restart.

</member>
        <member name="M:Ogre.WorkQueue.ResponseHandler.handleResponse(Ogre.WorkQueue.Response!System.Runtime.CompilerServices.IsConst*,Ogre.WorkQueue!System.Runtime.CompilerServices.IsConst*)">
The handler method every subclass must implement. 
			@param res The Response structure. The caller is responsible for
			deleting this after the call is made, none of the data contained
			(except pointers to structures in user Any data) will persist
			after this call is returned.
			@param srcQ The work queue that this request originated from

</member>
        <member name="M:Ogre.WorkQueue.ResponseHandler.canHandleResponse(Ogre.WorkQueue.Response!System.Runtime.CompilerServices.IsConst*,Ogre.WorkQueue!System.Runtime.CompilerServices.IsConst*)">
Return whether this handler can process a given response. 
			@remarks
			Defaults to true, but if you wish to add several handlers each of
			which deal with different types of response, you can override
			this method. 

</member>
        <member name="T:Ogre.WorkQueue.ResponseHandler">
Interface definition for a handler of responses. 
		@remarks
		User classes are expected to implement this interface in order to
		process responses from the queue. All calls to this class will be 
		in the main render thread and thus all GPU resources will be
		available. 

</member>
        <member name="M:Ogre.WorkQueue.RequestHandler.handleRequest(Ogre.WorkQueue.Request!System.Runtime.CompilerServices.IsConst*,Ogre.WorkQueue!System.Runtime.CompilerServices.IsConst*)">
The handler method every subclass must implement. 
			If a failure is encountered, return a Response with a failure
			result rather than raise an exception.
			@param req The Request structure, which is effectively owned by the
			handler during this call. It must be attached to the returned
			Response regardless of success or failure.
			@param srcQ The work queue that this request originated from
			@return Pointer to a Response object - the caller is responsible
			for deleting the object.

</member>
        <member name="M:Ogre.WorkQueue.RequestHandler.canHandleRequest(Ogre.WorkQueue.Request!System.Runtime.CompilerServices.IsConst*,Ogre.WorkQueue!System.Runtime.CompilerServices.IsConst*)">
Return whether this handler can process a given request. 
			@remarks
			Defaults to true, but if you wish to add several handlers each of
			which deal with different types of request, you can override
			this method. 

</member>
        <member name="T:Ogre.WorkQueue.RequestHandler">
Interface definition for a handler of requests. 
		@remarks
		User classes are expected to implement this interface in order to
		process requests on the queue. It's important to realise that
		the calls to this class may be in a separate thread to the main
		render context, and as such it may not be possible to make
		rendersystem or other GPU-dependent calls in this handler. You can only
		do so if the queue was created with 'workersCanAccessRenderSystem'
		set to true, and OGRE_THREAD_SUPPORT=1, but this puts extra strain
		on the thread safety of the render system and is not recommended.
		It is best to perform CPU-side work in these handlers and let the
		response handler transfer results to the GPU in the main render thread.

</member>
        <member name="M:Ogre.WorkQueue.Response.abortRequest">
Abort the request
</member>
        <member name="M:Ogre.WorkQueue.Response.getData">
Return the response data (user defined, only valid on success)
</member>
        <member name="M:Ogre.WorkQueue.Response.getMessages">
Get any diagnostic messages about the process
</member>
        <member name="M:Ogre.WorkQueue.Response.succeeded">
Return whether this is a successful response
</member>
        <member name="M:Ogre.WorkQueue.Response.getRequest">
Get the request that this is a response to (NB destruction destroys this)
</member>
        <member name="F:Ogre.WorkQueue.Response.mData">
Data associated with the result of the process
</member>
        <member name="F:Ogre.WorkQueue.Response.mMessages">
Any diagnostic messages
</member>
        <member name="F:Ogre.WorkQueue.Response.mSuccess">
Whether the work item succeeded or not
</member>
        <member name="F:Ogre.WorkQueue.Response.mRequest">
Pointer to the request that this response is in relation to
</member>
        <member name="T:Ogre.WorkQueue.Response">
General purpose response structure. 

</member>
        <member name="M:Ogre.WorkQueue.Request.getAborted">
Get the abort flag
</member>
        <member name="M:Ogre.WorkQueue.Request.getID">
Get the identifier of this request
</member>
        <member name="M:Ogre.WorkQueue.Request.getRetryCount">
Get the remaining retry count
</member>
        <member name="M:Ogre.WorkQueue.Request.getData">
Get the user details of this request
</member>
        <member name="M:Ogre.WorkQueue.Request.getType">
Get the type of this request within the given channel
</member>
        <member name="M:Ogre.WorkQueue.Request.getChannel">
Get the request channel (top level categorisation)
</member>
        <member name="M:Ogre.WorkQueue.Request.abortRequest">
Set the abort flag
</member>
        <member name="M:Ogre.WorkQueue.Request.#ctor(System.UInt16,System.UInt16,Ogre.Any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte,System.UInt64)">
Constructor 
</member>
        <member name="F:Ogre.WorkQueue.Request.mAborted">
Abort Flag
</member>
        <member name="F:Ogre.WorkQueue.Request.mID">
Identifier (assigned by the system)
</member>
        <member name="F:Ogre.WorkQueue.Request.mRetryCount">
Retry count - set this to non-zero to have the request try again on failure
</member>
        <member name="F:Ogre.WorkQueue.Request.mData">
The details of the request (user defined)
</member>
        <member name="F:Ogre.WorkQueue.Request.mType">
The request type, as an integer within the channel (user can define enumerations on this)
</member>
        <member name="F:Ogre.WorkQueue.Request.mChannel">
The request channel, as an integer 
</member>
        <member name="T:Ogre.WorkQueue.Request">
General purpose request structure. 

</member>
        <member name="D:Ogre.WorkQueue.RequestID">
Numeric identifier for a request
</member>
        <member name="T:Ogre.WorkQueue">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

Interface to a general purpose request / response style background work queue.
	@remarks
		A work queue is a simple structure, where requests for work are placed
		onto the queue, then removed by a worker for processing, then finally
		a response is placed on the result queue for the originator to pick up
		at their leisure. The typical use for this is in a threaded environment, 
		although any kind of deferred processing could use this approach to 
		decouple and distribute work over a period of time even 
		if it was single threaded.
	@par
		WorkQueues also incorporate thread pools. One or more background worker threads
		can wait on the queue and be notified when a request is waiting to be
		processed. For maximal thread usage, a WorkQueue instance should be shared
		among many sources of work, rather than many work queues being created.
		This way, you can share a small number of hardware threads among a large 
		number of background tasks. This doesn't mean you have to implement all the
		request processing in one class, you can plug in many handlers in order to
		process the requests.
	@par
		This is an abstract interface definition; users can subclass this and 
		provide their own implementation if required to centralise task management
		in their own subsystems. We also provide a default implementation in the
		form of DefaultWorkQueue.

</member>
        <member name="M:Ogre.RenderWindow._setPrimary">
Indicates that this is the primary window. Only to be called by
            Ogre::Root

</member>
        <member name="M:Ogre.RenderWindow.setDeactivateOnFocusChange(System.Boolean)">
Indicates whether the window will automatically deactivate itself when it loses focus.
          * \param deactivate a value of 'true' will cause the window to deactivate itself when it loses focus.  'false' will allow it to continue to render even when window focus is lost.
          * \note 'true' is the default behavior.

</member>
        <member name="M:Ogre.RenderWindow.isDeactivatedOnFocusChange">
Returns true if the window will automatically de-activate itself when it loses focus.

</member>
        <member name="M:Ogre.RenderWindow.suggestPixelFormat">
Override since windows don't usually have alpha
</member>
        <member name="M:Ogre.RenderWindow.getMetrics(System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Overloaded version of getMetrics from RenderTarget, including extra details
            specific to windowing systems.

</member>
        <member name="M:Ogre.RenderWindow.isFullScreen">
Returns true if window is running in fullscreen mode.

</member>
        <member name="M:Ogre.RenderWindow.isPrimary">
Indicates whether the window is the primary window. The
        	primary window is special in that it is destroyed when 
        	ogre is shut down, and cannot be destroyed directly.
        	This is the case because it holds the context for vertex,
        	index buffers and textures.

</member>
        <member name="M:Ogre.RenderWindow.isClosed">
Indicates whether the window has been closed by the user.

</member>
        <member name="M:Ogre.RenderWindow.isActive">
Overridden from RenderTarget, flags invisible windows as inactive

</member>
        <member name="M:Ogre.RenderWindow.setVisible(System.Boolean)">
Set the visibility state

</member>
        <member name="M:Ogre.RenderWindow.isVisible">
Indicates whether the window is visible (not minimized or obscured)

</member>
        <member name="M:Ogre.RenderWindow.reposition(System.Int32,System.Int32)">
Reposition the window.

</member>
        <member name="M:Ogre.RenderWindow.windowMovedOrResized">
Notify that the window has been resized
        @remarks
            You don't need to call this unless you created the window externally.

</member>
        <member name="M:Ogre.RenderWindow.resize(System.UInt32,System.UInt32)">
Alter the size of the window.

</member>
        <member name="M:Ogre.RenderWindow.destroy">
Destroys the window.

</member>
        <member name="M:Ogre.RenderWindow.setFullscreen(System.Boolean,System.UInt32,System.UInt32)">
Alter fullscreen mode options. 
		@note Nothing will happen unless the settings here are different from the
			current settings.
		@param fullScreen Whether to use fullscreen mode or not. 
		@param width The new width to use
		@param height The new height to use

</member>
        <member name="M:Ogre.RenderWindow.#ctor">
Default constructor.

</member>
        <member name="T:Ogre.RenderWindow">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

Manages the target rendering window.
        @remarks
            This class handles a window into which the contents
            of a scene are rendered. There is a many-to-1 relationship
            between instances of this class an instance of RenderSystem
            which controls the rendering of the scene. There may be
            more than one window in the case of level editor tools etc.
            This class is abstract since there may be
            different implementations for different windowing systems.
        @remarks
            Instances are created and communicated with by the render system
            although client programs can get a reference to it from
            the render system if required for resizing or moving.
            Note that you can have multiple viewpoints
            in the window for effects like rear-view mirrors and
            picture-in-picture views (see Viewport and Camera).
        @author
            Steven Streeting
        @version
            1.0

</member>
        <member name="M:Ogre.RenderTargetListener.viewportRemoved(Ogre.RenderTargetViewportEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called to notify listener that a Viewport has been removed from the 
			target in question.

</member>
        <member name="M:Ogre.RenderTargetListener.viewportAdded(Ogre.RenderTargetViewportEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called to notify listener that a Viewport has been added to the 
			target in question.

</member>
        <member name="M:Ogre.RenderTargetListener.postRenderTargetUpdate(Ogre.RenderTargetEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called just after a RenderTarget has been rendered to.
        @remarks
            This event is called just after all the viewports attached to the target
            in question have been rendered to. You can perform your own manual rendering
            commands in this event handler if you like, these will be composited with
            the contents of the target already there (depending on the material settings 
            you use etc).

</member>
        <member name="M:Ogre.RenderTargetListener.preRenderTargetUpdate(Ogre.RenderTargetEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called just before a RenderTarget is about to be rendered into.
        @remarks
            This event is raised just before any of the viewports on the target
            are rendered to. You can perform manual rendering operations here if
            you want, but please note that if the Viewport objects attached to this
            target are set up to clear the background, you will lose whatever you 
            render. If you want some kind of backdrop in this event
            you should turn off background clearing off on the viewports, and either
            clear the viewports yourself in this event handler before doing your rendering
            or just render over the top if you don't need to.

</member>
        <member name="F:Ogre.RenderTargetViewportEvent.source">
The source of the event being raised
</member>
        <member name="T:Ogre.RenderTargetViewportEvent">
Struct containing information about a RenderTarget Viewport-specific event.

</member>
        <member name="F:Ogre.RenderTargetEvent.source">
The source of the event being raised
</member>
        <member name="T:Ogre.RenderTargetEvent">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

Struct containing information about a RenderTarget event.

</member>
        <member name="M:Ogre.RenderSystem.initialiseFromRenderSystemCapabilities(Ogre.RenderSystemCapabilities*,Ogre.RenderTarget*)">
Initialize the render system from the capabilities
</member>
        <member name="M:Ogre.RenderSystem.setClipPlanesImpl(std.vector&lt;Ogre.Plane&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method used to set the underlying clip planes when needed
</member>
        <member name="F:Ogre.RenderSystem.mRealCapabilities">
Used to store the capabilities of the graphics card
</member>
        <member name="M:Ogre.RenderSystem.fireEvent(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerSer">
Internal method for firing a rendersystem event
</member>
        <member name="F:Ogre.RenderSystem.mEventNames">
List of names of events this rendersystem may raise
</member>
        <member name="M:Ogre.RenderSystem.updatePassIterationRenderState">
updates pass iteration rendering state including bound gpu program parameter
		pass iteration auto constant entry
		@returns True if more iterations are required

</member>
        <member name="F:Ogre.RenderSystem.mDerivedDepthBias">
Whether to update the depth bias per render call
</member>
        <member name="F:Ogre.RenderSystem.mCurrentPassIterationCount">
number of times to render the current state
</member>
        <member name="F:Ogre.RenderSystem.mDisabledTexUnitsFrom">
Texture units from this upwards are disabled
</member>
        <member name="F:Ogre.RenderSystem.mManualBlendColours">
Saved manual colour blends
</member>
        <member name="F:Ogre.RenderSystem.mActiveVertexGpuProgramParameters">
The Active GPU programs and gpu program parameters
</member>
        <member name="F:Ogre.RenderSystem.mActiveRenderTarget">
The Active render target. 
</member>
        <member name="F:Ogre.RenderSystem.mPrioritisedRenderTargets">
The render targets, ordered by priority. 
</member>
        <member name="F:Ogre.RenderSystem.mRenderTargets">
The render targets. 
</member>
        <member name="M:Ogre.RenderSystem.getDisplayMonitorCount">
		* Gets the number of display monitors.
		@see Root::getDisplayMonitorCount

</member>
        <member name="M:Ogre.RenderSystem.unregisterThread">
Unregister an additional thread which may make calls to rendersystem-related objects.
		@see RenderSystem::registerThread

</member>
        <member name="M:Ogre.RenderSystem.registerThread">
Register the an additional thread which may make calls to rendersystem-related 
		objects.
		@remarks
		This method should only be called by additional threads during their
		initialisation. If they intend to use hardware rendering system resources 
		they should call this method before doing anything related to the render system.
		Some rendering APIs require a per-thread setup and this method will sort that
		out. It is also necessary to call unregisterThread before the thread shuts down.
		@note
		This method takes no parameters - it must be called from the thread being
		registered and that context is enough.

</member>
        <member name="M:Ogre.RenderSystem.getRenderSystemEvents">
Gets a list of the rendersystem specific events that this rendersystem
		can raise.
		@see RenderSystem::addListener

</member>
        <member name="M:Ogre.RenderSystem.removeListener(Ogre.RenderSystem.Listener*)">
Remove a listener to the custom events that this render system can raise.

</member>
        <member name="M:Ogre.RenderSystem.addListener(Ogre.RenderSystem.Listener*)">
Adds a listener to the custom events that this render system can raise.
		@remarks
		Some render systems have quite specific, internally generated events 
		that the application may wish to be notified of. Many applications
		don't have to worry about these events, and can just trust OGRE to 
		handle them, but if you want to know, you can add a listener here.
		@par
		Events are raised very generically by string name. Perhaps the most 
		common example of a render system specific event is the loss and 
		restoration of a device in DirectX; which OGRE deals with, but you 
		may wish to know when it happens. 
		@see RenderSystem::getRenderSystemEvents

</member>
        <member name="M:Ogre.RenderSystem.Listener.eventOccurred(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtim">
A rendersystem-specific event occurred.
			@param eventName The name of the event which has occurred
			@param parameters A list of parameters that may belong to this event,
			may be null if there are no parameters

</member>
        <member name="T:Ogre.RenderSystem.Listener">
Defines a listener on the custom events that this render system 
		can raise.
		@see RenderSystem::addListener

</member>
        <member name="M:Ogre.RenderSystem._setRenderTarget(Ogre.RenderTarget*)">
Set current render target to target, enabling its device context if needed

</member>
        <member name="M:Ogre.RenderSystem.setDeriveDepthBias(System.Boolean,System.Single,System.Single,System.Single)">
Tell the render system whether to derive a depth bias on its own based on 
		the values passed to it in setCurrentPassIterationCount.
		The depth bias set will be baseValue + iteration * multiplier
		@param derive True to tell the RS to derive this automatically
		@param baseValue The base value to which the multiplier should be
		added
		@param multiplier The amount of depth bias to apply per iteration
		@param slopeScale The constant slope scale bias for completeness

</member>
        <member name="M:Ogre.RenderSystem.setCurrentPassIterationCount(System.UInt32!System.Runtime.CompilerServices.IsConst)">
set the current multi pass count value.  This must be set prior to 
		calling _render() if multiple renderings of the same pass state are 
		required.
		@param count Number of times to render the current state.

</member>
        <member name="M:Ogre.RenderSystem.getMaximumDepthInputValue">
Gets the maximum (farthest) depth value to be used when rendering
		using identity transforms.
		@remarks
		When using identity transforms you can manually set the depth
		of a vertex; however the input values required differ per
		rendersystem. This method lets you retrieve the correct value.
		@see Renderable::getUseIdentityView, Renderable::getUseIdentityProjection

</member>
        <member name="M:Ogre.RenderSystem.getMinimumDepthInputValue">
Gets the minimum (closest) depth value to be used when rendering
		using identity transforms.
		@remarks
		When using identity transforms you can manually set the depth
		of a vertex; however the input values required differ per
		rendersystem. This method lets you retrieve the correct value.
		@see Renderable::getUseIdentityView, Renderable::getUseIdentityProjection

</member>
        <member name="M:Ogre.RenderSystem.getVerticalTexelOffset">
Returns the vertical texel offset value required for mapping 
		texel origins to pixel origins in this rendersystem.
		@remarks
		Since rendersystems sometimes disagree on the origin of a texel, 
		mapping from texels to pixels can sometimes be problematic to 
		implement generically. This method allows you to retrieve the offset
		required to map the origin of a texel to the origin of a pixel in
		the vertical direction.

</member>
        <member name="M:Ogre.RenderSystem.getHorizontalTexelOffset">
Returns the horizontal texel offset value required for mapping 
		texel origins to pixel origins in this rendersystem.
		@remarks
		Since rendersystems sometimes disagree on the origin of a texel, 
		mapping from texels to pixels can sometimes be problematic to 
		implement generically. This method allows you to retrieve the offset
		required to map the origin of a texel to the origin of a pixel in
		the horizontal direction.

</member>
        <member name="M:Ogre.RenderSystem.clearFrameBuffer(System.UInt32,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.UInt16)">
Clears one or more frame buffers on the active render target. 
		@param buffers Combination of one or more elements of FrameBufferType
		denoting which buffers are to be cleared
		@param colour The colour to clear the colour buffer with, if enabled
		@param depth The value to initialise the depth buffer with, if enabled
		@param stencil The value to initialise the stencil buffer with, if enabled.

</member>
        <member name="M:Ogre.RenderSystem.setScissorTest(System.Boolean,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
Sets the 'scissor region' ie the region of the target in which rendering can take place.
		@remarks
		This method allows you to 'mask off' rendering in all but a given rectangular area
		as identified by the parameters to this method.
		@note
		Not all systems support this method. Check the RenderSystemCapabilities for the
		RSC_SCISSOR_TEST capability to see if it is supported.
		@param enabled True to enable the scissor test, false to disable it.
		@param left, top, right, bottom The location of the corners of the rectangle, expressed in
		<i>pixels</i>.

</member>
        <member name="M:Ogre.RenderSystem.getVertexWindingInverted">
Indicates whether or not the vertex windings set will be inverted for the current render (e.g. reflections)
		@see RenderSystem::setInvertVertexWinding

</member>
        <member name="M:Ogre.RenderSystem.setInvertVertexWinding(System.Boolean)">
Sets whether or not vertex windings set should be inverted; this can be important
		for rendering reflections. 
</member>
        <member name="M:Ogre.RenderSystem.getInvertVertexWinding">
Gets whether or not vertex windings set should be inverted; this can be important
		for rendering reflections. 
</member>
        <member name="M:Ogre.RenderSystem._swapAllRenderTargetBuffers(System.Boolean)">
Internal method for swapping all the buffers on all render targets,
		if _updateAllRenderTargets was called with a 'false' parameter. 
</member>
        <member name="M:Ogre.RenderSystem._updateAllRenderTargets(System.Boolean)">
Internal method for updating all render targets attached to this rendering system. 
</member>
        <member name="M:Ogre.RenderSystem._notifyCameraRemoved(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Utility method to notify all render targets that a camera has been removed, 
		in case they were referring to it as their viewer. 

</member>
        <member name="M:Ogre.RenderSystem._initRenderTargets">
Utility method for initialising all render targets attached to this rendering system. 
</member>
        <member name="M:Ogre.RenderSystem.resetClipPlanes">
Clears the user clipping region.

</member>
        <member name="M:Ogre.RenderSystem.addClipPlane(System.Single,System.Single,System.Single,System.Single)">
Add a user clipping plane. 
</member>
        <member name="M:Ogre.RenderSystem.addClipPlane(Ogre.Plane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add a user clipping plane. 
</member>
        <member name="M:Ogre.RenderSystem.setClipPlanes(std.vector&lt;Ogre.Plane&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the user clipping region.

</member>
        <member name="M:Ogre.RenderSystem.isGpuProgramBound(Ogre.GpuProgramType)">
Returns whether or not a Gpu program of the given type is currently bound. 
</member>
        <member name="M:Ogre.RenderSystem.unbindGpuProgram(Ogre.GpuProgramType)">
Unbinds GpuPrograms of a given GpuProgramType.
		@remarks
		This returns the pipeline to fixed-function processing for this type.

</member>
        <member name="M:Ogre.RenderSystem.bindGpuProgramPassIterationParameters(Ogre.GpuProgramType)">
Only binds Gpu program parameters used for passes that have more than one iteration rendering

</member>
        <member name="M:Ogre.RenderSystem.bindGpuProgramParameters(Ogre.GpuProgramType,Ogre.SharedPtr&lt;Ogre.GpuProgramParameters&gt;,System.UInt16)">
Bind Gpu program parameters.
		@param gptype The type of program to bind the parameters to
		@param params The parameters to bind
		@param variabilityMask A mask of GpuParamVariability identifying which params need binding

</member>
        <member name="M:Ogre.RenderSystem.bindGpuProgram(Ogre.GpuProgram*)">
Binds a given GpuProgram (but not the parameters). 
		@remarks Only one GpuProgram of each type can be bound at once, binding another
		one will simply replace the existing one.

</member>
        <member name="M:Ogre.RenderSystem.getDriverVersion">
Returns the driver version.

</member>
        <member name="M:Ogre.RenderSystem.getCapabilities">
Gets the capabilities of the render system. 
</member>
        <member name="M:Ogre.RenderSystem._render(Ogre.RenderOperation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
		Render something to the active viewport.

		Low-level rendering interface to perform rendering
		operations. Unlikely to be used directly by client
		applications, since the SceneManager and various support
		classes will be responsible for calling this method.
		Can only be called between _beginScene and _endScene

		@param op A rendering operation instance, which contains
		details of the operation to be performed.

</member>
        <member name="M:Ogre.RenderSystem.setNormaliseNormals(System.Boolean)">
Sets whether or not normals are to be automatically normalised.
		@remarks
		This is useful when, for example, you are scaling SceneNodes such that
		normals may not be unit-length anymore. Note though that this has an
		overhead so should not be turn on unless you really need it.
		@par
		You should not normally call this direct unless you are rendering
		world geometry; set it on the Renderable because otherwise it will be
		overridden by material settings. 

</member>
        <member name="M:Ogre.RenderSystem.setVertexBufferBinding(Ogre.VertexBufferBinding*)">
Sets the current vertex buffer binding state. 
</member>
        <member name="M:Ogre.RenderSystem.setVertexDeclaration(Ogre.VertexDeclaration*)">
Sets the current vertex declaration, ie the source of vertex data. 
</member>
        <member name="M:Ogre.RenderSystem.setStencilCheckEnabled(System.Boolean)">
Turns stencil buffer checking on or off. 
		@remarks
		Stencilling (masking off areas of the rendering target based on the stencil 
		buffer) can be turned on or off using this method. By default, stencilling is
		disabled.

</member>
        <member name="M:Ogre.RenderSystem._setPolygonMode(Ogre.PolygonMode)">
Sets how to rasterise triangles, as points, wireframe or solid polys. 
</member>
        <member name="M:Ogre.RenderSystem._applyObliqueDepthProjection(Ogre.Matrix4*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Plane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Update a perspective projection matrix to use 'oblique depth projection'.
		@remarks
		This method can be used to change the nature of a perspective 
		transform in order to make the near plane not perpendicular to the 
		camera view direction, but to be at some different orientation. 
		This can be useful for performing arbitrary clipping (e.g. to a 
		reflection plane) which could otherwise only be done using user
		clip planes, which are more expensive, and not necessarily supported
		on all cards.
		@param matrix The existing projection matrix. Note that this must be a
		perspective transform (not orthographic), and must not have already
		been altered by this method. The matrix will be altered in-place.
		@param plane The plane which is to be used as the clipping plane. This
		plane must be in CAMERA (view) space.
		@param forGpuProgram Is this for use with a Gpu program or fixed-function

</member>
        <member name="M:Ogre.RenderSystem._makeOrthoMatrix(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single,Ogre.Matrix4*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Builds an orthographic projection matrix suitable for this render system.
		@remarks
		Because different APIs have different requirements (some incompatible) for the
		projection matrix, this method allows each to implement their own correctly and pass
		back a generic OGRE matrix for storage in the engine.

</member>
        <member name="M:Ogre.RenderSystem._makeProjectionMatrix(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Ogre.Matrix4*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Builds a perspective projection matrix for the case when frustum is
		not centered around camera.
		@remarks
		Viewport coordinates are in camera coordinate frame, i.e. camera is 
		at the origin.

</member>
        <member name="M:Ogre.RenderSystem._makeProjectionMatrix(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single,Ogre.Matrix4*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Builds a perspective projection matrix suitable for this render system.
		@remarks
		Because different APIs have different requirements (some incompatible) for the
		projection matrix, this method allows each to implement their own correctly and pass
		back a generic OGRE matrix for storage in the engine.

</member>
        <member name="M:Ogre.RenderSystem._convertProjectionMatrix(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Matrix4*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Converts a uniform projection matrix to suitable for this render system.
		@remarks
		Because different APIs have different requirements (some incompatible) for the
		projection matrix, this method allows each to implement their own correctly and pass
		back a generic OGRE matrix for storage in the engine.

</member>
        <member name="M:Ogre.RenderSystem.getColourVertexElementType">
Get the native VertexElementType for a compact 32-bit colour value
		for this rendersystem.

</member>
        <member name="M:Ogre.RenderSystem.convertColourValue(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*)">
Generates a packed data version of the passed in ColourValue suitable for
		use as with this RenderSystem.
		@remarks
		Since different render systems have different colour data formats (eg
		RGBA for GL, ARGB for D3D) this method allows you to use 1 method for all.
		@param colour The colour to convert
		@param pDest Pointer to location to put the result.

</member>
        <member name="M:Ogre.RenderSystem._getVertexCount">
Reports the number of vertices passed to the renderer since the last _beginGeometryCount call. 
</member>
        <member name="M:Ogre.RenderSystem._getBatchCount">
Reports the number of batches rendered since the last _beginGeometryCount call. 
</member>
        <member name="M:Ogre.RenderSystem._getFaceCount">
Reports the number of tris rendered since the last _beginGeometryCount call. 
</member>
        <member name="M:Ogre.RenderSystem._beginGeometryCount">
The RenderSystem will keep a count of tris rendered, this resets the count. 
</member>
        <member name="M:Ogre.RenderSystem._setFog(Ogre.FogMode,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single)">
Sets the fogging mode for future geometry.
		@param mode Set up the mode of fog as described in the FogMode enum, or set to FOG_NONE to turn off.
		@param colour The colour of the fog. Either set this to the same as your viewport background colour,
		or to blend in with a skydome or skybox.
		@param expDensity The density of the fog in FOG_EXP or FOG_EXP2 mode, as a value between 0 and 1. The default is 1. i.e. completely opaque, lower values can mean
		that fog never completely obscures the scene.
		@param linearStart Distance at which linear fog starts to encroach. The distance must be passed
		as a parametric value between 0 and 1, with 0 being the near clipping plane, and 1 being the far clipping plane. Only applicable if mode is FOG_LINEAR.
		@param linearEnd Distance at which linear fog becomes completely opaque.The distance must be passed
		as a parametric value between 0 and 1, with 0 being the near clipping plane, and 1 being the far clipping plane. Only applicable if mode is FOG_LINEAR.

</member>
        <member name="M:Ogre.RenderSystem._setDepthBias(System.Single,System.Single)">
Sets the depth bias, NB you should use the Material version of this. 
		@remarks
		When polygons are coplanar, you can get problems with 'depth fighting' where
		the pixels from the two polys compete for the same screen pixel. This is particularly
		a problem for decals (polys attached to another surface to represent details such as
		bulletholes etc.).
		@par
		A way to combat this problem is to use a depth bias to adjust the depth buffer value
		used for the decal such that it is slightly higher than the true value, ensuring that
		the decal appears on top.
		@note
		The final bias value is a combination of a constant bias and a bias proportional
		to the maximum depth slope of the polygon being rendered. The final bias
		is constantBias + slopeScaleBias * maxslope. Slope scale biasing is
		generally preferable but is not available on older hardware.
		@param constantBias The constant bias value, expressed as a value in 
		homogeneous depth coordinates.
		@param slopeScaleBias The bias value which is factored by the maximum slope
		of the polygon, see the description above. This is not supported by all
		cards.


</member>
        <member name="M:Ogre.RenderSystem._setColourBufferWriteEnabled(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
Sets whether or not colour buffer writing is enabled, and for which channels. 
		@remarks
		For some advanced effects, you may wish to turn off the writing of certain colour
		channels, or even all of the colour channels so that only the depth buffer is updated
		in a rendering pass. However, the chances are that you really want to use this option
		through the Material class.
		@param red, green, blue, alpha Whether writing is enabled for each of the 4 colour channels. 
</member>
        <member name="M:Ogre.RenderSystem._setDepthBufferFunction(Ogre.CompareFunction)">
Sets the comparison function for the depth buffer check.
		Advanced use only - allows you to choose the function applied to compare the depth values of
		new and existing pixels in the depth buffer. Only an issue if the deoth buffer check is enabled
		(see _setDepthBufferCheckEnabled)
		@param  func The comparison between the new depth and the existing depth which must return true
		for the new pixel to be written.

</member>
        <member name="M:Ogre.RenderSystem._setDepthBufferWriteEnabled(System.Boolean)">
Sets whether or not the depth buffer is updated after a pixel write.
		@param enabled If true, the depth buffer is updated with the depth of the new pixel if the depth test succeeds.
		If false, the depth buffer is left unchanged even if a new pixel is written.

</member>
        <member name="M:Ogre.RenderSystem._setDepthBufferCheckEnabled(System.Boolean)">
Sets whether or not the depth buffer check is performed before a pixel write.
		@param enabled If true, the depth buffer is tested for each pixel and the frame buffer is only updated
		if the depth function test succeeds. If false, no test is performed and pixels are always written.

</member>
        <member name="M:Ogre.RenderSystem._setDepthBufferParams(System.Boolean,System.Boolean,Ogre.CompareFunction)">
Sets the mode of operation for depth buffer tests from this point onwards.
		Sometimes you may wish to alter the behaviour of the depth buffer to achieve
		special effects. Because it's unlikely that you'll set these options for an entire frame,
		but rather use them to tweak settings between rendering objects, this is an internal
		method (indicated by the '_' prefix) which will be used by a SceneManager implementation
		rather than directly from the client application.
		If this method is never called the settings are automatically the same as the default parameters.
		@param depthTest If true, the depth buffer is tested for each pixel and the frame buffer is only updated
		if the depth function test succeeds. If false, no test is performed and pixels are always written.
		@param depthWrite If true, the depth buffer is updated with the depth of the new pixel if the depth test succeeds.
		If false, the depth buffer is left unchanged even if a new pixel is written.
		@param depthFunction Sets the function required for the depth test.

</member>
        <member name="M:Ogre.RenderSystem._setCullingMode(Ogre.CullingMode)">
Sets the culling mode for the render system based on the 'vertex winding'.
		A typical way for the rendering engine to cull triangles is based on the
		'vertex winding' of triangles. Vertex winding refers to the direction in
		which the vertices are passed or indexed to in the rendering operation as viewed
		from the camera, and will wither be clockwise or anticlockwise (that's 'counterclockwise' for
		you Americans out there ;) The default is CULL_CLOCKWISE i.e. that only triangles whose vertices
		are passed/indexed in anticlockwise order are rendered - this is a common approach and is used in 3D studio models
		for example. You can alter this culling mode if you wish but it is not advised unless you know what you are doing.
		You may wish to use the CULL_NONE option for mesh data that you cull yourself where the vertex
		winding is uncertain.

</member>
        <member name="M:Ogre.RenderSystem._getViewport">
Get the current active viewport for rendering. 
</member>
        <member name="M:Ogre.RenderSystem._setViewport(Ogre.Viewport*)">
		Sets the provided viewport as the active one for future
		rendering operations. This viewport is aware of it's own
		camera and render target. Must be implemented by subclass.

		@param target Pointer to the appropriate viewport.

</member>
        <member name="M:Ogre.RenderSystem._endFrame">
Ends rendering of a frame to the current viewport.

</member>
        <member name="M:Ogre.RenderSystem._resumeFrame(Ogre.RenderSystem.RenderSystemContext*)">
Resume rendering for a frame. This has to be called after a _pauseFrame call
Will usually be called by the SceneManager, don't use this manually unless you know what
you are doing.
@param context the render system context, as returned by _pauseFrame

</member>
        <member name="M:Ogre.RenderSystem._pauseFrame">
Pause rendering for a frame. This has to be called after _beginFrame and before _endFrame.
Will usually be called by the SceneManager, don't use this manually unless you know what
you are doing.

</member>
        <member name="M:Ogre.RenderSystem._beginFrame">
Signifies the beginning of a frame, i.e. the start of rendering on a single viewport. Will occur
several times per complete frame if multiple viewports exist.

</member>
        <member name="M:Ogre.RenderSystem._setTextureProjectionRelativeTo(System.Boolean,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Notify the rendersystem that it should adjust texture projection to be 
			relative to a different origin.

</member>
        <member name="M:Ogre.RenderSystem._setAlphaRejectSettings(Ogre.CompareFunction,System.Byte,System.Boolean)">
Sets the global alpha rejection approach for future renders.
		By default images are rendered regardless of texture alpha. This method lets you change that.
		@param func The comparison function which must pass for a pixel to be written.
		@param val The value to compare each pixels alpha value to (0-255)
		@param alphaToCoverage Whether to enable alpha to coverage, if supported

</member>
        <member name="M:Ogre.RenderSystem._setTextureMatrix(System.UInt32,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the texture coordinate transformation matrix for a texture unit.
		@param unit Texture unit to affect
		@param xform The 4x4 matrix

</member>
        <member name="M:Ogre.RenderSystem._setTextureMipmapBias(System.UInt32,System.Single)">
Sets the mipmap bias value for a given texture unit.
		@remarks
		This allows you to adjust the mipmap calculation up or down for a
		given texture unit. Negative values force a larger mipmap to be used, 
		positive values force a smaller mipmap to be used. Units are in numbers
		of levels, so +1 forces the mipmaps to one smaller level.
		@note Only does something if render system has capability RSC_MIPMAP_LOD_BIAS.

</member>
        <member name="M:Ogre.RenderSystem._setTextureBorderColour(System.UInt32,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the texture border colour for a texture unit.
</member>
        <member name="M:Ogre.RenderSystem._setTextureAddressingMode(System.UInt32,Ogre.TextureUnitState.UVWAddressingMode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the texture addressing mode for a texture unit.
</member>
        <member name="M:Ogre.RenderSystem._setTextureLayerAnisotropy(System.UInt32,System.UInt32)">
Sets the maximal anisotropy for the specified texture unit.
</member>
        <member name="M:Ogre.RenderSystem._setTextureUnitFiltering(System.UInt32,Ogre.FilterType,Ogre.FilterOptions)">
Sets a single filter for a given texture unit.
		@param unit The texture unit to set the filtering options for
		@param ftype The filter type
		@param filter The filter to be used

</member>
        <member name="M:Ogre.RenderSystem._setTextureUnitFiltering(System.UInt32,Ogre.FilterOptions,Ogre.FilterOptions,Ogre.FilterOptions)">
Sets the filtering options for a given texture unit.
		@param unit The texture unit to set the filtering options for
		@param minFilter The filter used when a texture is reduced in size
		@param magFilter The filter used when a texture is magnified
		@param mipFilter The filter used between mipmap levels, FO_NONE disables mipmapping

</member>
        <member name="M:Ogre.RenderSystem._setTextureBlendMode(System.UInt32,Ogre.LayerBlendModeEx!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the texture blend modes from a TextureUnitState record.
		Meant for use internally only - apps should use the Material
		and TextureUnitState classes.
		@param unit Texture unit as above
		@param bm Details of the blending mode

</member>
        <member name="M:Ogre.RenderSystem._setTextureCoordCalculation(System.UInt32,Ogre.TexCoordCalcMethod,Ogre.Frustum!System.Runtime.CompilerServices.IsConst*)">
Sets a method for automatically calculating texture coordinates for a stage.
Should not be used by apps - for use by Ogre only.
@param unit Texture unit as above
@param m Calculation method to use
@param frustum Optional Frustum param, only used for projective effects

</member>
        <member name="M:Ogre.RenderSystem._setTextureCoordSet(System.UInt32,System.UInt32)">
		Sets the texture coordinate set to use for a texture unit.

		Meant for use internally - not generally used directly by apps - the Material and TextureUnitState
		classes let you manage textures far more easily.

		@param unit Texture unit as above
		@param index The index of the texture coordinate set to use.

</member>
        <member name="M:Ogre.RenderSystem._setVertexTexture(System.UInt32,Ogre.TexturePtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Binds a texture to a vertex sampler.
		@remarks
		Not all rendersystems support separate vertex samplers. For those that
		do, you can set a texture for them, separate to the regular texture
		samplers, using this method. For those that don't, you should use the
		regular texture samplers which are shared between the vertex and
		fragment units; calling this method will throw an exception.
		@see RenderSystemCapabilites::getVertexTextureUnitsShared

</member>
        <member name="M:Ogre.RenderSystem._setTexture(System.UInt32,System.Boolean,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
		Sets the texture to bind to a given texture unit.

		User processes would not normally call this direct unless rendering
		primitives themselves.

		@param unit The index of the texture unit to modify. Multitexturing 
		hardware can support multiple units (see 
		RenderSystemCapabilites::getNumTextureUnits)
		@param enabled Boolean to turn the unit on/off
		@param texname The name of the texture to use - this should have
		already been loaded with TextureManager::load.

</member>
        <member name="M:Ogre.RenderSystem._setTexture(System.UInt32,System.Boolean,Ogre.TexturePtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
		Sets the texture to bind to a given texture unit.

		User processes would not normally call this direct unless rendering
		primitives themselves.

		@param unit The index of the texture unit to modify. Multitexturing 
		hardware can support multiple units (see 
		RenderSystemCapabilites::getNumTextureUnits)
		@param enabled Boolean to turn the unit on/off
		@param texPtr Pointer to the texture to use.

</member>
        <member name="M:Ogre.RenderSystem._setPointParameters(System.Single,System.Boolean,System.Single,System.Single,System.Single,System.Single,System.Single)">
Sets the size of points and how they are attenuated with distance.
		@remarks
		When performing point rendering or point sprite rendering,
		point size can be attenuated with distance. The equation for
		doing this is attenuation = 1 / (constant + linear * dist + quadratic * d^2) .
		@par
		For example, to disable distance attenuation (constant screensize) 
		you would set constant to 1, and linear and quadratic to 0. A
		standard perspective attenuation would be 0, 1, 0 respectively.

</member>
        <member name="M:Ogre.RenderSystem._setPointSpritesEnabled(System.Boolean)">
Sets whether or not rendering points using OT_POINT_LIST will 
		render point sprites (textured quads) or plain points.
		@param enabled True enables point sprites, false returns to normal
		point rendering.

</member>
        <member name="M:Ogre.RenderSystem._setSurfaceParams(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Int32)">
Sets the surface properties to be used for future rendering.

		This method sets the the properties of the surfaces of objects
		to be rendered after it. In this context these surface properties
		are the amount of each type of light the object reflects (determining
		it's colour under different types of light), whether it emits light
		itself, and how shiny it is. Textures are not dealt with here,
		see the _setTetxure method for details.
		This method is used by _setMaterial so does not need to be called
		direct if that method is being used.

		@param ambient The amount of ambient (sourceless and directionless)
		light an object reflects. Affected by the colour/amount of ambient light in the scene.
		@param diffuse The amount of light from directed sources that is
		reflected (affected by colour/amount of point, directed and spot light sources)
		@param specular The amount of specular light reflected. This is also
		affected by directed light sources but represents the colour at the
		highlights of the object.
		@param emissive The colour of light emitted from the object. Note that
		this will make an object seem brighter and not dependent on lights in
		the scene, but it will not act as a light, so will not illuminate other
		objects. Use a light attached to the same SceneNode as the object for this purpose.
		@param shininess A value which only has an effect on specular highlights (so
		specular must be non-black). The higher this value, the smaller and crisper the
		specular highlights will be, imitating a more highly polished surface.
		This value is not constrained to 0.0-1.0, in fact it is likely to
		be more (10.0 gives a modest sheen to an object).
		@param tracking A bit field that describes which of the ambient, diffuse, specular
		and emissive colours follow the vertex colour of the primitive. When a bit in this field is set
		its ColourValue is ignored. This is a combination of TVC_AMBIENT, TVC_DIFFUSE, TVC_SPECULAR(note that the shininess value is still
		taken from shininess) and TVC_EMISSIVE. TVC_NONE means that there will be no material property
		tracking the vertex colours.

</member>
        <member name="M:Ogre.RenderSystem._disableTextureUnitsFrom(System.UInt32)">
Disables all texture units from the given unit upwards 
</member>
        <member name="M:Ogre.RenderSystem._disableTextureUnit(System.UInt32)">
Turns off a texture unit. 
</member>
        <member name="M:Ogre.RenderSystem._setTextureUnitSettings(System.UInt32,Ogre.TextureUnitState*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Utility function for setting all the properties of a texture unit at once.
		This method is also worth using over the individual texture unit settings because it
		only sets those settings which are different from the current settings for this
		unit, thus minimising render state changes.

</member>
        <member name="M:Ogre.RenderSystem._setProjectionMatrix(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the projection transform matrix 
</member>
        <member name="M:Ogre.RenderSystem._setViewMatrix(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the view transform matrix 
</member>
        <member name="M:Ogre.RenderSystem._setWorldMatrices(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*,System.UInt16)">
Sets multiple world matrices (vertex blending). 
</member>
        <member name="M:Ogre.RenderSystem._setWorldMatrix(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the world transform matrix. 
</member>
        <member name="M:Ogre.RenderSystem.areFixedFunctionLightsInViewSpace">
Are fixed-function lights provided in view space? Affects optimisation. 

</member>
        <member name="M:Ogre.RenderSystem._useLights(Ogre.HashedVector&lt;Ogre.Light**&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16)">
Tells the rendersystem to use the attached set of lights (and no others) 
		up to the number specified (this allows the same list to be used with different
		count limits) 
</member>
        <member name="M:Ogre.RenderSystem.getWaitForVerticalBlank">
Returns true if the system is synchronising frames with the monitor vertical blank.

</member>
        <member name="M:Ogre.RenderSystem.setWaitForVerticalBlank(System.Boolean)">
Defines whether or now fullscreen render windows wait for the vertical blank before flipping buffers.
		@remarks
		By default, all rendering windows wait for a vertical blank (when the CRT beam turns off briefly to move
		from the bottom right of the screen back to the top left) before flipping the screen buffers. This ensures
		that the image you see on the screen is steady. However it restricts the frame rate to the refresh rate of
		the monitor, and can slow the frame rate down. You can speed this up by not waiting for the blank, but
		this has the downside of introducing 'tearing' artefacts where part of the previous frame is still displayed
		as the buffers are switched. Speed vs quality, you choose.
		@note
		Has NO effect on windowed mode render targets. Only affects fullscreen mode.
		@param
		enabled If true, the system waits for vertical blanks - quality over speed. If false it doesn't - speed over quality.

</member>
        <member name="M:Ogre.RenderSystem.getErrorDescription(System.Int32!System.Runtime.CompilerServices.IsLong)">
Returns a description of an error code.

</member>
        <member name="M:Ogre.RenderSystem.getRenderTargetIterator">
Returns a specialised MapIterator over all render targets attached to the RenderSystem. 
</member>
        <member name="D:Ogre.RenderSystem.RenderTargetIterator">
Iterator over RenderTargets
</member>
        <member name="M:Ogre.RenderSystem.detachRenderTarget(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Detaches the render target with the passed name from the render system and
		returns a pointer to it.
		@note
		If the render target cannot be found, NULL is returned.

</member>
        <member name="M:Ogre.RenderSystem.getRenderTarget(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a pointer to the render target with the passed name, or NULL if that
		render target cannot be found.

</member>
        <member name="M:Ogre.RenderSystem.attachRenderTarget(Ogre.RenderTarget*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Attaches the passed render target to the render system.

</member>
        <member name="M:Ogre.RenderSystem.destroyRenderTarget(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroys a render target of any sort 
</member>
        <member name="M:Ogre.RenderSystem.destroyRenderTexture(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroys a render texture 
</member>
        <member name="M:Ogre.RenderSystem.destroyRenderWindow(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroys a render window 
</member>
        <member name="M:Ogre.RenderSystem.createMultiRenderTarget(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a MultiRenderTarget, which is a render target that renders to multiple RenderTextures
		at once. Surfaces can be bound and unbound at will.
		This fails if mCapabilities-&gt;getNumMultiRenderTargets() is smaller than 2.

</member>
        <member name="M:Ogre.RenderSystem._createRenderWindows(std.vector&lt;Ogre.RenderWindowDescription&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Ogre.RenderWindow**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates multiple rendering windows.		
		@param
		renderWindowDescriptions Array of structures containing the descriptions of each render window.
		The structure's members are the same as the parameters of _createRenderWindow:
		* name
		* width
		* height
		* fullScreen
		* miscParams
		See _createRenderWindow for details about each member.		
		@param
		createdWindows This array will hold the created render windows.
		@returns
		true on success.		

</member>
        <member name="M:Ogre.RenderSystem.getWBufferEnabled">
Returns true if the renderer will try to use W-buffers when avalible.

</member>
        <member name="M:Ogre.RenderSystem.setWBufferEnabled(System.Boolean)">
Sets whether or not W-buffers are enabled if they are available for this renderer.
		@param
		enabled If true and the renderer supports them W-buffers will be used.  If false 
		W-buffers will not be used even if available.  W-buffers are enabled by default 
		for 16bit depth buffers and disabled for all other depths.

</member>
        <member name="M:Ogre.RenderSystem.setLightingEnabled(System.Boolean)">
Sets whether or not dynamic lighting is enabled.
		@param
		enabled If true, dynamic lighting is performed on geometry with normals supplied, geometry without
		normals will not be displayed. If false, no lighting is applied and all geometry will be full brightness.

</member>
        <member name="M:Ogre.RenderSystem.setShadingType(Ogre.ShadeOptions)">
Sets the type of light shading required (default = Gouraud).

</member>
        <member name="M:Ogre.RenderSystem.shutdown">
Shutdown the renderer and cleanup resources.

</member>
        <member name="M:Ogre.RenderSystem.reinitialise">
Restart the renderer (normally following a change in settings).

</member>
        <member name="M:Ogre.RenderSystem.useCustomRenderSystemCapabilities(Ogre.RenderSystemCapabilities*)">
Force the render system to use the special capabilities. Can only be called
		*    before the render system has been fully initializer (before createWindow is called) 
		*	@param
		*		 capabilities has to be a subset of the real capabilities and the caller is 
		*		 responsible for deallocating capabilities.

</member>
        <member name="M:Ogre.RenderSystem.createRenderSystemCapabilities">
Query the real capabilities of the GPU and driver in the RenderSystem
</member>
        <member name="M:Ogre.RenderSystem._initialise(System.Boolean,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Start up the renderer using the settings selected (Or the defaults if none have been selected).
		@remarks
		Called by Root::setRenderSystem. Shouldn't really be called
		directly, although  this can be done if the app wants to.
		@param
		autoCreateWindow If true, creates a render window
		automatically, based on settings chosen so far. This saves
		an extra call to _createRenderWindow
		for the main render window.
		@par
		If an application has more specific window requirements,
		however (e.g. a level design app), it should specify false
		for this parameter and do it manually.
		@returns
		A pointer to the automatically created window, if requested, otherwise null.

</member>
        <member name="M:Ogre.RenderSystem.validateConfigOptions">
Validates the options set for the rendering system, returning a message if there are problems.
		@note
		If the returned string is empty, there are no problems.

</member>
        <member name="M:Ogre.RenderSystem.destroyHardwareOcclusionQuery(Ogre.HardwareOcclusionQuery*)">
Destroy a hardware occlusion query object. 

</member>
        <member name="M:Ogre.RenderSystem.createHardwareOcclusionQuery">
Create an object for performing hardware occlusion queries. 

</member>
        <member name="M:Ogre.RenderSystem.setConfigOption(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets an option for this API
		@remarks
		Used to confirm the settings (normally chosen by the user) in
		order to make the renderer able to initialise with the settings as required.
		This may be video mode, D3D driver, full screen / windowed etc.
		Called automatically by the default configuration
		dialog, and by the restoration of saved settings.
		These settings are stored and only activated when
		RenderSystem::initialise or RenderSystem::reinitialise
		are called.
		@par
		If using a custom configuration dialog, it is advised that the
		caller calls RenderSystem::getConfigOptions
		again, since some options can alter resulting from a selection.
		@param
		name The name of the option to alter.
		@param
		value The value to set the option to.

</member>
        <member name="M:Ogre.RenderSystem.getConfigOptions">
Returns the details of this API's configuration options
		@remarks
		Each render system must be able to inform the world
		of what options must/can be specified for it's
		operation.
		@par
		These are passed as strings for portability, but
		grouped into a structure (_ConfigOption) which includes
		both options and current value.
		@par
		Note that the settings returned from this call are
		affected by the options that have been set so far,
		since some options are interdependent.
		@par
		This routine is called automatically by the default
		configuration dialogue produced by Root::showConfigDialog
		or may be used by the caller for custom settings dialogs
		@returns
		A 'map' of options, i.e. a list of options which is also
		indexed by option name.

</member>
        <member name="M:Ogre.RenderSystem.getName">
Returns the name of the rendering system.

</member>
        <member name="M:Ogre.RenderSystem.Dispose">
Destructor.

</member>
        <member name="M:Ogre.RenderSystem.#ctor">
Default Constructor.

</member>
        <member name="T:Ogre.RenderSystem">
Defines the functionality of a 3D API
	@remarks
	The RenderSystem class provides a base interface
	which abstracts the general functionality of the 3D API
	e.g. Direct3D or OpenGL. Whilst a few of the general
	methods have implementations, most of this class is
	abstract, requiring a subclass based on a specific API
	to be constructed to provide the full functionality.
	Note there are 2 levels to the interface - one which
	will be used often by the caller of the Ogre library,
	and one which is at a lower level and will be used by the
	other classes provided by Ogre. These lower level
	methods are prefixed with '_' to differentiate them.
	The advanced user of the library may use these lower
	level methods to access the 3D API at a more fundamental
	level (dealing direct with render states and rendering
	primitives), but still benefiting from Ogre's abstraction
	of exactly which 3D API is in use.
	@author
	Steven Streeting
	@version
	1.0

</member>
        <member name="T:Ogre.StencilOperation">
Enum describing the various actions which can be taken onthe stencil buffer
</member>
        <member name="F:SOP_INVERT">
Invert the bits of the stencil buffer
</member>
        <member name="F:SOP_DECREMENT_WRAP">
Decrease the stencil value by 1, wrapping when decrementing 0
</member>
        <member name="F:SOP_INCREMENT_WRAP">
Increase the stencil value by 1, wrapping back to 0 when incrementing the maximum value
</member>
        <member name="F:SOP_DECREMENT">
Decrease the stencil value by 1, clamping at 0
</member>
        <member name="F:SOP_INCREMENT">
Increase the stencil value by 1, clamping at the maximum value
</member>
        <member name="F:SOP_REPLACE">
Set the stencil value to the reference value
</member>
        <member name="F:SOP_ZERO">
Set the stencil value to zero
</member>
        <member name="F:SOP_KEEP">
Leave the stencil buffer unchanged
</member>
        <member name="T:Ogre.TexCoordCalcMethod">
Enum describing the ways to generate texture coordinates
</member>
        <member name="F:TEXCALC_PROJECTIVE_TEXTURE">
Projective texture
</member>
        <member name="F:TEXCALC_ENVIRONMENT_MAP_PLANAR">
Environment map based on vertex positions
</member>
        <member name="F:TEXCALC_ENVIRONMENT_MAP">
Environment map based on vertex normals
</member>
        <member name="F:TEXCALC_NONE">
No calculated texture coordinates
</member>
        <member name="D:Ogre.RenderTargetMap">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

</member>
        <member name="T:Ogre._ConfigOption">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

Packages the details of a configuration option.
        @remarks
            Used for RenderSystem::getConfigOptions. If immutable is true, this
            option must be disabled for modifying.

</member>
        <member name="M:Ogre.MultiRenderTarget.unbindSurfaceImpl(System.UInt32)">
implementation of unbindSurface, must be provided
</member>
        <member name="M:Ogre.MultiRenderTarget.bindSurfaceImpl(System.UInt32,Ogre.RenderTexture*)">
implementation of bindSurface, must be provided
</member>
        <member name="M:Ogre.MultiRenderTarget.getBoundSurface(System.UInt32)">
Get a pointer to a bound surface 
</member>
        <member name="M:Ogre.MultiRenderTarget.getBoundSurfaceList">
Get a list of the surfaces which have been bound
</member>
        <member name="M:Ogre.MultiRenderTarget.suggestPixelFormat">
Irrelevant implementation since cannot copy
</member>
        <member name="M:Ogre.MultiRenderTarget.copyContentsToMemory(Ogre.PixelBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.RenderTarget.FrameBuffer)">
Error throwing implementation, it's not possible to write a MultiRenderTarget
			to disk. 

</member>
        <member name="M:Ogre.MultiRenderTarget.unbindSurface(System.UInt32)">
Unbind attachment.

</member>
        <member name="M:Ogre.MultiRenderTarget.bindSurface(System.UInt32,Ogre.RenderTexture*)">
Bind a surface to a certain attachment point.
            @param attachment	0 .. mCapabilities-&gt;getNumMultiRenderTargets()-1
			@param target		RenderTexture to bind.

			It does not bind the surface and fails with an exception (ERR_INVALIDPARAMS) if:
			- Not all bound surfaces have the same size
			- Not all bound surfaces have the same internal format 

</member>
        <member name="T:Ogre.MultiRenderTarget">
This class represents a render target that renders to multiple RenderTextures
		at once. Surfaces can be bound and unbound at will, as long as the following constraints
		are met:
		- All bound surfaces have the same size
		- All bound surfaces have the same bit depth
		- Target 0 is bound

</member>
        <member name="T:Ogre.RenderTexture">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

This class represents a RenderTarget that renders to a Texture. There is no 1 on 1
        relation between Textures and RenderTextures, as there can be multiple 
        RenderTargets rendering to different mipmaps, faces (for cubemaps) or slices (for 3D textures)
        of the same Texture.

</member>
        <member name="M:Ogre.RenderTarget.updateImpl">
Internal implementation of update()
</member>
        <member name="M:Ogre.RenderTarget.fireViewportRemoved(Ogre.Viewport*)">
internal method for firing events
</member>
        <member name="M:Ogre.RenderTarget.fireViewportAdded(Ogre.Viewport*)">
internal method for firing events
</member>
        <member name="M:Ogre.RenderTarget.fireViewportPostUpdate(Ogre.Viewport*)">
internal method for firing events
</member>
        <member name="M:Ogre.RenderTarget.fireViewportPreUpdate(Ogre.Viewport*)">
internal method for firing events
</member>
        <member name="M:Ogre.RenderTarget.firePostUpdate">
internal method for firing events
</member>
        <member name="M:Ogre.RenderTarget.firePreUpdate">
internal method for firing events
</member>
        <member name="F:Ogre.RenderTarget.mViewportList">
List of viewports, map on Z-order
</member>
        <member name="F:Ogre.RenderTarget.mPriority">
The priority of the render target.
</member>
        <member name="F:Ogre.RenderTarget.mName">
The name of this target.
</member>
        <member name="M:Ogre.RenderTarget._endUpdate">
Method for manual management of rendering - finishes statistics calculation 
			and fires 'postRenderTargetUpdate'.
		@remarks
		You should call it after a _beginUpdate
		@see _beginUpdate for more details.

</member>
        <member name="M:Ogre.RenderTarget._updateAutoUpdatedViewports(System.Boolean)">
Method for manual management of rendering - renders only viewports that are auto updated
		@remarks
		This also fires preViewportUpdate and postViewportUpdate, and manages statistics.
		You should call it between _beginUpdate() and _endUpdate().
		See _beginUpdate for more details.
		@param updateStatistics Whether you want to update statistics or not.
		@see _beginUpdate()

</member>
        <member name="M:Ogre.RenderTarget._updateViewport(Ogre.Viewport*,System.Boolean)">
Method for manual management of rendering - renders the given viewport (even if it is not autoupdated)
		@remarks
		This also fires preViewportUpdate and postViewportUpdate, and manages statistics
		if needed. You should call it between _beginUpdate() and _endUpdate().
		@see _beginUpdate for more details.
		@param viewport The viewport you want to update, it must be bound to the rendertarget.
		@param updateStatistics Whether you want to update statistics or not.

</member>
        <member name="M:Ogre.RenderTarget._updateViewport(System.Int32,System.Boolean)">
Method for manual management of rendering - renders the given 
		viewport (even if it is not autoupdated)
		@remarks
		This also fires preViewportUpdate and postViewportUpdate, and manages statistics.
		You should call it between _beginUpdate() and _endUpdate().
		@see _beginUpdate for more details.
		@param zorder The zorder of the viewport to update.
		@param updateStatistics Whether you want to update statistics or not.

</member>
        <member name="M:Ogre.RenderTarget._beginUpdate">
Method for manual management of rendering : fires 'preRenderTargetUpdate'
			and initialises statistics etc.
		@remarks 
		<ul><li>_beginUpdate resets statistics and fires 'preRenderTargetUpdate'.</li><li>_updateViewport renders the given viewport (even if it is not autoupdated),
		fires preViewportUpdate and postViewportUpdate and manages statistics.</li><li>_updateAutoUpdatedViewports renders only viewports that are auto updated,
		fires preViewportUpdate and postViewportUpdate and manages statistics.</li><li>_endUpdate() ends statistics calculation and fires postRenderTargetUpdate.</li></ul>
		you can use it like this for example :
		<pre>
			renderTarget-&gt;_beginUpdate();
			renderTarget-&gt;_updateViewport(1); // which is not auto updated
			renderTarget-&gt;_updateViewport(2); // which is not auto updated
			renderTarget-&gt;_updateAutoUpdatedViewports();
			renderTarget-&gt;_endUpdate();
			renderTarget-&gt;swapBuffers(true);
		</pre>
			Please note that in that case, the zorder may not work as you expect,
			since you are responsible for calling _updateViewport in the correct order.

</member>
        <member name="M:Ogre.RenderTarget._getImpl">
Get rendersystem specific interface for this RenderTarget.
            This is used by the RenderSystem to (un)bind this target, 
            and to get specific information like surfaces
            and framebuffer objects.

</member>
        <member name="T:Ogre.RenderTarget.Impl">
RenderSystem specific interface for a RenderTarget;
            this should be subclassed by RenderSystems.

</member>
        <member name="M:Ogre.RenderTarget.getFSAAHint">
Gets the FSAA hint (@see Root::createRenderWindow)

</member>
        <member name="M:Ogre.RenderTarget.getFSAA">
Indicates whether multisampling is performed on rendering and at what level.

</member>
        <member name="M:Ogre.RenderTarget.isHardwareGammaEnabled">
Indicates whether on rendering, linear colour space is converted to 
			sRGB gamma colour space. This is the exact opposite conversion of
			what is indicated by Texture::isHardwareGammaEnabled, and can only
			be enabled on creation of the render target. For render windows, it's
			enabled through the 'gamma' creation misc parameter. For textures, 
			it is enabled through the hwGamma parameter to the create call.

</member>
        <member name="M:Ogre.RenderTarget.isPrimary">
Indicates whether this target is the primary window. The
            primary window is special in that it is destroyed when
            ogre is shut down, and cannot be destroyed directly.
            This is the case because it holds the context for vertex,
            index buffers and textures.

</member>
        <member name="M:Ogre.RenderTarget._notifyCameraRemoved(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Utility method to notify a render target that a camera has been removed,
        incase it was referring to it as a viewer.

</member>
        <member name="M:Ogre.RenderTarget.getBatchCount">
Gets the number of batches rendered in the last update() call. 
</member>
        <member name="M:Ogre.RenderTarget.getTriangleCount">
Gets the number of triangles rendered in the last update() call. 
</member>
        <member name="M:Ogre.RenderTarget.writeContentsToTimestampedFile(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Writes the current contents of the render target to the (PREFIX)(time-stamp)(SUFFIX) file.
			@returns the name of the file used.
</member>
        <member name="M:Ogre.RenderTarget.writeContentsToFile(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Writes the current contents of the render target to the named file. 
</member>
        <member name="M:Ogre.RenderTarget.suggestPixelFormat">
Suggests a pixel format to use for extracting the data in this target, 
			when calling copyContentsToMemory.

</member>
        <member name="M:Ogre.RenderTarget.copyContentsToMemory(Ogre.PixelBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.RenderTarget.FrameBuffer)">
Copies the current contents of the render target to a pixelbox. 
		@remarks See suggestPixelFormat for a tip as to the best pixel format to
			extract into, although you can use whatever format you like and the 
			results will be converted.

</member>
        <member name="M:Ogre.RenderTarget.isAutoUpdated">
Gets whether this target is automatically updated if Ogre's rendering
            loop or Root::_updateAllRenderTargets is being used.

</member>
        <member name="M:Ogre.RenderTarget.setAutoUpdated(System.Boolean)">
Sets whether this target should be automatically updated if Ogre's rendering
            loop or Root::_updateAllRenderTargets is being used.
        @remarks
            By default, if you use Ogre's own rendering loop (Root::startRendering)
            or call Root::_updateAllRenderTargets, all render targets are updated 
            automatically. This method allows you to control that behaviour, if 
            for example you have a render target which you only want to update periodically.
        @param autoupdate If true, the render target is updated during the automatic render
            loop or when Root::_updateAllRenderTargets is called. If false, the 
            target is only updated when its update() method is called explicitly.

</member>
        <member name="M:Ogre.RenderTarget.setActive(System.Boolean)">
Used to set the active state of the render target.

</member>
        <member name="M:Ogre.RenderTarget.isActive">
Used to retrieve or set the active state of the render target.

</member>
        <member name="M:Ogre.RenderTarget.getPriority">
Gets the priority of a render target. 
</member>
        <member name="M:Ogre.RenderTarget.setPriority(System.Byte)">
Sets the priority of this render target in relation to the others. 
        @remarks
            This can be used in order to schedule render target updates. Lower
            priorities will be rendered first. Note that the priority must be set
            at the time the render target is attached to the render system, changes
            afterwards will not affect the ordering.

</member>
        <member name="M:Ogre.RenderTarget.removeAllListeners">
Removes all listeners from this instance. 
</member>
        <member name="M:Ogre.RenderTarget.removeListener(Ogre.RenderTargetListener*)">
Removes a RenderTargetListener previously registered using addListener. 
</member>
        <member name="M:Ogre.RenderTarget.getCustomAttribute(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void*)">
Gets a custom (maybe platform-specific) attribute.
            @remarks
                This is a nasty way of satisfying any API's need to see platform-specific details.
                It horrid, but D3D needs this kind of info. At least it's abstracted.
            @param
                name The name of the attribute.
            @param
                pData Pointer to memory of the right kind of structure to receive the info.

</member>
        <member name="M:Ogre.RenderTarget.resetStatistics">
Resets saved frame-rate statistices.

</member>
        <member name="M:Ogre.RenderTarget.getWorstFrameTime">
Individual stats access - gets the worst frame time

</member>
        <member name="M:Ogre.RenderTarget.getBestFrameTime">
Individual stats access - gets the best frame time

</member>
        <member name="M:Ogre.RenderTarget.getWorstFPS">
Individual stats access - gets the worst frames per second (FPS) since call to Root::startRendering.

</member>
        <member name="M:Ogre.RenderTarget.getBestFPS">
Individual stats access - gets the best frames per second (FPS) since call to Root::startRendering.

</member>
        <member name="M:Ogre.RenderTarget.getAverageFPS">
Individual stats access - gets the average frames per second (FPS) since call to Root::startRendering.

</member>
        <member name="M:Ogre.RenderTarget.getLastFPS">
Individual stats access - gets the number of frames per second (FPS) based on the last frame rendered.

</member>
        <member name="M:Ogre.RenderTarget.getStatistics(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retieves details of current rendering performance.
            @remarks
                If the user application wishes to do it's own performance
                display, or use performance for some other means, this
                method allows it to retrieve the statistics.
                @param
                    lastFPS Pointer to a float to receive the number of frames per second (FPS)
                    based on the last frame rendered.
                @param
                    avgFPS Pointer to a float to receive the FPS rating based on an average of all
                    the frames rendered since rendering began (the call to
                    Root::startRendering).
                @param
                    bestFPS Pointer to a float to receive the best FPS rating that has been achieved
                    since rendering began.
                @param
                    worstFPS Pointer to a float to receive the worst FPS rating seen so far.

</member>
        <member name="M:Ogre.RenderTarget.removeAllViewports">
Removes all viewports on this target.

</member>
        <member name="M:Ogre.RenderTarget.removeViewport(System.Int32)">
Removes a viewport at a given ZOrder.

</member>
        <member name="M:Ogre.RenderTarget.getViewport(System.UInt16)">
Retrieves a pointer to the viewport with the given index. 
</member>
        <member name="M:Ogre.RenderTarget.getNumViewports">
Returns the number of viewports attached to this target.
</member>
        <member name="M:Ogre.RenderTarget.addViewport(Ogre.Camera*,System.Int32,System.Single,System.Single,System.Single,System.Single)">
Adds a viewport to the rendering target.
            @remarks
                A viewport is the rectangle into which rendering output is sent. This method adds
                a viewport to the render target, rendering from the supplied camera. The
                rest of the parameters are only required if you wish to add more than one viewport
                to a single rendering target. Note that size information passed to this method is
                passed as a parametric, i.e. it is relative rather than absolute. This is to allow
                viewports to automatically resize along with the target.
            @param
                cam The camera from which the viewport contents will be rendered (mandatory)
            @param
                ZOrder The relative order of the viewport with others on the target (allows overlapping
                viewports i.e. picture-in-picture). Higher ZOrders are on top of lower ones. The actual number
                is irrelevant, only the relative ZOrder matters (you can leave gaps in the numbering)
            @param
                left The relative position of the left of the viewport on the target, as a value between 0 and 1.
            @param
                top The relative position of the top of the viewport on the target, as a value between 0 and 1.
            @param
                width The relative width of the viewport on the target, as a value between 0 and 1.
            @param
                height The relative height of the viewport on the target, as a value between 0 and 1.

</member>
        <member name="M:Ogre.RenderTarget.swapBuffers(System.Boolean)">
Swaps the frame buffers to display the next frame.
            @remarks
                For targets that are double-buffered so that no
                'in-progress' versions of the scene are displayed
                during rendering. Once rendering has completed (to
                an off-screen version of the window) the buffers
                are swapped to display the new frame.

            @param
                waitForVSync If true, the system waits for the
                next vertical blank period (when the CRT beam turns off
                as it travels from bottom-right to top-left at the
                end of the pass) before flipping. If false, flipping
                occurs no matter what the beam position. Waiting for
                a vertical blank can be slower (and limits the
                framerate to the monitor refresh rate) but results
                in a steadier image with no 'tearing' (a flicker
                resulting from flipping buffers when the beam is
                in the progress of drawing the last frame).

</member>
        <member name="M:Ogre.RenderTarget.update(System.Boolean)">
Tells the target to update it's contents.
            @remarks
                If OGRE is not running in an automatic rendering loop
                (started using Root::startRendering),
                the user of the library is responsible for asking each render
                target to refresh. This is the method used to do this. It automatically
                re-renders the contents of the target using whatever cameras have been
                pointed at it (using Camera::setRenderTarget).
            @par
                This allows OGRE to be used in multi-windowed utilities
                and for contents to be refreshed only when required, rather than
                constantly as with the automatic rendering loop.
			@param swapBuffers For targets that support double-buffering, if set 
				to true, the target will immediately
				swap it's buffers after update. Otherwise, the buffers are
				not swapped, and you have to call swapBuffers yourself sometime
				later. You might want to do this on some rendersystems which 
				pause for queued rendering commands to complete before accepting
				swap buffers calls - so you could do other CPU tasks whilst the 
				queued commands complete. Or, you might do this if you want custom
				control over your windows, such as for externally created windows.

</member>
        <member name="M:Ogre.RenderTarget.getMetrics(System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieve information about the render target.
</member>
        <member name="M:Ogre.RenderTarget.getName">
Retrieve target's name.
</member>
        <member name="T:Ogre.RenderTarget">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

A 'canvas' which can receive the results of a rendering
        operation.
        @remarks
            This abstract class defines a common root to all targets of rendering operations. A
            render target could be a window on a screen, or another
            offscreen surface like a texture or bump map etc.
        @author
            Steven Streeting
        @version
            1.0

</member>
        <member name="M:Ogre.Timer.getMicrosecondsCPU">
Returns microseconds since initialisation or last reset, only CPU time measured 
</member>
        <member name="M:Ogre.Timer.getMillisecondsCPU">
Returns milliseconds since initialisation or last reset, only CPU time measured 
</member>
        <member name="M:Ogre.Timer.getMicroseconds">
Returns microseconds since initialisation or last reset 
</member>
        <member name="M:Ogre.Timer.getMilliseconds">
Returns milliseconds since initialisation or last reset 
</member>
        <member name="M:Ogre.Timer.reset">
Resets timer 
</member>
        <member name="M:Ogre.Timer.setOption(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void!System.Runtime.CompilerServices.IsConst*)">
Method for setting a specific option of the Timer. These options are usually
            specific for a certain implementation of the Timer class, and may (and probably
            will) not exist across different implementations.  reset() must be called after
			all setOption() calls.
			@par
			Current options supported are:
			<ul><li>"QueryAffinityMask" (DWORD): Set the thread affinity mask to be used
			to check the timer. If 'reset' has been called already this mask should
			overlap with the process mask that was in force at that point, and should
			be a power of two (a single core).</li></ul>
            @param
                strKey The name of the option to set
            @param
                pValue A pointer to the value - the size should be calculated by the timer
                based on the key
            @return
                On success, true is returned.
            @par
                On failure, false is returned.

</member>
        <member name="M:Ogre.Timer.#ctor">
Timer constructor.  MUST be called on same thread that calls getMilliseconds() 
</member>
        <member name="T:Ogre.Timer">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

</member>
        <member name="F:Ogre.Viewport.mIsAutoUpdated">
Automatic rendering on/off
</member>
        <member name="F:Ogre.Viewport.mOrientationMode">
Viewport orientation mode
</member>
        <member name="F:Ogre.Viewport.mMaterialSchemeName">
Material scheme
</member>
        <member name="F:Ogre.Viewport.mBackColour">
Background options
</member>
        <member name="F:Ogre.Viewport.mZOrder">
ZOrder
</member>
        <member name="M:Ogre.Viewport.pointOrientedToScreen(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,Ogre.Vector2*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Convert oriented input point coordinates to screen coordinates. 
</member>
        <member name="M:Ogre.Viewport._getRenderQueueInvocationSequence">
Get the invocation sequence - will return null if using standard
</member>
        <member name="M:Ogre.Viewport.getRenderQueueInvocationSequenceName">
Gets the name of the render queue invocation sequence for this target. 
</member>
        <member name="M:Ogre.Viewport.setRenderQueueInvocationSequenceName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the use of a custom RenderQueueInvocationSequence for
			rendering this target.
		@remarks
			RenderQueueInvocationSequence instances are managed through Root. By
			setting this, you are indicating that you wish this RenderTarget to
			be updated using a custom sequence of render queue invocations, with
			potentially customised ordering and render state options. You should
			create the named sequence through Root first, then set the name here.
		@param The name of the RenderQueueInvocationSequence to use. If you
			specify a blank string, behaviour will return to the default render
			queue management.

</member>
        <member name="M:Ogre.Viewport.getVisibilityMask">
Gets a per-viewport visibility mask.
		@see Viewport::setVisibilityMask

</member>
        <member name="M:Ogre.Viewport.setVisibilityMask(System.UInt32)">
Sets a per-viewport visibility mask.
		@remarks
			The visibility mask is a way to exclude objects from rendering for
			a given viewport. For each object in the frustum, a check is made
			between this mask and the objects visibility flags 
			(@see MovableObject::setVisibilityFlags), and if a binary 'and'
			returns zero, the object will not be rendered.

</member>
        <member name="M:Ogre.Viewport.getShadowsEnabled">
Returns whether or not shadows (defined in the SceneManager) are displayed in this
            viewport. 
</member>
        <member name="M:Ogre.Viewport.setShadowsEnabled(System.Boolean)">
Tells this viewport whether it should display shadows.
        @remarks
            This setting enables you to disable shadow rendering for a given viewport. The global
			shadow technique set on SceneManager still controls the type and nature of shadows,
			but this flag can override the setting so that no shadows are rendered for a given
			viewport to save processing time where they are not required.
        @param enabled If true, any shadows are displayed, if false they are not.

</member>
        <member name="M:Ogre.Viewport.getSkiesEnabled">
Returns whether or not skies (created in the SceneManager) are displayed in this
            viewport. 
</member>
        <member name="M:Ogre.Viewport.setSkiesEnabled(System.Boolean)">
Tells this viewport whether it should display skies.
        @remarks
            Skies are layers which appear on background of the scene. They are created via
            SceneManager::setSkyBox, SceneManager::setSkyPlane and SceneManager::setSkyDome and
            every viewport displays these by default. However, you probably don't want this if
            you're using multiple viewports, because one of them is probably a picture-in-picture
            which is not supposed to have skies of it's own. In this case you can turn off skies
            on this viewport by calling this method.
        @param enabled If true, any skies are displayed, if false they are not.

</member>
        <member name="M:Ogre.Viewport.getOverlaysEnabled">
Returns whether or not Overlay objects (created in the SceneManager) are displayed in this
            viewport. 
</member>
        <member name="M:Ogre.Viewport.setOverlaysEnabled(System.Boolean)">
Tells this viewport whether it should display Overlay objects.
        @remarks
            Overlay objects are layers which appear on top of the scene. They are created via
            SceneManager::createOverlay and every viewport displays these by default.
            However, you probably don't want this if you're using multiple viewports,
            because one of them is probably a picture-in-picture which is not supposed to
            have overlays of it's own. In this case you can turn off overlays on this viewport
            by calling this method.
        @param enabled If true, any overlays are displayed, if false they are not.

</member>
        <member name="M:Ogre.Viewport._getNumRenderedBatches">
Gets the number of rendered batches in the last update.

</member>
        <member name="M:Ogre.Viewport._getNumRenderedFaces">
Gets the number of rendered faces in the last update.

</member>
        <member name="M:Ogre.Viewport.getActualDimensions(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Access to actual dimensions (based on target size).

</member>
        <member name="M:Ogre.Viewport.getMaterialScheme">
Get the material scheme which the viewport should use.

</member>
        <member name="M:Ogre.Viewport.setMaterialScheme(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the material scheme which the viewport should use.
		@remarks
			This allows you to tell the system to use a particular
			material scheme when rendering this viewport, which can 
			involve using different techniques to render your materials.
		@see Technique::setSchemeName

</member>
        <member name="M:Ogre.Viewport.isAutoUpdated">
Gets whether this viewport is automatically updated if 
			Ogre's rendering loop or RenderTarget::update is being used.

</member>
        <member name="M:Ogre.Viewport.setAutoUpdated(System.Boolean)">
Sets whether this viewport should be automatically updated 
			if Ogre's rendering loop or RenderTarget::update is being used.
        @remarks
            By default, if you use Ogre's own rendering loop (Root::startRendering)
            or call RenderTarget::update, all viewports are updated automatically.
            This method allows you to control that behaviour, if for example you 
			have a viewport which you only want to update periodically.
        @param autoupdate If true, the viewport is updated during the automatic
            render loop or when RenderTarget::update() is called. If false, the 
            viewport is only updated when its update() method is called explicitly.

</member>
        <member name="M:Ogre.Viewport.getClearBuffers">
Gets which buffers are to be cleared each frame. 
</member>
        <member name="M:Ogre.Viewport.getClearEveryFrame">
Determines if the viewport is cleared before every frame.

</member>
        <member name="M:Ogre.Viewport.setClearEveryFrame(System.Boolean,System.UInt32)">
Determines whether to clear the viewport before rendering.
		@remarks
			You can use this method to set which buffers are cleared
			(if any) before rendering every frame.
        @param clear Whether or not to clear any buffers
		@param buffers One or more values from FrameBufferType denoting
			which buffers to clear, if clear is set to true. Note you should
			not clear the stencil buffer here unless you know what you're doing.

</member>
        <member name="M:Ogre.Viewport.getBackgroundColour">
Gets the background colour.

</member>
        <member name="M:Ogre.Viewport.setBackgroundColour(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the initial background colour of the viewport (before
            rendering).

</member>
        <member name="M:Ogre.Viewport.getDefaultOrientationMode">
Get the initial orientation mode of viewports.

</member>
        <member name="M:Ogre.Viewport.setDefaultOrientationMode(Ogre.OrientationMode)">
Set the initial orientation mode of viewports.

</member>
        <member name="M:Ogre.Viewport.getOrientationMode">
Get the orientation mode of the viewport.

</member>
        <member name="M:Ogre.Viewport.setOrientationMode(Ogre.OrientationMode,System.Boolean)">
Set the orientation mode of the viewport.

</member>
        <member name="M:Ogre.Viewport.setDimensions(System.Single,System.Single,System.Single,System.Single)">
Sets the dimensions (after creation).
            @param
                left
            @param
                top
            @param
                width
            @param
                height Dimensions relative to the size of the target,
                represented as real values between 0 and 1. i.e. the full
                target area is 0, 0, 1, 1.

</member>
        <member name="M:Ogre.Viewport.getActualHeight">
Gets one of the actual dimensions of the viewport, a value in
            pixels.

</member>
        <member name="M:Ogre.Viewport.getActualWidth">
Gets one of the actual dimensions of the viewport, a value in
            pixels.

</member>
        <member name="M:Ogre.Viewport.getActualTop">
Gets one of the actual dimensions of the viewport, a value in
            pixels.

</member>
        <member name="M:Ogre.Viewport.getActualLeft">
Gets one of the actual dimensions of the viewport, a value in
            pixels.

</member>
        <member name="M:Ogre.Viewport.getHeight">
Gets one of the relative dimensions of the viewport, a value
            between 0.0 and 1.0.

</member>
        <member name="M:Ogre.Viewport.getWidth">
Gets one of the relative dimensions of the viewport, a value
            between 0.0 and 1.0.

</member>
        <member name="M:Ogre.Viewport.getTop">
Gets one of the relative dimensions of the viewport, a value
            between 0.0 and 1.0.

</member>
        <member name="M:Ogre.Viewport.getLeft">
Gets one of the relative dimensions of the viewport,
            a value between 0.0 and 1.0.

</member>
        <member name="M:Ogre.Viewport.getZOrder">
Gets the Z-Order of this viewport. 
</member>
        <member name="M:Ogre.Viewport.setCamera(Ogre.Camera*)">
Sets the camera to use for rendering to this viewport. 
</member>
        <member name="M:Ogre.Viewport.getCamera">
Retrieves a pointer to the camera for this viewport.

</member>
        <member name="M:Ogre.Viewport.getTarget">
Retrieves a pointer to the render target for this viewport.

</member>
        <member name="M:Ogre.Viewport.clear(System.UInt32,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.UInt16)">
Instructs the viewport to clear itself, without performing an update.
		 @remarks
			You would not normally call this method when updating the viewport, 
			since the viewport usually clears itself when updating anyway (@see 
		    Viewport::setClearEveryFrame). However, if you wish you have the
			option of manually clearing the frame buffer (or elements of it)
		    using this method.
		 @param buffers Bitmask identifying which buffer elements to clear
		 @param colour The colour value to clear to, if FBT_COLOUR is included
		 @param depth The depth value to clear to, if FBT_DEPTH is included
		 @param stencil The stencil value to clear to, if FBT_STENCIL is included

</member>
        <member name="M:Ogre.Viewport.update">
Instructs the viewport to updates its contents.

</member>
        <member name="M:Ogre.Viewport._updateDimensions">
Notifies the viewport of a possible change in dimensions.
            @remarks
                Used by the target to update the viewport's dimensions
                (usually the result of a change in target size).
            @note
                Internal use by Ogre only.

</member>
        <member name="M:Ogre.Viewport.Dispose">
Default destructor.

</member>
        <member name="M:Ogre.Viewport.#ctor(Ogre.Camera*,Ogre.RenderTarget*,System.Single,System.Single,System.Single,System.Single,System.Int32)">
The usual constructor.
            @param
                cam Pointer to a camera to be the source for the image.
            @param
                target Pointer to the render target to be the destination
                for the rendering.
            @param
                left
            @param
                top
            @param
                width
            @param
                height
                Dimensions of the viewport, expressed as a value between
                0 and 1. This allows the dimensions to apply irrespective of
                changes in the target's size: e.g. to fill the whole area,
                values of 0,0,1,1 are appropriate.
            @param
                ZOrder Relative Z-order on the target. Lower = further to
                the front.

</member>
        <member name="T:Ogre.Viewport">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

An abstraction of a viewport, i.e. a rendering region on a render
        target.
        @remarks
            A viewport is the meeting of a camera and a rendering surface -
            the camera renders the scene from a viewpoint, and places its
            results into some subset of a rendering target, which may be the
            whole surface or just a part of the surface. Each viewport has a
            single camera as source and a single target as destination. A
            camera only has 1 viewport, but a render target may have several.
            A viewport also has a Z-order, i.e. if there is more than one
            viewport on a single render target and they overlap, one must
            obscure the other in some predetermined way.

</member>
        <member name="M:Ogre.TextureManager.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.TextureManager.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.TextureManager.getDefaultNumMipmaps">
Gets the default number of mipmaps to be used for loaded textures.

</member>
        <member name="M:Ogre.TextureManager.setDefaultNumMipmaps(System.UInt32)">
Sets the default number of mipmaps to be used for loaded textures, for when textures are
            loaded automatically (e.g. by Material class) or when 'load' is called with the default
            parameters by the application.
			If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible
				level, 1x1x1.
            @note
                The default value is 0.

</member>
        <member name="M:Ogre.TextureManager.isHardwareFilteringSupported(Ogre.TextureType,Ogre.PixelFormat,System.Int32,System.Boolean)">
Returns whether this render system has hardware filtering supported for the
            texture format requested with the given usage options.
        @remarks
            Not all texture format are supports filtering by the hardware, i.e. some
            cards support floating point format, but it doesn't supports filtering on
            the floating point texture at all, or only a subset floating point formats
            have flitering supported.
        @par
            In the case you want to write shader to work with floating point texture, and
            you want to produce better visual quality, it's necessary to flitering the
            texture manually in shader (potential requires four or more texture fetch
            instructions, plus several arithmetic instructions) if filtering doesn't
            supported by hardware. But in case on the hardware that supports floating
            point filtering natively, it had better to adopt this capability for
            performance (because only one texture fetch instruction are required) and
            doesn't loss visual quality.
        @par
            This method allow you queries hardware texture filtering capability to deciding
            which verion of the shader to be used. Note it's up to you to write multi-version
            shaders for support various hardware, internal engine can't do that for you
            automatically.
        @note
            Under GL, texture filtering are always supported by driver, but if it's not
            supported by hardware natively, software simulation will be used, and you
            will end up with very slow speed (less than 0.1 fps for example). To slove
            this performance problem, you must disable filtering manually (by use
            <b>filtering none</b> in the material script's texture_unit section, or
            call TextureUnitState::setTextureFiltering with TFO_NONE if populate
            material in code).
		@param ttype The texture type requested
		@param format The pixel format requested
		@param usage The kind of usage this texture is intended for, a combination of 
			the TextureUsage flags.
        @param preciseFormatOnly Whether precise or fallback format mode is used to detecting.
            In case the pixel format doesn't supported by device, false will be returned
            if in precise mode, and natively used pixel format will be actually use to
            check if in fallback mode.
		@returns true if the texture filtering is supported.

</member>
        <member name="M:Ogre.TextureManager.getNativeFormat(Ogre.TextureType,Ogre.PixelFormat,System.Int32)">
Gets the format which will be natively used for a requested format given the
			constraints of the current device.

</member>
        <member name="M:Ogre.TextureManager.isEquivalentFormatSupported(Ogre.TextureType,Ogre.PixelFormat,System.Int32)">
Returns whether this render system can support the texture format requested
			with the given usage options, or another format with no quality reduction.

</member>
        <member name="M:Ogre.TextureManager.isFormatSupported(Ogre.TextureType,Ogre.PixelFormat,System.Int32)">
Returns whether this render system can natively support the precise texture 
			format requested with the given usage options.
		@remarks
			You can still create textures with this format even if this method returns
			false; the texture format will just be altered to one which the device does
			support.
		@note
			Sometimes the device may just slightly change the format, such as reordering the 
			channels or packing the channels differently, without it making and qualitative 
			differences to the texture. If you want to just detect whether the quality of a
			given texture will be reduced, use isEquivalentFormatSupport instead.
		@param format The pixel format requested
		@param usage The kind of usage this texture is intended for, a combination of 
			the TextureUsage flags.
		@returns true if the format is natively supported, false if a fallback would be used.

</member>
        <member name="M:Ogre.TextureManager.setPreferredBitDepths(System.UInt16,System.UInt16,System.Boolean)">
Sets preferred bit depth for integer and float pixel format.
        @param
            integerBits Number of bits. Available values: 0, 16 and 32, where 0 (the default) means keep
            original format as it is. This value is number of bits for the pixel.
        @param
            floatBits Number of bits. Available values: 0, 16 and 32, where 0 (the default) means keep
            original format as it is. This value is number of bits for a channel of the pixel.
        @param
            reloadTextures If true (the default), will reloading all reloadable textures.

</member>
        <member name="M:Ogre.TextureManager.getPreferredFloatBitDepth">
gets preferred bit depth for float pixel format textures.

</member>
        <member name="M:Ogre.TextureManager.setPreferredFloatBitDepth(System.UInt16,System.Boolean)">
Sets preferred bit depth for float pixel format textures.
        @param
            bits Number of bits. Available values: 0, 16 and 32, where 0 (the default) means keep
            original format as it is. This value is number of bits for a channel of the pixel.
        @param
            reloadTextures If true (the default), will reloading all reloadable textures.

</member>
        <member name="M:Ogre.TextureManager.getPreferredIntegerBitDepth">
gets preferred bit depth for integer pixel format textures.

</member>
        <member name="M:Ogre.TextureManager.setPreferredIntegerBitDepth(System.UInt16,System.Boolean)">
Sets preferred bit depth for integer pixel format textures.
        @param
            bits Number of bits. Available values: 0, 16 and 32, where 0 (the default) means keep
            original format as it is. This value is number of bits for the pixel.
        @param
            reloadTextures If true (the default), will reloading all reloadable textures.

</member>
        <member name="M:Ogre.TextureManager.createManual(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.TextureType,System.UInt32,System.UInt32">
Create a manual texture with specified width, height and depth (not loaded from a file).
            @param
                name The name to give the resulting texture
            @param
                group The name of the resource group to assign the texture to
            @param
                texType The type of texture to load/create, defaults to normal 2D textures
            @param
                width, height, depth The dimensions of the texture
            @param
                numMipmaps The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then
                the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps())
				If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible
				level, 1x1x1.
            @param
                format The internal format you wish to request; the manager reserves
                the right to create a different format if the one you select is
                not available in this context.
			@param 
				usage The kind of usage this texture is intended for. It 
				is a combination of TU_STATIC, TU_DYNAMIC, TU_WRITE_ONLY, 
				TU_AUTOMIPMAP and TU_RENDERTARGET (see TextureUsage enum). You are
            	strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to 
            	update regularly, consider HBU_DYNAMIC_WRITE_ONLY.
            @param
                loader If you intend the contents of the manual texture to be 
                regularly updated, to the extent that you don't need to recover 
                the contents if the texture content is lost somehow, you can leave
                this parameter as 0. However, if you intend to populate the
                texture only once, then you should implement ManualResourceLoader
                and pass a pointer to it in this parameter; this means that if the
                manual texture ever needs to be reloaded, the ManualResourceLoader
                will be called to do it.
			@param hwGammaCorrection Pass 'true' to enable hardware gamma correction
				(sRGB) on this texture. The hardware will convert from gamma space
				to linear space when reading from this texture. Only applicable for 
				8-bits per channel textures, will be ignored for other types. Has the advantage
				over pre-applied gamma that the texture precision is maintained.
			@param fsaa The level of multisampling to use if this is a render target. Ignored
				if usage does not include TU_RENDERTARGET or if the device does
				not support it.


Create a manual texture with a depth of 1 (not loaded from a file).
            @param
                name The name to give the resulting texture
            @param
                group The name of the resource group to assign the texture to
            @param
                texType The type of texture to load/create, defaults to normal 2D textures
            @param
                width, height The dimensions of the texture
            @param
                numMipmaps The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then
                the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()).
				If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible
				level, 1x1x1.
            @param
                format The internal format you wish to request; the manager reserves
                the right to create a different format if the one you select is
                not available in this context.
			@param 
				usage The kind of usage this texture is intended for. It 
				is a combination of TU_STATIC, TU_DYNAMIC, TU_WRITE_ONLY, 
				TU_AUTOMIPMAP and TU_RENDERTARGET (see TextureUsage enum). You are
            	strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to 
            	update regularly, consider HBU_DYNAMIC_WRITE_ONLY.
            @param
                loader If you intend the contents of the manual texture to be 
                regularly updated, to the extent that you don't need to recover 
                the contents if the texture content is lost somehow, you can leave
                this parameter as 0. However, if you intend to populate the
                texture only once, then you should implement ManualResourceLoader
                and pass a pointer to it in this parameter; this means that if the
                manual texture ever needs to be reloaded, the ManualResourceLoader
                will be called to do it.
			 @param hwGammaCorrection Pass 'true' to enable hardware gamma correction
				 (sRGB) on this texture. The hardware will convert from gamma space
				 to linear space when reading from this texture. Only applicable for 
				 8-bits per channel textures, will be ignored for other types. Has the advantage
				 over pre-applied gamma that the texture precision is maintained.
			@param fsaa The level of multisampling to use if this is a render target. Ignored
				if usage does not include TU_RENDERTARGET or if the device does
				not support it.

</member>
        <member name="M:Ogre.TextureManager.loadRawData(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runti">
Loads a texture from a raw data stream.
            @note
                The texture will create as manual texture without loader.
            @param
                name The name to give the resulting texture
            @param
                group The name of the resource group to assign the texture to
            @param
                stream Incoming data stream
            @param
                width, height The dimensions of the texture
            @param
                format The format of the data being passed in; the manager reserves
                the right to create a different format for the texture if the 
                original format is not available in this context.
            @param
                texType The type of texture to load/create, defaults to normal 2D textures
            @param
                numMipmaps The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then
                the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps())
				If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible
				level, 1x1x1.
            @param
                gamma The gamma adjustment factor to apply to this texture (brightening/darkening)
				 while loading
			 @param hwGammaCorrection Pass 'true' to enable hardware gamma correction
				 (sRGB) on this texture. The hardware will convert from gamma space
				 to linear space when reading from this texture. Only applicable for 
				 8-bits per channel textures, will be ignored for other types. Has the advantage
				 over pre-applied gamma that the texture precision is maintained.


</member>
        <member name="M:Ogre.TextureManager.loadImage(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Image!System.Runtime.CompilerServices.IsCo">
Loads a texture from an Image object.
            @note
                The texture will create as manual texture without loader.
            @param
                name The name to give the resulting texture
            @param
                group The name of the resource group to assign the texture to
            @param
                img The Image object which contains the data to load
            @param
                texType The type of texture to load/create, defaults to normal 2D textures
            @param
                numMipmaps The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then
                the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps())
				If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible
				level, 1x1x1.
            @param
                gamma The gamma adjustment factor to apply to this texture (brightening/darkening)
			@param 
				isAlpha Only applicable to greyscale images. If true, specifies that
				the image should be loaded into an alpha texture rather than a
				single channel colour texture - useful for fixed-function systems.
			@param 
				desiredFormat The format you would like to have used instead of
				the format being based on the contents of the texture
			@param hwGammaCorrection Pass 'true' to enable hardware gamma correction
				(sRGB) on this texture. The hardware will convert from gamma space
				to linear space when reading from this texture. Only applicable for 
				8-bits per channel textures, will be ignored for other types. Has the advantage
				over pre-applied gamma that the texture precision is maintained.

</member>
        <member name="M:Ogre.TextureManager.load(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.TextureType,System.Int32,System.Single,System.B">
Loads a texture from a file.
            @param
                name The file to load, or a String identifier in some cases
            @param
                group The name of the resource group to assign the texture to
            @param
                texType The type of texture to load/create, defaults to normal 2D textures
            @param
                numMipmaps The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then
                the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps())
				If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible
				level, 1x1x1.
            @param
                gamma The gamma adjustment factor to apply to this texture (brightening/darkening)
					during loading
			@param 
				isAlpha Only applicable to greyscale images. If true, specifies that
				the image should be loaded into an alpha texture rather than a
				single channel colour texture - useful for fixed-function systems.
			@param 
				desiredFormat The format you would like to have used instead of
				the format being based on the contents of the texture. Pass PF_UNKNOWN
				to default.
			@param hwGammaCorrection Pass 'true' to enable hardware gamma correction
				(sRGB) on this texture. The hardware will convert from gamma space
				to linear space when reading from this texture. Only applicable for 
				8-bits per channel textures, will be ignored for other types. Has the advantage
				over pre-applied gamma that the texture precision is maintained.

</member>
        <member name="M:Ogre.TextureManager.prepare(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.TextureType,System.Int32,System.Single,Syste">
Prepares to loads a texture from a file.
            @param
                name The file to load, or a String identifier in some cases
            @param
                group The name of the resource group to assign the texture to
            @param
                texType The type of texture to load/create, defaults to normal 2D textures
            @param
                numMipmaps The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then
                the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps())
                If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible
                level, 1x1x1.
            @param
                gamma The gamma adjustment factor to apply to this texture (brightening/darkening)
            @param 
                isAlpha Only applicable to greyscale images. If true, specifies that
                the image should be loaded into an alpha texture rather than a
                single channel colour texture - useful for fixed-function systems.
            @param 
                desiredFormat The format you would like to have used instead of
                the format being based on the contents of the texture
			@param hwGammaCorrection Pass 'true' to enable hardware gamma correction
				(sRGB) on this texture. The hardware will convert from gamma space
				to linear space when reading from this texture. Only applicable for 
				8-bits per channel textures, will be ignored for other types. Has the advantage
				over pre-applied gamma that the texture precision is maintained.

</member>
        <member name="M:Ogre.TextureManager.createOrRetrieve(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.ManualResourceLoader">
Create a new texture, or retrieve an existing one with the same
            name if it already exists.
            @param
                texType The type of texture to load/create, defaults to normal 2D textures
            @param
                numMipmaps The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then
                the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps())
                If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible
                level, 1x1x1.
            @param
                gamma The gamma adjustment factor to apply to this texture (brightening/darkening)
            @param 
                isAlpha Only applicable to greyscale images. If true, specifies that
                the image should be loaded into an alpha texture rather than a
                single channel colour texture - useful for fixed-function systems.
            @param 
                desiredFormat The format you would like to have used instead of
                the format being based on the contents of the texture
			@param hwGammaCorrection Pass 'true' to enable hardware gamma correction
				(sRGB) on this texture. The hardware will convert from gamma space
				to linear space when reading from this texture. Only applicable for 
				8-bits per channel textures, will be ignored for other types. Has the advantage
				over pre-applied gamma that the texture precision is maintained.
            @see ResourceManager::createOrRetrieve

</member>
        <member name="M:Ogre.RenderObjectListener.notifyRenderSingleObject(Ogre.Renderable*,Ogre.Pass!System.Runtime.CompilerServices.IsConst*,Ogre.AutoParamDataSource!System.Runtime.CompilerServices.IsConst*,Ogre.HashedVector&lt;Ogre.Light**&gt;!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Event raised when render single object started.
		@remarks
		This method is called by the SceneManager.
		@param pass The renderable that is going to be rendered.
		@param pass The pass which was set.
		@param source The auto parameter source used within this render call.
		@pLightList The light list in use.
		@suppressRenderStateChanges True if render state changes should be suppressed.

</member>
        <member name="T:Ogre.RenderObjectListener">
Abstract interface which classes must implement if they wish to receive
        events from the scene manager when single object is about to be rendered. 

</member>
        <member name="M:Ogre.RenderQueueListener.renderQueueEnded(System.Byte,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Event raised after a queue group is rendered. 
        @remarks
            This method is called by the SceneManager after each queue group is
            rendered. 
        @param queueGroupId The id of the queue group which has just been rendered
		@param invocation Name of the invocation which is causing this to be 
			called (@see RenderQueueInvocation)
		@param repeatThisInvocation A boolean passed by reference which is by default set to 
			false. If the event sets this to true, the queue which has just been
			rendered will be repeated, and the renderQueueStarted and renderQueueEnded
			events will also be fired for it again.

</member>
        <member name="M:Ogre.RenderQueueListener.renderQueueStarted(System.Byte,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Event raised before a queue group is rendered. 
        @remarks
            This method is called by the SceneManager before each queue group is
            rendered. 
        @param queueGroupId The id of the queue group which is about to be rendered
		@param invocation Name of the invocation which is causing this to be 
			called (@see RenderQueueInvocation)
		@param skipThisInvocation A boolean passed by reference which is by default set to 
			false. If the event sets this to true, the queue will be skipped and not
			rendered. Note that in this case the renderQueueEnded event will not be raised
			for this queue group.

</member>
        <member name="M:Ogre.RenderQueueListener.postRenderQueues">
Event raised after all render queues are processed. 

</member>
        <member name="M:Ogre.RenderQueueListener.preRenderQueues">
Event raised before all render queues are processed. 

</member>
        <member name="T:Ogre.RenderQueueListener">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

Abstract interface which classes must implement if they wish to receive
        events from the render queue. 
    @remarks
        The OGRE render queue is divided into several queue groups, as defined by
        uint8. A class may implement this interface, and register itself
        as a listener by calling SceneManager::addRenderQueueListener. After doing so,
        the class will receive an event before and after each queue group is sent to 
        the rendering system.
    @par
        The event listeners have an option to make a queue either be skipped, or to repeat.
        Note that if multiple listeners are registered, the one registered last has the final
        say, although options set by previous listeners will not be changed if the latest
        does not express a preference.

</member>
        <member name="M:Ogre.RenderQueueInvocationSequence.iterator">
Get an iterator over the invocations. 
</member>
        <member name="M:Ogre.RenderQueueInvocationSequence.remove(System.UInt32)">
Removes (and deletes) an invocation by index. 
</member>
        <member name="M:Ogre.RenderQueueInvocationSequence.get(System.UInt32)">
Gets the details of an invocation at a given index. 
</member>
        <member name="M:Ogre.RenderQueueInvocationSequence.clear">
Clear and delete all invocations in this sequence. 
</member>
        <member name="M:Ogre.RenderQueueInvocationSequence.size">
Get the number of invocations in this sequence. 
</member>
        <member name="M:Ogre.RenderQueueInvocationSequence.add(Ogre.RenderQueueInvocation*)">
Add a custom invocation to the sequence.
		@remarks
			Use this to add your own custom subclasses of RenderQueueInvocation
			to the sequence; just remember that this class takes ownership of
			deleting this pointer when it is cleared / destroyed.

</member>
        <member name="M:Ogre.RenderQueueInvocationSequence.add(System.Byte,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add a standard invocation to the sequence.
		@param renderQueueGroupID The ID of the render queue group
		@param invocationName Optional name to identify the invocation, useful
			for listeners if a single queue group is invoked more than once
		@returns A new RenderQueueInvocatin instance which you may customise

</member>
        <member name="M:Ogre.RenderQueueInvocationSequence.getName">
Get the name of this sequence. 
</member>
        <member name="T:Ogre.RenderQueueInvocationSequence">
Class to hold a linear sequence of RenderQueueInvocation objects. 
	@remarks
		This is just a simple data holder class which contains a list of 
		RenderQueueInvocation objects representing the sequence of invocations
		made for a viewport. It's only real purpose is to ensure that 
		RenderQueueInvocation instances are deleted on shutdown, since you can
		provide your own subclass instances on RenderQueueInvocation. Remember
		that any invocation instances you give to this class will be deleted
		by it when it is cleared / destroyed.

</member>
        <member name="D:Ogre.RenderQueueInvocationList">
List of RenderQueueInvocations
</member>
        <member name="F:Ogre.RenderQueueInvocation.RENDER_QUEUE_INVOCATION_SHADOWS">
Invocation identifier for shadows
</member>
        <member name="M:Ogre.RenderQueueInvocation.invoke(Ogre.RenderQueueGroup*,Ogre.SceneManager*)">
Invoke this class on a concrete queue group.
		@remarks
			Implementation will send the queue group to the target scene manager
			after doing what it needs to do.

</member>
        <member name="M:Ogre.RenderQueueInvocation.getSuppressRenderStateChanges">
Gets whether shadows are suppressed when invoking this queue. 

</member>
        <member name="M:Ogre.RenderQueueInvocation.setSuppressRenderStateChanges(System.Boolean)">
Sets whether render state changes are suppressed when invoking this queue. 
		@remarks
			When doing special effects you may want to set up render state yourself
			and have it apply for the entire rendering of a queue. In that case, 
			you should call this method with a parameter of 'true', and use a
			RenderQueueListener to set the render state directly on RenderSystem
			yourself before the invocation.
		@par
			Suppressing render state changes is only intended for advanced use, 
			don't use it if you're unsure of the effect. The only RenderSystem
			calls made are to set the world matrix for each object (note - 
			view an projection matrices are NOT SET - they are under your control) 
			and to render the object; it is up to the caller to do everything else, 
			including enabling any vertex / fragment programs and updating their 
			parameter state, and binding parameters to the RenderSystem.
			We advise you use a RenderQueueListener in order to get a notification
			when this invocation is going to happen (use an invocation name to
			identify it if you like), at which point you can set the state you
			need to apply before the objects are rendered.

</member>
        <member name="M:Ogre.RenderQueueInvocation.getSuppressShadows">
Gets whether shadows are suppressed when invoking this queue. 

</member>
        <member name="M:Ogre.RenderQueueInvocation.setSuppressShadows(System.Boolean)">
Sets whether shadows are suppressed when invoking this queue. 
		@remarks
			When doing effects you often will want to suppress shadow processing
			if shadows will already have been done by a previous render.

</member>
        <member name="M:Ogre.RenderQueueInvocation.getSolidsOrganisation">
Get the organisation mode being used for solids in this queue group
			invocation.

</member>
        <member name="M:Ogre.RenderQueueInvocation.setSolidsOrganisation(Ogre.QueuedRenderableCollection.OrganisationMode)">
Set the organisation mode being used for solids in this queue group
		invocation.

</member>
        <member name="M:Ogre.RenderQueueInvocation.getInvocationName">
Get the invocation name (may be blank if not set by creator)
</member>
        <member name="M:Ogre.RenderQueueInvocation.getRenderQueueGroupID">
Get the render queue group id
</member>
        <member name="M:Ogre.RenderQueueInvocation.#ctor(System.Byte,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor
		@param renderQueueGroupID ID of the queue this will target
		@param invocationName Optional name to uniquely identify this
			invocation from others in a RenderQueueListener

</member>
        <member name="F:Ogre.RenderQueueInvocation.mSuppressRenderStateChanges">
Suppress OGRE's render state management?
</member>
        <member name="F:Ogre.RenderQueueInvocation.mSuppressShadows">
Suppress shadows processing in this invocation?
</member>
        <member name="F:Ogre.RenderQueueInvocation.mSolidsOrganisation">
Solids ordering mode
</member>
        <member name="F:Ogre.RenderQueueInvocation.mInvocationName">
Invocation identifier - used in listeners
</member>
        <member name="F:Ogre.RenderQueueInvocation.mRenderQueueGroupID">
Target queue group
</member>
        <member name="T:Ogre.RenderQueueInvocation">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

Class representing the invocation of queue groups in a RenderQueue.
	@remarks
		The default behaviour for OGRE's render queue is to render each queue
		group in turn, dealing with shadows automatically, and rendering solids
		in grouped passes, followed by transparent objects in descending order.
		This class, together with RenderQueueInvocationSequence and the ability
		to associate one with a Viewport, allows you to change that behaviour
		and render queue groups in arbitrary sequence, repeatedly, and to skip
		shadows, change the ordering of solids, or even prevent OGRE controlling
		the render state during a particular invocation for special effects.
	@par
		Note that whilst you can change the ordering of rendering solids, you 
		can't change the ordering on transparent objects, since to do this would
		cause them to render incorrectly.
	@par
		As well as using this class directly and using the options it provides you
		with, you can also provide subclasses of it to a 
		RenderQueueInvocationSequence instance if you want to gain ultimate control.
	@note
		Invocations will be skipped if there are scene-level options preventing
		them being rendered - for example special-case render queues and
		render queue listeners that dictate this.

</member>
        <member name="M:Ogre.RenderQueueGroup.merge(Ogre.RenderQueueGroup!System.Runtime.CompilerServices.IsConst*)">
Merge group of renderables. 

</member>
        <member name="M:Ogre.RenderQueueGroup.defaultOrganisationMode">
Setthe  sorting / grouping mode for the solids in this group to the default.
		@remarks
			You can only do this when the group is empty, ie after clearing the 
			queue.
		@see QueuedRenderableCollection::OrganisationMode

</member>
        <member name="M:Ogre.RenderQueueGroup.addOrganisationMode(Ogre.QueuedRenderableCollection.OrganisationMode)">
Add a required sorting / grouping mode for the solids in this group.
		@remarks
			You can only do this when the group is empty, ie after clearing the 
			queue.
		@see QueuedRenderableCollection::OrganisationMode

</member>
        <member name="M:Ogre.RenderQueueGroup.resetOrganisationModes">
Reset the organisation modes required for the solids in this group. 
		@remarks
			You can only do this when the group is empty, ie after clearing the 
			queue.
		@see QueuedRenderableCollection::OrganisationMode

</member>
        <member name="M:Ogre.RenderQueueGroup.setShadowCastersCannotBeReceivers(System.Boolean)">
Sets whether or not objects which cast shadows should be treated as
		never receiving shadows. 

</member>
        <member name="M:Ogre.RenderQueueGroup.setSplitNoShadowPasses(System.Boolean)">
Sets whether or not the queue will split passes which have shadow receive
        turned off (in their parent material), which is needed when certain shadow
        techniques are used.

</member>
        <member name="M:Ogre.RenderQueueGroup.setSplitPassesByLightingType(System.Boolean)">
Sets whether or not the queue will split passes by their lighting type,
        ie ambient, per-light and decal. 

</member>
        <member name="M:Ogre.RenderQueueGroup.getShadowsEnabled">
Are shadows enabled for this queue? 
</member>
        <member name="M:Ogre.RenderQueueGroup.setShadowsEnabled(System.Boolean)">
Indicate whether a given queue group will be doing any
		shadow setup.
		@remarks
		This method allows you to inform the queue about a queue group, and to 
		indicate whether this group will require shadow processing of any sort.
		In order to preserve rendering order, OGRE has to treat queue groups
		as very separate elements of the scene, and this can result in it
		having to duplicate shadow setup for each group. Therefore, if you
		know that a group which you are using will never need shadows, you
		should preregister the group using this method in order to improve
		the performance.

</member>
        <member name="M:Ogre.RenderQueueGroup.clear(System.Boolean)">
Clears this group of renderables. 
        @param destroy
            If false, doesn't delete any priority groups, just empties them. Saves on 
            memory deallocations since the chances are roughly the same kinds of 
            renderables are going to be sent to the queue again next time. If
			true, completely destroys.

</member>
        <member name="M:Ogre.RenderQueueGroup.addRenderable(Ogre.Renderable*,Ogre.Technique*,System.UInt16)">
Add a renderable to this group, with the given priority. 
</member>
        <member name="M:Ogre.RenderQueueGroup.getIterator">
Get an iterator for browsing through child contents. 

Get a const iterator for browsing through child contents. 
</member>
        <member name="F:Ogre.RenderQueueGroup.mOrganisationMode">
Bitmask of the organisation modes requested (for new priority groups)
</member>
        <member name="F:Ogre.RenderQueueGroup.mShadowsEnabled">
Whether shadows are enabled for this queue
</member>
        <member name="F:Ogre.RenderQueueGroup.mPriorityGroups">
Map of RenderPriorityGroup objects
</member>
        <member name="T:Ogre.RenderQueueGroup">
A grouping level underneath RenderQueue which groups renderables
    to be issued at coarsely the same time to the renderer.
    @remarks
        Each instance of this class itself hold RenderPriorityGroup instances, 
        which are the groupings of renderables by priority for fine control
        of ordering (not required for most instances).

</member>
        <member name="M:Ogre.RenderPriorityGroup.merge(Ogre.RenderPriorityGroup!System.Runtime.CompilerServices.IsConst*)">
Merge group of renderables. 

</member>
        <member name="M:Ogre.RenderPriorityGroup.setShadowCastersCannotBeReceivers(System.Boolean)">
Sets whether or not objects which cast shadows should be treated as
			never receiving shadows. 

</member>
        <member name="M:Ogre.RenderPriorityGroup.setSplitNoShadowPasses(System.Boolean)">
Sets whether or not passes which have shadow receive disabled should
            be separated. 

</member>
        <member name="M:Ogre.RenderPriorityGroup.setSplitPassesByLightingType(System.Boolean)">
Sets whether or not the queue will split passes by their lighting type,
        ie ambient, per-light and decal. 

</member>
        <member name="M:Ogre.RenderPriorityGroup.clear">
Clears this group of renderables. 

</member>
        <member name="M:Ogre.RenderPriorityGroup.sort(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Sorts the objects which have been added to the queue; transparent objects by their 
            depth in relation to the passed in Camera. 
</member>
        <member name="M:Ogre.RenderPriorityGroup.addRenderable(Ogre.Renderable*,Ogre.Technique*)">
Add a renderable to this group. 
</member>
        <member name="M:Ogre.RenderPriorityGroup.defaultOrganisationMode">
Set the sorting / grouping mode for the solids in this group to the default.
		@remarks
			You can only do this when the group is empty, i.e. after clearing the 
			queue.
		@see QueuedRenderableCollection::OrganisationMode

</member>
        <member name="M:Ogre.RenderPriorityGroup.addOrganisationMode(Ogre.QueuedRenderableCollection.OrganisationMode)">
Add a required sorting / grouping mode for the solids in this group.
		@remarks
			You can only do this when the group is empty, i.e. after clearing the 
			queue.
		@see QueuedRenderableCollection::OrganisationMode

</member>
        <member name="M:Ogre.RenderPriorityGroup.resetOrganisationModes">
Reset the organisation modes required for the solids in this group. 
		@remarks
			You can only do this when the group is empty, i.e. after clearing the 
			queue.
		@see QueuedRenderableCollection::OrganisationMode

</member>
        <member name="M:Ogre.RenderPriorityGroup.getTransparents">
Get the collection of transparent objects currently queued 
</member>
        <member name="M:Ogre.RenderPriorityGroup.getTransparentsUnsorted">
Get the collection of transparent objects currently queued 
</member>
        <member name="M:Ogre.RenderPriorityGroup.getSolidsNoShadowReceive">
Get the collection of solids for which shadow receipt is disabled (only
			applicable when shadows are enabled). 
</member>
        <member name="M:Ogre.RenderPriorityGroup.getSolidsDecal">
Get the collection of solids currently queued for decal passes (only 
			applicable in additive shadow modes). 
</member>
        <member name="M:Ogre.RenderPriorityGroup.getSolidsDiffuseSpecular">
Get the collection of solids currently queued per light (only applicable in 
		 	additive shadow modes). 
</member>
        <member name="M:Ogre.RenderPriorityGroup.getSolidsBasic">
Get the collection of basic solids currently queued, this includes
			all solids when there are no shadows, or all solids which have shadow
			receiving enabled when using modulative shadows, or all ambient passes
			of solids which have shadow receive enabled for additive shadows. 
</member>
        <member name="M:Ogre.RenderPriorityGroup.addTransparentRenderable(Ogre.Technique*,Ogre.Renderable*)">
Internal method for adding a transparent renderable
</member>
        <member name="M:Ogre.RenderPriorityGroup.addUnsortedTransparentRenderable(Ogre.Technique*,Ogre.Renderable*)">
Internal method for adding an unsorted transparent renderable
</member>
        <member name="M:Ogre.RenderPriorityGroup.addSolidRenderableSplitByLightType(Ogre.Technique*,Ogre.Renderable*)">
Internal method for adding a solid renderable
</member>
        <member name="M:Ogre.RenderPriorityGroup.addSolidRenderable(Ogre.Technique*,Ogre.Renderable*,System.Boolean)">
Internal method for adding a solid renderable
</member>
        <member name="M:Ogre.RenderPriorityGroup.removePassEntry(Ogre.Pass*)">
remove a pass entry from all collections
</member>
        <member name="F:Ogre.RenderPriorityGroup.mTransparents">
Transparent list
</member>
        <member name="F:Ogre.RenderPriorityGroup.mTransparentsUnsorted">
Unsorted transparent list
</member>
        <member name="F:Ogre.RenderPriorityGroup.mSolidsNoShadowReceive">
Solid pass list, used when shadows are enabled but shadow receive is turned off for these passes
</member>
        <member name="F:Ogre.RenderPriorityGroup.mSolidsDecal">
Solid decal (texture) pass list, used with additive shadows
</member>
        <member name="F:Ogre.RenderPriorityGroup.mSolidsDiffuseSpecular">
Solid per-light pass list, used with additive shadows
</member>
        <member name="F:Ogre.RenderPriorityGroup.mSolidsBasic">
Solid pass list, used when no shadows, modulative shadows, or ambient passes for additive
</member>
        <member name="F:Ogre.RenderPriorityGroup.mParent">
Parent queue group
</member>
        <member name="T:Ogre.RenderPriorityGroup">
Collection of renderables by priority.
    @remarks
        This class simply groups renderables for rendering. All the 
        renderables contained in this class are destined for the same
        RenderQueueGroup (coarse groupings like those between the main
        scene and overlays) and have the same priority (fine groupings
        for detailed overlap control).
    @par
        This class can order solid renderables by a number of criteria; 
		it can optimise them into groups based on pass to reduce render 
		state changes, or can sort them by ascending or descending view 
		depth. Transparent objects are always ordered by descending depth.
	@par
		To iterate over items in the collections held by this object 
	   	you should retrieve the collection in use (e.g. solids, solids with
		no shadows, transparents) and use the accept() method, providing 
		a class implementing QueuedRenderableVisitor.
	

</member>
        <member name="M:Ogre.QueuedRenderableCollection.merge(Ogre.QueuedRenderableCollection!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Merge renderable collection. 

</member>
        <member name="M:Ogre.QueuedRenderableCollection.acceptVisitor(Ogre.QueuedRenderableVisitor*,Ogre.QueuedRenderableCollection.OrganisationMode)">
Accept a visitor over the collection contents.
		@param visitor Visitor class which should be called back
		@param om The organisation mode which you want to iterate over.
			Note that this must have been included in an addOrganisationMode
			call before any renderables were added.

</member>
        <member name="M:Ogre.QueuedRenderableCollection.sort(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Perform any sorting that is required on this collection.
		@param cam The camera

</member>
        <member name="M:Ogre.QueuedRenderableCollection.addRenderable(Ogre.Pass*,Ogre.Renderable*)">
Add a renderable to the collection using a given pass
</member>
        <member name="M:Ogre.QueuedRenderableCollection.addOrganisationMode(Ogre.QueuedRenderableCollection.OrganisationMode)">
Add a required sorting / grouping mode to this collection when next used.
		@remarks
			You can only do this when the collection is empty.
		@see OrganisationMode

</member>
        <member name="M:Ogre.QueuedRenderableCollection.resetOrganisationModes">
Reset the organisation modes required for this collection. 
		@remarks
			You can only do this when the collection is empty.
		@see OrganisationMode

</member>
        <member name="M:Ogre.QueuedRenderableCollection.removePassGroup(Ogre.Pass*)">
Remove the group entry (if any) for a given Pass.
		@remarks
			To be used when a pass is destroyed, such that any
			grouping level for it becomes useless.

</member>
        <member name="M:Ogre.QueuedRenderableCollection.clear">
Empty the collection
</member>
        <member name="M:Ogre.QueuedRenderableCollection.acceptVisitorAscending(Ogre.QueuedRenderableVisitor*)">
Internal visitor implementation
</member>
        <member name="M:Ogre.QueuedRenderableCollection.acceptVisitorDescending(Ogre.QueuedRenderableVisitor*)">
Internal visitor implementation
</member>
        <member name="M:Ogre.QueuedRenderableCollection.acceptVisitorGrouped(Ogre.QueuedRenderableVisitor*)">
Internal visitor implementation
</member>
        <member name="F:Ogre.QueuedRenderableCollection.mSortedDescending">
Sorted descending (can iterate backwards to get ascending)
</member>
        <member name="F:Ogre.QueuedRenderableCollection.mGrouped">
Grouped 
</member>
        <member name="F:Ogre.QueuedRenderableCollection.mOrganisationMode">
Bitmask of the organisation modes requested
</member>
        <member name="F:Ogre.QueuedRenderableCollection.msRadixSorter2">
Radix sorter for sort value 2 (distance)
</member>
        <member name="T:Ogre.QueuedRenderableCollection.RadixSortFunctorDistance">
Functor for descending sort value 2 for radix sort (distance)
</member>
        <member name="F:Ogre.QueuedRenderableCollection.msRadixSorter1">
Radix sorter for accessing sort value 1 (Pass)
</member>
        <member name="T:Ogre.QueuedRenderableCollection.RadixSortFunctorPass">
Functor for accessing sort value 1 for radix sort (Pass)
</member>
        <member name="D:Ogre.QueuedRenderableCollection.PassGroupRenderableMap">
Map of pass to renderable lists, this is a grouping by pass. 
</member>
        <member name="D:Ogre.QueuedRenderableCollection.RenderablePassList">
Vector of RenderablePass objects, this is built on the assumption that
         vectors only ever increase in size, so even if we do clear() the memory stays
         allocated, ie fast 
</member>
        <member name="T:Ogre.QueuedRenderableCollection.DepthSortDescendingLess">
Comparator to order objects by descending camera distance
</member>
        <member name="T:Ogre.QueuedRenderableCollection.PassGroupLess">
Comparator to order pass groups
</member>
        <member name="F:OM_SORT_ASCENDING">
Sort ascending camera distance 
				Note value overlaps with descending since both use same sort

</member>
        <member name="F:OM_SORT_DESCENDING">
Sort descending camera distance
</member>
        <member name="F:OM_PASS_GROUP">
Group by pass
</member>
        <member name="T:Ogre.QueuedRenderableCollection.OrganisationMode">
Organisation modes required for this collection.
		@remarks
			This affects the internal placement of the items added to this collection;
			if only one type of sorting / grouping is to be required, then renderables
			can be stored only once, whilst if multiple types are going to be needed
			then internally there will be multiple organisations. Changing the organisation
			needs to be done when the collection is empty.

</member>
        <member name="T:Ogre.QueuedRenderableCollection">
Lowest level collection of renderables.
	@remarks
		To iterate over items in this collection, you must call
		the accept method and supply a QueuedRenderableVisitor.
		The order of the iteration, and whether that iteration is
		over a RenderablePass list or a 2-level grouped list which 
		causes a visit call at the Pass level, and a call for each
		Renderable underneath.

</member>
        <member name="M:Ogre.QueuedRenderableVisitor.visit(Ogre.Renderable*)">
Visit method called once per Renderable on a grouped 
			collection.
		@remarks
			If this method is called, the RenderablePass visit 
			method will not be called for this collection. 

</member>
        <member name="M:Ogre.QueuedRenderableVisitor.visit(Ogre.RenderablePass*)">
Called when visiting a RenderablePass, i.e. items in a
			sorted collection where items are not grouped by pass.
		@remarks
			If this is called, neither of the other 2 visit methods
			will be called.

</member>
        <member name="T:Ogre.QueuedRenderableVisitor">
Visitor interface for items in a QueuedRenderableCollection.
	@remarks
		Those wishing to iterate over the items in a 
		QueuedRenderableCollection should implement this visitor pattern,
		since internal organisation of the collection depends on the 
		sorting method in use.

</member>
        <member name="F:Ogre.RenderablePass.pass">
Pointer to the Pass
</member>
        <member name="F:Ogre.RenderablePass.renderable">
Pointer to the Renderable details
</member>
        <member name="T:Ogre.RenderablePass">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

Struct associating a single Pass with a single Renderable. 
		This is used to for objects sorted by depth and thus not
		grouped by pass.

</member>
        <member name="M:Ogre.Technique.getUserObjectBindings">
Return an instance of user objects binding associated with this class.
		You can use it to associate one or more custom objects with this class instance.
		@see UserObjectBindings::setUserAny.


Return an instance of user objects binding associated with this class.
		You can use it to associate one or more custom objects with this class instance.
		@see UserObjectBindings::setUserAny.		

</member>
        <member name="M:Ogre.Technique.getGPUDeviceNameRuleIterator">
Get an iterator over the currently registered device name rules.
</member>
        <member name="M:Ogre.Technique.removeGPUDeviceNameRule(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Removes a matching device name rule.
		@see addGPUDeviceNameRule

</member>
        <member name="M:Ogre.Technique.addGPUDeviceNameRule(Ogre.Technique.GPUDeviceNameRule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add a rule which manually influences the support for this technique based
			on a pattern that matches a GPU device name (e.g. '*8800*').
		@remarks
			You can use this facility to manually control whether a technique is
			considered supported, based on a GPU device name pattern. You can add inclusive
			or exclusive rules, and you can add as many of each as you like. If
			at least one inclusive rule is added, a	technique is considered 
			unsupported if it does not match any of those inclusive rules. If exclusive rules are
			added, the technique is considered unsupported if it matches any of
			those inclusive rules. The pattern you supply can include wildcard
			characters ('*') if you only want to match part of the device name.
		@note
			Any rule for the same device pattern will be removed before adding this one.

</member>
        <member name="M:Ogre.Technique.addGPUDeviceNameRule(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Technique.IncludeOrExclude,System.Boolean)">
Add a rule which manually influences the support for this technique based
			on a pattern that matches a GPU device name (e.g. '*8800*').
		@remarks
			You can use this facility to manually control whether a technique is
			considered supported, based on a GPU device name pattern. You can add inclusive
			or exclusive rules, and you can add as many of each as you like. If
			at least one inclusive rule is added, a	technique is considered 
			unsupported if it does not match any of those inclusive rules. If exclusive rules are
			added, the technique is considered unsupported if it matches any of
			those inclusive rules. The pattern you supply can include wildcard
			characters ('*') if you only want to match part of the device name.
		@note
			Any rule for the same device pattern will be removed before adding this one.
		@param devicePattern The GPU vendor
		@param includeOrExclude Whether this is an inclusive or exclusive rule
		@param caseSensitive Whether the match is case sensitive or not

</member>
        <member name="M:Ogre.Technique.getGPUVendorRuleIterator">
Get an iterator over the currently registered vendor rules.
</member>
        <member name="M:Ogre.Technique.removeGPUVendorRule(Ogre.GPUVendor)">
Removes a matching vendor rule.
		@see addGPUVendorRule

</member>
        <member name="M:Ogre.Technique.addGPUVendorRule(Ogre.Technique.GPUVendorRule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add a rule which manually influences the support for this technique based
			on a GPU vendor.
		@remarks
			You can use this facility to manually control whether a technique is
			considered supported, based on a GPU vendor. You can add inclusive
			or exclusive rules, and you can add as many of each as you like. If
			at least one inclusive rule is added, a	technique is considered 
			unsupported if it does not match any of those inclusive rules. If exclusive rules are
			added, the technique is considered unsupported if it matches any of
			those inclusive rules. 
		@note
			Any rule for the same vendor will be removed before adding this one.

</member>
        <member name="M:Ogre.Technique.addGPUVendorRule(Ogre.GPUVendor,Ogre.Technique.IncludeOrExclude)">
Add a rule which manually influences the support for this technique based
			on a GPU vendor.
		@remarks
			You can use this facility to manually control whether a technique is
			considered supported, based on a GPU vendor. You can add inclusive
			or exclusive rules, and you can add as many of each as you like. If
			at least one inclusive rule is added, a	technique is considered 
			unsupported if it does not match any of those inclusive rules. If exclusive rules are
			added, the technique is considered unsupported if it matches any of
			those inclusive rules. 
		@note
			Any rule for the same vendor will be removed before adding this one.
		@param vendor The GPU vendor
		@param includeOrExclude Whether this is an inclusive or exclusive rule

</member>
        <member name="M:Ogre.Technique.applyTextureAliases(std.map&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.less&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerSer">
Applies texture names to Texture Unit State with matching texture name aliases.
            All passes, and Texture Unit States within the technique are checked.
            If matching texture aliases are found then true is returned.

        @param
            aliasList is a map container of texture alias, texture name pairs
        @param
            apply set true to apply the texture aliases else just test to see if texture alias matches are found.
        @return
            True if matching texture aliases were found in the Technique.

</member>
        <member name="M:Ogre.Technique.getName">
Gets the name of the technique
</member>
        <member name="M:Ogre.Technique.setName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the name of the technique.
        @remarks
		The use of technique name is optional.  Its useful in material scripts where a material could inherit
		from another material and only want to modify a particular technique.

</member>
        <member name="M:Ogre.Technique.hasColourWriteDisabled">
Exists colour writing disabled pass on this technique? 
</member>
        <member name="M:Ogre.Technique.isDepthCheckEnabled">
Is depth checking going to occur on this technique? 
</member>
        <member name="M:Ogre.Technique.isDepthWriteEnabled">
Is depth writing going to occur on this technique? 
</member>
        <member name="M:Ogre.Technique._getSchemeIndex">
Internal method for getting the scheme index
</member>
        <member name="M:Ogre.Technique.getSchemeName">
Returns the scheme to which this technique is assigned.
			@see Technique::setSchemeName

</member>
        <member name="M:Ogre.Technique.setSchemeName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the 'scheme name' for this technique. 
		@remarks
			Material schemes are used to control top-level switching from one
			set of techniques to another. For example, you might use this to 
			define 'high', 'medium' and 'low' complexity levels on materials
		    to allow a user to pick a performance / quality ratio. Another
			possibility is that you have a fully HDR-enabled pipeline for top
			machines, rendering all objects using unclamped shaders, and a 
			simpler pipeline for others; this can be implemented using 
			schemes.
		@par
			Every technique belongs to a scheme - if you don't specify one, the
			Technique belongs to the scheme called 'Default', which is also the
			scheme used to render by default. The active scheme is set one of
			two ways - either by calling Viewport::setMaterialScheme, or
			by manually calling MaterialManager::setActiveScheme.

</member>
        <member name="M:Ogre.Technique.getLodIndex">
Gets the level-of-detail index assigned to this Technique. 
</member>
        <member name="M:Ogre.Technique.setLodIndex(System.UInt16)">
Assigns a level-of-detail (LOD) index to this Technique.
        @remarks
            As noted previously, as well as providing fallback support for various
            graphics cards, multiple Technique objects can also be used to implement
            material LOD, where the detail of the material diminishes with distance to 
            save rendering power.
        @par
            By default, all Techniques have a LOD index of 0, which means they are the highest
            level of detail. Increasing LOD indexes are lower levels of detail. You can 
            assign more than one Technique to the same LOD index, meaning that the best 
            Technique that is supported at that LOD index is used. 
        @par
            You should not leave gaps in the LOD sequence; Ogre will allow you to do this
            and will continue to function as if the LODs were sequential, but it will 
            confuse matters.

</member>
        <member name="M:Ogre.Technique.setSeparateSceneBlending(Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst,Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst,Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst,Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst)">
Allows very fine control of blending every Pass with the existing contents of the scene, using individual factors both color and alpha channels
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setSeparateSceneBlending

</member>
        <member name="M:Ogre.Technique.setSceneBlending(Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst,Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst)">
Allows very fine control of blending every Pass with the existing contents of the scene.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setSceneBlending

</member>
        <member name="M:Ogre.Technique.setSeparateSceneBlending(Ogre.SceneBlendType!System.Runtime.CompilerServices.IsConst,Ogre.SceneBlendType!System.Runtime.CompilerServices.IsConst)">
Sets the kind of blending every pass has with the existing contents of the scene, using individual factors both color and alpha channels
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setSeparateSceneBlending

</member>
        <member name="M:Ogre.Technique.setSceneBlending(Ogre.SceneBlendType!System.Runtime.CompilerServices.IsConst)">
Sets the kind of blending every pass has with the existing contents of the scene.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setSceneBlending

</member>
        <member name="M:Ogre.Technique.setTextureAnisotropy(System.UInt32)">
Sets the anisotropy level to be used for all textures.
        @note
            This property has been moved to the TextureUnitState class, which is accessible via the 
            Technique and Pass. For simplicity, this method allows you to set these properties for 
            every current TeextureUnitState, If you need more precision, retrieve the Technique, 
            Pass and TextureUnitState instances and set the property there.
        @see TextureUnitState::setTextureAnisotropy

</member>
        <member name="M:Ogre.Technique.setTextureFiltering(Ogre.TextureFilterOptions)">
Set texture filtering for every texture unit in every Pass
        @note
            This property actually exists on the TextureUnitState class
            For simplicity, this method allows you to set these properties for 
            every current TeextureUnitState, If you need more precision, retrieve the  
            Pass and TextureUnitState instances and set the property there.
        @see TextureUnitState::setTextureFiltering

</member>
        <member name="M:Ogre.Technique.setDepthBias(System.Single,System.Single)">
Sets the depth bias to be used for each Pass.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setDepthBias

</member>
        <member name="M:Ogre.Technique.setFog(System.Boolean,Ogre.FogMode,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single)">
Sets the fogging mode applied to each pass.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setFog

</member>
        <member name="M:Ogre.Technique.setShadingMode(Ogre.ShadeOptions)">
Sets the type of light shading required
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setShadingMode

</member>
        <member name="M:Ogre.Technique.setLightingEnabled(System.Boolean)">
Sets whether or not dynamic lighting is enabled for every Pass.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setLightingEnabled

</member>
        <member name="M:Ogre.Technique.setManualCullingMode(Ogre.ManualCullingMode)">
Sets the manual culling mode, performed by CPU rather than hardware.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setManualCullingMode

</member>
        <member name="M:Ogre.Technique.setCullingMode(Ogre.CullingMode)">
Sets the culling mode for each pass  based on the 'vertex winding'.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setCullingMode

</member>
        <member name="M:Ogre.Technique.setColourWriteEnabled(System.Boolean)">
Sets whether or not colour buffer writing is enabled for each Pass.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setColourWriteEnabled

</member>
        <member name="M:Ogre.Technique.setDepthFunction(Ogre.CompareFunction)">
Sets the function used to compare depth values when depth checking is on.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setDepthFunction

</member>
        <member name="M:Ogre.Technique.setDepthWriteEnabled(System.Boolean)">
Sets whether or not each Pass renders with depth-buffer writing on or not.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setDepthWriteEnabled

</member>
        <member name="M:Ogre.Technique.setDepthCheckEnabled(System.Boolean)">
Sets whether or not each Pass renders with depth-buffer checking on or not.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setDepthCheckEnabled

</member>
        <member name="M:Ogre.Technique.setSelfIllumination(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the amount of self-illumination of every Pass in every Technique.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setSelfIllumination

</member>
        <member name="M:Ogre.Technique.setSelfIllumination(System.Single,System.Single,System.Single)">
Sets the amount of self-illumination of every Pass in every Technique.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setSelfIllumination

</member>
        <member name="M:Ogre.Technique.setShininess(System.Single)">
Sets the shininess properties of every Pass in every Technique.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setShininess

</member>
        <member name="M:Ogre.Technique.setSpecular(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the specular colour reflectance properties of every Pass in every Technique.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setSpecular

</member>
        <member name="M:Ogre.Technique.setSpecular(System.Single,System.Single,System.Single,System.Single)">
Sets the specular colour reflectance properties of every Pass in every Technique.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setSpecular

</member>
        <member name="M:Ogre.Technique.setDiffuse(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the diffuse colour reflectance properties of every Pass in every Technique.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setDiffuse

</member>
        <member name="M:Ogre.Technique.setDiffuse(System.Single,System.Single,System.Single,System.Single)">
Sets the diffuse colour reflectance properties of every Pass in every Technique.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setDiffuse

</member>
        <member name="M:Ogre.Technique.setAmbient(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the ambient colour reflectance properties for every Pass in every Technique.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setAmbient

</member>
        <member name="M:Ogre.Technique.setAmbient(System.Single,System.Single,System.Single)">
Sets the ambient colour reflectance properties for every Pass in every Technique.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setAmbient

</member>
        <member name="M:Ogre.Technique.setPointSize(System.Single)">
Sets the point size properties for every Pass in this Technique.
        @note
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
        @see Pass::setPointSize

</member>
        <member name="M:Ogre.Technique.setShadowReceiverMaterial(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set this material specific  shadow receiving specific material

</member>
        <member name="M:Ogre.Technique.setShadowReceiverMaterial(Ogre.MaterialPtr)">
set this material specific  shadow receiving specific material

</member>
        <member name="M:Ogre.Technique.getShadowReceiverMaterial">
return this material specific shadow receiving specific material

</member>
        <member name="M:Ogre.Technique.setShadowCasterMaterial(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set this material specific  shadow casting specific material

</member>
        <member name="M:Ogre.Technique.setShadowCasterMaterial(Ogre.MaterialPtr)">
set this material specific  shadow casting specific material

</member>
        <member name="M:Ogre.Technique.getShadowCasterMaterial">
return this material specific  shadow casting specific material

</member>
        <member name="M:Ogre.Technique._notifyNeedsRecompile">
Tells the technique that it needs recompilation. 
</member>
        <member name="M:Ogre.Technique._unload">
Internal unload method, derived from call to Material::unload. 
</member>
        <member name="M:Ogre.Technique._load">
Internal load method, derived from call to Material::load. 
</member>
        <member name="M:Ogre.Technique._unprepare">
Internal unprepare method, derived from call to Material::unprepare. 
</member>
        <member name="M:Ogre.Technique._prepare">
Internal prepare method, derived from call to Material::prepare. 
</member>
        <member name="M:Ogre.Technique.isTransparentSortingForced">
Returns true if this Technique has transparent sorting forced. 
		@remarks
			This basically boils down to whether the first pass
			has transparent sorting forced or not

</member>
        <member name="M:Ogre.Technique.isTransparentSortingEnabled">
Returns true if this Technique has transparent sorting enabled. 
		@remarks
			This basically boils down to whether the first pass
			has transparent sorting enabled or not

</member>
        <member name="M:Ogre.Technique.isTransparent">
Returns true if this Technique involves transparency. 
		@remarks
			This basically boils down to whether the first pass
			has a scene blending factor. Even if the other passes 
			do not, the base colour, including parts of the original 
			scene, may be used for blending, therefore we have to treat
			the whole Technique as transparent.

</member>
        <member name="M:Ogre.Technique.getResourceGroup">
Gets the resource group of the ultimate parent Material
</member>
        <member name="M:Ogre.Technique.op_Assign(Ogre.Technique!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Overloaded operator to copy on Technique to another. 
</member>
        <member name="M:Ogre.Technique.getParent">
Gets the parent Material
</member>
        <member name="M:Ogre.Technique.getIlluminationPassIterator">
Gets an iterator over the illumination-stage categorised passes. 
</member>
        <member name="M:Ogre.Technique.getPassIterator">
Gets an iterator over the passes in this Technique. 
</member>
        <member name="M:Ogre.Technique.movePass(System.UInt16!System.Runtime.CompilerServices.IsConst,System.UInt16!System.Runtime.CompilerServices.IsConst)">
Move a pass from source index to destination index.
            If successful then returns true.

</member>
        <member name="M:Ogre.Technique.removeAllPasses">
Removes all Passes from this Technique. 
</member>
        <member name="M:Ogre.Technique.removePass(System.UInt16)">
Removes the Pass with the given index. 
</member>
        <member name="M:Ogre.Technique.getNumPasses">
Retrieves the number of passes. 
</member>
        <member name="M:Ogre.Technique.getPass(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves the Pass matching name.
            Returns 0 if name match is not found.

</member>
        <member name="M:Ogre.Technique.getPass(System.UInt16)">
Retrieves the Pass with the given index. 
</member>
        <member name="M:Ogre.Technique.createPass">
Creates a new Pass for this Technique.
        @remarks
            A Pass is a single rendering pass, i.e. a single draw of the given material.
            Note that if you create a pass without a fragment program, during compilation of the
            material the pass may be split into multiple passes if the graphics card cannot
            handle the number of texture units requested. For passes with fragment programs, however, 
            the number of passes you create will never be altered, so you have to make sure 
            that you create an alternative fallback Technique for if a card does not have 
            enough facilities for what you're asking for.

</member>
        <member name="M:Ogre.Technique._compileIlluminationPasses">
Internal method for splitting the passes into illumination passes. 
</member>
        <member name="M:Ogre.Technique.checkHardwareSupport(System.Boolean,std.basic_stringstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for checking hardware support
</member>
        <member name="M:Ogre.Technique.checkGPURules(std.basic_stringstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for checking GPU vendor / device rules
</member>
        <member name="M:Ogre.Technique._compile(System.Boolean)">
Internal compilation method; see Material::compile. 
		@returns Any information explaining problems with the compile.

</member>
        <member name="M:Ogre.Technique.isSupported">
Indicates if this technique is supported by the current graphics card.
        @remarks
            This will only be correct after the Technique has been compiled, which is
            usually done from Material::compile.

</member>
        <member name="M:Ogre.Technique.#ctor(Ogre.Material*,Ogre.Technique!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:Ogre.Technique.#ctor(Ogre.Material*)">
Constructor
</member>
        <member name="T:Ogre.Technique.GPUDeviceNameRule">
Rule controlling whether technique is deemed supported based on GPU device name
</member>
        <member name="T:Ogre.Technique.GPUVendorRule">
Rule controlling whether technique is deemed supported based on GPU vendor
</member>
        <member name="F:EXCLUDE">
Exclusive - do not support if present
</member>
        <member name="F:INCLUDE">
Inclusive - only support if present
</member>
        <member name="T:Ogre.Technique.IncludeOrExclude">
Directive used to manually control technique support based on the
			inclusion or exclusion of some factor.

</member>
        <member name="F:Ogre.Technique.mShadowReceiverMaterialName">
When receiving shadow, if not using default Ogre shadow receiving material, or 
		* nor using fixed function texture projection receiving, mShadowReceiverMaterial let you customize per material
		* shadow caster behavior. There only material name is stored so that it can be loaded once all file parsed in a resource group.

</member>
        <member name="F:Ogre.Technique.mShadowReceiverMaterial">
When receiving shadow, if not using default Ogre shadow receiving material, or 
		* nor using fixed function texture projection receiving, mShadowReceiverMaterial let you customize per material
		* shadow caster behavior

</member>
        <member name="F:Ogre.Technique.mShadowCasterMaterialName">
When casting shadow, if not using default Ogre shadow casting material, or 
		* nor using fixed function casting, mShadowCasterMaterial let you customize per material
		* shadow caster behavior.There only material name is stored so that it can be loaded once all file parsed in a resource group.

</member>
        <member name="F:Ogre.Technique.mShadowCasterMaterial">
When casting shadow, if not using default Ogre shadow casting material, or 
		* nor using fixed function casting, mShadowCasterMaterial let you customize per material
		* shadow caster behavior

</member>
        <member name="M:Ogre.Technique.checkManuallyOrganisedIlluminationPasses">
Internal method - check for manually assigned illumination passes
</member>
        <member name="M:Ogre.Technique.clearIlluminationPasses">
Internal method for clearing illumination pass list
</member>
        <member name="F:Ogre.Technique.mSchemeIndex">
Scheme index, derived from scheme name but the names are held on
			MaterialManager, for speed an index is used here.

</member>
        <member name="F:Ogre.Technique.mLodIndex">
LOD level
</member>
        <member name="F:Ogre.Technique.mIlluminationPasses">
List of derived passes, categorised into IlluminationStage (ordered)
</member>
        <member name="F:Ogre.Technique.mPasses">
List of primary passes
</member>
        <member name="T:Ogre.Technique">
\addtogroup Core
	*  @{

\addtogroup Materials
	*  @{

Class representing an approach to rendering this particular Material. 
    @remarks
        Ogre will attempt to use the best technique supported by the active hardware, 
        unless you specifically request a lower detail technique (say for distant
        rendering).

</member>
        <member name="M:Ogre.RenderSystemCapabilities.log(Ogre.Log*)">
Write the capabilities to the pass in Log 
</member>
        <member name="M:Ogre.RenderSystemCapabilities.isCategoryRelevant(Ogre.CapabilitiesCategory)">
Return whether a category is 'relevant' or not, ie will it be reported
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setCategoryRelevant(Ogre.CapabilitiesCategory,System.Boolean)">
Mark a category as 'relevant' or not, ie will it be reported
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setRenderSystemName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Set the identifier of the rendersystem from which these capabilities were generated
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getRenderSystemName">
Get the identifier of the rendersystem from which these capabilities were generated
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getGeometryProgramNumOutputVertices">
Get the number of vertices a single geometry program run can emit
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setGeometryProgramNumOutputVertices(System.Int32)">
Set the number of vertices a single geometry program run can emit
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getVertexTextureUnitsShared">
Get whether the vertex texture units are shared with the fragment processor
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setVertexTextureUnitsShared(System.Boolean)">
Set whether the vertex texture units are shared with the fragment processor
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getNumVertexTextureUnits">
Get the number of vertex texture units supported
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setNumVertexTextureUnits(System.UInt16)">
Set the number of vertex texture units supported
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getNonPOW2TexturesLimited">
Are non-power of two textures limited in features?
		@remarks
		If the RSC_NON_POWER_OF_2_TEXTURES capability is set, but this
		method returns true, you can use non power of 2 textures only if:
		<ul><li>You load them explicitly with no mip maps</li><li>You don't use DXT texture compression</li><li>You use clamp texture addressing</li></ul></member>
        <member name="M:Ogre.RenderSystemCapabilities.setNonPOW2TexturesLimited(System.Boolean)">
Non-POW2 textures limited
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getMaxPointSize">
Maximum point screen size in pixels
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setMaxPointSize(System.Single)">
Maximum point screen size in pixels
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setFragmentProgramConstantBoolCount(System.UInt16)">
The number of boolean constants fragment programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setFragmentProgramConstantIntCount(System.UInt16)">
The number of integer constants fragment programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setFragmentProgramConstantFloatCount(System.UInt16)">
The number of floating-point constants fragment programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setGeometryProgramConstantBoolCount(System.UInt16)">
The number of boolean constants geometry programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setGeometryProgramConstantIntCount(System.UInt16)">
The number of integer constants geometry programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setGeometryProgramConstantFloatCount(System.UInt16)">
The number of floating-point constants geometry programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setVertexProgramConstantBoolCount(System.UInt16)">
The number of boolean constants vertex programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setVertexProgramConstantIntCount(System.UInt16)">
The number of integer constants vertex programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setVertexProgramConstantFloatCount(System.UInt16)">
The number of floating-point constants vertex programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getDeviceName">
gets the device name for render system
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setDeviceName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
sets the device name for Render system
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getFragmentProgramConstantBoolCount">
The number of boolean constants fragment programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getFragmentProgramConstantIntCount">
The number of integer constants fragment programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getFragmentProgramConstantFloatCount">
The number of floating-point constants fragment programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getGeometryProgramConstantBoolCount">
The number of boolean constants geometry programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getGeometryProgramConstantIntCount">
The number of integer constants geometry programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getGeometryProgramConstantFloatCount">
The number of floating-point constants geometry programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getVertexProgramConstantBoolCount">
The number of boolean constants vertex programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getVertexProgramConstantIntCount">
The number of integer constants vertex programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getVertexProgramConstantFloatCount">
The number of floating-point constants vertex programs support
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getSupportedShaderProfiles">
Returns a set of all supported shader profiles
		* 
</member>
        <member name="M:Ogre.RenderSystemCapabilities.isShaderProfileSupported(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns true if profile is in the list of supported profiles

</member>
        <member name="M:Ogre.RenderSystemCapabilities.removeShaderProfile(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Remove a given shader profile, if present.

</member>
        <member name="M:Ogre.RenderSystemCapabilities.addShaderProfile(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds the profile to the list of supported profiles

</member>
        <member name="M:Ogre.RenderSystemCapabilities.hasCapability(Ogre.Capabilities!System.Runtime.CompilerServices.IsConst)">
Checks for a capability

</member>
        <member name="M:Ogre.RenderSystemCapabilities.unsetCapability(Ogre.Capabilities!System.Runtime.CompilerServices.IsConst)">
Remove a capability flag

</member>
        <member name="M:Ogre.RenderSystemCapabilities.setCapability(Ogre.Capabilities!System.Runtime.CompilerServices.IsConst)">
Adds a capability flag

</member>
        <member name="M:Ogre.RenderSystemCapabilities.isCapabilityRenderSystemSpecific(Ogre.Capabilities!System.Runtime.CompilerServices.IsConst)">
Returns true if capability is render system specific

</member>
        <member name="M:Ogre.RenderSystemCapabilities.getNumMultiRenderTargets">
The number of simultaneous render targets supported
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getNumVertexBlendMatrices">
Returns the number of matrices available to hardware vertex 
		blending for this rendering system. 
</member>
        <member name="M:Ogre.RenderSystemCapabilities.getStencilBufferBitDepth">
Determines the bit depth of the hardware accelerated stencil 
		buffer, if supported.
		@remarks
		If hardware stencilling is not supported, the software will
		provide an 8-bit software stencil.

</member>
        <member name="M:Ogre.RenderSystemCapabilities.getNumTextureUnits">
Returns the number of texture units the current output hardware
		supports.

		For use in rendering, this determines how many texture units the
		are available for multitexturing (i.e. rendering multiple 
		textures in a single pass). Where a Material has multiple 
		texture layers, it will try to use multitexturing where 
		available, and where it is not available, will perform multipass
		rendering to achieve the same effect. This property only applies
		to the fixed-function pipeline, the number available to the 
		programmable pipeline depends on the shader model in use.

</member>
        <member name="M:Ogre.RenderSystemCapabilities.setNumMultiRenderTargets(System.UInt16)">
The number of simultaneous render targets supported
</member>
        <member name="M:Ogre.RenderSystemCapabilities.vendorToString(Ogre.GPUVendor)">
Convert a vendor enum to a string
</member>
        <member name="M:Ogre.RenderSystemCapabilities.vendorFromString(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Convert a vendor string to an enum
</member>
        <member name="M:Ogre.RenderSystemCapabilities.parseVendorFromString(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Parse and set vendor
</member>
        <member name="M:Ogre.RenderSystemCapabilities.setDriverVersion(Ogre.DriverVersion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the driver version. 
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mSupportedShaderProfiles">
The list of supported shader profiles
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mGeometryProgramNumOutputVertices">
The number of vertices a geometry program can emit in a single run
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mVertexTextureUnitsShared">
Are vertex texture units shared with fragment processor?
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mNumVertexTextureUnits">
The number of vertex texture units supported
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mNonPOW2TexturesLimited">
Are non-POW2 textures feature-limited?
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mMaxPointSize">
The maximum point size
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mNumMultiRenderTargets">
The number of simultaneous render targets supported
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mFragmentProgramConstantBoolCount">
The number of boolean constants fragment programs support
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mFragmentProgramConstantIntCount">
The number of integer constants fragment programs support
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mFragmentProgramConstantFloatCount">
The number of floating-point constants fragment programs support
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mGeometryProgramConstantBoolCount">
The number of boolean constants vertex geometry support
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mGeometryProgramConstantIntCount">
The number of integer constants vertex geometry support
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mGeometryProgramConstantFloatCount">
The number of floating-point constants geometry programs support
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mVertexProgramConstantBoolCount">
The number of boolean constants vertex programs support
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mVertexProgramConstantIntCount">
The number of integer constants vertex programs support
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mVertexProgramConstantFloatCount">
The number of floating-point constants vertex programs support
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mRenderSystemName">
The identifier associated with the render system for which these capabilities are valid
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mDeviceName">
The name of the device as reported by the render system
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mCategoryRelevant">
Which categories are relevant
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mCapabilities">
Stores the capabilities flags.
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mNumVertexBlendMatrices">
The number of matrices available for hardware blending
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mStencilBufferBitDepth">
The stencil buffer bit depth
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mNumTextureUnits">
The number of texture units available
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mNumWorldMatrices">
The number of world matrices available
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mVendor">
GPU Vendor
</member>
        <member name="F:Ogre.RenderSystemCapabilities.mDriverVersion">
This is used to build a database of RSC's
if a RSC with same name, but newer version is introduced, the older one 
will be removed
</member>
        <member name="T:Ogre.RenderSystemCapabilities">
singleton class for storing the capabilities of the graphics card. 
	@remarks
	This class stores the capabilities of the graphics card.  This
	information is set by the individual render systems.

</member>
        <member name="T:Ogre.GPUVendor">
Enumeration of GPU vendors. 
</member>
        <member name="F:GPU_VENDOR_COUNT">
placeholder
</member>
        <member name="T:Ogre.DriverVersion">
DriverVersion is used by RenderSystemCapabilities and both GL and D3D9
to store the version of the current GPU driver
</member>
        <member name="T:Ogre.Capabilities">
Enum describing the different hardware capabilities we want to check for
OGRE_CAPS_VALUE(a, b) defines each capability
</member>
        <member name="F:RSC_POINT_EXTENDED_PARAMETERS_EXT">
Support for point parameters EXT implementation
</member>
        <member name="F:RSC_POINT_EXTENDED_PARAMETERS_ARB">
Support for point parameters ARB implementation
</member>
        <member name="F:RSC_GL1_5_NOHWOCCLUSION">
Support for GL 1.5 but without HW occlusion workaround
</member>
        <member name="F:RSC_PBUFFER">
Support for PBuffer
</member>
        <member name="F:RSC_FBO_ATI">
Support for Frame Buffer Objects ATI implementation (ARB FBO is higher precedence)
</member>
        <member name="F:RSC_FBO_ARB">
Support for Frame Buffer Objects ARB implementation (regular FBO is higher precedence)
</member>
        <member name="F:RSC_FBO">
Support for Frame Buffer Objects (FBOs)
</member>
        <member name="F:RSC_GL1_5_NOVBO">
Supports openGL GLEW version 1.5
</member>
        <member name="F:RSC_PERSTAGECONSTANT">
Is DirectX feature "per stage constants" supported
</member>
        <member name="F:RSC_ADVANCED_BLEND_OPERATIONS">
Supports Blending operations other than +
</member>
        <member name="F:RSC_ALPHA_TO_COVERAGE">
Supports Alpha to Coverage (A2C)
</member>
        <member name="F:RSC_MRT_DIFFERENT_BIT_DEPTHS">
Supports MRTs with different bit depths
</member>
        <member name="F:RSC_FIXED_FUNCTION">
Supports fixed-function pipeline
</member>
        <member name="F:RSC_TEXTURE_COMPRESSION_PVRTC">
Supports compressed textures in the PVRTC format
</member>
        <member name="F:RSC_TEXTURE_COMPRESSION_VTC">
Supports compressed textures in the VTC format
</member>
        <member name="F:RSC_TEXTURE_COMPRESSION_DXT">
Supports compressed textures in the DXT/ST3C formats
</member>
        <member name="F:RSC_TEXTURE_COMPRESSION">
Supports compressed textures
</member>
        <member name="F:RSC_HWRENDER_TO_VERTEX_BUFFER">
Supports rendering to vertex buffers
</member>
        <member name="F:RSC_GEOMETRY_PROGRAM">
Supports hardware geometry programs
</member>
        <member name="F:RSC_MIPMAP_LOD_BIAS">
Supports mipmap LOD biasing
</member>
        <member name="F:RSC_VERTEX_TEXTURE_FETCH">
Supports vertex texture fetch
</member>
        <member name="F:RSC_POINT_EXTENDED_PARAMETERS">
Supports extra point parameters (minsize, maxsize, attenuation)
</member>
        <member name="F:RSC_POINT_SPRITES">
Supports basic point sprite rendering
</member>
        <member name="F:RSC_TEXTURE_3D">
Supports 3d (volume) textures
</member>
        <member name="F:RSC_NON_POWER_OF_2_TEXTURES">
Supports non-power of two textures
</member>
        <member name="F:RSC_TEXTURE_FLOAT">
Supports float textures and render targets
</member>
        <member name="F:RSC_HWRENDER_TO_TEXTURE">
Supports hardware render-to-texture (bigger than framebuffer)
</member>
        <member name="F:RSC_INFINITE_FAR_PLANE">
Supports infinite far plane projection
</member>
        <member name="F:RSC_VERTEX_FORMAT_UBYTE4">
Supports the VET_UBYTE4 vertex element type
</member>
        <member name="F:RSC_USER_CLIP_PLANES">
Supports user clipping planes
</member>
        <member name="F:RSC_HWOCCLUSION">
Supports hardware occlusion queries
</member>
        <member name="F:RSC_STENCIL_WRAP">
Supports wrapping the stencil value at the range extremeties
</member>
        <member name="F:RSC_TWO_SIDED_STENCIL">
Supports separate stencil updates for both front and back faces
</member>
        <member name="F:RSC_SCISSOR_TEST">
Supports performing a scissor test to exclude areas of the screen
</member>
        <member name="F:RSC_FRAGMENT_PROGRAM">
Supports fragment programs (pixel shaders)
</member>
        <member name="F:RSC_VERTEX_PROGRAM">
Supports vertex programs (vertex shaders)
</member>
        <member name="F:RSC_VBO">
Supports hardware vertex and index buffers
</member>
        <member name="F:RSC_HWSTENCIL">
Supports hardware stencil buffer
</member>
        <member name="F:RSC_CUBEMAPPING">
Supports cube mapping
</member>
        <member name="F:RSC_DOT3">
Supports fixed-function DOT3 texture blend
</member>
        <member name="F:RSC_ANISOTROPY">
Supports anisotropic texture filtering
</member>
        <member name="F:RSC_AUTOMIPMAP">
Supports generating mipmaps in hardware
</member>
        <member name="T:Ogre.CapabilitiesCategory">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

Enumerates the categories of capabilities
</member>
        <member name="F:CAPS_CATEGORY_COUNT">
Placeholder for max value
</member>
        <member name="M:Ogre.StringConverter.isNumber(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Checks the String is a valid number value. 
</member>
        <member name="M:Ogre.StringConverter.parseStringVector(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Pareses a StringVector from a string.
        @remarks
            Strings must not contain spaces since space is used as a delimiter in
            the output.

</member>
        <member name="M:Ogre.StringConverter.parseColourValue(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Parses a ColourValue out of a String. 
        @remarks
            Format is "r g b a" (i.e. 4x Real values, space delimited), or "r g b" which implies
            an alpha value of 1.0 (opaque). Failure to parse returns ColourValue::Black.

</member>
        <member name="M:Ogre.StringConverter.parseQuaternion(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Parses a Quaternion out of a String. 
        @remarks
            Format is "w x y z" (i.e. 4x Real values, space delimited). 
            Failure to parse returns Quaternion::IDENTITY.


</member>
        <member name="M:Ogre.StringConverter.parseMatrix4(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Parses a Matrix4 out of a String.
        @remarks
            Format is "00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33" where 
            '01' means row 0 column 1 etc. Failure to parse returns Matrix4::IDENTITY.

</member>
        <member name="M:Ogre.StringConverter.parseMatrix3(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Parses a Matrix3 out of a String.
        @remarks
            Format is "00 01 02 10 11 12 20 21 22" where '01' means row 0 column 1 etc.
            Failure to parse returns Matrix3::IDENTITY.

</member>
        <member name="M:Ogre.StringConverter.parseVector4(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Parses a Vector4 out of a String.
        @remarks
            Format is "x y z w" ie. 4 Real components, space delimited. Failure to parse returns
            Vector4::ZERO.

</member>
        <member name="M:Ogre.StringConverter.parseVector3(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Parses a Vector3 out of a String.
        @remarks
            Format is "x y z" ie. 3 Real components, space delimited. Failure to parse returns
            Vector3::ZERO.

</member>
        <member name="M:Ogre.StringConverter.parseVector2(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Parses a Vector2 out of a String.
        @remarks
            Format is "x y" ie. 2 Real components, space delimited. Failure to parse returns
            Vector2::ZERO.

</member>
        <member name="M:Ogre.StringConverter.parseBool(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts a String to a boolean. 
        @remarks
            Returns true if case-insensitive match of the start of the string
			matches "true", "yes" or "1", false otherwise.

</member>
        <member name="M:Ogre.StringConverter.parseUnsignedLong(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts a String to a whole number. 
        @returns
            0.0 if the value could not be parsed, otherwise the numeric version of the String.

</member>
        <member name="M:Ogre.StringConverter.parseLong(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts a String to a whole number. 
        @returns
            0.0 if the value could not be parsed, otherwise the numeric version of the String.

</member>
        <member name="M:Ogre.StringConverter.parseUnsignedInt(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts a String to a whole number. 
        @returns
            0.0 if the value could not be parsed, otherwise the numeric version of the String.

</member>
        <member name="M:Ogre.StringConverter.parseInt(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts a String to a whole number. 
        @returns
            0.0 if the value could not be parsed, otherwise the numeric version of the String.

</member>
        <member name="M:Ogre.StringConverter.parseAngle(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts a String to a Angle. 
        @returns
            0.0 if the value could not be parsed, otherwise the Angle version of the String.

</member>
        <member name="M:Ogre.StringConverter.parseReal(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts a String to a Real. 
        @returns
            0.0 if the value could not be parsed, otherwise the Real version of the String.

</member>
        <member name="M:Ogre.StringConverter.toString(std.vector&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts a StringVector to a string.
        @remarks
            Strings must not contain spaces since space is used as a delimiter in
            the output.

</member>
        <member name="M:Ogre.StringConverter.toString(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts a ColourValue to a String. 
        @remarks
            Format is "r g b a" (i.e. 4x Real values, space delimited). 

</member>
        <member name="M:Ogre.StringConverter.toString(Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts a Quaternion to a String. 
        @remarks
            Format is "w x y z" (i.e. 4x Real values, space delimited)

</member>
        <member name="M:Ogre.StringConverter.toString(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts a Matrix4 to a String. 
        @remarks
            Format is "00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33" where 
            '01' means row 0 column 1 etc.

</member>
        <member name="M:Ogre.StringConverter.toString(Ogre.Matrix3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts a Matrix3 to a String. 
        @remarks
            Format is "00 01 02 10 11 12 20 21 22" where '01' means row 0 column 1 etc.

</member>
        <member name="M:Ogre.StringConverter.toString(Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts a Vector4 to a String. 
        @remarks
            Format is "x y z w" (i.e. 4x Real values, space delimited)

</member>
        <member name="M:Ogre.StringConverter.toString(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts a Vector3 to a String. 
        @remarks
            Format is "x y z" (i.e. 3x Real values, space delimited)

</member>
        <member name="M:Ogre.StringConverter.toString(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Converts a Vector2 to a String. 
        @remarks
            Format is "x y" (i.e. 2x Real values, space delimited)

</member>
        <member name="M:Ogre.StringConverter.toString(System.Boolean,System.Boolean)">
Converts a boolean to a String. 
        @param yesNo If set to true, result is 'yes' or 'no' instead of 'true' or 'false'

</member>
        <member name="M:Ogre.StringConverter.toString(System.Int32!System.Runtime.CompilerServices.IsLong,System.UInt16,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32)">
Converts a long to a String. 
</member>
        <member name="M:Ogre.StringConverter.toString(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt16,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32)">
Converts an unsigned long to a String. 
</member>
        <member name="M:Ogre.StringConverter.toString(System.UInt32,System.UInt16,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32)">
Converts a size_t to a String. 
</member>
        <member name="M:Ogre.StringConverter.toString(System.Int32,System.UInt16,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32)">
Converts an int to a String. 
</member>
        <member name="M:Ogre.StringConverter.toString(Ogre.Degree,System.UInt16,System.UInt16,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32)">
Converts a Degree to a String. 
</member>
        <member name="M:Ogre.StringConverter.toString(Ogre.Radian,System.UInt16,System.UInt16,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32)">
Converts a Radian to a String. 
</member>
        <member name="M:Ogre.StringConverter.toString(System.Single,System.UInt16,System.UInt16,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32)">
Converts a Real to a String. 
</member>
        <member name="T:Ogre.StringConverter">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

Class for converting the core Ogre data types to/from Strings.
    @remarks
        The code for converting values to and from strings is here as a separate
        class to avoid coupling String to other datatypes (and vice-versa) which reduces
        compilation dependency: important given how often the core types are used.
    @par
        This class is mainly used for parsing settings in text files. External applications
        can also use it to interface with classes which use the StringInterface template
        class.
    @par
        The String formats of each of the major types is listed with the methods. The basic types
        like int and Real just use the underlying C runtime library atof and atoi family methods,
        however custom types like Vector3, ColourValue and Matrix4 are also supported by this class
        using custom formats.
    @author
        Steve Streeting

</member>
        <member name="F:Ogre.Profiler.mAverageFrameTime">
Rolling average of millisecs
</member>
        <member name="F:Ogre.Profiler.mMaxTotalFrameTime">
The max frame time recorded
</member>
        <member name="F:Ogre.Profiler.mDisplayMode">
How to display the overlay
</member>
        <member name="F:Ogre.Profiler.mProfileMask">
Mask to decide whether a type of profile is enabled or not
</member>
        <member name="F:Ogre.Profiler.mNewEnableState">
Keeps track of the new enabled/disabled state that the user has requested
which will be applied after the frame ends
</member>
        <member name="F:Ogre.Profiler.mEnableStateChangePending">
Keeps track of whether this profiler has
received a request to be enabled/disabled
</member>
        <member name="F:Ogre.Profiler.mEnabled">
Whether this profiler is enabled
</member>
        <member name="F:Ogre.Profiler.mTotalFrameTime">
The total time each frame takes
</member>
        <member name="F:Ogre.Profiler.mTimer">
The timer used for profiling
</member>
        <member name="F:Ogre.Profiler.mCurrentFrame">
The number of elapsed frame, used with mUpdateDisplayFrequency
</member>
        <member name="F:Ogre.Profiler.mUpdateDisplayFrequency">
The number of frames that must elapse before the current
frame display is updated
</member>
        <member name="F:Ogre.Profiler.mBarSpacing">
The distance between bars
</member>
        <member name="F:Ogre.Profiler.mBarLineWidth">
The width of the min, avg, and max lines in a profile display
</member>
        <member name="F:Ogre.Profiler.mGuiBorderWidth">
The width of the border between the profile window and each bar
</member>
        <member name="F:Ogre.Profiler.mBarIndent">
The size of the indent for each profile display bar
</member>
        <member name="F:Ogre.Profiler.mGuiTop">
The vertical position of the stats window
</member>
        <member name="F:Ogre.Profiler.mGuiLeft">
The horz position of the stats window
</member>
        <member name="F:Ogre.Profiler.mGuiWidth">
The width of the stats window
</member>
        <member name="F:Ogre.Profiler.mGuiHeight">
The height of the stats window
</member>
        <member name="F:Ogre.Profiler.mBarHeight">
The height of each bar
</member>
        <member name="F:Ogre.Profiler.mProfileGui">
The window that displays the profiler results
</member>
        <member name="F:Ogre.Profiler.mOverlay">
The overlay which contains our profiler results display
</member>
        <member name="F:Ogre.Profiler.mMaxDisplayProfiles">
The max number of profiles we can display
</member>
        <member name="F:Ogre.Profiler.mInitialized">
Whether the GUI elements have been initialized
</member>
        <member name="F:Ogre.Profiler.mProfileBars">
Holds the display bars for each profile results
</member>
        <member name="F:Ogre.Profiler.mDisabledProfiles">
Holds the names of disabled profiles
</member>
        <member name="F:Ogre.Profiler.mProfileHistoryMap">
We use this for quick look-ups of profiles in the history list
</member>
        <member name="F:Ogre.Profiler.mProfileHistory">
Keeps track of the statistics of each profile
</member>
        <member name="F:Ogre.Profiler.mProfileFrame">
Accumulates the results of each profile per frame (since a profile can be called
more than once a frame)
</member>
        <member name="F:Ogre.Profiler.mProfiles">
A stack for each individual profile per frame
</member>
        <member name="F:Ogre.Profiler.ProfileHistory.hierarchicalLvl">
The hierarchical level of this profile, 0 being the root profile
</member>
        <member name="F:Ogre.Profiler.ProfileHistory.totalCalls">
The total number of times this profile was called
(used to calculate average)
</member>
        <member name="F:Ogre.Profiler.ProfileHistory.totalTimeMillisecs">
The total frame time this profile has taken in milliseconds
</member>
        <member name="F:Ogre.Profiler.ProfileHistory.totalTimePercent">
The total percentage of frame time this profile has taken
</member>
        <member name="F:Ogre.Profiler.ProfileHistory.numCallsThisFrame">
The number of times this profile has been called each frame
</member>
        <member name="F:Ogre.Profiler.ProfileHistory.minTimeMillisecs">
The minimum frame time this profile has taken in milliseconds
</member>
        <member name="F:Ogre.Profiler.ProfileHistory.minTimePercent">
The minimum percentage of frame time this profile has taken
</member>
        <member name="F:Ogre.Profiler.ProfileHistory.maxTimeMillisecs">
The maximum frame time this profile has taken in milliseconds
</member>
        <member name="F:Ogre.Profiler.ProfileHistory.maxTimePercent">
The maximum percentage of frame time this profile has taken
</member>
        <member name="F:Ogre.Profiler.ProfileHistory.currentTimeMillisecs">
The current frame time this profile has taken in milliseconds
</member>
        <member name="F:Ogre.Profiler.ProfileHistory.currentTimePercent">
The current percentage of frame time this profile has taken
</member>
        <member name="F:Ogre.Profiler.ProfileHistory.name">
The name of the profile
</member>
        <member name="T:Ogre.Profiler.ProfileHistory">
Represents a history of each profile during the duration of the app
</member>
        <member name="F:Ogre.Profiler.ProfileFrame.hierarchicalLvl">
The hierarchical level of this profile, 0 being the main loop
</member>
        <member name="F:Ogre.Profiler.ProfileFrame.calls">
The number of times this profile was called this frame
</member>
        <member name="F:Ogre.Profiler.ProfileFrame.frameTime">
The total time this profile has taken this frame
</member>
        <member name="F:Ogre.Profiler.ProfileFrame.name">
The name of the profile
</member>
        <member name="T:Ogre.Profiler.ProfileFrame">
Represents the total timing information of a profile
since profiles can be called more than once each frame
</member>
        <member name="F:Ogre.Profiler.ProfileInstance.hierarchicalLvl">
The hierarchical level of this profile, 0 being the root profile
</member>
        <member name="F:Ogre.Profiler.ProfileInstance.accum">
Represents the total time of all child profiles to subtract
from this profile
</member>
        <member name="F:Ogre.Profiler.ProfileInstance.currTime">
The time this profile was started
</member>
        <member name="F:Ogre.Profiler.ProfileInstance.parent">
The name of the parent, empty string if root
</member>
        <member name="F:Ogre.Profiler.ProfileInstance.name">
The name of the profile
</member>
        <member name="T:Ogre.Profiler.ProfileInstance">
Represents an individual profile call
</member>
        <member name="M:Ogre.Profiler.createPanel(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single,System.Single,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDerefere">
An internal function to create a panel 
</member>
        <member name="M:Ogre.Profiler.createTextArea(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single,System.Single,System.UInt32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsI">
An internal function to create a text area 
</member>
        <member name="M:Ogre.Profiler.createContainer">
An internal function to create the container which will hold our display elements
</member>
        <member name="M:Ogre.Profiler.changeEnableState">
Handles a change of the profiler's enabled state
</member>
        <member name="M:Ogre.Profiler.processFrameStats">
Processes the profiler data after each frame 
</member>
        <member name="M:Ogre.Profiler.displayResults">
Prints the profiling results of each frame 
</member>
        <member name="M:Ogre.Profiler.initialize">
Initializes the profiler's GUI elements 
</member>
        <member name="M:Ogre.Profiler.getSingletonPtr">
Override standard Singleton retrieval.
            @remarks
            Why do we do this? Well, it's because the Singleton
            implementation is in a .h file, which means it gets compiled
            into anybody who includes it. This is needed for the
            Singleton template to work, but we actually only want it
            compiled into the implementation of the class based on the
            Singleton, not all of them. If we don't change this, we get
            link errors when trying to use the Singleton-based class from
            an outside dll.
            @par
            This method just delegates to the template version anyway,
            but the implementation stays in this single compilation unit,
            preventing link errors.

</member>
        <member name="M:Ogre.Profiler.getSingleton">
Override standard Singleton retrieval.
            @remarks
            Why do we do this? Well, it's because the Singleton
            implementation is in a .h file, which means it gets compiled
            into anybody who includes it. This is needed for the
            Singleton template to work, but we actually only want it
            compiled into the implementation of the class based on the
            Singleton, not all of them. If we don't change this, we get
            link errors when trying to use the Singleton-based class from
            an outside dll.
            @par
            This method just delegates to the template version anyway,
            but the implementation stays in this single compilation unit,
            preventing link errors.

</member>
        <member name="M:Ogre.Profiler.setOverlayPosition(System.Single,System.Single)">
Set the position of the profiler overlay, in pixels. 
</member>
        <member name="M:Ogre.Profiler.setOverlayDimensions(System.Single,System.Single)">
Set the size of the profiler overlay, in pixels. 
</member>
        <member name="M:Ogre.Profiler.getUpdateDisplayFrequency">
Gets the frequency that the Profiler display is updated 
</member>
        <member name="M:Ogre.Profiler.setUpdateDisplayFrequency(System.UInt32)">
Sets the Profiler so the display of results are updated every n frames
</member>
        <member name="M:Ogre.Profiler.getDisplayMode">
Get the display mode for the overlay. 

</member>
        <member name="M:Ogre.Profiler.setDisplayMode(Ogre.Profiler.DisplayMode)">
Set the display mode for the overlay. 

</member>
        <member name="F:DISPLAY_MILLISECONDS">
Display milliseconds on the overlay
</member>
        <member name="F:DISPLAY_PERCENTAGE">
Display % frame usage on the overlay
</member>
        <member name="M:Ogre.Profiler.reset">
Clears the profiler statistics 
</member>
        <member name="M:Ogre.Profiler.logResults">
Outputs current profile statistics to the log 
</member>
        <member name="M:Ogre.Profiler.watchForLimit(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Boolean)">
Returns true if the specified profile goes over or under the given limit
                frame time
            @remarks If this is called during a frame, it will be reading the results
            from the previous frame. Therefore, it is best to use this after the frame
            has ended.
            @param limit A number between 0 and 1 representing the percentage of frame time
            @param greaterThan If true, this will return whether the limit is exceeded. Otherwise,
            it will return if the frame time has gone under this limit.

</member>
        <member name="M:Ogre.Profiler.watchForMin(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns true if the specified profile reaches a new frame time minimum
            @remarks If this is called during a frame, it will be reading the results
            from the previous frame. Therefore, it is best to use this after the frame
            has ended.

</member>
        <member name="M:Ogre.Profiler.watchForMax(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns true if the specified profile reaches a new frame time maximum
            @remarks If this is called during a frame, it will be reading the results
            from the previous frame. Therefore, it is best to use this after the frame
            has ended.

</member>
        <member name="M:Ogre.Profiler.getProfileGroupMask">
Get the mask which all profiles must pass to be enabled. 

</member>
        <member name="M:Ogre.Profiler.setProfileGroupMask(System.UInt32)">
Set the mask which all profiles must pass to be enabled. 

</member>
        <member name="M:Ogre.Profiler.disableProfile(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Disables a profile
            @remarks Only disables the profile if this function is not called during
            the profile it is trying to disable.

</member>
        <member name="M:Ogre.Profiler.enableProfile(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Enables a previously disabled profile 
            @remarks Only enables the profile if this function is not 
            called during the profile it is trying to enable.

</member>
        <member name="M:Ogre.Profiler.getEnabled">
Gets whether this profiler is enabled 
</member>
        <member name="M:Ogre.Profiler.setEnabled(System.Boolean)">
Sets whether this profiler is enabled. Only takes effect after the
                the frame has ended.
                @remarks When this is called the first time with the parameter true,
                it initializes the GUI for the Profiler

</member>
        <member name="M:Ogre.Profiler.endProfile(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Ends a profile
            @remarks 
                Use the macro OgreProfileEnd(name) instead of calling this directly so that
                profiling can be ignored in the release version of your app.
            @remarks
                This function is usually not called directly unless you want a profile to
                last outside of its scope. In most cases, using the macro OgreProfile(name) 
                which will call this function automatically when it goes out of scope. Make 
                sure the name of this profile matches its corresponding beginProfile name. 
                This function will be ignored for a profile that has been disabled or if the
                profiler is disabled.
			@param profileName Must be unique and must not be an empty string
			@param groupID A profile group identifier, which can allow you to mask profiles

</member>
        <member name="M:Ogre.Profiler.beginProfile(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Begins a profile
            @remarks 
                Use the macro OgreProfileBegin(name) instead of calling this directly 
                so that profiling can be ignored in the release version of your app. 
            @remarks 
                You only use the macro (or this) if you want a profile to last outside
                of its scope (i.e. the main game loop). If you use this function, make sure you 
                use a corresponding OgreProfileEnd(name). Usually you would use the macro 
                OgreProfile(name). This function will be ignored for a profile that has been 
                disabled or if the profiler is disabled.
            @param profileName Must be unique and must not be an empty string
			@param groupID A profile group identifier, which can allow you to mask profiles

</member>
        <member name="M:Ogre.Profiler.getTimer">
Retrieves the timer for the profiler 
</member>
        <member name="M:Ogre.Profiler.setTimer(Ogre.Timer*)">
Sets the timer for the profiler 
</member>
        <member name="T:Ogre.Profiler">
The profiler allows you to measure the performance of your code
        @remarks
            Do not create profiles directly from this unless you want a profile to last
            outside of its scope (i.e. the main game loop). For most cases, use the macro
            OgreProfile(name) and braces to limit the scope. You must enable the Profile
            before you can used it with setEnabled(true). If you want to disable profiling
            in Ogre, simply set the macro OGRE_PROFILING to 0.
        @author Amit Mathew (amitmathew (at) yahoo (dot) com)
        @todo resolve artificial cap on number of profiles displayed
        @todo fix display ordering of profiles not called every frame

</member>
        <member name="F:Ogre.Profile.mGroupID">
The group ID
</member>
        <member name="F:Ogre.Profile.mName">
The name of this profile
</member>
        <member name="T:Ogre.Profile">
An individual profile that will be processed by the Profiler
        @remarks
            Use the macro OgreProfile(name) instead of instantiating this profile directly
        @remarks
            We use this Profile to allow scoping rules to signify the beginning and end of
            the profile. Use the Profiler singleton (through the macro OgreProfileBegin(name)
            and OgreProfileEnd(name)) directly if you want a profile to last
            outside of a scope (i.e. the main game loop).
        @author Amit Mathew (amitmathew (at) yahoo (dot) com)

</member>
        <member name="T:Ogre.ProfileGroupMask">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

List of reserved profiling masks

</member>
        <member name="F:OGREPROF_RENDERING">
Rendering
</member>
        <member name="F:OGREPROF_CULLING">
Culling
</member>
        <member name="F:OGREPROF_GENERAL">
General processing
</member>
        <member name="F:OGREPROF_ALL">
All in-built Ogre profiling will match this mask
</member>
        <member name="F:OGREPROF_USER_DEFAULT">
User default profile
</member>
        <member name="F:Ogre.IlluminationPass.originalPass">
The original pass which spawned this one
</member>
        <member name="F:Ogre.IlluminationPass.destroyOnShutdown">
Whether this pass is one which should be deleted itself
</member>
        <member name="F:Ogre.IlluminationPass.pass">
The pass to use in this stage
</member>
        <member name="T:Ogre.IlluminationPass">
Struct recording a pass which can be used for a specific illumination stage.
    @remarks
        This structure is used to record categorised passes which fit into a
        number of distinct illumination phases - ambient, diffuse / specular
        (per-light) and decal (post-lighting texturing).
        An original pass may fit into one of these categories already, or it
        may require splitting into its component parts in order to be categorised
        properly.

</member>
        <member name="M:Ogre.Pass.getUserObjectBindings">
Return an instance of user objects binding associated with this class.
		You can use it to associate one or more custom objects with this class instance.
		@see UserObjectBindings::setUserAny.


Return an instance of user objects binding associated with this class.
		You can use it to associate one or more custom objects with this class instance.
		@see UserObjectBindings::setUserAny.		

</member>
        <member name="M:Ogre.Pass.getBuiltinHashFunction(Ogre.Pass.BuiltinHashFunction)">
Get the builtin hash function.

</member>
        <member name="M:Ogre.Pass.getHashFunction">
Get the hash function used for all passes.

</member>
        <member name="M:Ogre.Pass.setHashFunction(Ogre.Pass.HashFunc*)">
Set the hash function used for all passes.
		@remarks
			You absolutely must not change the hash function whilst any Pass instances
			exist in the render queue. The only time you can do this is either
			before you render anything, or directly after you manuall call
			RenderQueue::clear(true) to completely destroy the queue structures.
		@note
			You can also use one of the built-in hash functions, see the alternate version
			of this method. The default is MIN_TEXTURE_CHANGE.
		@see HashFunc

</member>
        <member name="M:Ogre.Pass.setHashFunction(Ogre.Pass.BuiltinHashFunction)">
Sets one of the default hash functions to be used.
		@remarks
			You absolutely must not change the hash function whilst any Pass instances
			exist in the render queue. The only time you can do this is either
			before you render anything, or directly after you manuall call
			RenderQueue::clear(true) to completely destroy the queue structures.
			The default is MIN_TEXTURE_CHANGE.
		@note
			You can also implement your own hash function, see the alternate version
			of this method.
		@see HashFunc

</member>
        <member name="F:MIN_GPU_PROGRAM_CHANGE">
Try to minimise the number of GPU program changes.
			@note Only really useful if you use GPU programs for all of your
				materials. 

</member>
        <member name="F:MIN_TEXTURE_CHANGE">
Try to minimise the number of texture changes. 
</member>
        <member name="T:Ogre.Pass.BuiltinHashFunction">
There are some default hash functions used to order passes so that
			render state changes are minimised, this enumerates them.

</member>
        <member name="M:Ogre.Pass.getIlluminationStage">
Get the manually assigned illumination stage, if any
</member>
        <member name="M:Ogre.Pass.setIlluminationStage(Ogre.IlluminationStage)">
Manually set which illumination stage this pass is a member of.
		@remarks
			When using an additive lighting mode (SHADOWTYPE_STENCIL_ADDITIVE or
			SHADOWTYPE_TEXTURE_ADDITIVE), the scene is rendered in 3 discrete
			stages, ambient (or pre-lighting), per-light (once per light, with 
			shadowing) and decal (or post-lighting). Usually OGRE figures out how
			to categorise your passes automatically, but there are some effects you
			cannot achieve without manually controlling the illumination. For example
			specular effects are muted by the typical sequence because all textures
			are saved until the IS_DECAL stage which mutes the specular effect. 
			Instead, you could do texturing within the per-light stage if it's
			possible for your material and thus add the specular on after the
			decal texturing, and have no post-light rendering. 
		@par
			If you assign an illumination stage to a pass you have to assign it
			to all passes in the technique otherwise it will be ignored. Also note
			that whilst you can have more than one pass in each group, they cannot
			alternate, ie all ambient passes will be before all per-light passes, 
			which will also be before all decal passes. Within their categories
			the passes will retain their ordering though.

</member>
        <member name="M:Ogre.Pass.getLightClipPlanesEnabled">
Gets whether or not this pass will be clipped by user clips planes
			bounding the area covered by the light.

</member>
        <member name="M:Ogre.Pass.setLightClipPlanesEnabled(System.Boolean)">
Gets whether or not this pass will be clipped by user clips planes
			bounding the area covered by the light.
		@remarks
			In order to cut down on the geometry set up to render this pass 
			when you have a single fixed-range light being rendered through it, 
			you can enable this option to request that during triangle setup, 
			clip planes are defined to bound the range of the light. In the case
			of a point light these planes form a cube, and in the case of 
			a spotlight they form a pyramid. Directional lights are never clipped.
		@par
			This option is only likely to be useful for multipass additive lighting 
			algorithms, where the scene has already been 'seeded' with an ambient 
			pass and this pass is just adding light in affected areas. In addition,
			it will only be honoured if there is exactly one non-directional light
			being used in this pass. Also, these clip planes override any user clip
			planes set on Camera.
		@note
			When using SHADOWTYPE_STENCIL_ADDITIVE or SHADOWTYPE_TEXTURE_ADDITIVE,
			this option is automatically used for all per-light passes if you 
			enable SceneManager::setShadowUseLightClipPlanes and does
			not need to be specified. It is disabled by default since clip planes have
			a cost of their own which may not always exceed the benefits they give you.

</member>
        <member name="M:Ogre.Pass.getLightScissoringEnabled">
Gets whether or not this pass will be clipped by a scissor rectangle
			encompassing the lights that are being used in it.

</member>
        <member name="M:Ogre.Pass.setLightScissoringEnabled(System.Boolean)">
Sets whether or not this pass will be clipped by a scissor rectangle
			encompassing the lights that are being used in it.
		@remarks
			In order to cut down on fillrate when you have a number of fixed-range
			lights in the scene, you can enable this option to request that
			during rendering, only the region of the screen which is covered by
			the lights is rendered. This region is the screen-space rectangle 
			covering the union of the spheres making up the light ranges. Directional
			lights are ignored for this.
		@par
			This is only likely to be useful for multipass additive lighting 
			algorithms, where the scene has already been 'seeded' with an ambient 
			pass and this pass is just adding light in affected areas.
		@note
			When using SHADOWTYPE_STENCIL_ADDITIVE or SHADOWTYPE_TEXTURE_ADDITIVE,
			this option is implicitly used for all per-light passes and does
			not need to be specified. If you are not using shadows or are using
			a modulative or an integrated shadow technique then this could be useful.


</member>
        <member name="M:Ogre.Pass.applyTextureAliases(std.map&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.less&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices">
Applies texture names to Texture Unit State with matching texture name aliases.
            All Texture Unit States within the pass are checked.
            If matching texture aliases are found then true is returned.

        @param
            aliasList is a map container of texture alias, texture name pairs
        @param
            apply set true to apply the texture aliases else just test to see if texture alias matches are found.
        @return
            True if matching texture aliases were found in the pass.

</member>
        <member name="M:Ogre.Pass.getPassIterationCount">
Gets the pass iteration count value.

</member>
        <member name="M:Ogre.Pass.setPassIterationCount(System.UInt32!System.Runtime.CompilerServices.IsConst)">
set the number of iterations that this pass
        should perform when doing fast multi pass operation.
        @remarks
            Only applicable for programmable passes.
        @param count number of iterations to perform fast multi pass operations.
            A value greater than 1 will cause the pass to be executed count number of
            times without changing the render state.  This is very usefull for passes
            that use programmable shaders that have to iterate more than once but don't
            need a render state change.  Using multi pass can dramatically speed up rendering
            for materials that do things like fur, blur.
            A value of 1 turns off multi pass operation and the pass does
            the normal pass operation.

</member>
        <member name="M:Ogre.Pass.isAmbientOnly">
Returns whether this pass is ambient only.

</member>
        <member name="M:Ogre.Pass.queueForDeletion">
Queue this pass for deletion when appropriate. 
</member>
        <member name="M:Ogre.Pass.processPendingPassUpdates">
Process all dirty and pending deletion passes. 
</member>
        <member name="M:Ogre.Pass.clearDirtyHashList">
Static method to reset the list of passes which need their hash
		    values recalculated.
		@remarks
			For performance, the dirty list is not updated progressively as
			the hashes are recalculated, instead we expect the processor of the
			dirty hash list to clear the list when they are done.

</member>
        <member name="M:Ogre.Pass.getPassGraveyard">
Static method to retrieve all the Passes which are pending deletion.

</member>
        <member name="M:Ogre.Pass.getDirtyHashList">
Static method to retrieve all the Passes which need their
		    hash values recalculated.

</member>
        <member name="M:Ogre.Pass.getNormaliseNormals">
Returns true if this pass has auto-normalisation of normals set. 
</member>
        <member name="M:Ogre.Pass.setNormaliseNormals(System.Boolean)">
If set to true, this forces normals to be normalised dynamically 
			by the hardware for this pass.
		@remarks
			This option can be used to prevent lighting variations when scaling an
			object - normally because this scaling is hardware based, the normals 
			get scaled too which causes lighting to become inconsistent. By default the
			SceneManager detects scaled objects and does this for you, but 
			this has an overhead so you might want to turn that off through
			SceneManager::setNormaliseNormalsOnScale(false) and only do it per-Pass
			when you need to.

</member>
        <member name="M:Ogre.Pass.setTextureAnisotropy(System.UInt32)">
Sets the anisotropy level to be used for all textures.
        @note
            This property has been moved to the TextureUnitState class, which is accessible via the
            Technique and Pass. For simplicity, this method allows you to set these properties for
            every current TeextureUnitState, If you need more precision, retrieve the Technique,
            Pass and TextureUnitState instances and set the property there.
        @see TextureUnitState::setTextureAnisotropy

</member>
        <member name="M:Ogre.Pass.setTextureFiltering(Ogre.TextureFilterOptions)">
Set texture filtering for every texture unit 
        @note
            This property actually exists on the TextureUnitState class
            For simplicity, this method allows you to set these properties for
            every current TeextureUnitState, If you need more precision, retrieve the
            TextureUnitState instance and set the property there.
        @see TextureUnitState::setTextureFiltering

</member>
        <member name="M:Ogre.Pass._getTextureUnitWithContentTypeIndex(Ogre.TextureUnitState.ContentType,System.UInt16)">
Gets the 'nth' texture which references the given content type.
		@remarks
			If the 'nth' texture unit which references the content type doesn't
			exist, then this method returns an arbitrary high-value outside the
			valid range to index texture units.

</member>
        <member name="M:Ogre.Pass._updateAutoParams(Ogre.AutoParamDataSource!System.Runtime.CompilerServices.IsConst*,System.UInt16)">
Update automatic parameters.
		@param source The source of the parameters
		@param variabilityMask A mask of GpuParamVariability which identifies which autos will need updating

</member>
        <member name="M:Ogre.Pass._notifyNeedsRecompile">
Tells the pass that it needs recompilation. 
</member>
        <member name="M:Ogre.Pass._recalculateHash">
Internal method for recalculating the hash.
		@remarks
			Do not call this unless you are sure the old hash is not still being
			used by anything. If in doubt, call _dirtyHash if you want to force
			recalculation of the has next time.

</member>
        <member name="M:Ogre.Pass._dirtyHash">
Mark the hash as dirty
</member>
        <member name="M:Ogre.Pass.getHash">
Gets the 'hash' of this pass, ie a precomputed number to use for sorting
        @remarks
            This hash is used to sort passes, and for this reason the pass is hashed
            using firstly its index (so that all passes are rendered in order), then
            by the textures which it's TextureUnitState instances are using.

</member>
        <member name="M:Ogre.Pass._unload">
Internal method for unloading this pass. 
</member>
        <member name="M:Ogre.Pass._load">
Internal method for loading this pass. 
</member>
        <member name="M:Ogre.Pass._unprepare">
Internal method for undoing the load preparartion for this pass. 
</member>
        <member name="M:Ogre.Pass._prepare">
Internal method for preparing to load this pass. 
</member>
        <member name="M:Ogre.Pass._notifyIndex(System.UInt16)">
Internal method to adjust pass index. 
</member>
        <member name="M:Ogre.Pass._split(System.UInt16)">
Splits this Pass to one which can be handled in the number of
			texture units specified.
		@remarks
			Only works on non-programmable passes, programmable passes cannot be
			split, it's up to the author to ensure that there is a fallback Technique
			for less capable cards.
		@param numUnits The target number of texture units
		@returns A new Pass which contains the remaining units, and a scene_blend
				setting appropriate to approximate the multitexture. This Pass will be
				attached to the parent Technique of this Pass.

</member>
        <member name="M:Ogre.Pass.getGeometryProgram">
Gets the geometry program used by this pass, only available after _load(). 
</member>
        <member name="M:Ogre.Pass.getGeometryProgramParameters">
Gets the geometry program parameters used by this pass. 
</member>
        <member name="M:Ogre.Pass.getGeometryProgramName">
Gets the name of the geometry program used by this pass. 
</member>
        <member name="M:Ogre.Pass.setGeometryProgramParameters(Ogre.SharedPtr&lt;Ogre.GpuProgramParameters&gt;)">
Sets the geometry program parameters.
		@remarks
			Only applicable to programmable passes.

</member>
        <member name="M:Ogre.Pass.setGeometryProgram(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Sets the details of the geometry program to use.
		@remarks
			Only applicable to programmable passes, this sets the details of
			the geometry program to use in this pass. The program will not be
			loaded until the parent Material is loaded.
		@param name The name of the program - this must have been
			created using GpuProgramManager by the time that this Pass
			is loaded. If this parameter is blank, any geometry program in this pass is disabled.
        @param resetParams
            If true, this will create a fresh set of parameters from the
            new program being linked, so if you had previously set parameters
            you will have to set them again. If you set this to false, you must
            be absolutely sure that the parameters match perfectly, and in the
            case of named parameters refers to the indexes underlying them,
            not just the names.

</member>
        <member name="M:Ogre.Pass.getFragmentProgram">
Gets the fragment program used by this pass, only available after _load(). 
</member>
        <member name="M:Ogre.Pass.getFragmentProgramParameters">
Gets the fragment program parameters used by this pass. 
</member>
        <member name="M:Ogre.Pass.getFragmentProgramName">
Gets the name of the fragment program used by this pass. 
</member>
        <member name="M:Ogre.Pass.setFragmentProgramParameters(Ogre.SharedPtr&lt;Ogre.GpuProgramParameters&gt;)">
Sets the fragment program parameters.
		@remarks
			Only applicable to programmable passes.

</member>
        <member name="M:Ogre.Pass.setFragmentProgram(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Sets the details of the fragment program to use.
		@remarks
			Only applicable to programmable passes, this sets the details of
			the fragment program to use in this pass. The program will not be
			loaded until the parent Material is loaded.
		@param name The name of the program - this must have been
			created using GpuProgramManager by the time that this Pass
			is loaded. If this parameter is blank, any fragment program in this pass is disabled.
        @param resetParams
            If true, this will create a fresh set of parameters from the
            new program being linked, so if you had previously set parameters
            you will have to set them again. If you set this to false, you must
            be absolutely sure that the parameters match perfectly, and in the
            case of named parameters refers to the indexes underlying them,
            not just the names.

</member>
        <member name="M:Ogre.Pass.getShadowReceiverFragmentProgram">
Gets the fragment program used by this pass when rendering shadow receivers,
		only available after _load(). 
</member>
        <member name="M:Ogre.Pass.getShadowReceiverFragmentProgramParameters">
Gets the fragment program parameters used by this pass when rendering shadow receivers. 
</member>
        <member name="M:Ogre.Pass.getShadowReceiverFragmentProgramName">
Gets the name of the fragment program used by this pass when rendering shadow receivers. 
</member>
        <member name="M:Ogre.Pass.getShadowReceiverVertexProgram">
Gets the vertex program used by this pass when rendering shadow receivers,
        only available after _load(). 
</member>
        <member name="M:Ogre.Pass.getShadowReceiverVertexProgramParameters">
Gets the vertex program parameters used by this pass when rendering shadow receivers. 
</member>
        <member name="M:Ogre.Pass.getShadowReceiverVertexProgramName">
Gets the name of the vertex program used by this pass when rendering shadow receivers. 
</member>
        <member name="M:Ogre.Pass.setShadowReceiverFragmentProgramParameters(Ogre.SharedPtr&lt;Ogre.GpuProgramParameters&gt;)">
Sets the fragment program parameters for rendering as a shadow receiver.
        @remarks
        Only applicable to programmable passes, and this particular call is
        designed for low-level programs; use the named parameter methods
        for setting high-level program parameters.

</member>
        <member name="M:Ogre.Pass.setShadowReceiverVertexProgramParameters(Ogre.SharedPtr&lt;Ogre.GpuProgramParameters&gt;)">
Sets the vertex program parameters for rendering as a shadow receiver.
        @remarks
        Only applicable to programmable passes, and this particular call is
        designed for low-level programs; use the named parameter methods
        for setting high-level program parameters.

</member>
        <member name="M:Ogre.Pass.setShadowReceiverVertexProgram(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the details of the vertex program to use when rendering as a
            shadow receiver.
        @remarks
            Texture-based shadows require that the shadow receiver is rendered using
            a projective texture. Whilst Ogre can arrange this for the fixed function
            pipeline, passes which use vertex programs might need the vertex
            programs still to run in order to preserve any deformation etc
            that it does. So in this case, we need a vertex program which does the
            appropriate vertex transformation, but generates projective texture
            coordinates.
        @par
            Therefore, it is up to implementors of vertex programs to provide an
            alternative vertex program which can be used to render the object
            as a shadow receiver. Do all the same vertex transforms, but generate
            <strong>2 sets</strong> of texture coordinates using the auto parameter
            ACT_TEXTURE_VIEWPROJ_MATRIX, which Ogre will bind to the parameter name /
            index you supply as the second parameter to this method. 2 texture
            sets are needed because Ogre needs to use 2 texture units for some
            shadow effects.
        @note
            This is only applicable to programmable passes.
        @par
            The default behaviour is for Ogre to switch to fixed-function
            rendering if an explict vertex program alternative is not set.

</member>
        <member name="M:Ogre.Pass.getShadowCasterVertexProgram">
Gets the vertex program used by this pass when rendering shadow casters,
            only available after _load(). 
</member>
        <member name="M:Ogre.Pass.getShadowCasterVertexProgramParameters">
Gets the vertex program parameters used by this pass when rendering shadow casters. 
</member>
        <member name="M:Ogre.Pass.getShadowCasterVertexProgramName">
Gets the name of the vertex program used by this pass when rendering shadow casters. 
</member>
        <member name="M:Ogre.Pass.setShadowCasterVertexProgramParameters(Ogre.SharedPtr&lt;Ogre.GpuProgramParameters&gt;)">
Sets the vertex program parameters for rendering as a shadow caster.
        @remarks
        Only applicable to programmable passes, and this particular call is
        designed for low-level programs; use the named parameter methods
        for setting high-level program parameters.

</member>
        <member name="M:Ogre.Pass.setShadowCasterVertexProgram(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the details of the vertex program to use when rendering as a
        shadow caster.
        @remarks
        Texture-based shadows require that the caster is rendered to a texture
        in a solid colour (the shadow colour in the case of modulative texture
        shadows). Whilst Ogre can arrange this for the fixed function
        pipeline, passes which use vertex programs might need the vertex
        programs still to run in order to preserve any deformation etc
        that it does. However, lighting calculations must be a lot simpler,
        with only the ambient colour being used (which the engine will ensure
        is bound to the shadow colour).
        @par
        Therefore, it is up to implementors of vertex programs to provide an
        alternative vertex program which can be used to render the object
        to a shadow texture. Do all the same vertex transforms, but set the
        colour of the vertex to the ambient colour, as bound using the
        standard auto parameter binding mechanism.
        @note
        Some vertex programs will work without doing this, because Ogre ensures
        that all lights except for ambient are set black. However, the chances
        are that your vertex program is doing a lot of unnecessary work in this
        case, since the other lights are having no effect, and it is good practice
        to supply an alternative.
        @note
        This is only applicable to programmable passes.
        @par
        The default behaviour is for Ogre to switch to fixed-function
        rendering if an explicit vertex program alternative is not set.

</member>
        <member name="M:Ogre.Pass.getVertexProgram">
Gets the vertex program used by this pass, only available after _load(). 
</member>
        <member name="M:Ogre.Pass.getVertexProgramParameters">
Gets the vertex program parameters used by this pass. 
</member>
        <member name="M:Ogre.Pass.getVertexProgramName">
Gets the name of the vertex program used by this pass. 
</member>
        <member name="M:Ogre.Pass.setVertexProgramParameters(Ogre.SharedPtr&lt;Ogre.GpuProgramParameters&gt;)">
Sets the vertex program parameters.
		@remarks
			Only applicable to programmable passes, and this particular call is
			designed for low-level programs; use the named parameter methods
			for setting high-level program parameters.

</member>
        <member name="M:Ogre.Pass.setVertexProgram(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Sets the details of the vertex program to use.
		@remarks
			Only applicable to programmable passes, this sets the details of
			the vertex program to use in this pass. The program will not be
			loaded until the parent Material is loaded.
		@param name The name of the program - this must have been
			created using GpuProgramManager by the time that this Pass
			is loaded. If this parameter is blank, any vertex program in this pass is disabled.
        @param resetParams
            If true, this will create a fresh set of parameters from the
            new program being linked, so if you had previously set parameters
            you will have to set them again. If you set this to false, you must
            be absolutely sure that the parameters match perfectly, and in the
            case of named parameters refers to the indexes underlying them,
            not just the names.

</member>
        <member name="M:Ogre.Pass.getResourceGroup">
Gets the resource group of the ultimate parent Material
</member>
        <member name="M:Ogre.Pass.getParent">
Gets the parent Technique
</member>
        <member name="M:Ogre.Pass.getLightCountPerIteration">
If light iteration is enabled, determine the number of lights per
		iteration.

</member>
        <member name="M:Ogre.Pass.setLightCountPerIteration(System.UInt16)">
If light iteration is enabled, determine the number of lights per
			iteration.
		@remarks
			The default for this setting is 1, so if you enable light iteration
			(Pass::setIteratePerLight), the pass is rendered once per light. If
			you set this value higher, the passes will occur once per 'n' lights.
			The start of the iteration is set by Pass::setStartLight and the end
			by Pass::setMaxSimultaneousLights.

</member>
        <member name="M:Ogre.Pass.getOnlyLightType">
Gets the single light type this pass runs for if  getIteratePerLight and
            getRunOnlyForOneLightType are both true. 
</member>
        <member name="M:Ogre.Pass.getRunOnlyForOneLightType">
Does this pass run only for a single light type (if getIteratePerLight is true). 
</member>
        <member name="M:Ogre.Pass.getIteratePerLight">
Does this pass run once for every light in range? 
</member>
        <member name="M:Ogre.Pass.setIteratePerLight(System.Boolean,System.Boolean,Ogre.Light.LightTypes)">
Sets whether or not this pass should iterate per light or number of
			lights which can affect the object being rendered.
		@remarks
			The default behaviour for a pass (when this option is 'false'), is
			for a pass to be rendered only once (or the number of times set in
			setPassIterationCount), with all the lights which could
			affect this object set at the same time (up to the maximum lights
			allowed in the render system, which is typically 8).
		@par
			Setting this option to 'true' changes this behaviour, such that
			instead of trying to issue render this pass once per object, it
			is run <b>per light</b>, or for a group of 'n' lights each time
			which can affect this object, the number of
			times set in setPassIterationCount (default is once). In
			this case, only light index 0 is ever used, and is a different light
			every time the pass is issued, up to the total number of lights
			which is affecting this object. This has 2 advantages:
			<ul><li>There is no limit on the number of lights which can be
			supported</li><li>It's easier to write vertex / fragment programs for this because
			a single program can be used for any number of lights</li></ul>
			However, this technique is more expensive, and typically you
			will want an additional ambient pass, because if no lights are 
			affecting the object it will not be rendered at all, which will look
			odd even if ambient light is zero (imagine if there are lit objects
			behind it - the objects silhouette would not show up). Therefore,
			use this option with care, and you would be well advised to provide
			a less expensive fallback technique for use in the distance.
		@note
			The number of times this pass runs is still limited by the maximum
			number of lights allowed as set in setMaxSimultaneousLights, so
			you will never get more passes than this. Also, the iteration is
			started from the 'start light' as set in Pass::setStartLight, and
			the number of passes is the number of lights to iterate over divided
			by the number of lights per iteration (default 1, set by 
			setLightCountPerIteration).
        @param enabled Whether this feature is enabled
        @param onlyForOneLightType If true, the pass will only be run for a single type
            of light, other light types will be ignored.
        @param lightType The single light type which will be considered for this pass

</member>
        <member name="M:Ogre.Pass.getTransparentSortingForced">
Returns whether or not transparent sorting is forced.

</member>
        <member name="M:Ogre.Pass.setTransparentSortingForced(System.Boolean)">
Sets whether or not transparent sorting is forced.
        @param enabled
			If true depth sorting of this material will be depend only on the value of
            getTransparentSortingEnabled().
        @remarks
			By default even if transparent sorting is enabled, depth sorting will only be
            performed when the material is transparent and depth write/check are disabled.
            This function disables these extra conditions.

</member>
        <member name="M:Ogre.Pass.getTransparentSortingEnabled">
Returns whether or not transparent sorting is enabled.

</member>
        <member name="M:Ogre.Pass.setTransparentSortingEnabled(System.Boolean)">
Sets whether or not transparent sorting is enabled.
        @param enabled
			If false depth sorting of this material will be disabled.
        @remarks
			By default all transparent materials are sorted such that renderables furthest
			away from the camera are rendered first. This is usually the desired behaviour
			but in certain cases this depth sorting may be unnecessary and undesirable. If
			for example it is necessary to ensure the rendering order does not change from
			one frame to the next.
		@note
			This will have no effect on non-transparent materials.

</member>
        <member name="M:Ogre.Pass.isAlphaToCoverageEnabled">
Gets whether to use alpha to coverage (A2C) when blending alpha rejected values. 

</member>
        <member name="M:Ogre.Pass.setAlphaToCoverageEnabled(System.Boolean)">
Sets whether to use alpha to coverage (A2C) when blending alpha rejected values. 
		@remarks
			Alpha to coverage performs multisampling on the edges of alpha-rejected
			textures to produce a smoother result. It is only supported when multisampling
			is already enabled on the render target, and when the hardware supports
			alpha to coverage (see RenderSystemCapabilities). 

</member>
        <member name="M:Ogre.Pass.getAlphaRejectValue">
Gets the alpha reject value. See setAlphaRejectSettings for more information.

</member>
        <member name="M:Ogre.Pass.getAlphaRejectFunction">
Gets the alpha reject function. See setAlphaRejectSettings for more information.

</member>
        <member name="M:Ogre.Pass.setAlphaRejectValue(System.Byte)">
Gets the alpha reject value. See setAlphaRejectSettings for more information.

</member>
        <member name="M:Ogre.Pass.setAlphaRejectFunction(Ogre.CompareFunction)">
Sets the alpha reject function. See setAlphaRejectSettings for more information.

</member>
        <member name="M:Ogre.Pass.setAlphaRejectSettings(Ogre.CompareFunction,System.Byte,System.Boolean)">
Sets the way the pass will have use alpha to totally reject pixels from the pipeline.
        @remarks
			The default is CMPF_ALWAYS_PASS i.e. alpha is not used to reject pixels.
        @param func The comparison which must pass for the pixel to be written.
        @param value 1 byte value against which alpha values will be tested(0-255)
		@param alphaToCoverageEnabled Whether to enable alpha to coverage support
        @note
			This option applies in both the fixed function and the programmable pipeline.

</member>
        <member name="M:Ogre.Pass.getIterationDepthBias">
Gets a factor which derives an additional depth bias from the number 
			of times a pass is iterated.

</member>
        <member name="M:Ogre.Pass.setIterationDepthBias(System.Single)">
Sets a factor which derives an additional depth bias from the number 
			of times a pass is iterated.
		@remarks
			The Final depth bias will be the constant depth bias as set through
			setDepthBias, plus this value times the iteration number. 

</member>
        <member name="M:Ogre.Pass.getDepthBiasSlopeScale">
Retrieves the slope-scale depth bias value as set by setDepthBias. 
</member>
        <member name="M:Ogre.Pass.getDepthBiasConstant">
Retrieves the const depth bias value as set by setDepthBias. 
</member>
        <member name="M:Ogre.Pass.setDepthBias(System.Single,System.Single)">
Sets the depth bias to be used for this material.
        @remarks
        When polygons are coplanar, you can get problems with 'depth fighting' where
        the pixels from the two polys compete for the same screen pixel. This is particularly
        a problem for decals (polys attached to another surface to represent details such as
        bulletholes etc.).
        @par
        A way to combat this problem is to use a depth bias to adjust the depth buffer value
        used for the decal such that it is slightly higher than the true value, ensuring that
        the decal appears on top. There are two aspects to the biasing, a constant
		bias value and a slope-relative biasing value, which varies according to the
		maximum depth slope relative to the camera, ie:
		<pre>finalBias = maxSlope * slopeScaleBias + constantBias</pre>
		Note that slope scale bias, whilst more accurate, may be ignored by old hardware.
        @param constantBias The constant bias value, expressed as a factor of the
			minimum observable depth
		@param slopeScaleBias The slope-relative bias value, expressed as a factor
			of the depth slope

</member>
        <member name="M:Ogre.Pass.getFogDensity">
Returns the fog density for this pass.
        @note
        Only valid if getFogOverride is true.

</member>
        <member name="M:Ogre.Pass.getFogEnd">
Returns the fog end distance for this pass.
        @note
        Only valid if getFogOverride is true.

</member>
        <member name="M:Ogre.Pass.getFogStart">
Returns the fog start distance for this pass.
        @note
        Only valid if getFogOverride is true.

</member>
        <member name="M:Ogre.Pass.getFogColour">
Returns the fog colour for the scene.

</member>
        <member name="M:Ogre.Pass.getFogMode">
Returns the fog mode for this pass.
        @note
        Only valid if getFogOverride is true.

</member>
        <member name="M:Ogre.Pass.getFogOverride">
Returns true if this pass is to override the scene fog settings.

</member>
        <member name="M:Ogre.Pass.setFog(System.Boolean,Ogre.FogMode,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single)">
Sets the fogging mode applied to this pass.
        @remarks
        Fogging is an effect that is applied as polys are rendered. Sometimes, you want
        fog to be applied to an entire scene. Other times, you want it to be applied to a few
        polygons only. This pass-level specification of fog parameters lets you easily manage
        both.
        @par
        The SceneManager class also has a setFog method which applies scene-level fog. This method
        lets you change the fog behaviour for this pass compared to the standard scene-level fog.
        @param
        overrideScene If true, you authorise this pass to override the scene's fog params with it's own settings.
        If you specify false, so other parameters are necessary, and this is the default behaviour for passes.
        @param
        mode Only applicable if overrideScene is true. You can disable fog which is turned on for the
        rest of the scene by specifying FOG_NONE. Otherwise, set a pass-specific fog mode as
        defined in the enum FogMode.
        @param
        colour The colour of the fog. Either set this to the same as your viewport background colour,
        or to blend in with a skydome or skybox.
        @param
        expDensity The density of the fog in FOG_EXP or FOG_EXP2 mode, as a value between 0 and 1.
        The default is 0.001.
        @param
        linearStart Distance in world units at which linear fog starts to encroach.
        Only applicable if mode is FOG_LINEAR.
        @param
        linearEnd Distance in world units at which linear fog becomes completely opaque.
        Only applicable if mode is FOG_LINEAR.

</member>
        <member name="M:Ogre.Pass.getPolygonModeOverrideable">
Gets whether this renderable's chosen detail level can be
			overridden (downgraded) by the camera setting. 

</member>
        <member name="M:Ogre.Pass.setPolygonModeOverrideable(System.Boolean)">
Sets whether this pass's chosen detail level can be
			overridden (downgraded) by the camera setting. 
		@param override true means that a lower camera detail will override this
			pass's detail level, false means it won't (default true).

</member>
        <member name="M:Ogre.Pass.getPolygonMode">
Returns the type of light shading to be used.

</member>
        <member name="M:Ogre.Pass.setPolygonMode(Ogre.PolygonMode)">
Sets the type of polygon rendering required
		@note
		The default shading method is Solid

</member>
        <member name="M:Ogre.Pass.getShadingMode">
Returns the type of light shading to be used.

</member>
        <member name="M:Ogre.Pass.setShadingMode(Ogre.ShadeOptions)">
Sets the type of light shading required
        @note
        The default shading method is Gouraud shading.

</member>
        <member name="M:Ogre.Pass.getStartLight">
Gets the light index that this pass will start at in the light list. 
</member>
        <member name="M:Ogre.Pass.setStartLight(System.UInt16)">
Sets the light index that this pass will start at in the light list.
		@remarks
			Normally the lights passed to a pass will start from the beginning
			of the light list for this object. This option allows you to make this
			pass start from a higher light index, for example if one of your earlier
			passes could deal with lights 0-3, and this pass dealt with lights 4+. 
			This option also has an interaction with pass iteration, in that
			if you choose to iterate this pass per light too, the iteration will
			only begin from light 4.

</member>
        <member name="M:Ogre.Pass.getMaxSimultaneousLights">
Gets the maximum number of lights to be used by this pass. 
</member>
        <member name="M:Ogre.Pass.setMaxSimultaneousLights(System.UInt16)">
Sets the maximum number of lights to be used by this pass.
        @remarks
            During rendering, if lighting is enabled (or if the pass uses an automatic
            program parameter based on a light) the engine will request the nearest lights
            to the object being rendered in order to work out which ones to use. This
            parameter sets the limit on the number of lights which should apply to objects
            rendered with this pass.

</member>
        <member name="M:Ogre.Pass.getLightingEnabled">
Returns whether or not dynamic lighting is enabled.

</member>
        <member name="M:Ogre.Pass.setLightingEnabled(System.Boolean)">
Sets whether or not dynamic lighting is enabled.
        @param
        enabled
        If true, dynamic lighting is performed on geometry with normals supplied, geometry without
        normals will not be displayed.
        @par
        If false, no lighting is applied and all geometry will be full brightness.

</member>
        <member name="M:Ogre.Pass.getManualCullingMode">
Retrieves the manual culling mode for this pass
        @see
        setManualCullingMode

</member>
        <member name="M:Ogre.Pass.setManualCullingMode(Ogre.ManualCullingMode)">
Sets the manual culling mode, performed by CPU rather than hardware.
        @remarks
        In some situations you want to use manual culling of triangles rather than sending the
        triangles to the hardware and letting it cull them. This setting only takes effect on SceneManager's
        that use it (since it is best used on large groups of planar world geometry rather than on movable
        geometry since this would be expensive), but if used can cull geometry before it is sent to the
        hardware.
        @note
        The default for this setting is MANUAL_CULL_BACK.
        @param
        mode The mode to use - see enum ManualCullingMode for details


</member>
        <member name="M:Ogre.Pass.getCullingMode">
Returns the culling mode for geometry rendered with this pass. See setCullingMode for more information.

</member>
        <member name="M:Ogre.Pass.setCullingMode(Ogre.CullingMode)">
Sets the culling mode for this pass  based on the 'vertex winding'.
        @remarks
        A typical way for the rendering engine to cull triangles is based on the 'vertex winding' of
        triangles. Vertex winding refers to the direction in which the vertices are passed or indexed
        to in the rendering operation as viewed from the camera, and will wither be clockwise or
        anticlockwise (that's 'counterclockwise' for you Americans out there ;) The default is
        CULL_CLOCKWISE i.e. that only triangles whose vertices are passed/indexed in anticlockwise order
        are rendered - this is a common approach and is used in 3D studio models for example. You can
        alter this culling mode if you wish but it is not advised unless you know what you are doing.
        @par
        You may wish to use the CULL_NONE option for mesh data that you cull yourself where the vertex
        winding is uncertain.

</member>
        <member name="M:Ogre.Pass.getColourWriteEnabled">
Determines if colour buffer writing is enabled for this pass. 
</member>
        <member name="M:Ogre.Pass.setColourWriteEnabled(System.Boolean)">
Sets whether or not colour buffer writing is enabled for this Pass.
		@remarks
			For some effects, you might wish to turn off the colour write operation
			when rendering geometry; this means that only the depth buffer will be
			updated (provided you have depth buffer writing enabled, which you
			probably will do, although you may wish to only update the stencil
			buffer for example - stencil buffer state is managed at the RenderSystem
			level only, not the Material since you are likely to want to manage it
			at a higher level).

</member>
        <member name="M:Ogre.Pass.getDepthFunction">
Returns the function used to compare depth values when depth checking is on.
        @see
        setDepthFunction

</member>
        <member name="M:Ogre.Pass.setDepthFunction(Ogre.CompareFunction)">
Sets the function used to compare depth values when depth checking is on.
        @remarks
        If depth checking is enabled (see setDepthCheckEnabled) a comparison occurs between the depth
        value of the pixel to be written and the current contents of the buffer. This comparison is
        normally CMPF_LESS_EQUAL, i.e. the pixel is written if it is closer (or at the same distance)
        than the current contents. If you wish you can change this comparison using this method.

</member>
        <member name="M:Ogre.Pass.getDepthWriteEnabled">
Returns whether or not this pass renders with depth-buffer writing on or not.
        @see
        setDepthWriteEnabled

</member>
        <member name="M:Ogre.Pass.setDepthWriteEnabled(System.Boolean)">
Sets whether or not this pass renders with depth-buffer writing on or not.
        @remarks
        If depth-buffer writing is on, whenever a pixel is written to the frame buffer
        the depth buffer is updated with the depth value of that new pixel, thus affecting future
        rendering operations if future pixels are behind this one.
        @par
        If depth writing is off, pixels are written without updating the depth buffer Depth writing should
        normally be on but can be turned off when rendering static backgrounds or when rendering a collection
        of transparent objects at the end of a scene so that they overlap each other correctly.

</member>
        <member name="M:Ogre.Pass.getDepthCheckEnabled">
Returns whether or not this pass renders with depth-buffer checking on or not.
        @see
        setDepthCheckEnabled

</member>
        <member name="M:Ogre.Pass.setDepthCheckEnabled(System.Boolean)">
Sets whether or not this pass renders with depth-buffer checking on or not.
        @remarks
        If depth-buffer checking is on, whenever a pixel is about to be written to the frame buffer
        the depth buffer is checked to see if the pixel is in front of all other pixels written at that
        point. If not, the pixel is not written.
        @par
        If depth checking is off, pixels are written no matter what has been rendered before.
        Also see setDepthFunction for more advanced depth check configuration.
        @see
        setDepthFunction

</member>
        <member name="M:Ogre.Pass.isTransparent">
Returns true if this pass has some element of transparency. 
</member>
        <member name="M:Ogre.Pass.getSceneBlendingOperationAlpha">
Returns the current alpha blending operation 
</member>
        <member name="M:Ogre.Pass.getSceneBlendingOperation">
Returns the current blending operation 
</member>
        <member name="M:Ogre.Pass.hasSeparateSceneBlendingOperations">
Returns true if this pass uses separate scene blending operations. 
</member>
        <member name="M:Ogre.Pass.setSeparateSceneBlendingOperation(Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)">
Sets the specific operation used to blend source and destination pixels together.
			@remarks 
			By default this operation is +, which creates this equation
			<span align="center">
			final = (texture * sourceFactor) + (pixel * destFactor)
			</span>
			By setting this to something other than SBO_ADD you can change the operation to achieve
			a different effect.
			This function allows more control over blending since it allows you to select different blending
			modes for the color and alpha channels
			@param op The blending operation mode to use for color channels in this pass
			@param op The blending operation mode to use for alpha channels in this pass

</member>
        <member name="M:Ogre.Pass.setSceneBlendingOperation(Ogre.SceneBlendOperation)">
Sets the specific operation used to blend source and destination pixels together.
			@remarks 
			By default this operation is +, which creates this equation
			<span align="center">
			final = (texture * sourceFactor) + (pixel * destFactor)
			</span>
			By setting this to something other than SBO_ADD you can change the operation to achieve
			a different effect.
			@param op The blending operation mode to use for this pass

</member>
        <member name="M:Ogre.Pass.getDestBlendFactorAlpha">
Retrieves the alpha destination blending factor for the material (as set using Materiall::setSeparateSceneBlending).

</member>
        <member name="M:Ogre.Pass.getSourceBlendFactorAlpha">
Retrieves the alpha source blending factor for the material (as set using Materiall::setSeparateSceneBlending).

</member>
        <member name="M:Ogre.Pass.getDestBlendFactor">
Retrieves the destination blending factor for the material (as set using Materiall::setSceneBlending).

</member>
        <member name="M:Ogre.Pass.getSourceBlendFactor">
Retrieves the source blending factor for the material (as set using Materiall::setSceneBlending).

</member>
        <member name="M:Ogre.Pass.hasSeparateSceneBlending">
Return true if this pass uses separate scene blending 
</member>
        <member name="M:Ogre.Pass.setSeparateSceneBlending(Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst,Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst,Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst,Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst)">
Allows very fine control of blending this Pass with the existing contents of the scene.
        @remarks
        Wheras the texture blending operations seen in the TextureUnitState class are concerned with
        blending between texture layers, this blending is about combining the output of the material
        as a whole with the existing contents of the rendering target. This blending therefore allows
        object transparency and other special effects.
        @par
        This version of the method allows complete control over the blending operation, by specifying the
        source and destination blending factors. The result of the blending operation is:
        <span align="center">
        final = (texture * sourceFactor) + (pixel * destFactor)
        </span>
        @par
        Each of the factors is specified as one of a number of options, as specified in the SceneBlendFactor
        enumerated type.
        @param
        sourceFactor The source factor in the above calculation, i.e. multiplied by the texture colour components.
        @param
        destFactor The destination factor in the above calculation, i.e. multiplied by the pixel colour components.
        @param
        sourceFactorAlpha The alpha source factor in the above calculation, i.e. multiplied by the texture alpha component.
        @param
        destFactorAlpha The alpha destination factor in the above calculation, i.e. multiplied by the pixel alpha component.
		@note
        This method is applicable for both the fixed-function and programmable pipelines.

</member>
        <member name="M:Ogre.Pass.setSceneBlending(Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst,Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst)">
Allows very fine control of blending this Pass with the existing contents of the scene.
        @remarks
        Whereas the texture blending operations seen in the TextureUnitState class are concerned with
        blending between texture layers, this blending is about combining the output of the material
        as a whole with the existing contents of the rendering target. This blending therefore allows
        object transparency and other special effects.
        @par
        This version of the method allows complete control over the blending operation, by specifying the
        source and destination blending factors. The result of the blending operation is:
        <span align="center">
        final = (texture * sourceFactor) + (pixel * destFactor)
        </span>
        @par
        Each of the factors is specified as one of a number of options, as specified in the SceneBlendFactor
        enumerated type.
        @param
        sourceFactor The source factor in the above calculation, i.e. multiplied by the texture colour components.
        @param
        destFactor The destination factor in the above calculation, i.e. multiplied by the pixel colour components.
        @note
        This method is applicable for both the fixed-function and programmable pipelines.

</member>
        <member name="M:Ogre.Pass.setSeparateSceneBlending(Ogre.SceneBlendType!System.Runtime.CompilerServices.IsConst,Ogre.SceneBlendType!System.Runtime.CompilerServices.IsConst)">
Sets the kind of blending this pass has with the existing contents of the scene, separately for color and alpha channels
        @remarks
        Whereas the texture blending operations seen in the TextureUnitState class are concerned with
        blending between texture layers, this blending is about combining the output of the Pass
        as a whole with the existing contents of the rendering target. This blending therefore allows
        object transparency and other special effects. If all passes in a technique have a scene
        blend, then the whole technique is considered to be transparent.
        @par
        This method allows you to select one of a number of predefined blending types. If you require more
        control than this, use the alternative version of this method which allows you to specify source and
        destination blend factors.
        @note
        This method is applicable for both the fixed-function and programmable pipelines.
        @param
        sbt One of the predefined SceneBlendType blending types for the color channel
        @param
        sbta One of the predefined SceneBlendType blending types for the alpha channel

</member>
        <member name="M:Ogre.Pass.setSceneBlending(Ogre.SceneBlendType!System.Runtime.CompilerServices.IsConst)">
Sets the kind of blending this pass has with the existing contents of the scene.
        @remarks
        Wheras the texture blending operations seen in the TextureUnitState class are concerned with
        blending between texture layers, this blending is about combining the output of the Pass
        as a whole with the existing contents of the rendering target. This blending therefore allows
        object transparency and other special effects. If all passes in a technique have a scene
        blend, then the whole technique is considered to be transparent.
        @par
        This method allows you to select one of a number of predefined blending types. If you require more
        control than this, use the alternative version of this method which allows you to specify source and
        destination blend factors.
        @note
        This method is applicable for both the fixed-function and programmable pipelines.
        @param
        sbt One of the predefined SceneBlendType blending types

</member>
        <member name="M:Ogre.Pass.getNumTextureUnitStates">
Returns the number of texture unit settings.

</member>
        <member name="M:Ogre.Pass.removeAllTextureUnitStates">
Removes all texture unit settings.

</member>
        <member name="M:Ogre.Pass.removeTextureUnitState(System.UInt16)">
Removes the indexed texture unit state from this pass.
        @remarks
            Note that removing a texture which is not the topmost will have a larger performance impact.

</member>
        <member name="M:Ogre.Pass.getTextureUnitStateIterator">
Get an iterator over the TextureUnitStates contained in this Pass. 

Get an iterator over the TextureUnitStates contained in this Pass. 
</member>
        <member name="M:Ogre.Pass.getTextureUnitStateIndex(Ogre.TextureUnitState!System.Runtime.CompilerServices.IsConst*)">
Retrieve the index of the Texture Unit State in the pass.
       @param
       state The Texture Unit State this is attached to this pass.
       @note
           Throws an exception if the state is not attached to the pass.

</member>
        <member name="M:Ogre.Pass.getTextureUnitState(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves the Texture Unit State matching name.
            Returns 0 if name match is not found.


Retrieves the Texture Unit State matching name.
		Returns 0 if name match is not found.

</member>
        <member name="M:Ogre.Pass.getTextureUnitState(System.UInt16)">
Retrieves a pointer to a texture unit state so it may be modified.


Retrieves a const pointer to a texture unit state.

</member>
        <member name="M:Ogre.Pass.addTextureUnitState(Ogre.TextureUnitState*)">
Adds the passed in TextureUnitState, to the existing Pass.
        @param
        state The Texture Unit State to be attached to this pass.  It must not be attached to another pass.
        @note
            Throws an exception if the TextureUnitState is attached to another Pass.
</member>
        <member name="M:Ogre.Pass.createTextureUnitState(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16)">
Inserts a new TextureUnitState object into the Pass.
        @remarks
        This unit is is added on top of all previous units.
        @param
        name The basic name of the texture e.g. brickwall.jpg, stonefloor.png
        @param
        texCoordSet The index of the texture coordinate set to use.
        @note
        Applies to both fixed-function and programmable passes.

</member>
        <member name="M:Ogre.Pass.createTextureUnitState">
Inserts a new TextureUnitState object into the Pass.
        @remarks
        This unit is is added on top of all previous units.

</member>
        <member name="M:Ogre.Pass.getVertexColourTracking">
Gets which material properties follow the vertex colour

</member>
        <member name="M:Ogre.Pass.getShininess">
Gets the 'shininess' property of the pass (affects specular highlights).

</member>
        <member name="M:Ogre.Pass.getSelfIllumination">
Gets the self illumination colour of the pass.

</member>
        <member name="M:Ogre.Pass.getSpecular">
Gets the specular colour reflectance of the pass.

</member>
        <member name="M:Ogre.Pass.getDiffuse">
Gets the diffuse colour reflectance of the pass.

</member>
        <member name="M:Ogre.Pass.getAmbient">
Gets the ambient colour reflectance of the pass.

</member>
        <member name="M:Ogre.Pass.getPointMaxSize">
Get the maximum point size, when point attenuation is in use.
		@remarks 0 indicates the max size supported by the card.

</member>
        <member name="M:Ogre.Pass.setPointMaxSize(System.Single)">
Set the maximum point size, when point attenuation is in use.
		@remarks Setting this to 0 indicates the max size supported by the card.

</member>
        <member name="M:Ogre.Pass.getPointMinSize">
Get the minimum point size, when point attenuation is in use. 
</member>
        <member name="M:Ogre.Pass.setPointMinSize(System.Single)">
Set the minimum point size, when point attenuation is in use. 
</member>
        <member name="M:Ogre.Pass.getPointAttenuationQuadratic">
Returns the quadratic coefficient of point attenuation. 
</member>
        <member name="M:Ogre.Pass.getPointAttenuationLinear">
Returns the linear coefficient of point attenuation. 
</member>
        <member name="M:Ogre.Pass.getPointAttenuationConstant">
Returns the constant coefficient of point attenuation. 
</member>
        <member name="M:Ogre.Pass.isPointAttenuationEnabled">
Returns whether points are attenuated with distance. 
</member>
        <member name="M:Ogre.Pass.setPointAttenuation(System.Boolean,System.Single,System.Single,System.Single)">
Sets how points are attenuated with distance.
		@remarks
			When performing point rendering or point sprite rendering,
			point size can be attenuated with distance. The equation for
			doing this is attenuation = 1 / (constant + linear * dist + quadratic * d^2).
		@par
			For example, to disable distance attenuation (constant screensize)
			you would set constant to 1, and linear and quadratic to 0. A
			standard perspective attenuation would be 0, 1, 0 respectively.
		@note
			The resulting size is clamped to the minimum and maximum point
			size.
		@param enabled Whether point attenuation is enabled
		@param constant, linear, quadratic Parameters to the attenuation
			function defined above

</member>
        <member name="M:Ogre.Pass.getPointSpritesEnabled">
Returns whether point sprites are enabled when rendering a
			point list.

</member>
        <member name="M:Ogre.Pass.setPointSpritesEnabled(System.Boolean)">
Sets whether or not rendering points using OT_POINT_LIST will
			render point sprites (textured quads) or plain points (dots).
		@param enabled True enables point sprites, false returns to normal
			point rendering.

</member>
        <member name="M:Ogre.Pass.setPointSize(System.Single)">
Sets the point size of this pass.
		@remarks
			This setting allows you to change the size of points when rendering
			a point list, or a list of point sprites. The interpretation of this
			command depends on the Pass::setPointSizeAttenuation option - if it
			is off (the default), the point size is in screen pixels, if it is on,
			it expressed as normalised screen coordinates (1.0 is the height of
			the screen) when the point is at the origin.
		@note
			Some drivers have an upper limit on the size of points they support
			- this can even vary between APIs on the same card! Don't rely on
			point sizes that cause the point sprites to get very large on screen,
			since they may get clamped on some cards. Upper sizes can range from
			64 to 256 pixels.

</member>
        <member name="M:Ogre.Pass.getPointSize">
Gets the point size of the pass.
		@remarks
			This property determines what point size is used to render a point
			list.

</member>
        <member name="M:Ogre.Pass.setVertexColourTracking(System.Int32)">
Sets which material properties follow the vertex colour

</member>
        <member name="M:Ogre.Pass.setSelfIllumination(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the amount of self-illumination an object has.
        @remarks
        If an object is self-illuminating, it does not need external sources to light it, ambient or
        otherwise. It's like the object has it's own personal ambient light. This property is rarely useful since
        you can already specify per-pass ambient light, but is here for completeness.
        @note
        This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled),
        or if this is a programmable pass.

</member>
        <member name="M:Ogre.Pass.setSelfIllumination(System.Single,System.Single,System.Single)">
Sets the amount of self-illumination an object has.
        @remarks
        If an object is self-illuminating, it does not need external sources to light it, ambient or
        otherwise. It's like the object has it's own personal ambient light. This property is rarely useful since
        you can already specify per-pass ambient light, but is here for completeness.
        @note
        This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled),
        or if this is a programmable pass.

</member>
        <member name="M:Ogre.Pass.setShininess(System.Single)">
Sets the shininess of the pass, affecting the size of specular highlights.
        @note
        This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled),
        or if this is a programmable pass.

</member>
        <member name="M:Ogre.Pass.setSpecular(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the specular colour reflectance properties of this pass.
        @remarks
        The base colour of a pass is determined by how much red, green and blue light is reflects
        (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how
        much specular light (highlights from instances of the Light class in the scene) is reflected.
        The default is to reflect no specular light.
        @note
        The size of the specular highlights is determined by the separate 'shininess' property.
        @note
        This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled),
        or if this is a programmable pass.

</member>
        <member name="M:Ogre.Pass.setSpecular(System.Single,System.Single,System.Single,System.Single)">
Sets the specular colour reflectance properties of this pass.
        @remarks
        The base colour of a pass is determined by how much red, green and blue light is reflects
        (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how
        much specular light (highlights from instances of the Light class in the scene) is reflected.
        The default is to reflect no specular light.
        @note
        The size of the specular highlights is determined by the separate 'shininess' property.
        @note
        This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled),
        or if this is a programmable pass.

</member>
        <member name="M:Ogre.Pass.setDiffuse(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the diffuse colour reflectance properties of this pass.
        @remarks
        The base colour of a pass is determined by how much red, green and blue light is reflects
        (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how
        much diffuse light (light from instances of the Light class in the scene) is reflected. The default
        is full white, meaning objects reflect the maximum white light they can from Light objects.
        @note
        This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled),
        or if this is a programmable pass.

</member>
        <member name="M:Ogre.Pass.setDiffuse(System.Single,System.Single,System.Single,System.Single)">
Sets the diffuse colour reflectance properties of this pass.
        @remarks
        The base colour of a pass is determined by how much red, green and blue light is reflects
        (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how
        much diffuse light (light from instances of the Light class in the scene) is reflected. The default
        is full white, meaning objects reflect the maximum white light they can from Light objects.
        @note
        This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled),
        or if this is a programmable pass.

</member>
        <member name="M:Ogre.Pass.setAmbient(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the ambient colour reflectance properties of this pass.
        @remarks
        The base colour of a pass is determined by how much red, green and blue light is reflects
        (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how
        much ambient light (directionless global light) is reflected. The default is full white, meaning
        objects are completely globally illuminated. Reduce this if you want to see diffuse or specular light
        effects, or change the blend of colours to make the object have a base colour other than white.
        @note
        This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled),
        or if this is a programmable pass.

</member>
        <member name="M:Ogre.Pass.setAmbient(System.Single,System.Single,System.Single)">
Sets the ambient colour reflectance properties of this pass.
        @remarks
        The base colour of a pass is determined by how much red, green and blue light is reflects
        (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how
        much ambient light (directionless global light) is reflected. The default is full white, meaning
        objects are completely globally illuminated. Reduce this if you want to see diffuse or specular light
        effects, or change the blend of colours to make the object have a base colour other than white.
        @note
        This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled),
        or if this is a programmable pass.

</member>
        <member name="M:Ogre.Pass.getName">
get the name of the pass
</member>
        <member name="M:Ogre.Pass.getIndex">
Gets the index of this Pass in the parent Technique
</member>
        <member name="M:Ogre.Pass.hasShadowReceiverFragmentProgram">
Returns true if this pass uses a shadow receiver fragment program
</member>
        <member name="M:Ogre.Pass.hasShadowReceiverVertexProgram">
Returns true if this pass uses a shadow receiver vertex program
</member>
        <member name="M:Ogre.Pass.hasShadowCasterVertexProgram">
Returns true if this pass uses a shadow caster vertex program
</member>
        <member name="M:Ogre.Pass.hasGeometryProgram">
Returns true if this pass uses a programmable geometry pipeline
</member>
        <member name="M:Ogre.Pass.hasFragmentProgram">
Returns true if this pass uses a programmable fragment pipeline
</member>
        <member name="M:Ogre.Pass.hasVertexProgram">
Returns true if this pass uses a programmable vertex pipeline
</member>
        <member name="M:Ogre.Pass.isProgrammable">
Returns true if this pass is programmable i.e. includes either a vertex or fragment program.
</member>
        <member name="M:Ogre.Pass.op_Assign(Ogre.Pass!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Operator = overload
</member>
        <member name="M:Ogre.Pass.#ctor(Ogre.Technique*,System.UInt16,Ogre.Pass!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:Ogre.Pass.#ctor(Ogre.Technique*,System.UInt16)">
Default constructor
</member>
        <member name="F:Ogre.Pass.msHashFunc">
The Pass hash functor
</member>
        <member name="F:Ogre.Pass.msPassGraveyard">
The place where passes go to die
</member>
        <member name="F:Ogre.Pass.msDirtyHashList">
List of Passes whose hashes need recalculating
</member>
        <member name="F:Ogre.Pass.mIlluminationStage">
Illumination stage?
</member>
        <member name="F:Ogre.Pass.mLightClipPlanes">
User clip planes for light?
</member>
        <member name="F:Ogre.Pass.mLightScissoring">
Scissoring for the light?
</member>
        <member name="D:Ogre.Pass.TextureUnitStates">
Storage of texture unit states
</member>
        <member name="F:Ogre.Pass.mNormaliseNormals">
Normalisation
</member>
        <member name="F:Ogre.Pass.mPolygonMode">
Polygon mode
</member>
        <member name="F:Ogre.Pass.mShadeOptions">
Shading options
</member>
        <member name="F:Ogre.Pass.mLightsPerIteration">
Iterate per how many lights?
</member>
        <member name="F:Ogre.Pass.mIteratePerLight">
Run this pass once per light?
</member>
        <member name="F:Ogre.Pass.mStartLight">
Starting light index
</member>
        <member name="F:Ogre.Pass.mMaxSimultaneousLights">
Max simultaneous lights
</member>
        <member name="F:Ogre.Pass.mLightingEnabled">
Lighting enabled?
</member>
        <member name="M:Ogre.Pass.HashFunc.Dispose">
Need virtual destructor in case subclasses use it
</member>
        <member name="T:Ogre.Pass.HashFunc">
Definition of a functor for calculating the hashcode of a Pass.
		@remarks
			The hashcode of a Pass is used to sort Passes for rendering, in order
			to reduce the number of render state changes. Each Pass represents a
			single unique set of states, but by ordering them, state changes can
			be minimised between passes. An implementation of this functor should
			order passes so that the elements that you want to keep constant are
			sorted next to each other.
		@see Pass::setHashFunc

</member>
        <member name="T:Ogre.Pass">
Class defining a single pass of a Technique (of a Material), i.e.
        a single rendering call.
    @remarks
        Rendering can be repeated with many passes for more complex effects.
        Each pass is either a fixed-function pass (meaning it does not use
        a vertex or fragment program) or a programmable pass (meaning it does
        use either a vertex and fragment program, or both).
    @par
        Programmable passes are complex to define, because they require custom
        programs and you have to set all constant inputs to the programs (like
        the position of lights, any base material colours you wish to use etc), but
        they do give you much total flexibility over the algorithms used to render your
        pass, and you can create some effects which are impossible with a fixed-function pass.
        On the other hand, you can define a fixed-function pass in very little time, and
        you can use a range of fixed-function effects like environment mapping very
        easily, plus your pass will be more likely to be compatible with older hardware.
        There are pros and cons to both, just remember that if you use a programmable
        pass to create some great effects, allow more time for definition and testing.

</member>
        <member name="T:Ogre.IlluminationStage">
\addtogroup Core
	*  @{

\addtogroup Materials
	*  @{

Categorisation of passes for the purpose of additive lighting
</member>
        <member name="F:IS_UNKNOWN">
Not determined
</member>
        <member name="F:IS_DECAL">
Post-lighting rendering
</member>
        <member name="F:IS_PER_LIGHT">
Part of the rendering which occurs per light
</member>
        <member name="F:IS_AMBIENT">
Part of the rendering which occurs without any kind of direct lighting
</member>
        <member name="T:Ogre.ParticleSystemFactory">
Factory object for creating ParticleSystem instances 
</member>
        <member name="M:Ogre.ParticleSystemManager.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.ParticleSystemManager.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.ParticleSystemManager._getFactory">
Get an instance of ParticleSystemFactory (internal use). 
</member>
        <member name="M:Ogre.ParticleSystemManager.getTemplateIterator">
Gets an iterator over the list of particle system templates. 
</member>
        <member name="M:Ogre.ParticleSystemManager.getRendererFactoryIterator">
Return an iterator over the renderer factories currently registered 
</member>
        <member name="M:Ogre.ParticleSystemManager.getEmitterFactoryIterator">
Return an iterator over the emitter factories currently registered 
</member>
        <member name="M:Ogre.ParticleSystemManager.getAffectorFactoryIterator">
Return an iterator over the affector factories currently registered 
</member>
        <member name="M:Ogre.ParticleSystemManager.getLoadingOrder">
@copydoc ScriptLoader::getLoadingOrder
</member>
        <member name="M:Ogre.ParticleSystemManager.parseScript(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc ScriptLoader::parseScript
</member>
        <member name="M:Ogre.ParticleSystemManager.getScriptPatterns">
@copydoc ScriptLoader::getScriptPatterns
</member>
        <member name="M:Ogre.ParticleSystemManager._initialise">
Init method to be called by OGRE system.
        @remarks
            Due to dependencies between various objects certain initialisation tasks cannot be done
            on construction. OGRE will call this method when the rendering subsystem is initialised.

</member>
        <member name="M:Ogre.ParticleSystemManager._destroyRenderer(Ogre.ParticleSystemRenderer*)">
Internal method for destroying a renderer.
        @remarks
            Because renderer are created by factories which may allocate memory from separate heaps,
            the memory allocated must be freed from the same place. This method is used to ask the factory
            to destroy the instance passed in as a pointer.
        @param
            renderer Pointer to renderer to be destroyed. On return this pointer will point to invalid (freed) memory.

</member>
        <member name="M:Ogre.ParticleSystemManager._createRenderer(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for creating a new renderer from a factory.
        @remarks
            Used internally by the engine to create new ParticleSystemRenderer instances from named
            factories. Applications should use the ParticleSystem::setRenderer method instead, 
            which calls this method to create an instance.
        @param
            rendererType String name of the renderer type to be created. A factory of this type must have been registered.

</member>
        <member name="M:Ogre.ParticleSystemManager._destroyAffector(Ogre.ParticleAffector*)">
Internal method for destroying an affector.
        @remarks
            Because affectors are created by factories which may allocate memory from separate heaps,
            the memory allocated must be freed from the same place. This method is used to ask the factory
            to destroy the instance passed in as a pointer.
        @param
            affector Pointer to affector to be destroyed. On return this pointer will point to invalid (freed) memory.

</member>
        <member name="M:Ogre.ParticleSystemManager._createAffector(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ParticleSystem*)">
Internal method for creating a new affector from a factory.
        @remarks
            Used internally by the engine to create new ParticleAffector instances from named
            factories. Applications should use the ParticleSystem::addAffector method instead, 
            which calls this method to create an instance.
        @param
            effectorType String name of the affector type to be created. A factory of this type must have been registered.
        @param
            psys The particle system it is being created for

</member>
        <member name="M:Ogre.ParticleSystemManager._destroyEmitter(Ogre.ParticleEmitter*)">
Internal method for destroying an emitter.
        @remarks
            Because emitters are created by factories which may allocate memory from separate heaps,
            the memory allocated must be freed from the same place. This method is used to ask the factory
            to destroy the instance passed in as a pointer.
        @param
            emitter Pointer to emitter to be destroyed. On return this pointer will point to invalid (freed) memory.

</member>
        <member name="M:Ogre.ParticleSystemManager._createEmitter(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ParticleSystem*)">
Internal method for creating a new emitter from a factory.
        @remarks
            Used internally by the engine to create new ParticleEmitter instances from named
            factories. Applications should use the ParticleSystem::addEmitter method instead, 
            which calls this method to create an instance.
        @param
            emitterType String name of the emitter type to be created. A factory of this type must have been registered.
        @param 
            psys The particle system this is being created for

</member>
        <member name="M:Ogre.ParticleSystemManager.getTemplate(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves a particle system template for possible modification. 
        @remarks
            Modifying a template does not affect the settings on any ParticleSystems already created
            from this template.

</member>
        <member name="M:Ogre.ParticleSystemManager.createTemplate(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a new particle system template. 
        @remarks
            This method is similar to the addTemplate method, except this just creates a new template
            and returns a pointer to it to be populated. Use this when you don't already have a system
            to add as a template and just want to create a new template which you will build up in-place.
        @param
            name The name of the template. Must be unique across all templates.
        @param
            resourceGroup The name of the resource group which will be used to 
                load any dependent resources.
            

</member>
        <member name="M:Ogre.ParticleSystemManager.removeTemplatesByResourceGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Removes all templates that belong to a secific Resource Group from the ParticleSystemManager.
        @remarks
            This method removes all templates that belong in a particular resource group from the ParticleSystemManager.
        @param
            resourceGroup to delete templates for

</member>
        <member name="M:Ogre.ParticleSystemManager.removeAllTemplates(System.Boolean)">
Removes a specified template from the ParticleSystemManager.
        @remarks
            This method removes all templates from the ParticleSystemManager.
        @param
            deleteTemplate Whether or not to delete the templates before removing them.

</member>
        <member name="M:Ogre.ParticleSystemManager.removeTemplate(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Removes a specified template from the ParticleSystemManager.
        @remarks
            This method removes a given template from the particle system manager, optionally deleting
            the template if the deleteTemplate method is called.  Throws an exception if the template
            could not be found.
        @param
            name The name of the template to remove.
        @param
            deleteTemplate Whether or not to delete the template before removing it.

</member>
        <member name="M:Ogre.ParticleSystemManager.addTemplate(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ParticleSystem*)">
Adds a new particle system template to the list of available templates. 
        @remarks
            Instances of particle systems in a scene are not normally unique - often you want to place the
            same effect in many places. This method allows you to register a ParticleSystem as a named template,
            which can subsequently be used to create instances using the createSystem method.
        @par
            Note that particle system templates can either be created programmatically by an application 
            and registered using this method, or they can be defined in a script file (*.particle) which is
            loaded by the engine at startup, very much like Material scripts.
        @param
            name The name of the template. Must be unique across all templates.
        @param
            sysTemplate A pointer to a particle system to be used as a template. The manager
                will take over ownership of this pointer.
            

</member>
        <member name="M:Ogre.ParticleSystemManager.addRendererFactory(Ogre.ParticleSystemRendererFactory*)">
Registers a factory class for creating ParticleSystemRenderer instances. 
        @par
            Note that the object passed to this function will not be destroyed by the ParticleSystemManager,
            since it may have been allocated on a different heap in the case of plugins. The caller must
            destroy the object later on, probably on plugin shutdown.
        @param
            factory Pointer to a ParticleSystemRendererFactory subclass created by the plugin or application code.

</member>
        <member name="M:Ogre.ParticleSystemManager.addAffectorFactory(Ogre.ParticleAffectorFactory*)">
Adds a new 'factory' object for affectors to the list of available affector types.
        @remarks
            This method allows plugins etc to add new particle affector types to Ogre. Particle
            affectors modify the particles in a system a certain way such as affecting their direction
            or changing their colour, lifespan etc. Plugins would
            create new subclasses of ParticleAffector which affect particles a certain way, and register
            a subclass of ParticleAffectorFactory to create them.
        @par
            All particle affector factories have an assigned name which is used to identify the affector
            type. This must be unique.
        @par
            Note that the object passed to this function will not be destroyed by the ParticleSystemManager,
            since it may have been allocated on a different heap in the case of plugins. The caller must
            destroy the object later on, probably on plugin shutdown.
        @param
            factory Pointer to a ParticleAffectorFactory subclass created by the plugin or application code.

</member>
        <member name="M:Ogre.ParticleSystemManager.addEmitterFactory(Ogre.ParticleEmitterFactory*)">
Adds a new 'factory' object for emitters to the list of available emitter types.
        @remarks
            This method allows plugins etc to add new particle emitter types to Ogre. Particle emitters
            are sources of particles, and generate new particles with their start positions, colours and
            momentums appropriately. Plugins would create new subclasses of ParticleEmitter which 
            emit particles a certain way, and register a subclass of ParticleEmitterFactory to create them (since multiple 
            emitters can be created for different particle systems).
        @par
            All particle emitter factories have an assigned name which is used to identify the emitter
            type. This must be unique.
        @par
            Note that the object passed to this function will not be destroyed by the ParticleSystemManager,
            since it may have been allocated on a different heap in the case of plugins. The caller must
            destroy the object later on, probably on plugin shutdown.
        @param
            factory Pointer to a ParticleEmitterFactory subclass created by the plugin or application code.

</member>
        <member name="M:Ogre.ParticleSystemManager.destroySystemImpl(Ogre.ParticleSystem*)">
Internal implementation of destroySystem
</member>
        <member name="M:Ogre.ParticleSystemManager.createSystemImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal implementation of createSystem
</member>
        <member name="M:Ogre.ParticleSystemManager.createSystemImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal implementation of createSystem
</member>
        <member name="M:Ogre.ParticleSystemManager.skipToNextOpenBrace(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal script parsing method. 
</member>
        <member name="M:Ogre.ParticleSystemManager.skipToNextCloseBrace(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal script parsing method. 
</member>
        <member name="M:Ogre.ParticleSystemManager.parseAffectorAttrib(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ParticleAffector*)">
Internal script parsing method. 
</member>
        <member name="M:Ogre.ParticleSystemManager.parseEmitterAttrib(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ParticleEmitter*)">
Internal script parsing method. 
</member>
        <member name="M:Ogre.ParticleSystemManager.parseAttrib(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ParticleSystem*)">
Internal script parsing method. 
</member>
        <member name="M:Ogre.ParticleSystemManager.parseNewAffector(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ParticleSystem*)">
Internal script parsing method. 
</member>
        <member name="M:Ogre.ParticleSystemManager.parseNewEmitter(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ParticleSystem*)">
Internal script parsing method. 
</member>
        <member name="F:Ogre.ParticleSystemManager.mRendererFactories">
Map of renderer types to factories
</member>
        <member name="F:Ogre.ParticleSystemManager.mAffectorFactories">
Factories for named affector types (can be extended using plugins)
</member>
        <member name="F:Ogre.ParticleSystemManager.mEmitterFactories">
Factories for named emitter types (can be extended using plugins)
</member>
        <member name="F:Ogre.ParticleSystemManager.mSystemTemplates">
Templates based on scripts
</member>
        <member name="M:Ogre.ParticleSystem._notifyReorganiseEmittedEmitterData">
This function clears all data structures that are used in combination with emitted emitters and
		    sets the flag to indicate that the emitted emitter pool must be initialised again.
            @remarks
                This function should be called if new emitters are added to a ParticleSystem or deleted from a
				ParticleSystem. The emitted emitter data structures become out of sync and need to be build up
				again. The data structures are not reorganised in this function, but by setting a flag, 
				they are rebuild in the regular process flow.

</member>
        <member name="M:Ogre.ParticleSystem.addActiveEmittedEmittersToFreeList">
Moves all emitted emitters from the active list to the free list
            @remarks
                The active emitted emitter list will not be cleared and still keeps references to the emitters!

</member>
        <member name="M:Ogre.ParticleSystem.removeFromActiveEmittedEmitters(Ogre.ParticleEmitter*)">
Removes an emitter from the active emitted emitter list.
            @remarks
                The emitter will not be destroyed!
            @param emitter Pointer to a particle emitter.

</member>
        <member name="M:Ogre.ParticleSystem.findFreeEmittedEmitter(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Find the list with free emitted emitters.
            @param name The name that identifies the list with free emitted emitters.

</member>
        <member name="M:Ogre.ParticleSystem.removeAllEmittedEmitters">
Removes all emitted emitters from this system.	
</member>
        <member name="M:Ogre.ParticleSystem.addFreeEmittedEmitters">
Add  emitters from the pool to the free emitted emitter queue. 
</member>
        <member name="M:Ogre.ParticleSystem.initialiseEmittedEmitterPool">
Determine which emitters in the Particle Systems main emitter become a template for creating an
			pool of emitters that can be emitted.

</member>
        <member name="M:Ogre.ParticleSystem.initialiseEmittedEmitters">
Create a pool of emitted emitters and assign them to the free emitter list.
            @remarks
                The emitters in the pool are grouped by name. This name is the name of the base emitter in the
				main list with particle emitters, which forms the template of the created emitted emitters.

</member>
        <member name="M:Ogre.ParticleSystem.destroyVisualParticles(System.UInt32,System.UInt32)">
Internal method for destroying ParticleVisualData instances for the pool
</member>
        <member name="M:Ogre.ParticleSystem.createVisualParticles(System.UInt32,System.UInt32)">
Internal method for creating ParticleVisualData instances for the pool
</member>
        <member name="M:Ogre.ParticleSystem.configureRenderer">
Internal method to configure the renderer. 
</member>
        <member name="M:Ogre.ParticleSystem.initParameters">
Internal method for initialising string interface. 
</member>
        <member name="M:Ogre.ParticleSystem.increaseEmittedEmitterPool(System.UInt32)">
Resize the internal pool of emitted emitters.
            @remarks
                The pool consists of multiple vectors containing pointers to particle emitters. Increasing the 
				pool with size implies that the vectors are equally increased. The quota of emitted emitters is 
				defined on a particle system level and not on a particle emitter level. This is to prevent that
				the number of created emitters becomes too high; the quota is shared amongst the emitted emitters.

</member>
        <member name="M:Ogre.ParticleSystem.increasePool(System.UInt32)">
Resize the internal pool of particles. 
</member>
        <member name="M:Ogre.ParticleSystem._sortParticles(Ogre.Camera*)">
Sort the particles in the system *
</member>
        <member name="M:Ogre.ParticleSystem._triggerAffectors(System.Single)">
Applies the effects of affectors. 
</member>
        <member name="M:Ogre.ParticleSystem._applyMotion(System.Single)">
Updates existing particle based on their momentum. 
</member>
        <member name="M:Ogre.ParticleSystem._executeTriggerEmitters(Ogre.ParticleEmitter*,System.UInt32,System.Single)">
Helper function that actually performs the emission of particles

</member>
        <member name="M:Ogre.ParticleSystem._triggerEmitters(System.Single)">
Spawn new particles based on free quota and emitter requirements. 
</member>
        <member name="M:Ogre.ParticleSystem._expire(System.Single)">
Internal method used to expire dead particles. 
</member>
        <member name="F:Ogre.ParticleSystem.msDefaultNonvisibleTimeout">
Default nonvisible update timeout
</member>
        <member name="F:Ogre.ParticleSystem.msDefaultIterationInterval">
Default iteration interval
</member>
        <member name="F:Ogre.ParticleSystem.mOrigin">
Optional origin of this particle system (eg script name)
</member>
        <member name="F:Ogre.ParticleSystem.mEmittedEmitterPoolSize">
The number of emitted emitters in the pool.
</member>
        <member name="F:Ogre.ParticleSystem.mPoolSize">
The number of particles in the pool.
</member>
        <member name="F:Ogre.ParticleSystem.mRendererType">
The name of the type of renderer used to render this system
</member>
        <member name="F:Ogre.ParticleSystem.mCullIndividual">
Do we cull each particle individually?
</member>
        <member name="F:Ogre.ParticleSystem.mRenderer">
The renderer used to render this particle system
</member>
        <member name="F:Ogre.ParticleSystem.mAffectors">
List of particle affectors, ie modifiers of particles
</member>
        <member name="F:Ogre.ParticleSystem.mEmitters">
List of particle emitters, ie sources of particles
</member>
        <member name="F:Ogre.ParticleSystem.mActiveEmittedEmitters">
Active emitted emitter list.
            @remarks
                This is a linked list of pointers to emitters in the emitted emitter pool.
				Emitters that are used are stored (their pointers) in both the list with active particles and in 
				the list with active emitted emitters.        
</member>
        <member name="F:Ogre.ParticleSystem.mFreeEmittedEmitters">
Free emitted emitter list.
            @remarks
                This contains a list of the emitters free for use as new instances as required by the set.

</member>
        <member name="F:Ogre.ParticleSystem.mEmittedEmitterPool">
Pool of emitted emitters for use and reuse in the active emitted emitter list.
        @remarks
			The emitters in this pool act as particles and as emitters. The pool is a map containing lists 
			of emitters, identified by their name.
        @par
            The emitters in this pool are cloned using emitters that are kept in the main emitter list
			of the ParticleSystem.

</member>
        <member name="F:Ogre.ParticleSystem.mParticlePool">
Pool of particle instances for use and reuse in the active particle list.
            @remarks
                This vector will be preallocated with the estimated size of the set,and will extend as required.

</member>
        <member name="F:Ogre.ParticleSystem.mFreeParticles">
Free particle queue.
            @remarks
                This contains a list of the particles free for use as new instances
                as required by the set. Particle instances are preconstructed up 
                to the estimated size in the mParticlePool vector and are 
                referenced on this deque at startup. As they get used this list
                reduces, as they get released back to to the set they get added
				back to the list.

</member>
        <member name="F:Ogre.ParticleSystem.SortByDistanceFunctor.sortPos">
Position to sort in
</member>
        <member name="T:Ogre.ParticleSystem.SortByDistanceFunctor">
Sort by distance functor 
</member>
        <member name="F:Ogre.ParticleSystem.SortByDirectionFunctor.sortDir">
Direction to sort in
</member>
        <member name="T:Ogre.ParticleSystem.SortByDirectionFunctor">
Sort by direction functor 
</member>
        <member name="F:Ogre.ParticleSystem.mIsEmitting">
Used to control if the particle system should emit particles or not.
</member>
        <member name="F:Ogre.ParticleSystem.mEmittedEmitterPoolInitialised">
Indication whether the emitted emitter pool (= pool with particle emitters that are emitted) is initialised
</member>
        <member name="F:Ogre.ParticleSystem.mTimeController">
Controller for time update
</member>
        <member name="F:Ogre.ParticleSystem.mLastVisibleFrame">
Last frame in which known to be visible
</member>
        <member name="F:Ogre.ParticleSystem.mTimeSinceLastVisible">
Amount of time non-visible so far
</member>
        <member name="F:Ogre.ParticleSystem.mNonvisibleTimeoutSet">
Update timeout when nonvisible set? Otherwise track default
</member>
        <member name="F:Ogre.ParticleSystem.mNonvisibleTimeout">
Update timeout when nonvisible (0 for no timeout)
</member>
        <member name="F:Ogre.ParticleSystem.mLocalSpace">
Particles in local space?
</member>
        <member name="F:Ogre.ParticleSystem.mSorted">
Particles sorted according to camera?
</member>
        <member name="F:Ogre.ParticleSystem.mIterationIntervalSet">
Iteration interval set? Otherwise track default
</member>
        <member name="F:Ogre.ParticleSystem.mIterationInterval">
Iteration interval
</member>
        <member name="F:Ogre.ParticleSystem.mSpeedFactor">
Speed factor
</member>
        <member name="F:Ogre.ParticleSystem.mDefaultHeight">
Default height of each particle
</member>
        <member name="F:Ogre.ParticleSystem.mDefaultWidth">
Default width of each particle
</member>
        <member name="F:Ogre.ParticleSystem.mpMaterial">
Pointer to the material to use
</member>
        <member name="F:Ogre.ParticleSystem.mIsRendererConfigured">
Have we set the material etc on the renderer?
</member>
        <member name="F:Ogre.ParticleSystem.mMaterialName">
Name of the material to use
</member>
        <member name="F:Ogre.ParticleSystem.mResourceGroupName">
Name of the resource group to use to load materials
</member>
        <member name="F:Ogre.ParticleSystem.mWorldAABB">
World AABB, only used to compare world-space positions to calc bounds
</member>
        <member name="F:Ogre.ParticleSystem.msCullCmd">
Command objects
</member>
        <member name="M:Ogre.ParticleSystem.getTypeFlags">
Override to return specific type flag
</member>
        <member name="M:Ogre.ParticleSystem.getEmitting">
Returns true if the particle system emitting flag is turned on.
		@remarks
			This function will not actually return whether the particles are being emitted.
			It only returns the value of emitting flag.

</member>
        <member name="M:Ogre.ParticleSystem.setEmitting(System.Boolean)">
This is used to turn on or off particle emission for this system.
		@remarks
			By default particle system is always emitting particles (if a emitters exists)
			and this can be used to stop the emission for all emitters. To turn it on again, 
			call it passing true.

			Note that this does not detach the particle system from the scene node, it will 
			still use some CPU.

</member>
        <member name="M:Ogre.ParticleSystem._updateBounds">
Internal method for updating the bounds of the particle system.
        @remarks
            This is called automatically for a period of time after the system's
            creation (10 seconds by default, settable by setBoundsAutoUpdated) 
            to increase (and only increase) the bounds of the system according 
            to the emitted and affected particles. After this period, the 
            system is assumed to achieved its maximum size, and the bounds are
            no longer computed for efficiency. You can tweak the behaviour by 
            either setting the bounds manually (setBounds, preferred), or 
            changing the time over which the bounds are updated (performance cost).
            You can also call this method manually if you need to update the 
            bounds on an ad-hoc basis.

</member>
        <member name="M:Ogre.ParticleSystem.getKeepParticlesInLocalSpace">
Gets whether particles (and any affector effects) remain relative 
			to the node the particle system is attached to.

</member>
        <member name="M:Ogre.ParticleSystem.setKeepParticlesInLocalSpace(System.Boolean)">
Sets whether particles (and any affector effects) remain relative 
			to the node the particle system is attached to.
		@remarks
			By default particles are in world space once emitted, so they are not
			affected by movement in the parent node of the particle system. This
			makes the most sense when dealing with completely independent particles, 
			but if you want to constrain them to follow local motion too, you
			can set this to true.

</member>
        <member name="M:Ogre.ParticleSystem.setBoundsAutoUpdated(System.Boolean,System.Single)">
Sets whether the bounds will be automatically updated
            for the life of the particle system
        @remarks
            If you have a stationary particle system, it would be a good idea to
            call this method and set the value to 'false', since the maximum
            bounds of the particle system will eventually be static. If you do
            this, you can either set the bounds manually using the setBounds()
            method, or set the second parameter of this method to a positive
            number of seconds, so that the bounds are calculated for a few
            seconds and then frozen.
        @param autoUpdate If true (the default), the particle system will
            update it's bounds every frame. If false, the bounds update will 
            cease after the 'stopIn' number of seconds have passed.
        @param stopIn Only applicable if the first parameter is true, this is the
            number of seconds after which the automatic update will cease.

</member>
        <member name="M:Ogre.ParticleSystem.setBounds(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the (initial) bounds of the particle system manually. 
        @remarks
            If you can, set the bounds of a particle system up-front and 
            call setBoundsAutoUpdated(false); this is the most efficient way to
            organise it. Otherwise, set an initial bounds and let the bounds increase
            for a little while (the default is 5 seconds), after which time the 
            AABB is fixed to save time.
        @param aabb Bounds in local space.

</member>
        <member name="M:Ogre.ParticleSystem.getSortingEnabled">
Gets whether particles are sorted relative to the camera.
</member>
        <member name="M:Ogre.ParticleSystem.setSortingEnabled(System.Boolean)">
Set whether or not particles are sorted according to the camera.
		@remarks
			Enabling sorting alters the order particles are sent to the renderer.
			When enabled, particles are sent to the renderer in order of 
			furthest distance from the camera.

</member>
        <member name="M:Ogre.ParticleSystem.setRenderQueueGroup(System.Byte)">
@copydoc MovableObject::setRenderQueueGroup 
</member>
        <member name="M:Ogre.ParticleSystem._notifyOrigin(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Notify this particle system of it's origin
</member>
        <member name="M:Ogre.ParticleSystem.getOrigin">
Get the origin of this particle system, e.g. a script file name.
		@remarks
			This property will only contain something if the creator of
			this particle system chose to populate it. Script loaders are advised
			to populate it.

</member>
        <member name="M:Ogre.ParticleSystem.getResourceGroupName">
Return the resource group to be used to load dependent resources
</member>
        <member name="M:Ogre.ParticleSystem.setCullIndividually(System.Boolean)">
Sets whether culling tests particles in this individually as well as in a group.
        @remarks
            Particle sets are always culled as a whole group, based on a bounding box which 
            encloses all particles in the set. For fairly localised sets, this is enough. However, you
            can optionally tell the set to also cull individual particles in the set, i.e. to test
            each individual particle before rendering. The default is not to do this.
        @par
            This is useful when you have a large, fairly distributed set of particles, like maybe 
            trees on a landscape. You probably still want to group them into more than one
            set (maybe one set per section of landscape), which will be culled coarsely, but you also
            want to cull the particles individually because they are spread out. Whilst you could have
            lots of single-tree sets which are culled separately, this would be inefficient to render
            because each tree would be issued as it's own rendering operation.
        @par
            By calling this method with a parameter of true, you can have large particle sets which 
            are spaced out and so get the benefit of batch rendering and coarse culling, but also have
            fine-grained culling so unnecessary rendering is avoided.
        @param cullIndividual If true, each particle is tested before being sent to the pipeline as well 
            as the whole set having to pass the coarse group bounding test.

</member>
        <member name="M:Ogre.ParticleSystem.getCullIndividually">
Returns whether or not particles in this are tested individually for culling. 
</member>
        <member name="M:Ogre.ParticleSystem.getDefaultHeight">
See setDefaultDimensions - this gets 1 component individually. 
</member>
        <member name="M:Ogre.ParticleSystem.setDefaultHeight(System.Single)">
See setDefaultDimensions - this sets 1 component individually. 
</member>
        <member name="M:Ogre.ParticleSystem.getDefaultWidth">
See setDefaultDimensions - this gets 1 component individually. 
</member>
        <member name="M:Ogre.ParticleSystem.setDefaultWidth(System.Single)">
See setDefaultDimensions - this sets 1 component individually. 
</member>
        <member name="M:Ogre.ParticleSystem.setDefaultDimensions(System.Single,System.Single)">
Sets the default dimensions of the particles in this set.
            @remarks
                All particles in a set are created with these default dimensions. The set will render most efficiently if
                all the particles in the set are the default size. It is possible to alter the size of individual
                particles at the expense of extra calculation. See the Particle class for more info.
            @param width
                The new default width for the particles in this set.
            @param height
                The new default height for the particles in this set.

</member>
        <member name="M:Ogre.ParticleSystem._notifyParticleRotated">
Internal callback used by Particles to notify their parent that they have been rotated.

</member>
        <member name="M:Ogre.ParticleSystem._notifyParticleResized">
Internal callback used by Particles to notify their parent that they have been resized.

</member>
        <member name="M:Ogre.ParticleSystem.getMovableType">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.ParticleSystem.getDefaultNonVisibleUpdateTimeout">
Get the default nonvisible timeout for all ParticleSystem instances.

</member>
        <member name="M:Ogre.ParticleSystem.setDefaultNonVisibleUpdateTimeout(System.Single)">
Set the default nonvisible timeout for all ParticleSystem instances.

</member>
        <member name="M:Ogre.ParticleSystem.getNonVisibleUpdateTimeout">
Gets when the particle system should stop updating after it hasn't been
			visible for a while.

</member>
        <member name="M:Ogre.ParticleSystem.setNonVisibleUpdateTimeout(System.Single)">
Sets when the particle system should stop updating after it hasn't been
			visible for a while.
		@remarks
			By default, visible particle systems update all the time, even when 
			not in view. This means that they are guaranteed to be consistent when 
			they do enter view. However, this comes at a cost, updating particle
			systems can be expensive, especially if they are perpetual.
		@par
			This option lets you set a 'timeout' on the particle system, so that
			if it isn't visible for this amount of time, it will stop updating
			until it is next visible.
		@param timeout The time after which the particle system will be disabled
			if it is no longer visible. 0 to disable the timeout and always update.

</member>
        <member name="M:Ogre.ParticleSystem.getDefaultIterationInterval">
Get the default iteration interval for all ParticleSystem instances.

</member>
        <member name="M:Ogre.ParticleSystem.setDefaultIterationInterval(System.Single)">
Set the default iteration interval for all ParticleSystem instances.

</member>
        <member name="M:Ogre.ParticleSystem.getIterationInterval">
Gets a 'iteration interval' on this particle system.

</member>
        <member name="M:Ogre.ParticleSystem.setIterationInterval(System.Single)">
Sets a 'iteration interval' on this particle system.
        @remarks
            The default Particle system update interval, based on elapsed frame time,
			will cause different behavior between low frame-rate and high frame-rate. 
			By using this option, you can make the particle system update at
			a fixed interval, keeping the behavior the same no matter what frame-rate 
			is.
        @par
            When iteration interval is set to zero, it means the update occurs based 
			on an elapsed frame time, otherwise each iteration will take place 
			at the given interval, repeating until it has used up all the elapsed 
			frame time.
        @param
            iterationInterval The iteration interval, default to zero.

</member>
        <member name="M:Ogre.ParticleSystem.getSpeedFactor">
Gets the 'speed factor' on this particle system.

</member>
        <member name="M:Ogre.ParticleSystem.setSpeedFactor(System.Single)">
Sets a 'speed factor' on this particle system, which means it scales the elapsed
			real time which has passed by this factor before passing it to the emitters, affectors,
			and the particle life calculation.
		@remarks
			An interesting side effect - if you want to create a completely manual particle system
			where you control the emission and life of particles yourself, you can set the speed
			factor to 0.0f, thus disabling normal particle emission, alteration, and death.

</member>
        <member name="M:Ogre.ParticleSystem.fastForward(System.Single,System.Single)">
Fast-forwards this system by the required number of seconds.
        @remarks
            This method allows you to fast-forward a system so that it effectively looks like
            it has already been running for the time you specify. This is useful to avoid the
            'startup sequence' of a system, when you want the system to be fully populated right
            from the start.
        @param
            time The number of seconds to fast-forward by.
        @param
            interval The sampling interval used to generate particles, apply affectors etc. The lower this
            is the more realistic the fast-forward, but it takes more iterations to do it.

</member>
        <member name="M:Ogre.ParticleSystem.visitRenderables(Ogre.Renderable.Visitor*,System.Boolean)">
@copydoc MovableObject::visitRenderables
</member>
        <member name="M:Ogre.ParticleSystem._updateRenderQueue(Ogre.RenderQueue*)">
Overridden from MovableObject
            @see
                MovableObject

</member>
        <member name="M:Ogre.ParticleSystem.getBoundingRadius">
Overridden from MovableObject
            @see
                MovableObject

</member>
        <member name="M:Ogre.ParticleSystem.getBoundingBox">
Overridden from MovableObject
            @see
                MovableObject

</member>
        <member name="M:Ogre.ParticleSystem._notifyAttached(Ogre.Node*,System.Boolean)">
Overridden from MovableObject
        @see
        MovableObject

</member>
        <member name="M:Ogre.ParticleSystem._notifyCurrentCamera(Ogre.Camera*)">
Overridden from MovableObject
            @see
                MovableObject

</member>
        <member name="M:Ogre.ParticleSystem.getMaterialName">
Sets the name of the material to be used for this billboard set.
            @returns The name of the material that is used for this set.

</member>
        <member name="M:Ogre.ParticleSystem.setMaterialName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the name of the material to be used for this billboard set.
            @param
                name The new name of the material to use for this set.

</member>
        <member name="M:Ogre.ParticleSystem._getIterator">
Returns an iterator for stepping through all particles in this system.
        @remarks
            This method is designed to be used by people providing new ParticleAffector subclasses,
            this is the easiest way to step through all the particles in a system and apply the
            changes the affector wants to make.

</member>
        <member name="M:Ogre.ParticleSystem._update(System.Single)">
Updates the particles in the system based on time elapsed.
        @remarks
            This is called automatically every frame by OGRE.
        @param
            timeElapsed The amount of time, in seconds, since the last frame.

</member>
        <member name="M:Ogre.ParticleSystem.op_Assign(Ogre.ParticleSystem!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator for copying.
        @remarks
            This operator deep copies all particle emitters and effectors, but not particles. The
            system's name is also not copied.

</member>
        <member name="M:Ogre.ParticleSystem.setEmittedEmitterQuota(System.UInt32)">
Sets the maximum number of emitted emitters this system is allowed to have active at once.
        @remarks
            Particle systems can have - besides a particle quota - also an emitted emitter quota.
        @param quota The maximum number of emitted emitters this system is allowed to have.

</member>
        <member name="M:Ogre.ParticleSystem.getEmittedEmitterQuota">
Returns the maximum number of emitted emitters this system is allowed to have active at once.
        @remarks
            See ParticleSystem::setEmittedEmitterQuota for more info.

</member>
        <member name="M:Ogre.ParticleSystem.setParticleQuota(System.UInt32)">
Sets the maximum number of particles this system is allowed to have active at once.
        @remarks
            Particle systems all have a particle quota, i.e. a maximum number of particles they are 
            allowed to have active at a time. This allows the application to set a keep particle systems
            under control should they be affected by complex parameters which alter their emission rates
            etc. If a particle system reaches it's particle quota, none of the emitters will be able to 
            emit any more particles. As existing particles die, the spare capacity will be allocated
            equally across all emitters to be as consistent to the origina particle system style as possible.
        @param quota The maximum number of particles this system is allowed to have.

</member>
        <member name="M:Ogre.ParticleSystem.getParticleQuota">
Returns the maximum number of particles this system is allowed to have active at once.
        @remarks
            See ParticleSystem::setParticleQuota for more info.

</member>
        <member name="M:Ogre.ParticleSystem.getParticle(System.UInt32)">
Retrieve a particle from the system for manual tweaking.
		@remarks
			Normally you use an affector to alter particles in flight, but
			for small manually controlled particle systems you might want to use
			this method.

</member>
        <member name="M:Ogre.ParticleSystem.createEmitterParticle(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Manually add an emitter particle to the system. 
		@remarks
			The purpose of a particle emitter is to emit particles. Besides visual particles, also other other
			particle types can be emitted, other emitters for example. The emitted emitters have a double role;
			they behave as particles and can be influenced by affectors, but they are still emitters and capable 
			to emit other particles (or emitters). It is possible to create a chain of emitters - emitters 
			emitting other emitters, which also emit emitters.
		@param emitterName The name of a particle emitter that must be emitted.

</member>
        <member name="M:Ogre.ParticleSystem.createParticle">
Manually add a particle to the system. 
		@remarks
			Instead of using an emitter, you can manually add a particle to the system.
			You must initialise the returned particle instance immediately with the
			'emission' state.
		@note
			There is no corresponding 'destroyParticle' method - if you want to dispose of a
			particle manually (say, if you've used setSpeedFactor(0) to make particles live forever)
			you should use getParticle() and modify it's timeToLive to zero, meaning that it will
			get cleaned up in the next update.

</member>
        <member name="M:Ogre.ParticleSystem.getNumParticles">
Gets the number of individual particles in the system right now.
        @remarks
            The number of particles active in a system at a point in time depends on 
            the number of emitters, their emission rates, the time-to-live (TTL) each particle is
            given on emission (and whether any affectors modify that TTL) and the maximum
            number of particles allowed in this system at once (particle quota).

</member>
        <member name="M:Ogre.ParticleSystem.clear">
Empties this set of all particles.

</member>
        <member name="M:Ogre.ParticleSystem.removeAllAffectors">
Removes all the affectors from this system. 
</member>
        <member name="M:Ogre.ParticleSystem.removeAffector(System.UInt16)">
Removes an affector from the system.
        @remarks
            Drops the affector with the index specified from this system.
            You should check how many affectors are registered against this system before calling
            this method with an arbitrary index using getNumAffectors.
        @param
            index Zero-based index of the affector to retrieve.

</member>
        <member name="M:Ogre.ParticleSystem.getNumAffectors">
Returns the number of affectors for this particle system. 
</member>
        <member name="M:Ogre.ParticleSystem.getAffector(System.UInt16)">
Retrieves an affector by it's index (zero-based).
        @remarks
            Used to retrieve a pointer to an affector for a particle system to procedurally change
            affector parameters etc.
            You should check how many affectors are registered against this system before calling
            this method with an arbitrary index using getNumAffectors.
        @param
            index Zero-based index of the affector to retrieve.

</member>
        <member name="M:Ogre.ParticleSystem.addAffector(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds an affector to this particle system.
        @remarks
            Particles are modified over time in a particle system by affectors - see the ParticleAffector
            class for more details.
        @param 
            affectorType String identifying the affector type to create. Affector types are defined
            by registering new factories with the manager - see ParticleAffectorFactory for more details.
            Affector types can be extended by OGRE, plugin authors or application developers.

</member>
        <member name="M:Ogre.ParticleSystem.removeAllEmitters">
Removes all the emitters from this system. 
</member>
        <member name="M:Ogre.ParticleSystem.removeEmitter(System.UInt16)">
Removes an emitter from the system.
        @remarks
            Drops the emitter with the index specified from this system.
            You should check how many emitters are registered against this system before calling
            this method with an arbitrary index using getNumEmitters.
        @param
            index Zero-based index of the emitter to retrieve.

</member>
        <member name="M:Ogre.ParticleSystem.getNumEmitters">
Returns the number of emitters for this particle system. 
</member>
        <member name="M:Ogre.ParticleSystem.getEmitter(System.UInt16)">
Retrieves an emitter by it's index (zero-based).
        @remarks
            Used to retrieve a pointer to an emitter for a particle system to procedurally change
            emission parameters etc.
            You should check how many emitters are registered against this system before calling
            this method with an arbitrary index using getNumEmitters.
        @param
            index Zero-based index of the emitter to retrieve.

</member>
        <member name="M:Ogre.ParticleSystem.addEmitter(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds an emitter to this particle system.
        @remarks
            Particles are created in a particle system by emitters - see the ParticleEmitter
            class for more details.
        @param 
            emitterType String identifying the emitter type to create. Emitter types are defined
            by registering new factories with the manager - see ParticleEmitterFactory for more details.
            Emitter types can be extended by OGRE, plugin authors or application developers.

</member>
        <member name="M:Ogre.ParticleSystem.getRendererName">
Gets the name of the ParticleRenderer to be used to render this particle system. 
</member>
        <member name="M:Ogre.ParticleSystem.getRenderer">
Gets the ParticleRenderer to be used to render this particle system. 
</member>
        <member name="M:Ogre.ParticleSystem.setRenderer(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the ParticleRenderer to be used to render this particle system.
        @remarks
            The main ParticleSystem just manages the creation and movement of 
            particles; they are rendered using functions in ParticleRenderer
            and the ParticleVisual instances they create.
		@param typeName String identifying the type of renderer to use; a new 
			instance of this type will be created; a factory must have been registered
			with ParticleSystemManager.

</member>
        <member name="M:Ogre.ParticleSystem.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a particle system with no emitters or affectors.
        @remarks
            You should use the ParticleSystemManager to create particle systems rather than creating
            them directly.

</member>
        <member name="M:Ogre.ParticleSystem.#ctor">
Default constructor required for STL creation in manager
</member>
        <member name="T:Ogre.ParticleSystem.CmdNonvisibleTimeout">
Command object for nonvisible timeout (see ParamCommand).
</member>
        <member name="T:Ogre.ParticleSystem.CmdIterationInterval">
Command object for iteration interval(see ParamCommand).
</member>
        <member name="T:Ogre.ParticleSystem.CmdLocalSpace">
Command object for local space (see ParamCommand).
</member>
        <member name="T:Ogre.ParticleSystem.CmdSorted">
Command object for sorting (see ParamCommand).
</member>
        <member name="T:Ogre.ParticleSystem.CmdRenderer">
Command object for renderer (see ParamCommand).
</member>
        <member name="T:Ogre.ParticleSystem.CmdHeight">
Command object for particle_height (see ParamCommand).
</member>
        <member name="T:Ogre.ParticleSystem.CmdWidth">
Command object for particle_width (see ParamCommand).
</member>
        <member name="T:Ogre.ParticleSystem.CmdCull">
Command object for cull_each (see ParamCommand).
</member>
        <member name="T:Ogre.ParticleSystem.CmdMaterial">
Command object for material (see ParamCommand).
</member>
        <member name="T:Ogre.ParticleSystem.CmdEmittedEmitterQuota">
Command object for emittedEmitterQuota (see ParamCommand).
</member>
        <member name="T:Ogre.ParticleSystem.CmdQuota">
Command object for quota (see ParamCommand).
</member>
        <member name="T:Ogre.ParticleSystem">
\addtogroup Core
	*  @{

\addtogroup Effects
	*  @{

Class defining particle system based special effects.
    @remarks
        Particle systems are special effects generators which are based on a 
        number of moving points to create the impression of things like like 
        sparkles, smoke, blood spurts, dust etc.
    @par
        This class simply manages a single collection of particles in world space
        with a shared local origin for emission. The visual aspect of the 
        particles is handled by a ParticleSystemRenderer instance.
    @par
        Particle systems are created using the SceneManager, never directly.
        In addition, like all subclasses of MovableObject, the ParticleSystem 
		will only be considered for rendering once it has been attached to a 
		SceneNode. 

</member>
        <member name="M:Ogre.ParticleIterator.getNext">
Returns a pointer to the next particle, and moves the iterator on by 1 element. 
</member>
        <member name="M:Ogre.ParticleIterator.#ctor(std.list&lt;Ogre.Particle**&gt;._Iterator&lt;true&gt;,std.list&lt;Ogre.Particle**&gt;._Iterator&lt;true&gt;)">
Protected constructor, only available from ParticleSystem::getIterator
</member>
        <member name="T:Ogre.ParticleIterator">
\addtogroup Core
	*  @{

\addtogroup Effects
	*  @{

Convenience class to make it easy to step through all particles in a ParticleSystem.

</member>
        <member name="M:Ogre.ParticleEmitter.setEmitted(System.Boolean)">
Set the indication (true/false) to indicate that the emitter is emitted by another emitter 
</member>
        <member name="M:Ogre.ParticleEmitter.isEmitted">
Return true if the emitter is emitted by another emitter 
</member>
        <member name="M:Ogre.ParticleEmitter.setEmittedEmitter(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the name of the emitter to be emitted
</member>
        <member name="M:Ogre.ParticleEmitter.getEmittedEmitter">
Returns the name of the emitter to be emitted 
</member>
        <member name="M:Ogre.ParticleEmitter.setName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the name of the emitter 
</member>
        <member name="M:Ogre.ParticleEmitter.getName">
Returns the name of the emitter 
</member>
        <member name="M:Ogre.ParticleEmitter.getMaxRepeatDelay">
Gets the maximum duration of this emitter in seconds (see setRepeatDelay for more details) 
</member>
        <member name="M:Ogre.ParticleEmitter.getMinRepeatDelay">
Gets the minimum duration of this emitter in seconds (see setRepeatDelay for more details) 
</member>
        <member name="M:Ogre.ParticleEmitter.setMaxRepeatDelay(System.Single)">
Sets the maximum duration of this emitter in seconds (see setRepeatDelay for more details) 
</member>
        <member name="M:Ogre.ParticleEmitter.setMinRepeatDelay(System.Single)">
Sets the minimum duration of this emitter in seconds (see setRepeatDelay for more details) 
</member>
        <member name="M:Ogre.ParticleEmitter.setRepeatDelay(System.Single,System.Single)">
Sets the range of random duration for this emitter. 
        @remarks
            By default emitters run indefinitely (unless you manually disable them). By setting this
            parameter, you can make an emitter turn off on it's own after a random number of seconds. It
            will then remain disabled until either setEnabled(true) is called, or if the 'repeatAfter' parameter
            has been set it will also repeat after a number of seconds.
        @par
            Also see the alternative version of this method which allows you to set a constant duration.
        @param min The minimum duration in seconds.
        @param max The minimum duration in seconds.

</member>
        <member name="M:Ogre.ParticleEmitter.getRepeatDelay">
Gets the duration of the emitter from when it is created or re-enabled. 
</member>
        <member name="M:Ogre.ParticleEmitter.setRepeatDelay(System.Single)">
Sets the time between repeats of the emitter.
        @remarks
            By default emitters run indefinitely (unless you manually disable them). However, if you manually
            disable the emitter (by calling setEnabled(false), or it's duration runs out, it will cease to emit
        @par
            Also see the alternative version of this method which allows you to set a min and max duration for
            a random variable duration.
        @param duration The duration in seconds.

</member>
        <member name="M:Ogre.ParticleEmitter.getMaxDuration">
Gets the maximum duration of this emitter in seconds (see setDuration for more details) 
</member>
        <member name="M:Ogre.ParticleEmitter.getMinDuration">
Gets the minimum duration of this emitter in seconds (see setDuration for more details) 
</member>
        <member name="M:Ogre.ParticleEmitter.setMaxDuration(System.Single)">
Sets the maximum duration of this emitter in seconds (see setDuration for more details) 
</member>
        <member name="M:Ogre.ParticleEmitter.setMinDuration(System.Single)">
Sets the minimum duration of this emitter in seconds (see setDuration for more details) 
</member>
        <member name="M:Ogre.ParticleEmitter.setDuration(System.Single,System.Single)">
Sets the range of random duration for this emitter. 
        @remarks
            By default emitters run indefinitely (unless you manually disable them). By setting this
            parameter, you can make an emitter turn off on it's own after a random number of seconds. It
            will then remain disabled until either setEnabled(true) is called, or if the 'repeatAfter' parameter
            has been set it will also repeat after a number of seconds.
        @par
            Also see the alternative version of this method which allows you to set a constant duration.
        @param min The minimum duration in seconds.
        @param max The minimum duration in seconds.

</member>
        <member name="M:Ogre.ParticleEmitter.getDuration">
Gets the duration of the emitter from when it is created or re-enabled. 
</member>
        <member name="M:Ogre.ParticleEmitter.setDuration(System.Single)">
Sets the duration of the emitter.
        @remarks
            By default emitters run indefinitely (unless you manually disable them). By setting this
            parameter, you can make an emitter turn off on it's own after a set number of seconds. It
            will then remain disabled until either setEnabled(true) is called, or if the 'repeatAfter' parameter
            has been set it will also repeat after a number of seconds.
        @par
            Also see the alternative version of this method which allows you to set a min and max duration for
            a random variable duration.
        @param duration The duration in seconds.

</member>
        <member name="M:Ogre.ParticleEmitter.getStartTime">
Gets the start time of the emitter. 
</member>
        <member name="M:Ogre.ParticleEmitter.setStartTime(System.Single)">
Sets the 'start time' of this emitter.
        @remarks
            By default an emitter starts straight away as soon as a ParticleSystem is first created,
            or also just after it is re-enabled. This parameter allows you to set a time delay so
            that the emitter does not 'kick in' until later.
        @param startTime The time in seconds from the creation or enabling of the emitter.

</member>
        <member name="M:Ogre.ParticleEmitter.getEnabled">
Gets the flag indicating if this emitter is enabled or not. 
</member>
        <member name="M:Ogre.ParticleEmitter.setEnabled(System.Boolean)">
Sets whether or not the emitter is enabled.
        @remarks
            You can turn an emitter off completely by setting this parameter to false.

</member>
        <member name="M:Ogre.ParticleEmitter.getType">
Returns the name of the type of emitter. 
        @remarks
            This property is useful for determining the type of emitter procedurally so another
            can be created.

</member>
        <member name="M:Ogre.ParticleEmitter._initParticle(Ogre.Particle*)">
Initialises a particle based on the emitter's approach and parameters.
        @remarks
            See the _getEmissionCount method for details of why there is a separation between
            'requested' emissions and actual initialised particles.
        @param
            pParticle Pointer to a particle which must be initialised based on how this emitter
            starts particles. This is passed as a pointer rather than being created by the emitter so the
            ParticleSystem can reuse Particle instances, and can also set defaults itself.

</member>
        <member name="M:Ogre.ParticleEmitter._getEmissionCount(System.Single)">
Gets the number of particles which this emitter would like to emit based on the time elapsed.
        @remarks
            For efficiency the emitter does not actually create new Particle instances (these are reused
            by the ParticleSystem as existing particles 'die'). The implementation for this method must
            return the number of particles the emitter would like to emit given the number of seconds which
            have elapsed (passed in as a parameter).
        @par
            Based on the return value from this method, the ParticleSystem class will call 
            _initParticle once for each particle it chooses to allow to be emitted by this emitter.
            The emitter should not track these _initParticle calls, it should assume all emissions
            requested were made (even if they could not be because of particle quotas).

</member>
        <member name="M:Ogre.ParticleEmitter.getColourRangeEnd">
Gets the maximum colour of particles to be emitted. 
</member>
        <member name="M:Ogre.ParticleEmitter.getColourRangeStart">
Gets the minimum colour of particles to be emitted. 
</member>
        <member name="M:Ogre.ParticleEmitter.getColour">
Gets the colour of particles to be emitted. 
</member>
        <member name="M:Ogre.ParticleEmitter.setColourRangeEnd(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the maximum colour of particles to be emitted. 
</member>
        <member name="M:Ogre.ParticleEmitter.setColourRangeStart(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the minimum colour of particles to be emitted. 
</member>
        <member name="M:Ogre.ParticleEmitter.setColour(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the range of colours for emitted particles.
        @remarks
            Particles have an initial colour on emission which the emitter sets. This method sets
            the range of this colour. See the alternate version of this method which takes a single colour
            in order to set a constant colour for all particles. Emitters may choose to randomly assign
            a colour in this range, or may use some other method to vary the colour.
        @param colourStart The start of the colour range
        @param colourEnd The end of the colour range

</member>
        <member name="M:Ogre.ParticleEmitter.setColour(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the initial colour of particles emitted.
        @remarks
            Particles have an initial colour on emission which the emitter sets. This method sets
            this colour. See the alternate version of this method which takes 2 colours in order to establish 
            a range of colours to be assigned to particles.
        @param colour The colour which all particles will be given on emission.

</member>
        <member name="M:Ogre.ParticleEmitter.getMaxTimeToLive">
Gets the maximum time each particle will live for. 
</member>
        <member name="M:Ogre.ParticleEmitter.getMinTimeToLive">
Gets the minimum time each particle will live for. 
</member>
        <member name="M:Ogre.ParticleEmitter.getTimeToLive">
Gets the time each particle will live for. 
</member>
        <member name="M:Ogre.ParticleEmitter.setMaxTimeToLive(System.Single)">
Sets the maximum time each particle will live for. 
</member>
        <member name="M:Ogre.ParticleEmitter.setMinTimeToLive(System.Single)">
Sets the minimum time each particle will live for. 
</member>
        <member name="M:Ogre.ParticleEmitter.setTimeToLive(System.Single,System.Single)">
Sets the range of lifetime for particles emitted.
        @remarks
            The emitter initialises particles with a time-to-live (TTL), the number of seconds a particle
            will exist before being destroyed. This method sets a range for the TTL for all particles emitted;
            the ttl may be randomised between these 2 extremes or will vary some other way depending on the
            emitter.
            Note that affectors are able to modify the TTL of particles later.
        @par
            Also see the alternate version of this method which takes a single TTL in order to 
            set a constant TTL for all particles.
        @param minTtl The minimum number of seconds each particle will live for.
        @param maxTtl The maximum number of seconds each particle will live for.

</member>
        <member name="M:Ogre.ParticleEmitter.setTimeToLive(System.Single)">
Sets the lifetime of all particles emitted.
        @remarks
            The emitter initialises particles with a time-to-live (TTL), the number of seconds a particle
            will exist before being destroyed. This method sets a constant TTL for all particles emitted.
            Note that affectors are able to modify the TTL of particles later.
        @par
            Also see the alternate version of this method which takes a min and max TTL in order to 
            have the TTL vary per particle.
        @param ttl The number of seconds each particle will live for.

</member>
        <member name="M:Ogre.ParticleEmitter.getEmissionRate">
Returns the emission rate set for this emitter. 
</member>
        <member name="M:Ogre.ParticleEmitter.setEmissionRate(System.Single)">
Sets the emission rate for this emitter.
        @remarks
            This method tells the emitter how many particles per second should be emitted. The emitter
            subclass does not have to emit these in a continuous burst - this is a relative parameter
            and the emitter may choose to emit all of the second's worth of particles every half-second
            for example. This is controlled by the emitter's getEmissionCount method.
        @par
            Also, if the ParticleSystem's particle quota is exceeded, not all the particles requested
            may be actually emitted.
        @param
            particlesPerSecond The number of particles to be emitted every second.

</member>
        <member name="M:Ogre.ParticleEmitter.getMaxParticleVelocity">
Returns the maximum particle velocity. 
</member>
        <member name="M:Ogre.ParticleEmitter.getMinParticleVelocity">
Returns the minimum particle velocity. 
</member>
        <member name="M:Ogre.ParticleEmitter.getParticleVelocity">
Returns the initial velocity of particles emitted. 
</member>
        <member name="M:Ogre.ParticleEmitter.setMaxParticleVelocity(System.Single)">
Returns the maximum particle velocity. 
</member>
        <member name="M:Ogre.ParticleEmitter.setMinParticleVelocity(System.Single)">
Returns the minimum particle velocity. 
</member>
        <member name="M:Ogre.ParticleEmitter.setParticleVelocity(System.Single,System.Single)">
Sets the initial velocity range of particles emitted.
        @remarks
            This method sets the range of starting speeds for emitted particles. 
            See the alternate version of this method which takes 1 parameter if you want a 
            constant speed. This emitter will randomly choose a speed between the minimum and 
            maximum for each particle.
        @param max The maximum speed in world units per second for the initial particle speed on emission.
        @param min The minimum speed in world units per second for the initial particle speed on emission.

</member>
        <member name="M:Ogre.ParticleEmitter.setParticleVelocity(System.Single)">
Sets the initial velocity of particles emitted.
        @remarks
            This method sets a constant speed for emitted particles. See the alternate version
            of this method which takes 2 parameters if you want a variable speed. 
        @param
            speed The initial speed in world units per second which every particle emitted starts with.

</member>
        <member name="M:Ogre.ParticleEmitter.getAngle">
Returns the maximum angle which the initial particle direction can deviate from the emitters base direction. 
</member>
        <member name="M:Ogre.ParticleEmitter.setAngle(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the maximum angle away from the emitter direction which particle will be emitted.
        @remarks
            Whilst the direction property defines the general direction of emission for particles, 
            this property defines how far the emission angle can deviate away from this base direction.
            This allows you to create a scatter effect - if set to 0, all particles will be emitted
            exactly along the emitters direction vector, whereas if you set it to 180 degrees or more,
            particles will be emitted in a sphere, i.e. in all directions.
        @param degrees
            Maximum angle which initial particle direction can deviate from the emitter base direction vector.

</member>
        <member name="M:Ogre.ParticleEmitter.getDirection">
Returns the base direction of the emitter. 
</member>
        <member name="M:Ogre.ParticleEmitter.setDirection(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the direction of the emitter.
        @remarks
            Most emitters will have a base direction in which they emit particles (those which
            emit in all directions will ignore this parameter). They may not emit exactly along this
            vector for every particle, many will introduce a random scatter around this vector using 
            the angle property.
        @param direction
            The base direction for particles emitted.

</member>
        <member name="M:Ogre.ParticleEmitter.getPosition">
Returns the position of this emitter relative to the center of the particle system. 
</member>
        <member name="M:Ogre.ParticleEmitter.setPosition(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the position of this emitter relative to the particle system center. 
</member>
        <member name="M:Ogre.ParticleEmitter.Dispose">
Virtual destructor essential. 
</member>
        <member name="M:Ogre.ParticleEmitter.addBaseParameters">
Internal method for setting up the basic parameter definitions for a subclass. 
        @remarks
            Because StringInterface holds a dictionary of parameters per class, subclasses need to
            call this to ask the base class to add it's parameters to their dictionary as well.
            Can't do this in the constructor because that runs in a non-virtual context.
        @par
            The subclass must have called it's own createParamDictionary before calling this method.

</member>
        <member name="M:Ogre.ParticleEmitter.genConstantEmissionCount(System.Single)">
Internal utility method for generating an emission count based on a constant emission rate. 
</member>
        <member name="M:Ogre.ParticleEmitter.genEmissionColour(Ogre.ColourValue*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal utility method for generating a colour for a particle. 
</member>
        <member name="M:Ogre.ParticleEmitter.genEmissionTTL">
Internal utility method for generating a time-to-live for a particle. 
</member>
        <member name="M:Ogre.ParticleEmitter.genEmissionVelocity(Ogre.Vector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal utility method to apply velocity to a particle direction.
        @param destVector The vector to scale by a randomly generated scale between min and max speed.
            Assumed normalised already, and likely already oriented in the right direction.

</member>
        <member name="M:Ogre.ParticleEmitter.genEmissionDirection(Ogre.Vector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal utility method for generating particle exit direction
        @param destVector Reference to vector to complete with new direction (normalised)

</member>
        <member name="F:Ogre.ParticleEmitter.mEmittedEmitter">
The name of the emitter to be emitted (optional)
</member>
        <member name="F:Ogre.ParticleEmitter.mName">
The name of the emitter. The name is optional unless it is used as an emitter that is emitted itself.
</member>
        <member name="F:Ogre.ParticleEmitter.mRepeatDelayRemain">
Repeat delay left
</member>
        <member name="F:Ogre.ParticleEmitter.mRepeatDelayMin">
Time between each repeat
</member>
        <member name="F:Ogre.ParticleEmitter.mDurationRemain">
Current duration remainder
</member>
        <member name="F:Ogre.ParticleEmitter.mDurationMax">
Maximum length of time the emitter will run for (0 = forever)
</member>
        <member name="F:Ogre.ParticleEmitter.mDurationMin">
Minimum length of time emitter will run for (0 = forever)
</member>
        <member name="F:Ogre.ParticleEmitter.mStartTime">
Start time (in seconds from start of first call to ParticleSystem to update)
</member>
        <member name="F:Ogre.ParticleEmitter.mEnabled">
Whether this emitter is currently enabled (defaults to true)
</member>
        <member name="F:Ogre.ParticleEmitter.mColourRangeEnd">
Initial colour of particles (range end)
</member>
        <member name="F:Ogre.ParticleEmitter.mColourRangeStart">
Initial colour of particles (range start)
</member>
        <member name="F:Ogre.ParticleEmitter.mMaxTTL">
Initial time-to-live of particles (max)
</member>
        <member name="F:Ogre.ParticleEmitter.mMinTTL">
Initial time-to-live of particles (min)
</member>
        <member name="F:Ogre.ParticleEmitter.mMaxSpeed">
Max speed of particles
</member>
        <member name="F:Ogre.ParticleEmitter.mMinSpeed">
Min speed of particles
</member>
        <member name="F:Ogre.ParticleEmitter.mAngle">
Angle around direction which particles may be emitted, internally radians but angleunits for interface
</member>
        <member name="F:Ogre.ParticleEmitter.mDirection">
Base direction of the emitter, may not be used by some emitters
</member>
        <member name="F:Ogre.ParticleEmitter.mType">
Name of the type of emitter, MUST be initialised by subclasses
</member>
        <member name="F:Ogre.ParticleEmitter.mEmissionRate">
Rate in particles per second at which this emitter wishes to emit particles
</member>
        <member name="F:Ogre.ParticleEmitter.mPosition">
Position relative to the center of the ParticleSystem
</member>
        <member name="F:Ogre.ParticleEmitter.mParent">
Parent particle system
</member>
        <member name="T:Ogre.ParticleEmitter">
\addtogroup Core
	*  @{

\addtogroup Effects
	*  @{

Abstract class defining the interface to be implemented by particle emitters.
    @remarks
        Particle emitters are the sources of particles in a particle system. 
        This class defines the ParticleEmitter interface, and provides a basic implementation 
        for tasks which most emitters will do (these are of course overridable).
        Particle emitters can be  grouped into types, e.g. 'point' emitters, 'box' emitters etc; each type will 
        create particles with a different starting point, direction and velocity (although
        within the types you can configure the ranges of these parameters). 
    @par
        Because there are so many types of emitters you could use, OGRE chooses not to dictate
        the available types. It comes with some in-built, but allows plugins or applications to extend the emitter types available.
        This is done by subclassing ParticleEmitter to have the appropriate emission behaviour you want,
        and also creating a subclass of ParticleEmitterFactory which is responsible for creating instances 
        of your new emitter type. You register this factory with the ParticleSystemManager using
        addEmitterFactory, and from then on emitters of this type can be created either from code or through
        text particle scripts by naming the type.
    @par
        This same approach is used for ParticleAffectors (which modify existing particles per frame).
        This means that OGRE is particularly flexible when it comes to creating particle system effects,
        with literally infinite combinations of emitter and affector types, and paramters within those
        types.

</member>
        <member name="M:Ogre.Particle.resetDimensions">
Utility method to reset this particle
</member>
        <member name="M:Ogre.Particle.getVisualData">
Get the optional visual data associated with the class
</member>
        <member name="M:Ogre.Particle._notifyVisualData(Ogre.ParticleVisualData*)">
Internal method for notifying the particle of it's optional visual data.

</member>
        <member name="M:Ogre.Particle._notifyOwner(Ogre.ParticleSystem*)">
Internal method for notifying the particle of it's owner.

</member>
        <member name="M:Ogre.Particle.setRotation(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the current rotation 
</member>
        <member name="M:Ogre.Particle.getOwnHeight">
Retrieves the particle's personal width, if hasOwnDimensions is true. 
</member>
        <member name="M:Ogre.Particle.getOwnWidth">
Retrieves the particle's personal width, if hasOwnDimensions is true. 
</member>
        <member name="M:Ogre.Particle.hasOwnDimensions">
Returns true if this particle deviates from the ParticleSystem's default dimensions (i.e. if the
        particle::setDimensions method has been called for this instance).
        @see
        particle::setDimensions

</member>
        <member name="M:Ogre.Particle.setDimensions(System.Single,System.Single)">
Sets the width and height for this particle.
        @remarks
        Note that it is most efficient for every particle in a ParticleSystem to have the same dimensions. If you
        choose to alter the dimensions of an individual particle the set will be less efficient. Do not call
        this method unless you really need to have different particle dimensions within the same set. Otherwise
        just call the ParticleSystem::setDefaultDimensions method instead.

</member>
        <member name="F:Ogre.Particle.particleType">
Determines the type of particle.
</member>
        <member name="F:Ogre.Particle.rotationSpeed">
Speed of rotation in radians/sec
</member>
        <member name="F:Ogre.Particle.totalTimeToLive">
Total Time to live, number of seconds of particles natural life
</member>
        <member name="F:Ogre.Particle.timeToLive">
Time to live, number of seconds left of particles natural life
</member>
        <member name="F:Ogre.Particle.colour">
Current colour
</member>
        <member name="F:Ogre.Particle.direction">
Direction (and speed) 
</member>
        <member name="F:Ogre.Particle.position">
World position
</member>
        <member name="F:Ogre.Particle.rotation">
Current rotation value
</member>
        <member name="F:Ogre.Particle.mHeight">
Personal height if mOwnDimensions == true
</member>
        <member name="F:Ogre.Particle.mWidth">
Personal width if mOwnDimensions == true
</member>
        <member name="F:Ogre.Particle.mOwnDimensions">
Does this particle have it's own dimensions?
</member>
        <member name="T:Ogre.Particle.ParticleType">
Type of particle
</member>
        <member name="F:Ogre.Particle.mVisual">
Additional visual data you might want to associate with the Particle
</member>
        <member name="F:Ogre.Particle.mParentSystem">
Parent ParticleSystem
</member>
        <member name="T:Ogre.Particle">
Class representing a single particle instance. 
</member>
        <member name="T:Ogre.ParticleVisualData">
\addtogroup Core
	*  @{

\addtogroup Effects
	*  @{

Abstract class containing any additional data required to be associated
		with a particle to perform the required rendering. 
	@remarks
		Because you can specialise the way that particles are rendered by supplying
		custom ParticleSystemRenderer classes, you might well need some additional 
		data for your custom rendering routine which is not held on the default particle
		class. If that's the case, then you should define a subclass of this class, 
		and construct it when asked in your custom ParticleSystemRenderer class.

</member>
        <member name="M:Ogre.Billboard.getTexcoordRect">
getTexcoordRect() returns the previous value set by setTexcoordRect(). 
            @remarks
                This value is useful only when isUseTexcoordRect return true.

</member>
        <member name="M:Ogre.Billboard.setTexcoordRect(System.Single,System.Single,System.Single,System.Single)">
setTexcoordRect() sets the individual texture coordinate rect of this billboard
            will use when rendering. The parent billboard set may contain more than one, in
            which case a billboard can be textured with different pieces of a larger texture
            sheet very efficiently.

</member>
        <member name="M:Ogre.Billboard.setTexcoordRect(Ogre.TRect&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
setTexcoordRect() sets the individual texture coordinate rect of this billboard
            will use when rendering. The parent billboard set may contain more than one, in
            which case a billboard can be textured with different pieces of a larger texture
            sheet very efficiently.

</member>
        <member name="M:Ogre.Billboard.getTexcoordIndex">
getTexcoordIndex() returns the previous value set by setTexcoordIndex(). 
            The default value is 0, which is always a valid texture coordinate set.
            @remarks
                This value is useful only when isUseTexcoordRect return false.

</member>
        <member name="M:Ogre.Billboard.setTexcoordIndex(System.UInt16)">
setTexcoordIndex() sets which texture coordinate rect this billboard will use 
            when rendering. The parent billboard set may contain more than one, in which 
            case a billboard can be textured with different pieces of a larger texture 
            sheet very efficiently.
          @see
            BillboardSet::setTextureCoords()

</member>
        <member name="M:Ogre.Billboard.isUseTexcoordRect">
Returns true if this billboard use individual texture coordinate rect (i.e. if the 
            Billboard::setTexcoordRect method has been called for this instance), or returns
            false if use texture coordinates defined in the parent BillboardSet's texture
            coordinates array (i.e. if the Billboard::setTexcoordIndex method has been called
            for this instance).
            @see
                Billboard::setTexcoordIndex()
                Billboard::setTexcoordRect()

</member>
        <member name="M:Ogre.Billboard._notifyOwner(Ogre.BillboardSet*)">
Internal method for notifying the billboard of it's owner.

</member>
        <member name="M:Ogre.Billboard.getOwnHeight">
Retrieves the billboard's personal width, if hasOwnDimensions is true. 
</member>
        <member name="M:Ogre.Billboard.getOwnWidth">
Retrieves the billboard's personal width, if hasOwnDimensions is true. 
</member>
        <member name="M:Ogre.Billboard.hasOwnDimensions">
Returns true if this billboard deviates from the BillboardSet's default dimensions (i.e. if the
            Billboard::setDimensions method has been called for this instance).
            @see
                Billboard::setDimensions

</member>
        <member name="M:Ogre.Billboard.getColour">
Gets the colour of this billboard.

</member>
        <member name="M:Ogre.Billboard.setColour(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the colour of this billboard.
            @remarks
                Billboards can be tinted based on a base colour. This allows variations in colour irrespective of the
                base colour of the material allowing more varied billboards. The default colour is white.
                The tinting is effected using vertex colours.

</member>
        <member name="M:Ogre.Billboard.resetDimensions">
Resets this Billboard to use the parent BillboardSet's dimensions instead of it's own. 
</member>
        <member name="M:Ogre.Billboard.setDimensions(System.Single,System.Single)">
Sets the width and height for this billboard.
            @remarks
                Note that it is most efficient for every billboard in a BillboardSet to have the same dimensions. If you
                choose to alter the dimensions of an individual billboard the set will be less efficient. Do not call
                this method unless you really need to have different billboard dimensions within the same set. Otherwise
                just call the BillboardSet::setDefaultDimensions method instead.

</member>
        <member name="M:Ogre.Billboard.getPosition">
Get the position of the billboard.
            @remarks
                This position is relative to a point on the quad which is the billboard. Depending on the BillboardSet,
                this may be the center of the quad, the top-left etc. See BillboardSet::setBillboardOrigin for more info.

</member>
        <member name="M:Ogre.Billboard.setPosition(System.Single,System.Single,System.Single)">
Set the position of the billboard.
            @remarks
                This position is relative to a point on the quad which is the billboard. Depending on the BillboardSet,
                this may be the center of the quad, the top-left etc. See BillboardSet::setBillboardOrigin for more info.

</member>
        <member name="M:Ogre.Billboard.setPosition(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the position of the billboard.
            @remarks
                This position is relative to a point on the quad which is the billboard. Depending on the BillboardSet,
                this may be the center of the quad, the top-left etc. See BillboardSet::setBillboardOrigin for more info.

</member>
        <member name="M:Ogre.Billboard.setRotation(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the rotation of the billboard.
            @remarks
                This rotation is relative to the center of the billboard.

</member>
        <member name="M:Ogre.Billboard.getRotation">
Get the rotation of the billboard.
            @remarks
                This rotation is relative to the center of the billboard.

</member>
        <member name="M:Ogre.Billboard.#ctor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.BillboardSet*,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Normal constructor as called by BillboardSet.

</member>
        <member name="M:Ogre.Billboard.Dispose">
Default destructor.

</member>
        <member name="M:Ogre.Billboard.#ctor">
Default constructor.

</member>
        <member name="T:Ogre.Billboard">
\addtogroup Core
	*  @{

\addtogroup Effects
	*  @{

A billboard is a primitive which always faces the camera in every frame.
        @remarks
            Billboards can be used for special effects or some other trickery which requires the
            triangles to always facing the camera no matter where it is. Ogre groups billboards into
            sets for efficiency, so you should never create a billboard on it's own (it's ok to have a
            set of one if you need it).
        @par
            Billboards have their geometry generated every frame depending on where the camera is. It is most
            beneficial for all billboards in a set to be identically sized since Ogre can take advantage of this and
            save some calculations - useful when you have sets of hundreds of billboards as is possible with special
            effects. You can deviate from this if you wish (example: a smoke effect would probably have smoke puffs
            expanding as they rise, so each billboard will legitimately have it's own size) but be aware the extra
            overhead this brings and try to avoid it if you can.
        @par
            Billboards are just the mechanism for rendering a range of effects such as particles. It is other classes
            which use billboards to create their individual effects, so the methods here are quite generic.
        @see
            BillboardSet

</member>
        <member name="T:Ogre.EmitterCommands.CmdEmittedEmitter">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdName">
Command object for particle emitter  - see ParamCommand
</member>
        <member name="T:Ogre.EmitterCommands.CmdMaxRepeatDelay">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdMinRepeatDelay">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdRepeatDelay">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdMaxDuration">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdMinDuration">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdDuration">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdPosition">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdMaxTTL">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdMinTTL">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdTTL">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdMaxVelocity">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdMinVelocity">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdVelocity">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdEmissionRate">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdDirection">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdColourRangeEnd">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdColourRangeStart">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdColour">
Command object for particle emitter  - see ParamCommand 
</member>
        <member name="T:Ogre.EmitterCommands.CmdAngle">
Command object for ParticleEmitter  - see ParamCommand 
</member>
        <member name="M:Ogre.ParticleAffector.getType">
Returns the name of the type of affector. 
        @remarks
            This property is useful for determining the type of affector procedurally so another
            can be created.

</member>
        <member name="M:Ogre.ParticleAffector._affectParticles(Ogre.ParticleSystem*,System.Single)">
Method called to allow the affector to 'do it's stuff' on all active particles in the system.
        @remarks
            This is where the affector gets the chance to apply it's effects to the particles of a system.
            The affector is expected to apply it's effect to some or all of the particles in the system
            passed to it, depending on the affector's approach.
        @param
            pSystem Pointer to a ParticleSystem to affect.
        @param
            timeElapsed The number of seconds which have elapsed since the last call.

</member>
        <member name="M:Ogre.ParticleAffector._initParticle(Ogre.Particle*)">
Method called to allow the affector to initialize all newly created particles in the system.
        @remarks
            This is where the affector gets the chance to initialize it's effects to the particles of a system.
            The affector is expected to initialize some or all of the particles in the system
            passed to it, depending on the affector's approach.
        @param
            pParticle Pointer to a Particle to initialize.

</member>
        <member name="M:Ogre.ParticleAffector.Dispose">
Virtual destructor essential. 
</member>
        <member name="M:Ogre.ParticleAffector.addBaseParameters">
Internal method for setting up the basic parameter definitions for a subclass. 
        @remarks
            Because StringInterface holds a dictionary of parameters per class, subclasses need to
            call this to ask the base class to add it's parameters to their dictionary as well.
            Can't do this in the constructor because that runs in a non-virtual context.
        @par
            The subclass must have called it's own createParamDictionary before calling this method.

</member>
        <member name="F:Ogre.ParticleAffector.mType">
Name of the type of affector, MUST be initialised by subclasses
</member>
        <member name="T:Ogre.ParticleAffector">
\addtogroup Core
	*  @{

\addtogroup Effects
	*  @{

Abstract class defining the interface to be implemented by particle affectors.
    @remarks
        Particle affectors modify particles in a particle system over their lifetime. They can be
        grouped into types, e.g. 'vector force' affectors, 'fader' affectors etc; each type will 
        modify particles in a different way, using different parameters.
    @par
        Because there are so many types of affectors you could use, OGRE chooses not to dictate
        the available types. It comes with some in-built, but allows plugins or applications to extend the affector types available.
        This is done by subclassing ParticleAffector to have the appropriate emission behaviour you want,
        and also creating a subclass of ParticleAffectorFactory which is responsible for creating instances 
        of your new affector type. You register this factory with the ParticleSystemManager using
        addAffectorFactory, and from then on affectors of this type can be created either from code or through
        text particle scripts by naming the type.
    @par
        This same approach is used for ParticleEmitters (which are the source of particles in a system).
        This means that OGRE is particularly flexible when it comes to creating particle system effects,
        with literally infinite combinations of affector and affector types, and parameters within those
        types.

</member>
        <member name="M:Ogre.OverlayManager.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.OverlayManager.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.OverlayManager.getTemplateIterator">
Returns an iterator over all templates in this manager.
</member>
        <member name="M:Ogre.OverlayManager.cloneOverlayElementFromTemplate(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@remarks
Creates a new OverlayElement object from the specified template name.  The new
object's name, and all of it's children, will be instanceName/orignalName.

</member>
        <member name="M:Ogre.OverlayManager.getOverlayElementFactoryMap">
Get const access to the list of registered OverlayElement factories. 
</member>
        <member name="M:Ogre.OverlayManager.addOverlayElementFactory(Ogre.OverlayElementFactory*)">
Registers a new OverlayElementFactory with this manager.
		@remarks
		Should be used by plugins or other apps wishing to provide
		a new OverlayElement subclass.

</member>
        <member name="M:Ogre.OverlayManager.destroyAllOverlayElements(System.Boolean)">
Destroys all the OverlayElement  created so far.
		@remarks
		Best to leave this to the engine to call internally, there
		should rarely be a need to call it yourself.

</member>
        <member name="M:Ogre.OverlayManager.destroyOverlayElement(Ogre.OverlayElement*,System.Boolean)">
Destroys a OverlayElement. 
		@remarks
		Make sure you're not still using this in an Overlay. If in
		doubt, let OGRE destroy elements on shutdown.

</member>
        <member name="M:Ogre.OverlayManager.destroyOverlayElement(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Destroys a OverlayElement. 
		@remarks
		Make sure you're not still using this in an Overlay. If in
		doubt, let OGRE destroy elements on shutdown.

</member>
        <member name="M:Ogre.OverlayManager.hasOverlayElement(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Tests if an element exists. 
</member>
        <member name="M:Ogre.OverlayManager.getOverlayElement(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Gets a reference to an existing element. 
</member>
        <member name="M:Ogre.OverlayManager.createOverlayElement(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Creates a new OverlayElement of the type requested.
		@remarks
		The type of element to create is passed in as a string because this
		allows plugins to register new types of component.
		@param typeName The type of element to create.
		@param instanceName The name to give the new instance.

</member>
        <member name="M:Ogre.OverlayManager.getViewportOrientationMode">
Gets the orientation mode of the destination viewport. 
</member>
        <member name="M:Ogre.OverlayManager.getViewportWidth">
Gets the width of the destination viewport in pixels. 
</member>
        <member name="M:Ogre.OverlayManager.getViewportHeight">
Gets the height of the destination viewport in pixels. 
</member>
        <member name="M:Ogre.OverlayManager.hasViewportChanged">
Method for determining if the viewport has changed dimensions. 
        @remarks This is used by pixel-based OverlayElements to work out if they need to
            recalculate their sizes.

</member>
        <member name="M:Ogre.OverlayManager._queueOverlaysForRendering(Ogre.Camera*,Ogre.RenderQueue*,Ogre.Viewport*)">
Internal method for queueing the visible overlays for rendering. 
</member>
        <member name="M:Ogre.OverlayManager.destroyAll">
Destroys all existing overlays 
</member>
        <member name="M:Ogre.OverlayManager.destroy(Ogre.Overlay*)">
Destroys an existing overlay 
</member>
        <member name="M:Ogre.OverlayManager.destroy(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroys an existing overlay by name 
</member>
        <member name="M:Ogre.OverlayManager.getByName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieve an Overlay by name 
        @returns A pointer to the Overlay, or 0 if not found

</member>
        <member name="M:Ogre.OverlayManager.create(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a new Overlay. 
</member>
        <member name="M:Ogre.OverlayManager.getLoadingOrder">
@copydoc ScriptLoader::getLoadingOrder
</member>
        <member name="M:Ogre.OverlayManager.parseScript(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc ScriptLoader::parseScript
</member>
        <member name="M:Ogre.OverlayManager.getScriptPatterns">
@copydoc ScriptLoader::getScriptPatterns
</member>
        <member name="T:Ogre.OverlayManager">
\addtogroup Core
	*  @{

\addtogroup Overlays
	*  @{

Manages Overlay objects, parsing them from .overlay files and
        storing a lookup library of them. Alo manages the creation of 
		OverlayContainers and OverlayElements, used for non-interactive 2D 
		elements such as HUDs.

</member>
        <member name="M:Ogre.OverlayContainer.findElementAt(System.Single,System.Single)">
This returns a OverlayElement at position x,y. 
</member>
        <member name="M:Ogre.OverlayContainer.setChildrenProcessEvents(System.Boolean)">
Should this container pass events to their children 
</member>
        <member name="M:Ogre.OverlayContainer.isChildrenProcessEvents">
Should this container pass events to their children 
</member>
        <member name="M:Ogre.OverlayContainer.isContainer">
Overridden from OverlayElement. 
</member>
        <member name="M:Ogre.OverlayContainer._updateRenderQueue(Ogre.RenderQueue*)">
Overridden from OverlayElement. 
</member>
        <member name="M:Ogre.OverlayContainer._notifyParent(Ogre.OverlayContainer*,Ogre.Overlay*)">
Overridden from OverlayElement. 
</member>
        <member name="M:Ogre.OverlayContainer._notifyWorldTransforms(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Overridden from OverlayElement. 
</member>
        <member name="M:Ogre.OverlayContainer._notifyViewport">
Overridden from OverlayElement. 
</member>
        <member name="M:Ogre.OverlayContainer._notifyZOrder(System.UInt16)">
Overridden from OverlayElement. 
</member>
        <member name="M:Ogre.OverlayContainer._update">
Overridden from OverlayElement. 
</member>
        <member name="M:Ogre.OverlayContainer._positionsOutOfDate">
Tell the object and its children to recalculate 
</member>
        <member name="M:Ogre.OverlayContainer.getChildContainerIterator">
Gets an iterator for just the container children of this object.
        @remarks
            Good for cascading updates without having to use RTTI

</member>
        <member name="M:Ogre.OverlayContainer.getChildIterator">
Gets an object for iterating over all the children of this object. 
</member>
        <member name="M:Ogre.OverlayContainer.initialise">
@copydoc OverlayElement::initialise 
</member>
        <member name="M:Ogre.OverlayContainer.getChild(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the named child of this container. 
</member>
        <member name="M:Ogre.OverlayContainer.removeChild(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Removes a named element from this container. 
</member>
        <member name="M:Ogre.OverlayContainer.addChildImpl(Ogre.OverlayContainer*)">
Add a nested container to this container. 
</member>
        <member name="M:Ogre.OverlayContainer.addChildImpl(Ogre.OverlayElement*)">
Adds another OverlayElement to this container. 
</member>
        <member name="M:Ogre.OverlayContainer.addChild(Ogre.OverlayElement*)">
Adds another OverlayElement to this container. 
</member>
        <member name="M:Ogre.OverlayContainer.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor: do not call direct, use OverlayManager::createOverlayElement
</member>
        <member name="T:Ogre.OverlayContainer">
\addtogroup Core
	*  @{

\addtogroup Overlays
	*  @{

A 2D element which contains other OverlayElement instances.
    @remarks
        This is a specialisation of OverlayElement for 2D elements that contain other
        elements. These are also the smallest elements that can be attached directly
        to an Overlay.
    @remarks
        OverlayContainers should be managed using OverlayManager. This class is responsible for
        instantiating / deleting elements, and also for accepting new types of element
        from plugins etc.

</member>
        <member name="M:Ogre.OverlayElement.getLights">
@copydoc Renderable::getLights 
</member>
        <member name="M:Ogre.OverlayElement.getSquaredViewDepth(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Overridden from Renderable 
</member>
        <member name="M:Ogre.OverlayElement.getZOrder">
Returns the zOrder of the element

</member>
        <member name="M:Ogre.OverlayElement.getParent">
Returns the parent container.

</member>
        <member name="M:Ogre.OverlayElement.isContainer">
returns false as this class is not a container type 

</member>
        <member name="M:Ogre.OverlayElement.findElementAt(System.Single,System.Single)">
Returns true if xy is within the constraints of the component 
</member>
        <member name="M:Ogre.OverlayElement.contains(System.Single,System.Single)">
Returns true if xy is within the constraints of the component 
</member>
        <member name="M:Ogre.OverlayElement.getVerticalAlignment">
Gets the vertical alignment for this element. 
</member>
        <member name="M:Ogre.OverlayElement.setVerticalAlignment(Ogre.GuiVerticalAlignment)">
Sets the vertical origin for this element. 
        @remarks
        By default, the vertical origin for a OverlayElement is the top edge of the parent container
        (or the screen if this is a root element). You can alter this by calling this method, which is
        especially useful when you want to use pixel-based metrics (see setMetricsMode) since in this
        mode you can't use relative positioning.
        @par
        For example, if you were using GMM_PIXELS metrics mode, and you wanted to place a 30x30 pixel
        crosshair in the center of the screen, you would use GHA_CENTER with a 'top' property of -15.
        @par
        Note that neither GVA_CENTER or GVA_BOTTOM alter the position of the element based
        on it's height, you have to alter the 'top' to a negative number to do that; all this
        does is establish the origin. This is because this way you can align multiple things
        in the center and bottom with different 'top' offsets for maximum flexibility.

</member>
        <member name="M:Ogre.OverlayElement.getHorizontalAlignment">
Gets the horizontal alignment for this element. 
</member>
        <member name="M:Ogre.OverlayElement.setHorizontalAlignment(Ogre.GuiHorizontalAlignment)">
Sets the horizontal origin for this element.
        @remarks
        By default, the horizontal origin for a OverlayElement is the left edge of the parent container
        (or the screen if this is a root element). You can alter this by calling this method, which is
        especially useful when you want to use pixel-based metrics (see setMetricsMode) since in this
        mode you can't use relative positioning.
        @par
        For example, if you were using GMM_PIXELS metrics mode, and you wanted to place a 30x30 pixel
        crosshair in the center of the screen, you would use GHA_CENTER with a 'left' property of -15.
        @par
        Note that neither GHA_CENTER or GHA_RIGHT alter the position of the element based
        on it's width, you have to alter the 'left' to a negative number to do that; all this
        does is establish the origin. This is because this way you can align multiple things
        in the center and right with different 'left' offsets for maximum flexibility.

</member>
        <member name="M:Ogre.OverlayElement.getMetricsMode">
Retrieves the current settings of how the element metrics are interpreted. 
</member>
        <member name="M:Ogre.OverlayElement.setMetricsMode(Ogre.GuiMetricsMode)">
Tells this element how to interpret the position and dimension values it is given.
        @remarks
        By default, OverlayElements are positioned and sized according to relative dimensions
        of the screen. This is to ensure portability between different resolutions when you
        want things to be positioned and sized the same way across all resolutions. However, 
        sometimes you want things to be sized according to fixed pixels. In order to do this,
        you can call this method with the parameter GMM_PIXELS. Note that if you then want
        to place your element relative to the center, right or bottom of it's parent, you will
        need to use the setHorizontalAlignment and setVerticalAlignment methods.

</member>
        <member name="M:Ogre.OverlayElement.getColour">
Gets the colour for this element. 
</member>
        <member name="M:Ogre.OverlayElement.setColour(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the colour on elements that support it. 
        @remarks
        This property doesn't do something on all elements, just those that support it.
        However, being a common requirement it is in the top-level interface to avoid
        having to set it via the StringInterface all the time.

</member>
        <member name="M:Ogre.OverlayElement.getCaption">
Gets the caption for this element. 
</member>
        <member name="M:Ogre.OverlayElement.setCaption(Ogre.UTFString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the caption on elements that support it. 
        @remarks
        This property doesn't do something on all elements, just those that support it.
        However, being a common requirement it is in the top-level interface to avoid
        having to set it via the StringInterface all the time.

</member>
        <member name="M:Ogre.OverlayElement.getTypeName">
Gets the type name of the element. All concrete subclasses must implement this. 
</member>
        <member name="M:Ogre.OverlayElement.visitRenderables(Ogre.Renderable.Visitor*,System.Boolean)">
@copydoc MovableObject::visitRenderables
</member>
        <member name="M:Ogre.OverlayElement._updateRenderQueue(Ogre.RenderQueue*)">
Internal method to put the contents onto the render queue. 
</member>
        <member name="M:Ogre.OverlayElement._notifyViewport">
Internal method to notify the element when the viewport
         of parent overlay has changed.

</member>
        <member name="M:Ogre.OverlayElement._notifyWorldTransforms(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method to notify the element when it's world transform
         of parent overlay has changed.

</member>
        <member name="M:Ogre.OverlayElement._notifyZOrder(System.UInt16)">
Internal method to notify the element when Zorder of parent overlay
        has changed.
        @remarks
        Overlays have explicit Z orders. OverlayElements do not, they inherit the 
        ZOrder of the overlay, and the Zorder is incremented for every container
        nested within this to ensure that containers are displayed behind contained
        items. This method is used internally to notify the element of a change in
        final zorder which is used to render the element.
		@return Return the next zordering number available. For single elements, this
		is simply newZOrder + 1, but for containers, they increment it once for each
		child (more if those children are also containers).

</member>
        <member name="M:Ogre.OverlayElement._getClippingRegion(Ogre.Rectangle*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the clipping region of the element 
</member>
        <member name="M:Ogre.OverlayElement._getRelativeHeight">
Gets the 'height' as derived from own height and metrics mode. 
</member>
        <member name="M:Ogre.OverlayElement._getRelativeWidth">
Gets the 'width' as derived from own width and metrics mode. 
</member>
        <member name="M:Ogre.OverlayElement._getDerivedTop">
Gets the 'top' position as derived from own left and that of parents. 
</member>
        <member name="M:Ogre.OverlayElement._getDerivedLeft">
Gets the 'left' position as derived from own left and that of parents. 
</member>
        <member name="M:Ogre.OverlayElement._notifyParent(Ogre.OverlayContainer*,Ogre.Overlay*)">
Internal method for notifying the GUI element of it's parent and ultimate overlay. 
</member>
        <member name="M:Ogre.OverlayElement._updateFromParent">
Updates this elements transform based on it's parent. 
</member>
        <member name="M:Ogre.OverlayElement._update">
Internal method to update the element based on transforms applied. 
</member>
        <member name="M:Ogre.OverlayElement._positionsOutOfDate">
Tell the object to recalculate 
</member>
        <member name="M:Ogre.OverlayElement.getWorldTransforms(Ogre.Matrix4*)">
See Renderable 
</member>
        <member name="M:Ogre.OverlayElement.getMaterial">
See Renderable 
</member>
        <member name="M:Ogre.OverlayElement.setMaterialName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the name of the material this element will use. 
        @remarks
        Different elements will use different materials. One constant about them
        all though is that a Material used for a OverlayElement must have it's depth
        checking set to 'off', which means it always gets rendered on top. OGRE
        will set this flag for you if necessary. What it does mean though is that 
        you should not use the same Material for rendering OverlayElements as standard 
        scene objects. It's fine to use the same textures, just not the same
        Material.

</member>
        <member name="M:Ogre.OverlayElement.getMaterialName">
Gets the name of the material this element uses. 
</member>
        <member name="M:Ogre.OverlayElement._setDimensions(System.Single,System.Single)">
Sets the width and height of this element in relation to the screen (where 1.0 = screen width) 
</member>
        <member name="M:Ogre.OverlayElement._setPosition(System.Single,System.Single)">
Sets the left and top of this element in relation to the screen (where 1.0 = screen width) 
</member>
        <member name="M:Ogre.OverlayElement._setHeight(System.Single)">
Sets the height of this element in relation to the screen (where 1.0 = screen width) 
</member>
        <member name="M:Ogre.OverlayElement._setWidth(System.Single)">
Sets the width of this element in relation to the screen (where 1.0 = screen width) 
</member>
        <member name="M:Ogre.OverlayElement._setTop(System.Single)">
Sets the top of this element in relation to the screen (where 1.0 = screen width) 
</member>
        <member name="M:Ogre.OverlayElement._setLeft(System.Single)">
Sets the left of this element in relation to the screen (where 1.0 = screen width) 
</member>
        <member name="M:Ogre.OverlayElement._getHeight">
Gets the height of this element in relation to the screen (where 1.0 = screen height)  
</member>
        <member name="M:Ogre.OverlayElement._getWidth">
Gets the width of this element in relation to the screen (where 1.0 = screen width)  
</member>
        <member name="M:Ogre.OverlayElement._getTop">
Gets the top of this element in relation to the screen (where 0 = far left, 1.0 = far right)  
</member>
        <member name="M:Ogre.OverlayElement._getLeft">
Gets the left of this element in relation to the screen (where 0 = far left, 1.0 = far right)  
</member>
        <member name="M:Ogre.OverlayElement.getTop">
Gets the top of this element in relation to the screen (where 0 = top, 1.0 = bottom)  
</member>
        <member name="M:Ogre.OverlayElement.setTop(System.Single)">
Sets the top of this element in relation to the screen (where 0 = top, 1.0 = bottom) 
</member>
        <member name="M:Ogre.OverlayElement.getLeft">
Gets the left of this element in relation to the screen (where 0 = far left, 1.0 = far right)  
</member>
        <member name="M:Ogre.OverlayElement.setLeft(System.Single)">
Sets the left of this element in relation to the screen (where 0 = far left, 1.0 = far right) 
</member>
        <member name="M:Ogre.OverlayElement.getHeight">
Gets the height of this element in relation to the screen (where 1.0 = screen height) 
</member>
        <member name="M:Ogre.OverlayElement.setHeight(System.Single)">
Sets the height of this element in relation to the screen (where 1.0 = screen height) 
</member>
        <member name="M:Ogre.OverlayElement.getWidth">
Gets the width of this element in relation to the screen (where 1.0 = screen width) 
</member>
        <member name="M:Ogre.OverlayElement.setWidth(System.Single)">
Sets the width of this element in relation to the screen (where 1.0 = screen width) 
</member>
        <member name="M:Ogre.OverlayElement.setPosition(System.Single,System.Single)">
Sets the position of the top-left corner of the element, relative to the screen size
        (1.0 = screen width / height) 
</member>
        <member name="M:Ogre.OverlayElement.setDimensions(System.Single,System.Single)">
Sets the dimensions of this element in relation to the screen (1.0 = screen width/height). 
</member>
        <member name="M:Ogre.OverlayElement.isVisible">
Returns whether or not the element is visible. 
</member>
        <member name="M:Ogre.OverlayElement.hide">
Hides this element if it was visible. 
</member>
        <member name="M:Ogre.OverlayElement.show">
Shows this element if it was hidden. 
</member>
        <member name="M:Ogre.OverlayElement.getName">
Gets the name of this overlay. 
</member>
        <member name="M:Ogre.OverlayElement.initialise">
Initialise gui element 
</member>
        <member name="M:Ogre.OverlayElement.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor: do not call direct, use OverlayManager::createElement
</member>
        <member name="M:Ogre.OverlayElement.addBaseParameters">
Internal method for setting up the basic parameter definitions for a subclass. 
        @remarks
        Because StringInterface holds a dictionary of parameters per class, subclasses need to
        call this to ask the base class to add it's parameters to their dictionary as well.
        Can't do this in the constructor because that runs in a non-virtual context.
        @par
        The subclass must have called it's own createParamDictionary before calling this method.

</member>
        <member name="M:Ogre.OverlayElement.updateTextureGeometry">
Internal method which is triggered when the UVs of the element get updated,
		meaning the element should be rebuilding it's mesh UVs. Abstract since
		subclasses must implement this.

</member>
        <member name="M:Ogre.OverlayElement.updatePositionGeometry">
Internal method which is triggered when the positions of the element get updated,
        meaning the element should be rebuilding it's mesh positions. Abstract since
        subclasses must implement this.

</member>
        <member name="F:Ogre.OverlayElement.mGeomUVsOutOfDate">
Flag indicating if the vertex uvs need recalculating
</member>
        <member name="F:Ogre.OverlayElement.mGeomPositionsOutOfDate">
Flag indicating if the vertex positions need recalculating
</member>
        <member name="T:Ogre.OverlayElement">
Abstract definition of a 2D element to be displayed in an Overlay.
    @remarks
    This class abstracts all the details of a 2D element which will appear in
    an overlay. In fact, not all OverlayElement instances can be directly added to an
    Overlay, only those which are OverlayContainer instances (a subclass of this class).
    OverlayContainer objects can contain any OverlayElement however. This is just to 
    enforce some level of grouping on widgets.
    @par
    OverlayElements should be managed using OverlayManager. This class is responsible for
    instantiating / deleting elements, and also for accepting new types of element
    from plugins etc.
    @par
    Note that positions / dimensions of 2D screen elements are expressed as parametric
    values (0.0 - 1.0) because this makes them resolution-independent. However, most
    screen resolutions have an aspect ratio of 1.3333:1 (width : height) so note that
    in physical pixels 0.5 is wider than it is tall, so a 0.5x0.5 panel will not be
    square on the screen (but it will take up exactly half the screen in both dimensions).
    @par
    Because this class is designed to be extensible, it subclasses from StringInterface
    so its parameters can be set in a generic way.

</member>
        <member name="T:Ogre.GuiVerticalAlignment">
Enum describing where '0' is in relation to the parent in the vertical dimension.
    @remarks Affects how 'top' is interpreted.

</member>
        <member name="T:Ogre.GuiHorizontalAlignment">
Enum describing where '0' is in relation to the parent in the horizontal dimension.
    @remarks Affects how 'left' is interpreted.

</member>
        <member name="T:Ogre.GuiMetricsMode">
Enum describing how the position / size of an element is to be recorded. 

</member>
        <member name="F:GMM_RELATIVE">
'left', 'top', 'height' and 'width' are parametrics from 0.0 to 1.0
</member>
        <member name="D:Ogre.DisplayString">
\addtogroup Core
	*  @{

\addtogroup Overlays
	*  @{

</member>
        <member name="M:Ogre.intersect(Ogre.Rectangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Rectangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Geometric intersection of two rectanglar regions.
     *
     * @remarks Calculates the geometric intersection of two rectangular
     * regions.  Rectangle coordinates must be ([0-N], [0-N]), such that
     * (0,0) is in the upper left hand corner.
     *
     * If the two input rectangles do not intersect, then the result will be
     * a degenerate rectangle, i.e. left &gt;= right or top &gt;= bottom, or both.

</member>
        <member name="T:Ogre.Rectangle">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

</member>
        <member name="T:Ogre.OverlayElementCommands.CmdVisible">
Command object for OverlayElement  - see ParamCommand 
</member>
        <member name="T:Ogre.OverlayElementCommands.CmdVerticalAlign">
Command object for OverlayElement  - see ParamCommand 
</member>
        <member name="T:Ogre.OverlayElementCommands.CmdHorizontalAlign">
Command object for OverlayElement  - see ParamCommand 
</member>
        <member name="T:Ogre.OverlayElementCommands.CmdMetricsMode">
Command object for OverlayElement  - see ParamCommand 
</member>
        <member name="T:Ogre.OverlayElementCommands.CmdCaption">
Command object for OverlayElement  - see ParamCommand 
</member>
        <member name="T:Ogre.OverlayElementCommands.CmdMaterial">
Command object for OverlayElement  - see ParamCommand 
</member>
        <member name="T:Ogre.OverlayElementCommands.CmdHeight">
Command object for OverlayElement  - see ParamCommand 
</member>
        <member name="T:Ogre.OverlayElementCommands.CmdWidth">
Command object for OverlayElement  - see ParamCommand 
</member>
        <member name="T:Ogre.OverlayElementCommands.CmdTop">
Command object for OverlayElement  - see ParamCommand 
</member>
        <member name="T:Ogre.OverlayElementCommands.CmdLeft">
Command object for OverlayElement  - see ParamCommand 
</member>
        <member name="M:Ogre.Overlay._notifyOrigin(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Notify this overlay of it's origin
</member>
        <member name="M:Ogre.Overlay.getOrigin">
Get the origin of this overlay, e.g. a script file name.
		@remarks
			This property will only contain something if the creator of
			this overlay chose to populate it. Script loaders are advised
			to populate it.

</member>
        <member name="D:Ogre.Overlay.Overlay2DElementsIterator">
Returns an iterator over all 2D elements in this manager.
        @remarks
            VectorIterator is actually a too generic name, since it also works for lists.

</member>
        <member name="M:Ogre.Overlay.findElementAt(System.Single,System.Single)">
This returns a OverlayElement at position x,y. 
</member>
        <member name="M:Ogre.Overlay._findVisibleObjects(Ogre.Camera*,Ogre.RenderQueue*)">
Internal method to put the overlay contents onto the render queue. 
</member>
        <member name="M:Ogre.Overlay._getWorldTransforms(Ogre.Matrix4*)">
Used to transform the overlay when scrolling, scaling etc. 
</member>
        <member name="M:Ogre.Overlay.getScaleY">
Gets the current Y scale value 
</member>
        <member name="M:Ogre.Overlay.getScaleX">
Gets the current X scale value 
</member>
        <member name="M:Ogre.Overlay.setScale(System.Single,System.Single)">
Sets the scaling factor of this overlay.
        @remarks
            You can use this to set an scale factor to be used to zoom an 
            overlay.
        @param x Horizontal scale value, where 1.0 = normal, 0.5 = half size etc
        @param y Vertical scale value, where 1.0 = normal, 0.5 = half size etc

</member>
        <member name="M:Ogre.Overlay.rotate(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds the passed in angle to the rotation applied to this overlay. 
</member>
        <member name="M:Ogre.Overlay.getRotate">
Gets the rotation applied to this overlay, in degrees.
</member>
        <member name="M:Ogre.Overlay.setRotate(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the rotation applied to this overlay.
</member>
        <member name="M:Ogre.Overlay.scroll(System.Single,System.Single)">
Scrolls the overlay by the offsets provided.
        @remarks
            This method moves the overlay by the amounts provided. As with
            other methods on this object, a full screen width / height is represented
            by the value 1.0.

</member>
        <member name="M:Ogre.Overlay.getScrollY">
Gets the current Y scroll value 
</member>
        <member name="M:Ogre.Overlay.getScrollX">
Gets the current X scroll value 
</member>
        <member name="M:Ogre.Overlay.setScroll(System.Single,System.Single)">
Sets the scrolling factor of this overlay.
        @remarks
            You can use this to set an offset to be used to scroll an 
            overlay around the screen.
        @param x Horizontal scroll value, where 0 = normal, -0.5 = scroll so that only
            the right half the screen is visible etc
        @param y Vertical scroll value, where 0 = normal, 0.5 = scroll down by half 
            a screen etc.

</member>
        <member name="M:Ogre.Overlay.clear">
Clears the overlay of all attached items. 
</member>
        <member name="M:Ogre.Overlay.remove3D(Ogre.SceneNode*)">
Removes a 3D element from the overlay. 
</member>
        <member name="M:Ogre.Overlay.add3D(Ogre.SceneNode*)">
Adds a node capable of holding 3D objects to the overlay.
        @remarks    
            Although overlays are traditionally associated with 2D elements, there 
            are reasons why you might want to attach 3D elements to the overlay too.
            For example, if you wanted to have a 3D cockpit, which was overlaid with a
            HUD, then you would create 2 overlays, one with a 3D object attached for the
            cockpit, and one with the HUD elements attached (the zorder of the HUD 
            overlay would be higher than the cockpit to ensure it was always on top).
        @par    
            A SceneNode can have any number of 3D objects attached to it. SceneNodes
            are usually created using SceneManager::createSceneNode, but in this case
			you should create a standard SceneNode instance <b>manually</b>; this is
			because these scene nodes are not managed by the SceneManager and some custom
			SceneManager plugins will rely on specialist behaviour the overlay does not
			support. By attaching a SceneNode to an overlay, you indicate that:<OL><LI>You want the contents of this node to only appear when the overlay is active</LI><LI>You want the node to inherit a coordinate space relative to the camera,
                rather than relative to the root scene node</LI><LI>You want these objects to be rendered after the contents of the main scene
                to ensure they are rendered on top</LI></OL>
            One major consideration when using 3D objects in overlays is the behaviour of 
            the depth buffer. Overlays should use materials with depth checking off, to ensure
            that their contents are always displayed on top of the main scene (to do 
            otherwise would result in objects 'poking through' the overlay). The problem
            with using 3D objects is that if they are concave, or self-overlap, then you
            can get artefacts because of the lack of depth buffer checking. So you should 
            ensure that any 3D objects you us in the overlay are convex, and don't overlap
            each other. If they must overlap, split them up and put them in 2 overlays.
			Alternatively, use a 2D element underneath them which will clear the depth buffer
			values underneath ready for the 3D element to be rendered correctly.

</member>
        <member name="M:Ogre.Overlay.remove2D(Ogre.OverlayContainer*)">
Removes a 2D container from the overlay. 
        @remarks
            NOT FAST. Consider OverlayElement::hide.

</member>
        <member name="M:Ogre.Overlay.add2D(Ogre.OverlayContainer*)">
Adds a 2D 'container' to the overlay.
        @remarks
            Containers are created and managed using the OverlayManager. A container
            could be as simple as a square panel, or something more complex like
            a grid or tree view. Containers group collections of other elements,
            giving them a relative coordinate space and a common z-order.
            If you want to attach a GUI widget to an overlay, you have to do it via
            a container.
        @param cont Pointer to a container to add, created using OverlayManager.

</member>
        <member name="M:Ogre.Overlay.hide">
Hides the overlay if it was visible. 
</member>
        <member name="M:Ogre.Overlay.show">
Shows the overlay if it was hidden. 
</member>
        <member name="M:Ogre.Overlay.isInitialised">
Gets whether the overlay is initialised or not. 
</member>
        <member name="M:Ogre.Overlay.isVisible">
Gets whether the overlay is displayed or not. 
</member>
        <member name="M:Ogre.Overlay.getZOrder">
Gets the ZOrder of this overlay. 
</member>
        <member name="M:Ogre.Overlay.setZOrder(System.UInt16)">
Alters the ZOrder of this overlay. 
        @remarks
            Values between 0 and 650 are valid here.

</member>
        <member name="M:Ogre.Overlay.getName">
Gets the name of this overlay. 
</member>
        <member name="M:Ogre.Overlay.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor: do not call direct, use OverlayManager::create
</member>
        <member name="M:Ogre.Overlay.assignZOrders">
Internal method for updating container elements' Z-ordering 
</member>
        <member name="M:Ogre.Overlay.initialise">
Internal method for initialising an overlay 
</member>
        <member name="M:Ogre.Overlay.updateTransform">
Internal lazy update method. 
</member>
        <member name="F:Ogre.Overlay.mRootNode">
Internal root node, used as parent for 3D objects
</member>
        <member name="T:Ogre.Overlay">
\addtogroup Core
	*  @{

\addtogroup Overlays
	*  @{

Represents a layer which is rendered on top of the 'normal' scene contents.
    @remarks
        An overlay is a container for visual components (2D and 3D) which will be 
        rendered after the main scene in order to composite heads-up-displays, menus
        or other layers on top of the contents of the scene.
    @par
        An overlay always takes up the entire size of the viewport, although the 
        components attached to it do not have to. An overlay has no visual element
        in itself, it it merely a container for visual elements.
    @par
        Overlays are created by calling OverlayManager::create, or by defining them
        in special text scripts (.overlay files). As many overlays
        as you like can be defined; after creation an overlay is hidden i.e. not
        visible until you specifically enable it by calling 'show'. This allows you to have multiple
        overlays predefined (menus etc) which you make visible only when you want.
        It is possible to have multiple overlays enabled at once; in this case the
        relative 'zorder' parameter of the overlays determine which one is displayed
        on top.
    @par
        By default overlays are rendered into all viewports. This is fine when you only
        have fullscreen viewports, but if you have picture-in-picture views, you probably
        don't want the overlay displayed in the smaller viewports. You turn this off for 
        a specific viewport by calling the Viewport::setDisplayOverlays method.

</member>
        <member name="M:Ogre.SceneNode.getDebugRenderable">
As Node::getDebugRenderable, except scaling is automatically determined
</member>
        <member name="M:Ogre.SceneNode.setDebugDisplayEnabled(System.Boolean,System.Boolean)">
Tells all objects attached to this node whether to display their
			debug information or not.
        @remarks    
            This is a shortcut to calling setDebugDisplayEnabled() on the objects attached
            to this node, and optionally to all objects attached to child
            nodes. 
        @param enabled Whether the objects are to display debug info or not
        @param cascade If true, this setting cascades into child nodes too.

</member>
        <member name="M:Ogre.SceneNode.flipVisibility(System.Boolean)">
Inverts the visibility of all objects attached to this node.
        @remarks    
        This is a shortcut to calling setVisible(!isVisible()) on the objects attached
        to this node, and optionally to all objects attached to child
        nodes. 
        @param cascade If true, this setting cascades into child nodes too.

</member>
        <member name="M:Ogre.SceneNode.setVisible(System.Boolean,System.Boolean)">
Makes all objects attached to this node become visible / invisible.
        @remarks    
            This is a shortcut to calling setVisible() on the objects attached
            to this node, and optionally to all objects attached to child
            nodes. 
        @param visible Whether the objects are to be made visible or invisible
        @param cascade If true, this setting cascades into child nodes too.

</member>
        <member name="M:Ogre.SceneNode.getParentSceneNode">
Gets the parent of this SceneNode. 
</member>
        <member name="M:Ogre.SceneNode._autoTrack">
Internal method used by OGRE to update auto-tracking cameras. 
</member>
        <member name="M:Ogre.SceneNode.getAutoTrackLocalDirection">
Get the auto tracking local direction for this node, if it is auto tracking. 
</member>
        <member name="M:Ogre.SceneNode.getAutoTrackOffset">
Get the auto tracking offset for this node, if the node is auto tracking. 
</member>
        <member name="M:Ogre.SceneNode.getAutoTrackTarget">
Get the auto tracking target for this node, if any. 
</member>
        <member name="M:Ogre.SceneNode.setAutoTracking(System.Boolean,Ogre.SceneNode*,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Enables / disables automatic tracking of another SceneNode.
        @remarks
        If you enable auto-tracking, this SceneNode will automatically rotate to
        point it's -Z at the target SceneNode every frame, no matter how 
        it or the other SceneNode move. Note that by default the -Z points at the 
        origin of the target SceneNode, if you want to tweak this, provide a 
        vector in the 'offset' parameter and the target point will be adjusted.
        @param enabled If true, tracking will be enabled and the next 
        parameter cannot be null. If false tracking will be disabled and the 
        current orientation will be maintained.
        @param target Pointer to the SceneNode to track. Make sure you don't
        delete this SceneNode before turning off tracking (e.g. SceneManager::clearScene will
        delete it so be careful of this). Can be null if and only if the enabled param is false.
        @param localDirectionVector The local vector considered to be the usual 'direction'
        of the node; normally the local -Z but can be another direction.
        @param offset If supplied, this is the target point in local space of the target node
        instead of the origin of the target node. Good for fine tuning the look at point.

</member>
        <member name="M:Ogre.SceneNode.lookAt(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Node.TransformSpace,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Points the local -Z direction of this node at a point in space.
        @param targetPoint A vector specifying the look at point.
        @param relativeTo The space in which the point resides
        @param localDirectionVector The vector which normally describes the natural
        direction of the node, usually -Z

</member>
        <member name="M:Ogre.SceneNode.setDirection(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Node.TransformSpace,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the node's direction vector ie it's local -z.
        @remarks
        Note that the 'up' vector for the orientation will automatically be 
        recalculated based on the current 'up' vector (i.e. the roll will 
        remain the same). If you need more control, use setOrientation.
        @param vec The direction vector
        @param relativeTo The space in which this direction vector is expressed
        @param localDirectionVector The vector which normally describes the natural
        direction of the node, usually -Z

</member>
        <member name="M:Ogre.SceneNode.setDirection(System.Single,System.Single,System.Single,Ogre.Node.TransformSpace,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the node's direction vector ie it's local -z.
        @remarks
        Note that the 'up' vector for the orientation will automatically be 
        recalculated based on the current 'up' vector (i.e. the roll will 
        remain the same). If you need more control, use setOrientation.
        @param x,y,z The components of the direction vector
        @param relativeTo The space in which this direction vector is expressed
        @param localDirectionVector The vector which normally describes the natural
        direction of the node, usually -Z

</member>
        <member name="M:Ogre.SceneNode.yaw(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Node.TransformSpace)">
Rotate the node around the Y-axis.

</member>
        <member name="M:Ogre.SceneNode.setFixedYawAxis(System.Boolean,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tells the node whether to yaw around it's own local Y axis or a fixed axis of choice.
        @remarks
        This method allows you to change the yaw behaviour of the node - by default, it
        yaws around it's own local Y axis when told to yaw with TS_LOCAL, this makes it
        yaw around a fixed axis. 
        You only really need this when you're using auto tracking (see setAutoTracking,
        because when you're manually rotating a node you can specify the TransformSpace
        in which you wish to work anyway.
        @param
        useFixed If true, the axis passed in the second parameter will always be the yaw axis no
        matter what the node orientation. If false, the node returns to it's default behaviour.
        @param
        fixedAxis The axis to use if the first parameter is true.

</member>
        <member name="M:Ogre.SceneNode.findLights(Ogre.HashedVector&lt;Ogre.Light**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.UInt32)">
Allows retrieval of the nearest lights to the centre of this SceneNode.
        @remarks
            This method allows a list of lights, ordered by proximity to the centre
            of this SceneNode, to be retrieved. Can be useful when implementing
            MovableObject::queryLights and Renderable::getLights.
        @par
            Note that only lights could be affecting the frustum will take into
            account, which cached in scene manager.
        @see SceneManager::_getLightsAffectingFrustum
        @see SceneManager::_populateLightList
        @param destList List to be populated with ordered set of lights; will be
            cleared by this method before population.
        @param radius Parameter to specify lights intersecting a given radius of
            this SceneNode's centre.
		@param lightMask The mask with which to include / exclude lights

</member>
        <member name="M:Ogre.SceneNode.createChildSceneNode(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a new named SceneNode as a child of this node.
        @remarks
            This creates a child node with a given name, which allows you to look the node up from 
            the parent which holds this collection of nodes.
            @param
                translate Initial translation offset of child relative to parent
            @param
                rotate Initial rotation relative to parent

</member>
        <member name="M:Ogre.SceneNode.createChildSceneNode(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates an unnamed new SceneNode as a child of this node.
        @param
            translate Initial translation offset of child relative to parent
        @param
            rotate Initial rotation relative to parent

</member>
        <member name="M:Ogre.SceneNode.getShowBoundingBox">
This allows scene managers to determine if the node's bounding box
			should be added to the rendering queue.
        @remarks
            Scene Managers that implement their own _findVisibleObjects will have to 
			check this flag and then use _addBoundingBoxToQueue to add the bounding box
			wireframe.

</member>
        <member name="M:Ogre.SceneNode._addBoundingBoxToQueue(Ogre.RenderQueue*)">
Add the bounding box to the rendering queue.

</member>
        <member name="M:Ogre.SceneNode.hideBoundingBox(System.Boolean)">
Allows the overriding of the node's bounding box
            over the SceneManager's bounding box setting.
        @remarks
            Use this to override the bounding box setting of the node.

</member>
        <member name="M:Ogre.SceneNode.showBoundingBox(System.Boolean)">
Allows the showing of the node's bounding box.
        @remarks
            Use this to show or hide the bounding box of the node.

</member>
        <member name="M:Ogre.SceneNode.removeAndDestroyAllChildren">
Removes and destroys all children of this node.
        @remarks
            Use this to destroy all child nodes of this node and remove
            them from the scene graph. Note that all objects attached to this
            node will be detached but will not be destroyed.

</member>
        <member name="M:Ogre.SceneNode.removeAndDestroyChild(System.UInt16)">
This method removes and destroys the child and all of its children.
        @remarks
            Unlike removeChild, which removes a single named child from this
            node but does not destroy it, this method destroys the child
            and all of it's children. 
        @par
            Use this if you wish to recursively destroy a node as well as 
            detaching it from it's parent. Note that any objects attached to
            the nodes will be detached but will not themselves be destroyed.

</member>
        <member name="M:Ogre.SceneNode.removeAndDestroyChild(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This method removes and destroys the named child and all of its children.
        @remarks
            Unlike removeChild, which removes a single named child from this
            node but does not destroy it, this method destroys the child
            and all of it's children. 
        @par
            Use this if you wish to recursively destroy a node as well as 
            detaching it from it's parent. Note that any objects attached to
            the nodes will be detached but will not themselves be destroyed.

</member>
        <member name="M:Ogre.SceneNode.getCreator">
Gets the creator of this scene node. 
        @remarks
            This method returns the SceneManager which created this node.
            This can be useful for destroying this node.

</member>
        <member name="M:Ogre.SceneNode.getAttachedObjectIterator">
Retrieves an iterator which can be used to efficiently step through the objects 
            attached to this node.
        @remarks
            This is a much faster way to go through <B>all</B> the objects attached to the node
            than using getAttachedObject. But the iterator returned is only valid until a change
            is made to the collection (ie an addition or removal) so treat the returned iterator
            as transient, and don't add / remove items as you go through the iterator, save changes
            until the end, or retrieve a new iterator after making the change. Making changes to
            the object returned through the iterator is OK though.


Retrieves an iterator which can be used to efficiently step through the objects 
            attached to this node.
        @remarks
            This is a much faster way to go through <B>all</B> the objects attached to the node
            than using getAttachedObject. But the iterator returned is only valid until a change
            is made to the collection (ie an addition or removal) so treat the returned iterator
            as transient, and don't add / remove items as you go through the iterator, save changes
            until the end, or retrieve a new iterator after making the change. Making changes to
            the object returned through the iterator is OK though.

</member>
        <member name="M:Ogre.SceneNode._getWorldAABB">
Gets the axis-aligned bounding box of this node (and hence all subnodes).
        @remarks
            Recommended only if you are extending a SceneManager, because the bounding box returned
            from this method is only up to date after the SceneManager has called _update.

</member>
        <member name="M:Ogre.SceneNode._findVisibleObjects(Ogre.Camera*,Ogre.RenderQueue*,Ogre.VisibleObjectsBoundsInfo*,System.Boolean,System.Boolean,System.Boolean)">
Internal method which locates any visible objects attached to this node and adds them to the passed in queue.
            @remarks
                Should only be called by a SceneManager implementation, and only after the _updat method has been called to
                ensure transforms and world bounds are up to date.
                SceneManager implementations can choose to let the search cascade automatically, or choose to prevent this
                and select nodes themselves based on some other criteria.
            @param
                cam The active camera
            @param
                queue The SceneManager's rendering queue
			@param
				visibleBounds bounding information created on the fly containing all visible objects by the camera
            @param
                includeChildren If true, the call is cascaded down to all child nodes automatically.
            @param
                displayNodes If true, the nodes themselves are rendered as a set of 3 axes as well
                    as the objects being rendered. For debugging purposes.

</member>
        <member name="M:Ogre.SceneNode._updateBounds">
Tells the SceneNode to update the world bound info it stores.

</member>
        <member name="M:Ogre.SceneNode._update(System.Boolean,System.Boolean)">
Internal method to update the Node.
            @note
                Updates this scene node and any relevant children to incorporate transforms etc.
                Don't call this yourself unless you are writing a SceneManager implementation.
            @param
                updateChildren If true, the update cascades down to all children. Specify false if you wish to
                update children separately, e.g. because of a more selective SceneManager implementation.
            @param
                parentHasChanged This flag indicates that the parent xform has changed,
                    so the child should retrieve the parent's xform and combine it with its own
                    even if it hasn't changed itself.

</member>
        <member name="M:Ogre.SceneNode._notifyRootNode">
Notifies this SceneNode that it is the root scene node. 
		@remarks
			Only SceneManager should call this!

</member>
        <member name="M:Ogre.SceneNode.isInSceneGraph">
Determines whether this node is in the scene graph, i.e.
			whether it's ultimate ancestor is the root scene node.

</member>
        <member name="M:Ogre.SceneNode.detachAllObjects">
Detaches all objects attached to this node.

</member>
        <member name="M:Ogre.SceneNode.detachObject(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Detaches the named object from this node and returns a pointer to it. 
</member>
        <member name="M:Ogre.SceneNode.detachObject(Ogre.MovableObject*)">
Detaches an object by pointer. 
</member>
        <member name="M:Ogre.SceneNode.detachObject(System.UInt16)">
Detaches the indexed object from this scene node.
        @remarks
            Detaches by index, see the alternate version to detach by name. Object indexes
            may change as other objects are added / removed.

</member>
        <member name="M:Ogre.SceneNode.getAttachedObject(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves a pointer to an attached object.
        @remarks Retrieves by object name, see alternate version to retrieve by index.

</member>
        <member name="M:Ogre.SceneNode.getAttachedObject(System.UInt16)">
Retrieves a pointer to an attached object.
        @remarks Retrieves by index, see alternate version to retrieve by name. The index
        of an object may change as other objects are added / removed.

</member>
        <member name="M:Ogre.SceneNode.numAttachedObjects">
Reports the number of objects attached to this node.

</member>
        <member name="M:Ogre.SceneNode.attachObject(Ogre.MovableObject*)">
Adds an instance of a scene object to this node.
        @remarks
            Scene objects can include Entity objects, Camera objects, Light objects, 
            ParticleSystem objects etc. Anything that subclasses from MovableObject.

</member>
        <member name="M:Ogre.SceneNode.#ctor(Ogre.SceneManager*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor, only to be called by the creator SceneManager.
        @remarks
            Creates a node with a specified name.

</member>
        <member name="M:Ogre.SceneNode.#ctor(Ogre.SceneManager*)">
Constructor, only to be called by the creator SceneManager.
        @remarks
            Creates a node with a generated name.

</member>
        <member name="F:Ogre.SceneNode.mIsInSceneGraph">
Is this node a current part of the scene graph?
</member>
        <member name="F:Ogre.SceneNode.mAutoTrackLocalDirection">
Local 'normal' direction vector
</member>
        <member name="F:Ogre.SceneNode.mAutoTrackOffset">
Tracking offset for fine tuning
</member>
        <member name="F:Ogre.SceneNode.mAutoTrackTarget">
Auto tracking target
</member>
        <member name="F:Ogre.SceneNode.mYawFixedAxis">
Fixed axis to yaw around
</member>
        <member name="F:Ogre.SceneNode.mYawFixed">
Whether to yaw around a fixed axis.
</member>
        <member name="M:Ogre.SceneNode.setInSceneGraph(System.Boolean)">
Internal method for setting whether the node is in the scene 
			graph.

</member>
        <member name="M:Ogre.SceneNode.setParent(Ogre.Node*)">
See Node 
</member>
        <member name="M:Ogre.SceneNode.createChildImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
See Node. 
</member>
        <member name="M:Ogre.SceneNode.createChildImpl">
See Node. 
</member>
        <member name="M:Ogre.SceneNode.updateFromParentImpl">
@copydoc Node::updateFromParentImpl. 
</member>
        <member name="F:Ogre.SceneNode.mWorldAABB">
World-Axis aligned bounding box, updated only through _update
</member>
        <member name="F:Ogre.SceneNode.mCreator">
SceneManager which created this node
</member>
        <member name="F:Ogre.SceneNode.mShowBoundingBox">
Flag that determines if the bounding box of the node should be displayed
</member>
        <member name="F:Ogre.SceneNode.mWireBoundingBox">
Pointer to a Wire Bounding Box for this Node
</member>
        <member name="T:Ogre.SceneNode">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Class representing a node in the scene graph.
        @remarks
            A SceneNode is a type of Node which is used to organise objects in a scene.
            It has the same hierarchical transformation properties of the generic Node class,
            but also adds the ability to attach world objects to the node, and stores hierarchical
            bounding volumes of the nodes in the tree.
            Child nodes are contained within the bounds of the parent, and so on down the
            tree, allowing for fast culling.

</member>
        <member name="M:Ogre.MeshSerializerListener.processSkeletonName(Ogre.Mesh*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*)">
Called to override the reference to a skeleton
</member>
        <member name="M:Ogre.MeshSerializerListener.processMaterialName(Ogre.Mesh*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*)">
Called to override the loading of the given named material
</member>
        <member name="T:Ogre.MeshSerializerListener">
	 @remarks
		This class allows users to hook into the mesh loading process and
		modify references within the mesh as they are loading. Material and
		skeletal references can be processed using this interface which allows
		finer control over resources.

</member>
        <member name="M:Ogre.MeshSerializer.getListener">
Returns the current listener
</member>
        <member name="M:Ogre.MeshSerializer.setListener(Ogre.MeshSerializerListener*)">
Sets the listener for this serializer
</member>
        <member name="M:Ogre.MeshSerializer.importMesh(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Mesh*)">
Imports Mesh and (optionally) Material data from a .mesh file DataStream.
        @remarks
            This method imports data from a DataStream opened from a .mesh file and places it's
            contents into the Mesh object which is passed in. 
        @param stream The DataStream holding the .mesh data. Must be initialised (pos at the start of the buffer).
        @param pDest Pointer to the Mesh object which will receive the data. Should be blank already.

</member>
        <member name="M:Ogre.MeshSerializer.exportMesh(Ogre.Mesh!System.Runtime.CompilerServices.IsConst*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Serializer.Endian)">
Exports a mesh to the file specified. 
        @remarks
            This method takes an externally created Mesh object, and exports both it
            and optionally the Materials it uses to a .mesh file.
        @param pMesh Pointer to the Mesh to export
        @param filename The destination filename
		@param endianMode The endian mode of the written file

</member>
        <member name="T:Ogre.MeshSerializer">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

Class for serialising mesh data to/from an OGRE .mesh file.
    @remarks
        This class allows exporters to write OGRE .mesh files easily, and allows the
        OGRE engine to import .mesh files into instantiated OGRE Meshes.
        Note that a .mesh file can include not only the Mesh, but also definitions of
        any Materials it uses (although this is optional, the .mesh can rely on the
        Material being loaded from another source, especially useful if you want to
        take advantage of OGRE's advanced Material properties which may not be available
        in your modeller).
    @par
        To export a Mesh:<OL><LI>Use the MaterialManager methods to create any dependent Material objects, if you want
            to export them with the Mesh.</LI><LI>Create a Mesh object and populate it using it's methods.</LI><LI>Call the exportMesh method</LI></OL>
    @par
        It's important to realise that this exporter uses OGRE terminology. In this context,
        'Mesh' means a top-level mesh structure which can actually contain many SubMeshes, each
        of which has only one Material. Modelling packages may refer to these differently, for
        example in Milkshape, it says 'Model' instead of 'Mesh' and 'Mesh' instead of 'SubMesh', 
        but the theory is the same.

</member>
        <member name="T:Ogre.MeshSerializerImpl_v1_1">
Class for providing backwards-compatibility for loading version 1.1 of the .mesh format. 
</member>
        <member name="T:Ogre.MeshSerializerImpl_v1_2">
Class for providing backwards-compatibility for loading version 1.2 of the .mesh format. 
</member>
        <member name="M:Ogre.MeshSerializerImpl_v1_3.reorganiseTriangles(Ogre.EdgeData*)">
Reorganise triangles of the edge list to group by vertex set
</member>
        <member name="T:Ogre.MeshSerializerImpl_v1_3">
Class for providing backwards-compatibility for loading version 1.3 of the .mesh format. 
</member>
        <member name="T:Ogre.MeshSerializerImpl_v1_4">
Class for providing backwards-compatibility for loading version 1.4 of the .mesh format. 
</member>
        <member name="M:Ogre.MeshSerializerImpl.flipEndian(System.Void*,System.UInt32,System.UInt32,std.list&lt;Ogre.VertexElement&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Flip the endianness of an entire vertex buffer, passed in as a 
pointer to locked or temporary memory 
</member>
        <member name="M:Ogre.MeshSerializerImpl.flipToLittleEndian(System.Void*,System.UInt32,System.UInt32,std.list&lt;Ogre.VertexElement&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Flip an entire vertex buffer to little endian
</member>
        <member name="M:Ogre.MeshSerializerImpl.flipFromLittleEndian(System.Void*,System.UInt32,System.UInt32,std.list&lt;Ogre.VertexElement&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Flip an entire vertex buffer from little endian
</member>
        <member name="M:Ogre.MeshSerializerImpl.importMesh(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Mesh*,Ogre.MeshSerializerListener*)">
Imports Mesh and (optionally) Material data from a .mesh file DataStream.
        @remarks
        This method imports data from a DataStream opened from a .mesh file and places it's
        contents into the Mesh object which is passed in. 
        @param stream The DataStream holding the .mesh data. Must be initialised (pos at the start of the buffer).
        @param pDest Pointer to the Mesh object which will receive the data. Should be blank already.

</member>
        <member name="M:Ogre.MeshSerializerImpl.exportMesh(Ogre.Mesh!System.Runtime.CompilerServices.IsConst*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Serializer.Endian)">
Exports a mesh to the file specified. 
        @remarks
        This method takes an externally created Mesh object, and exports both it
        and optionally the Materials it uses to a .mesh file.
        @param pMesh Pointer to the Mesh to export
        @param filename The destination filename
		@param endianMode The endian mode for the written file

</member>
        <member name="T:Ogre.MeshSerializerImpl">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

Internal implementation of Mesh reading / writing for the latest version of the
    .mesh format.
    @remarks
    In order to maintain compatibility with older versions of the .mesh format, there
    will be alternative subclasses of this class to load older versions, whilst this class
    will remain to load the latest version.

</member>
        <member name="M:Ogre.EdgeListBuilder.connectOrCreateEdge(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
Connect existing edge or create a new edge - utility method during building
</member>
        <member name="M:Ogre.EdgeListBuilder.findOrCreateCommonVertex(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32)">
Finds an existing common vertex, or inserts a new one
</member>
        <member name="D:Ogre.EdgeListBuilder.EdgeMap">
Edge map, used to connect edges. Note we allow many triangles on an edge,
        after connected an existing edge, we will remove it and never used again.

</member>
        <member name="D:Ogre.EdgeListBuilder.CommonVertexMap">
Map for identifying common vertices
</member>
        <member name="T:Ogre.EdgeListBuilder.vectorLess">
Comparator for unique vertex list 
</member>
        <member name="T:Ogre.EdgeListBuilder.geometryLess">
Comparator for sorting geometries by vertex set 
</member>
        <member name="T:Ogre.EdgeListBuilder.Geometry">
A set of indexed geometry data 
</member>
        <member name="T:Ogre.EdgeListBuilder.CommonVertex">
A vertex can actually represent several vertices in the final model, because
		vertices along texture seams etc will have been duplicated. In order to properly
		evaluate the surface properties, a single common vertex is used for these duplicates,
		and the faces hold the detail of the duplicated vertices.

</member>
        <member name="M:Ogre.EdgeListBuilder.log(Ogre.Log*)">
Debugging method
</member>
        <member name="M:Ogre.EdgeListBuilder.build">
Builds the edge information based on the information built up so far.
        @remarks
            The caller takes responsibility for deleting the returned structure.

</member>
        <member name="M:Ogre.EdgeListBuilder.addIndexData(Ogre.IndexData!System.Runtime.CompilerServices.IsConst*,System.UInt32,Ogre.RenderOperation.OperationType)">
Add a set of index geometry data to the edge builder. 
        @remarks
            You must add at least one set of index data to the builder before invoking the
            build method.
        @param indexData The index information which describes the triangles.
        @param vertexSet The vertex data set this index data refers to; you only need to alter this
            if you have added multiple sets of vertices
        @param opType The operation type used to render these indexes. Only triangle types
            are supported (no point or line types)

</member>
        <member name="M:Ogre.EdgeListBuilder.addVertexData(Ogre.VertexData!System.Runtime.CompilerServices.IsConst*)">
Add a set of vertex geometry data to the edge builder. 
        @remarks
            You must add at least one set of vertex data to the builder before invoking the
            build method.

</member>
        <member name="T:Ogre.EdgeListBuilder">
General utility class for building edge lists for geometry.
    @remarks
        You can add multiple sets of vertex and index data to build and edge list. 
        Edges will be built between the various sets as well as within sets; this allows 
        you to use a model which is built from multiple SubMeshes each using 
        separate index and (optionally) vertex data and still get the same connectivity 
        information. It's important to note that the indexes for the edge will be constrained
        to a single vertex buffer though (this is required in order to render the edge).

</member>
        <member name="M:Ogre.EdgeData.updateFaceNormals(System.UInt32,Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Updates the face normals for this edge list based on (changed)
            position information, useful for animated objects. 
        @param vertexSet The vertex set we are updating
        @param positionBuffer The updated position buffer, must contain ONLY xyz

</member>
        <member name="M:Ogre.EdgeData.updateTriangleLightFacing(Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculate the light facing state of the triangles in this edge list
        @remarks
            This is normally the first stage of calculating a silhouette, i.e.
            establishing which tris are facing the light and which are facing
            away. This state is stored in the 'triangleLightFacings'.
        @param lightPos 4D position of the light in object space, note that 
            for directional lights (which have no position), the w component
            is 0 and the x/y/z position are the direction.

</member>
        <member name="F:Ogre.EdgeData.isClosed">
Flag indicate the mesh is manifold. 
</member>
        <member name="F:Ogre.EdgeData.edgeGroups">
All edge groups of this edge list. 
</member>
        <member name="F:Ogre.EdgeData.triangleLightFacings">
Triangle light facing states. It should be 1:1 with triangles. 
</member>
        <member name="F:Ogre.EdgeData.triangleFaceNormals">
All triangle face normals. It should be 1:1 with triangles. 
</member>
        <member name="F:Ogre.EdgeData.triangles">
Main triangles array, stores all triangles of this edge list. Note that
            triangles are grouping against edge group.

</member>
        <member name="F:Ogre.EdgeData.EdgeGroup.edges">
The edges themselves. 
</member>
        <member name="F:Ogre.EdgeData.EdgeGroup.triCount">
Number triangles of this edge group. 
</member>
        <member name="F:Ogre.EdgeData.EdgeGroup.triStart">
Index to main triangles array, indicate the first triangle of this edge
                group, and all triangles of this edge group are stored continuous in
                main triangles array.

</member>
        <member name="F:Ogre.EdgeData.EdgeGroup.vertexData">
Pointer to vertex data used by this edge group. 
</member>
        <member name="F:Ogre.EdgeData.EdgeGroup.vertexSet">
The vertex set index that contains the vertices for this edge group. 
</member>
        <member name="T:Ogre.EdgeData.EdgeGroup">
A group of edges sharing the same vertex data. 
</member>
        <member name="F:Ogre.EdgeData.Edge.degenerate">
Indicates if this is a degenerate edge, ie it does not have 2 triangles 
</member>
        <member name="F:Ogre.EdgeData.Edge.sharedVertIndex">
Vertex indices as used in the shared vertex list, not exposed. 
</member>
        <member name="F:Ogre.EdgeData.Edge.vertIndex">
The vertex indices for this edge. Note that both vertices will be in the vertex
                set as specified in 'vertexSet', which will also be the same as tri 0 
</member>
        <member name="F:Ogre.EdgeData.Edge.triIndex">
The indexes of the 2 tris attached, note that tri 0 is the one where the 
                indexes run _anti_ clockwise along the edge. Indexes must be
                reversed for tri 1. 
</member>
        <member name="T:Ogre.EdgeData.Edge">
Edge data. 
</member>
        <member name="F:Ogre.EdgeData.Triangle.vertexSet">
The vertex set these vertices came from. 
</member>
        <member name="F:Ogre.EdgeData.Triangle.indexSet">
The set of indexes this triangle came from (NB it is possible that the triangles on 
               one side of an edge are using a different vertex buffer from those on the other side.) 
</member>
        <member name="T:Ogre.EdgeData.Triangle">
Basic triangle structure. 
</member>
        <member name="T:Ogre.EdgeData">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

This class contains the information required to describe the edge connectivity of a
        given set of vertices and indexes. 
    @remarks 
        This information is built using the EdgeListBuilder class. Note that for a given mesh,
        which can be made up of multiple submeshes, there are separate edge lists for when 

</member>
        <member name="M:Ogre.MeshManager.loadManualCurvedIllusionPlane(Ogre.Mesh*,Ogre.MeshManager.MeshBuildParams*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Utility method for manual loading a curved illusion plane 
</member>
        <member name="M:Ogre.MeshManager.loadManualCurvedPlane(Ogre.Mesh*,Ogre.MeshManager.MeshBuildParams*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Utility method for manual loading a curved plane 
</member>
        <member name="M:Ogre.MeshManager.loadManualPlane(Ogre.Mesh*,Ogre.MeshManager.MeshBuildParams*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Utility method for manual loading a plane 
</member>
        <member name="D:Ogre.MeshManager.MeshBuildParamsMap">
Map from resource pointer to parameter set 
</member>
        <member name="T:Ogre.MeshManager.MeshBuildParams">
Saved parameters used to (re)build a manual mesh built by this class 
</member>
        <member name="T:Ogre.MeshManager.MeshBuildType">
Enum identifying the types of manual mesh built by this manager 
</member>
        <member name="M:Ogre.MeshManager.tesselate2DMesh(Ogre.SubMesh*,System.UInt16,System.UInt16,System.Boolean,Ogre.HardwareBuffer.Usage,System.Boolean)">
Utility method for tessellating 2D meshes.

</member>
        <member name="M:Ogre.MeshManager.createImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.ManualResourceL">
@copydoc ResourceManager::createImpl
</member>
        <member name="M:Ogre.MeshManager.loadResource(Ogre.Resource*)">
@see ManualResourceLoader::loadResource 
</member>
        <member name="M:Ogre.MeshManager.getListener">
Gets the listener used to control mesh loading through the serializer.

</member>
        <member name="M:Ogre.MeshManager.setListener(Ogre.MeshSerializerListener*)">
Sets the listener used to control mesh loading through the serializer.

</member>
        <member name="M:Ogre.MeshManager.setBoundsPaddingFactor(System.Single)">
Sets the factor by which the bounding box of an entity is padded

</member>
        <member name="M:Ogre.MeshManager.getBoundsPaddingFactor">
Gets the factor by which the bounding box of an entity is padded.
	        Default is 0.01

</member>
        <member name="M:Ogre.MeshManager.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.MeshManager.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.MeshManager.getPrepareAllMeshesForShadowVolumes">
Retrieves whether all Meshes should prepare themselves for shadow volumes. 
</member>
        <member name="M:Ogre.MeshManager.setPrepareAllMeshesForShadowVolumes(System.Boolean)">
Tells the mesh manager that all future meshes should prepare themselves for
            shadow volumes on loading.

</member>
        <member name="M:Ogre.MeshManager.createBezierPatch(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void*,Ogre.VertexDeclaration*,Syste">
Creates a Bezier patch based on an array of control vertices.
            @param
                name The name to give the newly created mesh. 
            @param 
                groupName The name of the resource group to assign the mesh to 
            @param
                controlPointBuffer A pointer to a buffer containing the vertex data which defines control points 
                of the curves rather than actual vertices. Note that you are expected to provide not
                just position information, but potentially normals and texture coordinates too. The
                format of the buffer is defined in the VertexDeclaration parameter
            @param
                declaration VertexDeclaration describing the contents of the buffer. 
                Note this declaration must _only_ draw on buffer source 0!
            @param
                width Specifies the width of the patch in control points.
                Note this parameter must greater than or equal to 3.
            @param
                height Specifies the height of the patch in control points. 
                Note this parameter must greater than or equal to 3.
            @param
                uMaxSubdivisionLevel,vMaxSubdivisionLevel If you want to manually set the top level of subdivision, 
                do it here, otherwise let the system decide.
            @param
                visibleSide Determines which side of the patch (or both) triangles are generated for.
            @param
                vbUsage Vertex buffer usage flags. Recommend the default since vertex buffer should be static.
            @param
                ibUsage Index buffer usage flags. Recommend the default since index buffer should 
                be dynamic to change levels but not readable.
            @param
                vbUseShadow Flag to determine if a shadow buffer is generated for the vertex buffer. See
                    HardwareBuffer for full details.
            @param
                ibUseShadow Flag to determine if a shadow buffer is generated for the index buffer. See
                    HardwareBuffer for full details.

</member>
        <member name="M:Ogre.MeshManager.createCurvedPlane(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Plane!System.Runtime.CompilerServices">
Creates a genuinely curved plane, by default majoring on the x/y axes facing positive Z.
            @param
                name The name to give the resulting mesh
            @param 
                groupName The name of the resource group to assign the mesh to 
            @param
                plane The orientation of the plane and distance from the origin
            @param
                width The width of the plane in world coordinates
            @param
                height The height of the plane in world coordinates
			@param
				bow The amount of 'bow' in the curved plane.  (Could also be considered the depth.)
            @param
                xsegments The number of segments to the plane in the x direction
            @param
                ysegments The number of segments to the plane in the y direction
            @param
                normals If true, normals are created perpendicular to the plane
            @param
                numTexCoordSets The number of 2D texture coordinate sets created - by default the corners
                are created to be the corner of the texture.
            @param
                uTile The number of times the texture should be repeated in the u direction
            @param
                vTile The number of times the texture should be repeated in the v direction
            @param
                upVector The 'Up' direction of the plane.
			@param
				vertexBufferUsage The usage flag with which the vertex buffer for this plane will be created
			@param
				indexBufferUsage The usage flag with which the index buffer for this plane will be created
			@param
				vertexShadowBuffer If this flag is set to true, the vertex buffer will be created 
				with a system memory shadow buffer,
				allowing you to read it back more efficiently than if it is in hardware
			@param
				indexShadowBuffer If this flag is set to true, the index buffer will be 
				created with a system memory shadow buffer,
				allowing you to read it back more efficiently than if it is in hardware

</member>
        <member name="M:Ogre.MeshManager.createCurvedIllusionPlane(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Plane!System.Runtime.Compiler">
Creates a plane, which because of it's texture coordinates looks like a curved
			surface, useful for skies in a skybox. 
            @param
                name The name to give the resulting mesh
            @param 
                groupName The name of the resource group to assign the mesh to 
            @param
                plane The orientation of the plane and distance from the origin
            @param
                width The width of the plane in world coordinates
            @param
                height The height of the plane in world coordinates
            @param
				curvature The curvature of the plane. Good values are
                between 2 and 65. Higher values are more curved leading to
                a smoother effect, lower values are less curved meaning
                more distortion at the horizons but a better distance effect.
			@param
                xsegments The number of segments to the plane in the x direction
            @param
                ysegments The number of segments to the plane in the y direction
            @param
                normals If true, normals are created perpendicular to the plane
            @param
                numTexCoordSets The number of 2D texture coordinate sets created - by default the corners
                are created to be the corner of the texture.
            @param
                uTile The number of times the texture should be repeated in the u direction
            @param
                vTile The number of times the texture should be repeated in the v direction
            @param
                upVector The 'Up' direction of the plane.
            @param
                orientation The orientation of the overall sphere that's used to create the illusion
			@param
				vertexBufferUsage The usage flag with which the vertex buffer for this plane will be created
			@param
				indexBufferUsage The usage flag with which the index buffer for this plane will be created
			@param
				vertexShadowBuffer If this flag is set to true, the vertex buffer will be created 
				with a system memory shadow buffer,
				allowing you to read it back more efficiently than if it is in hardware
			@param
				indexShadowBuffer If this flag is set to true, the index buffer will be 
				created with a system memory shadow buffer,
				allowing you to read it back more efficiently than if it is in hardware
            @param ySegmentsToKeep The number of segments from the top of the dome
                downwards to keep. -1 keeps all of them. This can save fillrate if
                you cannot see much of the sky lower down.

</member>
        <member name="M:Ogre.MeshManager.createPlane(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Plane!System.Runtime.CompilerServices.IsCon">
Creates a basic plane, by default majoring on the x/y axes facing positive Z.
            @param
                name The name to give the resulting mesh
            @param 
                groupName The name of the resource group to assign the mesh to 
            @param
                plane The orientation of the plane and distance from the origin
            @param
                width The width of the plane in world coordinates
            @param
                height The height of the plane in world coordinates
            @param
                xsegments The number of segments to the plane in the x direction
            @param
                ysegments The number of segments to the plane in the y direction
            @param
                normals If true, normals are created perpendicular to the plane
            @param
                numTexCoordSets The number of 2D texture coordinate sets created - by default the corners
                are created to be the corner of the texture.
            @param
                uTile The number of times the texture should be repeated in the u direction
            @param
                vTile The number of times the texture should be repeated in the v direction
            @param
                upVector The 'Up' direction of the plane.
			@param
				vertexBufferUsage The usage flag with which the vertex buffer for this plane will be created
			@param
				indexBufferUsage The usage flag with which the index buffer for this plane will be created
			@param
				vertexShadowBuffer If this flag is set to true, the vertex buffer will be created 
				with a system memory shadow buffer,
				allowing you to read it back more efficiently than if it is in hardware
			@param
				indexShadowBuffer If this flag is set to true, the index buffer will be 
				created with a system memory shadow buffer,
				allowing you to read it back more efficiently than if it is in hardware

</member>
        <member name="M:Ogre.MeshManager.createManual(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ManualResourceLoader*)">
Creates a new Mesh specifically for manual definition rather
            than loading from an object file. 
		@remarks
			Note that once you've defined your mesh, you must call Mesh::_setBounds and
            Mesh::_setBoundingRadius in order to define the bounds of your mesh. In previous
            versions of OGRE you could call Mesh::_updateBounds, but OGRE's support of 
            write-only vertex buffers makes this no longer appropriate.
        @param name The name to give the new mesh
        @param groupName The name of the resource group to assign the mesh to 
        @param loader ManualResourceLoader which will be called to load this mesh
            when the time comes. It is recommended that you populate this field
            in order that the mesh can be rebuilt should the need arise

</member>
        <member name="M:Ogre.MeshManager.load(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.HardwareBuffer.Usage,Ogre.HardwareBuffer.Usage,Sys">
Loads a mesh from a file, making it immediately available for use.
            @note
                If the model has already been created (prepared or loaded), the existing instance
                will be returned.
            @remarks
                Ogre loads model files from it's own proprietary
                format called .mesh. This is because having a single file
                format is better for runtime performance, and we also have
                control over pre-processed data (such as
                collision boxes, LOD reductions etc).
			@param filename The name of the .mesh file
            @param groupName The name of the resource group to assign the mesh to 
			@param vertexBufferUsage The usage flags with which the vertex buffer(s)
				will be created
			@param indexBufferUsage The usage flags with which the index buffer(s) created for 
				this mesh will be created with.
			@param vertexBufferShadowed If true, the vertex buffers will be shadowed by system memory 
                copies for faster read access
			@param indexBufferShadowed If true, the index buffers will be shadowed by system memory 
                copies for faster read access

</member>
        <member name="M:Ogre.MeshManager.prepare(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.HardwareBuffer.Usage,Ogre.HardwareBuffer.Usage,">
Prepares a mesh for loading from a file.  This does the IO in advance of the call to load().
            @note
                If the model has already been created (prepared or loaded), the existing instance
                will be returned.
            @remarks
                Ogre loads model files from it's own proprietary
                format called .mesh. This is because having a single file
                format is better for runtime performance, and we also have
                control over pre-processed data (such as
                collision boxes, LOD reductions etc).
			@param filename The name of the .mesh file
            @param groupName The name of the resource group to assign the mesh to 
			@param vertexBufferUsage The usage flags with which the vertex buffer(s)
				will be created
			@param indexBufferUsage The usage flags with which the index buffer(s) created for 
				this mesh will be created with.
			@param vertexBufferShadowed If true, the vertex buffers will be shadowed by system memory 
                copies for faster read access
			@param indexBufferShadowed If true, the index buffers will be shadowed by system memory 
                copies for faster read access

</member>
        <member name="M:Ogre.MeshManager.createOrRetrieve(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.ManualResourceLoader*,s">
Create a new mesh, or retrieve an existing one with the same
            name if it already exists.
            @param vertexBufferUsage The usage flags with which the vertex buffer(s)
                will be created
            @param indexBufferUsage The usage flags with which the index buffer(s) created for 
                this mesh will be created with.
            @param vertexBufferShadowed If true, the vertex buffers will be shadowed by system memory 
                copies for faster read access
            @param indexBufferShadowed If true, the index buffers will be shadowed by system memory 
                copies for faster read access
        @see ResourceManager::createOrRetrieve

</member>
        <member name="M:Ogre.MeshManager._initialise">
Initialises the manager, only to be called by OGRE internally. 
</member>
        <member name="T:Ogre.MeshManager">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

Handles the management of mesh resources.
        @remarks
            This class deals with the runtime management of
            mesh data; like other resource managers it handles
            the creation of resources (in this case mesh data),
            working within a fixed memory budget.

</member>
        <member name="M:Ogre.PatchMeshPtr.op_Assign(Ogre.MeshPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Operator used to convert a MeshPtr to a PatchMeshPtr
</member>
        <member name="M:Ogre.PatchMeshPtr.op_Assign(Ogre.SharedPtr&lt;Ogre.Resource&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Operator used to convert a ResourcePtr to a PatchMeshPtr
</member>
        <member name="M:Ogre.PatchMesh.prepareImpl">
Overridden from Resource - do nothing (no disk caching)
</member>
        <member name="M:Ogre.PatchMesh.loadImpl">
Overridden from Resource
</member>
        <member name="M:Ogre.PatchMesh.define(System.Void*,Ogre.VertexDeclaration*,System.UInt32,System.UInt32,System.UInt32,System.UInt32,Ogre.PatchSurface.VisibleSide,Ogre.HardwareBuffer.Usage,Ogre.HardwareBuffer.Usage,System.Boolean,System.Boolean)">
Define the patch, as defined in MeshManager::createBezierPatch
</member>
        <member name="M:Ogre.PatchMesh.#ctor(Ogre.ResourceManager*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor
</member>
        <member name="F:Ogre.PatchMesh.mDeclaration">
Vertex declaration, cloned from the input
</member>
        <member name="F:Ogre.PatchMesh.mSurface">
Internal surface definition
</member>
        <member name="T:Ogre.PatchMesh">
\addtogroup Core
	*  @{

\addtogroup LOD
	*  @{

Patch specialisation of Mesh. 
    @remarks
        Instances of this class should be created by calling MeshManager::createBezierPatch.

</member>
        <member name="M:Ogre.PatchSurface.findLevel(Ogre.Vector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for finding the subdivision level given 3 control points.

</member>
        <member name="F:Ogre.PatchSurface.mVSide">
Which side is visible
</member>
        <member name="F:Ogre.PatchSurface.mMeshHeight">
Height of the subdivided mesh (big enough for max level)
</member>
        <member name="F:Ogre.PatchSurface.mMeshWidth">
Width of the subdivided mesh (big enough for max level)
</member>
        <member name="F:Ogre.PatchSurface.mMaxULevel">
Max subdivision level
</member>
        <member name="F:Ogre.PatchSurface.mVLevel">
V-direction subdivision level
</member>
        <member name="F:Ogre.PatchSurface.mULevel">
U-direction subdivision level
</member>
        <member name="F:Ogre.PatchSurface.mCtlCount">
TotalNumber of control points
</member>
        <member name="F:Ogre.PatchSurface.mCtlHeight">
Height in control points
</member>
        <member name="F:Ogre.PatchSurface.mCtlWidth">
Width in control points
</member>
        <member name="F:Ogre.PatchSurface.mType">
Type of surface
</member>
        <member name="F:Ogre.PatchSurface.mControlPointBuffer">
Buffer containing the system-memory control points
</member>
        <member name="F:Ogre.PatchSurface.mDeclaration">
Vertex declaration describing the control point buffer
</member>
        <member name="M:Ogre.PatchSurface.notifyControlPointBufferDeallocated">
Convenience method for telling the patch that the control points have been 
            deleted, since once the patch has been built they are not required. 
</member>
        <member name="M:Ogre.PatchSurface.getSubdivisionFactor">
Gets the current level of subdivision. 
</member>
        <member name="M:Ogre.PatchSurface.setSubdivisionFactor(System.Single)">
Alters the level of subdivision for this surface.
            @remarks
                This method changes the proportionate detail level of the patch; since
                the U and V directions can have different subdivision levels, this method
                takes a single Real value where 0 is the minimum detail (the control points)
                and 1 is the maximum detail level as supplied to the original call to 
                defineSurface.

</member>
        <member name="M:Ogre.PatchSurface.build(Ogre.HardwareVertexBufferSharedPtr,System.UInt32,Ogre.HardwareIndexBufferSharedPtr,System.UInt32)">
Tells the system to build the mesh relating to the surface into externally created
            buffers.
            @remarks
                The VertexDeclaration of the vertex buffer must be identical to the one passed into
                defineSurface.  In addition, there must be enough space in the buffer to 
                accommodate the patch at full detail level; you should call getRequiredVertexCount
                and getRequiredIndexCount to determine this. This method does not create an internal
                mesh for this patch and so getMesh will return null if you call it after building the
                patch this way.
            @param destVertexBuffer The destination vertex buffer in which to build the patch.
            @param vertexStart The offset at which to start writing vertices for this patch
            @param destIndexBuffer The destination index buffer in which to build the patch.
            @param vertexStart The offset at which to start writing indexes for this patch


</member>
        <member name="M:Ogre.PatchSurface.getBoundingSphereRadius">
Gets the radius of the bounding sphere for this patch, only valid after defineSurface 
        has been called. 
</member>
        <member name="M:Ogre.PatchSurface.getBounds">
Gets the bounds of this patch, only valid after calling defineSurface. 
</member>
        <member name="M:Ogre.PatchSurface.getVertexOffset">
Returns the vertex offset used by this buffer to write data into the buffer
</member>
        <member name="M:Ogre.PatchSurface.getIndexOffset">
Returns the index offset used by this buffer to write data into the buffer
</member>
        <member name="M:Ogre.PatchSurface.getCurrentIndexCount">
Gets the current index count based on the current subdivision level. 
</member>
        <member name="M:Ogre.PatchSurface.getRequiredIndexCount">
Based on a previous call to defineSurface, establishes the number of indexes required
            to hold this patch at the maximum detail level. 
            @remarks This is useful when you wish to build the patch into external vertex / index buffers.


</member>
        <member name="M:Ogre.PatchSurface.getRequiredVertexCount">
Based on a previous call to defineSurface, establishes the number of vertices required
            to hold this patch at the maximum detail level. 
            @remarks This is useful when you wish to build the patch into external vertex / index buffers.


</member>
        <member name="M:Ogre.PatchSurface.defineSurface(System.Void*,Ogre.VertexDeclaration*,System.UInt32,System.UInt32,Ogre.PatchSurface.PatchSurfaceType,System.UInt32,System.UInt32,Ogre.PatchSurface.VisibleSide)">
Sets up the surface by defining it's control points, type and initial subdivision level.
            @remarks
                This method initialises the surface by passing it a set of control points. The type of curves to be used
                are also defined here, although the only supported option currently is a bezier patch. You can also
                specify a global subdivision level here if you like, although it is recommended that the parameter
                is left as AUTO_LEVEL, which means the system decides how much subdivision is required (based on the
                curvature of the surface)
            @param
                controlPointBuffer A pointer to a buffer containing the vertex data which defines control points 
                of the curves rather than actual vertices. Note that you are expected to provide not
                just position information, but potentially normals and texture coordinates too. The
                format of the buffer is defined in the VertexDeclaration parameter
            @param
                declaration VertexDeclaration describing the contents of the buffer. 
                Note this declaration must _only_ draw on buffer source 0!
            @param
                width Specifies the width of the patch in control points.
            @param
                height Specifies the height of the patch in control points. 
            @param
                pType The type of surface - currently only PST_BEZIER is supported
            @param
                uMaxSubdivisionLevel,vMaxSubdivisionLevel If you want to manually set the top level of subdivision, 
                do it here, otherwise let the system decide.
            @param
                visibleSide Determines which side of the patch (or both) triangles are generated for.

</member>
        <member name="F:VS_BOTH">
Both sides are visible - warning this creates 2x the number of triangles and adds extra overhead for calculating normals
</member>
        <member name="F:VS_BACK">
The side from which u goes right and v goes down (reverse of texture coords)
</member>
        <member name="F:VS_FRONT">
The side from which u goes right and v goes up (as in texture coords)
</member>
        <member name="F:PST_BEZIER">
A patch defined by a set of bezier curves
</member>
        <member name="T:Ogre.PatchSurface">
\addtogroup Core
	*  @{

\addtogroup LOD
	*  @{

A surface which is defined by curves of some kind to form a patch, e.g. a Bezier patch.
        @remarks
            This object will take a list of control points with various assorted data, and will
            subdivide it into a patch mesh. Currently only Bezier curves are supported for defining
            the surface, but other techniques such as NURBS would follow the same basic approach.

</member>
        <member name="M:Ogre.MaterialManager.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.MaterialManager.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.MaterialManager._arbitrateMissingTechniqueForActiveScheme(Ogre.Material*,System.UInt16,Ogre.Renderable!System.Runtime.CompilerServices.IsConst*)">
Internal method for sorting out missing technique for a scheme
</member>
        <member name="M:Ogre.MaterialManager.removeListener(Ogre.MaterialManager.Listener*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Remove a listener handling material events. 
If the listener was added with a custom scheme name, it needs to be supplied here as well.

</member>
        <member name="M:Ogre.MaterialManager.addListener(Ogre.MaterialManager.Listener*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add a listener to handle material events. 
If schemeName is supplied, the listener will only receive events for that certain scheme.

</member>
        <member name="M:Ogre.MaterialManager.setActiveScheme(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the name of the active material scheme. 
		@see Technique::setSchemeName

</member>
        <member name="M:Ogre.MaterialManager.getActiveScheme">
Returns the name of the active material scheme. 
		@see Technique::setSchemeName

</member>
        <member name="M:Ogre.MaterialManager._getActiveSchemeIndex">
Internal method - returns the active scheme index.
		@see Technique::setSchemeName

</member>
        <member name="M:Ogre.MaterialManager._getSchemeName(System.UInt16)">
Internal method - returns name for a given material scheme index.
		@see Technique::setSchemeName

</member>
        <member name="M:Ogre.MaterialManager._getSchemeIndex(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method - returns index for a given material scheme name.
		@see Technique::setSchemeName

</member>
        <member name="M:Ogre.MaterialManager.getDefaultAnisotropy">
get the default maxAnisotropy
</member>
        <member name="M:Ogre.MaterialManager.setDefaultAnisotropy(System.UInt32)">
Sets the default anisotropy level to be used for loaded textures, for when textures are
            loaded automatically (e.g. by Material class) or when 'load' is called with the default
            parameters by the application.
            @note
                The default value is 1 (no anisotropy).

</member>
        <member name="M:Ogre.MaterialManager.getDefaultTextureFiltering(Ogre.FilterType)">
get the default texture filtering
</member>
        <member name="M:Ogre.MaterialManager.setDefaultTextureFiltering(Ogre.FilterOptions,Ogre.FilterOptions,Ogre.FilterOptions)">
Sets the default texture filtering to be used for loaded textures, for when textures are
            loaded automatically (e.g. by Material class) or when 'load' is called with the default
            parameters by the application.

</member>
        <member name="M:Ogre.MaterialManager.setDefaultTextureFiltering(Ogre.FilterType,Ogre.FilterOptions)">
Sets the default texture filtering to be used for loaded textures, for when textures are
            loaded automatically (e.g. by Material class) or when 'load' is called with the default
            parameters by the application.

</member>
        <member name="M:Ogre.MaterialManager.setDefaultTextureFiltering(Ogre.TextureFilterOptions)">
Sets the default texture filtering to be used for loaded textures, for when textures are
            loaded automatically (e.g. by Material class) or when 'load' is called with the default
            parameters by the application.
            @note
                The default value is TFO_BILINEAR.

</member>
        <member name="M:Ogre.MaterialManager.parseScript(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@see ScriptLoader::parseScript

</member>
        <member name="M:Ogre.MaterialManager.initialise">
Initialises the material manager, which also triggers it to 
		 * parse all available .program and .material scripts. 
</member>
        <member name="M:Ogre.MaterialManager.Dispose">
Default destructor.

</member>
        <member name="M:Ogre.MaterialManager.#ctor">
Default constructor.

</member>
        <member name="F:Ogre.MaterialManager.DEFAULT_SCHEME_NAME">
Default material scheme
</member>
        <member name="D:Ogre.MaterialManager.ListenerList">
The list of per-scheme (and general) material listeners
</member>
        <member name="F:Ogre.MaterialManager.mActiveSchemeIndex">
Current material scheme
</member>
        <member name="F:Ogre.MaterialManager.mActiveSchemeName">
Current material scheme
</member>
        <member name="F:Ogre.MaterialManager.mSchemes">
List of material schemes
</member>
        <member name="D:Ogre.MaterialManager.SchemeMap">
Scheme name -&gt; index. Never shrinks! Should be pretty static anyway
</member>
        <member name="M:Ogre.MaterialManager.createImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.ManualResou">
Overridden from ResourceManager
</member>
        <member name="F:Ogre.MaterialManager.mDefaultSettings">
Default settings
</member>
        <member name="F:Ogre.MaterialManager.mSerializer">
Serializer - Hold instance per thread if necessary
</member>
        <member name="F:Ogre.MaterialManager.mDefaultMaxAniso">
Default Texture anisotropy
</member>
        <member name="F:Ogre.MaterialManager.mDefaultMipFilter">
Default Texture filtering - mipmapping
</member>
        <member name="F:Ogre.MaterialManager.mDefaultMagFilter">
Default Texture filtering - magnification
</member>
        <member name="F:Ogre.MaterialManager.mDefaultMinFilter">
Default Texture filtering - minification
</member>
        <member name="M:Ogre.MaterialManager.Listener.handleSchemeNotFound(System.UInt16,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Material*,System.UInt16,Ogre.Renderable!System.Runtime.CompilerServices.IsConst*)">
Called if a technique for a given scheme is not found within a material,
				allows the application to specify a Technique instance manually.
			@remarks
				Material schemes allow you to switch wholesale between families of 
				techniques on a material. However they require you to define those
				schemes on the materials up-front, which might not be possible or
				desirable for all materials, particular if, for example, you wanted
				a simple way to replace all materials with another using a scheme.
			@par
				This callback allows you to handle the case where a scheme is requested
				but the material doesn't have an entry for it. You can return a
				Technique pointer from this method to specify the material technique
				you'd like to be applied instead, which can be from another material
				entirely (and probably will be). Note that it is critical that you
				only return a Technique that is supported on this hardware; there are
				utility methods like Material::getBestTechnique to help you with this.
			@param schemeIndex The index of the scheme that was requested - all 
				schemes have a unique index when created that does not alter. 
			@param schemeName The friendly name of the scheme being requested
			@param originalMaterial The material that is being processed, that 
				didn't have a specific technique for this scheme
			@param lodIndex The material level-of-detail that was being asked for, 
				in case you need to use it to determine a technique.
			@param rend Pointer to the Renderable that is requesting this technique
				to be used, so this may influence your choice of Technique. May be
				null if the technique isn't being requested in that context.
			@returns A pointer to the technique to be used, or NULL if you wish to
				use the default technique for this material

</member>
        <member name="M:Ogre.MaterialManager.Listener.Dispose">
Virtual destructor needed as class has virtual methods. 
</member>
        <member name="T:Ogre.MaterialManager.Listener">
Listener on any general material events.
		@see MaterialManager::addListener

</member>
        <member name="T:Ogre.MaterialManager">
\addtogroup Core
	*  @{

\addtogroup Materials
	*  @{

Class for managing Material settings for Ogre.
        @remarks
            Materials control the eventual surface rendering properties of geometry. This class
            manages the library of materials, dealing with programmatic registrations and lookups,
            as well as loading predefined Material settings from scripts.
        @par
            When loaded from a script, a Material is in an 'unloaded' state and only stores the settings
            required. It does not at that stage load any textures. This is because the material settings may be
            loaded 'en masse' from bulk material script files, but only a subset will actually be required.
        @par
            Because this is a subclass of ResourceManager, any files loaded will be searched for in any path or
            archive added to the resource paths/archives. See ResourceManager for details.
        @par
            For a definition of the material script format, see the Tutorials/MaterialScript.html file.

</member>
        <member name="M:Ogre.MaterialSerializer.removeListener(Ogre.MaterialSerializer.Listener*)">
Remove a listener from this Serializer.
		@see MaterialSerializer::Listener

</member>
        <member name="M:Ogre.MaterialSerializer.addListener(Ogre.MaterialSerializer.Listener*)">
Register a listener to this Serializer.
		@see MaterialSerializer::Listener

</member>
        <member name="M:Ogre.MaterialSerializer.parseScript(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Parses a Material script file passed as a stream.

</member>
        <member name="M:Ogre.MaterialSerializer.clearQueue">
Clears the internal buffer 
</member>
        <member name="M:Ogre.MaterialSerializer.getQueuedAsString">
Returns a string representing the parsed material(s) 
</member>
        <member name="M:Ogre.MaterialSerializer.exportMaterial(Ogre.MaterialPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean!System.Runtime.CompilerServices.IsConst,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.">
Exports a single in-memory Material to the named material script file.
        @param exportDefaults if true then exports all values including defaults
        @param includeProgDef if true includes Gpu shader program definitions in the
            export material script otherwise if false then program definitions will
            be exported to a separate file with name programFilename if
            programFilename is not empty
        @param programFilename the file name of the vertex / fragment program 
			script to be exported. This is only used if includeProgDef is false.
		@param materialName Allow exporting the given material under a different name.
			In case of empty string the original material name will be used.

</member>
        <member name="M:Ogre.MaterialSerializer.exportQueued(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean!System.Runtime.CompilerServices.IsConst,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicit">
Exports queued material(s) to a named material script file.
        @param filename the file name of the material script to be exported
		@param includeProgDef If true, vertex program and fragment program 
			definitions will be written at the top of the material script
        @param programFilename the file name of the vertex / fragment program 
			script to be exported. This is only used if there are program definitions
            to be exported and includeProgDef is false 
			when calling queueForExport.

</member>
        <member name="M:Ogre.MaterialSerializer.queueForExport(Ogre.MaterialPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Queue an in-memory Material to the internal buffer for export.
		@param pMat Material pointer
		@param clearQueued If true, any materials already queued will be removed
		@param exportDefaults If true, attributes which are defaulted will be
			included in the script exported, otherwise they will be omitted
		@param materialName Allow exporting the given material under a different name.
			In case of empty string the original material name will be used.

</member>
        <member name="M:Ogre.MaterialSerializer.Dispose">
default destructor
</member>
        <member name="M:Ogre.MaterialSerializer.#ctor">
default constructor
</member>
        <member name="M:Ogre.MaterialSerializer.fireTextureUnitStateEvent(Ogre.MaterialSerializer.SerializeEvent,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.TextureUnitState!System.Runtime.CompilerServices.IsConst*)">
Internal methods that invokes registered listeners callback.
		@see Listener::textureUnitStateEventRaised.

</member>
        <member name="M:Ogre.MaterialSerializer.fireGpuProgramRefEvent(Ogre.MaterialSerializer.SerializeEvent,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.GpuProgramPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.SharedPtr&lt;Ogre.GpuProgramParameters&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.GpuPr">
Internal methods that invokes registered listeners callback.
		@see Listener::gpuProgramRefEventRaised.

</member>
        <member name="M:Ogre.MaterialSerializer.firePassEvent(Ogre.MaterialSerializer.SerializeEvent,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Pass!System.Runtime.CompilerServices.IsConst*)">
Internal methods that invokes registered listeners callback.
		@see Listener::passEventRaised.

</member>
        <member name="M:Ogre.MaterialSerializer.fireTechniqueEvent(Ogre.MaterialSerializer.SerializeEvent,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Technique!System.Runtime.CompilerServices.IsConst*)">
Internal methods that invokes registered listeners callback.
		@see Listener::techniqueEventRaised.

</member>
        <member name="M:Ogre.MaterialSerializer.fireMaterialEvent(Ogre.MaterialSerializer.SerializeEvent,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Material!System.Runtime.CompilerServices.IsConst*)">
Internal methods that invokes registered listeners callback.
		@see Listener::materialEventRaised.

</member>
        <member name="D:Ogre.MaterialSerializer.ListenerList">
Listeners list of this Serializer.
</member>
        <member name="F:Ogre.MaterialSerializer.mProgramDefaultParamAttribParsers">
Parsers for the program definition section of a script
</member>
        <member name="F:Ogre.MaterialSerializer.mProgramAttribParsers">
Parsers for the program definition section of a script
</member>
        <member name="F:Ogre.MaterialSerializer.mProgramRefAttribParsers">
Parsers for the program reference section of a script
</member>
        <member name="F:Ogre.MaterialSerializer.mTextureUnitAttribParsers">
Parsers for the texture unit section of a script
</member>
        <member name="F:Ogre.MaterialSerializer.mPassAttribParsers">
Parsers for the pass section of a script
</member>
        <member name="F:Ogre.MaterialSerializer.mTechniqueAttribParsers">
Parsers for the technique section of a script
</member>
        <member name="F:Ogre.MaterialSerializer.mMaterialAttribParsers">
Parsers for the material section of a script
</member>
        <member name="F:Ogre.MaterialSerializer.mRootAttribParsers">
Parsers for the root of the material script
</member>
        <member name="M:Ogre.MaterialSerializer.finishProgramDefinition">
Internal method for saving a program definition which has been
		    built up.

</member>
        <member name="M:Ogre.MaterialSerializer.parseScriptLine(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
internal method for parsing a material
        @returns true if it expects the next line to be a {

</member>
        <member name="D:Ogre.MaterialSerializer.AttribParserList">
Keyword-mapped attribute parsers.
</member>
        <member name="M:Ogre.MaterialSerializer.Listener.textureUnitStateEventRaised(Ogre.MaterialSerializer*,Ogre.MaterialSerializer.SerializeEvent,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.TextureUnitState!System.Runtime.CompilerServices.IsConst*)">
Called when texture unit state section event raised.					
			@param ser The MaterialSerializer instance that writes the given material.
			@param stage The current section writing stage.
			@param skip May set to true by sub-class instances in order to skip the following section write.
			This parameter relevant only when stage equals MSE_PRE_WRITE. 
			@param textureUnit The texture unit state that is being written.		

</member>
        <member name="M:Ogre.MaterialSerializer.Listener.gpuProgramRefEventRaised(Ogre.MaterialSerializer*,Ogre.MaterialSerializer.SerializeEvent,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.GpuProgramPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.SharedPtr&lt;Ogre.GpuProgramParameters&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices">
Called when GPU program reference section event raised.				
			@param ser The MaterialSerializer instance that writes the given material.
			@param stage The current section writing stage.
			@param skip May set to true by sub-class instances in order to skip the following section write.
			This parameter relevant only when stage equals MSE_PRE_WRITE. 
			@param attrib The GPU program reference description (vertex_program_ref, fragment_program_ref, etc).		
			@param program The program being written.
			@param params The program parameters.
			@param defaultParams The default program parameters.

</member>
        <member name="M:Ogre.MaterialSerializer.Listener.passEventRaised(Ogre.MaterialSerializer*,Ogre.MaterialSerializer.SerializeEvent,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Pass!System.Runtime.CompilerServices.IsConst*)">
Called when pass section event raised.					
			@param ser The MaterialSerializer instance that writes the given material.
			@param stage The current section writing stage.
			@param skip May set to true by sub-class instances in order to skip the following section write.
			This parameter relevant only when stage equals MSE_PRE_WRITE. 
			@param pass The pass that is being written.		

</member>
        <member name="M:Ogre.MaterialSerializer.Listener.techniqueEventRaised(Ogre.MaterialSerializer*,Ogre.MaterialSerializer.SerializeEvent,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Technique!System.Runtime.CompilerServices.IsConst*)">
Called when technique section event raised.				
			@param ser The MaterialSerializer instance that writes the given material.
			@param stage The current section writing stage.
			@param skip May set to true by sub-class instances in order to skip the following section write.
			This parameter relevant only when stage equals MSE_PRE_WRITE. 
			@param tech The technique that is being written.		

</member>
        <member name="M:Ogre.MaterialSerializer.Listener.materialEventRaised(Ogre.MaterialSerializer*,Ogre.MaterialSerializer.SerializeEvent,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Material!System.Runtime.CompilerServices.IsConst*)">
Called when material section event raised.					
			@param ser The MaterialSerializer instance that writes the given material.
			@param stage The current section writing stage.
			@param skip May set to true by sub-class instances in order to skip the following section write.
			This parameter relevant only when stage equals MSE_PRE_WRITE. 
			@param mat The material that is being written.			

</member>
        <member name="T:Ogre.MaterialSerializer.Listener">
Class that allows listening in on the various stages of material serialization process.
		Sub-classing it enable extending the attribute set of any part in the material.

</member>
        <member name="T:Ogre.MaterialSerializer">
Class for serializing Materials to / from a .material script.
</member>
        <member name="D:Ogre.ATTRIBUTE_PARSER">
Function def for material attribute parser; return value determines if the next line should be {
</member>
        <member name="T:Ogre.MaterialScriptContext">
Struct for holding the script context while parsing. 
</member>
        <member name="T:Ogre.MaterialScriptProgramDefinition">
Struct for holding a program definition which is in progress. 
</member>
        <member name="T:Ogre.MaterialScriptSection">
\addtogroup Core
	*  @{

\addtogroup Materials
	*  @{

Enum to identify material sections. 
</member>
        <member name="T:Ogre.ManualObjectFactory">
Factory object for creating ManualObject instances 
</member>
        <member name="M:Ogre.ManualObject.copyTempVertexToBuffer">
Copy current temp vertex into buffer
</member>
        <member name="M:Ogre.ManualObject.resizeTempIndexBufferIfNeeded(System.UInt32)">
Resize the temp index buffer?
</member>
        <member name="M:Ogre.ManualObject.resizeTempVertexBufferIfNeeded(System.UInt32)">
Resize the temp vertex buffer?
</member>
        <member name="M:Ogre.ManualObject.resetTempAreas">
Delete temp buffers and reset init counts
</member>
        <member name="F:Ogre.ManualObject.mKeepDeclarationOrder">
Keep declaration order or let the queue optimize it
</member>
        <member name="F:Ogre.ManualObject.mUseIdentityView">
Whether to use identity view for sections
</member>
        <member name="F:Ogre.ManualObject.mUseIdentityProjection">
Whether to use identity projection for sections
</member>
        <member name="F:Ogre.ManualObject.mShadowRenderables">
List of shadow renderables
</member>
        <member name="F:Ogre.ManualObject.mEdgeList">
Edge list, used if stencil shadow casting is enabled 
</member>
        <member name="F:Ogre.ManualObject.mAnyIndexed">
Any indexed geometry on any sections?
</member>
        <member name="F:Ogre.ManualObject.mRadius">
Bounding sphere
</member>
        <member name="F:Ogre.ManualObject.mAABB">
Bounding box
</member>
        <member name="F:Ogre.ManualObject.mTexCoordIndex">
Current texture coordinate
</member>
        <member name="F:Ogre.ManualObject.mEstIndexCount">
Estimated index count
</member>
        <member name="F:Ogre.ManualObject.mEstVertexCount">
Estimated vertex count
</member>
        <member name="F:Ogre.ManualObject.mDeclSize">
Current declaration vertex size
</member>
        <member name="F:Ogre.ManualObject.mTempIndexSize">
System memory allocation size, in bytes
</member>
        <member name="F:Ogre.ManualObject.mTempIndexBuffer">
System-memory buffer whilst we establish the size required
</member>
        <member name="F:Ogre.ManualObject.mTempVertexSize">
System memory allocation size, in bytes
</member>
        <member name="F:Ogre.ManualObject.mTempVertexBuffer">
System-memory buffer whilst we establish the size required
</member>
        <member name="F:Ogre.ManualObject.mTempVertexPending">
Temp vertex data to copy?
</member>
        <member name="F:Ogre.ManualObject.mFirstVertex">
First vertex indicator
</member>
        <member name="F:Ogre.ManualObject.mTempVertex">
Temp storage
</member>
        <member name="T:Ogre.ManualObject.TempVertex">
Temporary vertex structure
</member>
        <member name="F:Ogre.ManualObject.mCurrentUpdating">
Are we updating?
</member>
        <member name="F:Ogre.ManualObject.mCurrentSection">
Current section
</member>
        <member name="F:Ogre.ManualObject.mSectionList">
List of subsections
</member>
        <member name="F:Ogre.ManualObject.mDynamic">
Dynamic?
</member>
        <member name="M:Ogre.ManualObject.visitRenderables(Ogre.Renderable.Visitor*,System.Boolean)">
@copydoc MovableObject::visitRenderables
</member>
        <member name="M:Ogre.ManualObject.ManualObjectSectionShadowRenderable.getWorldTransforms(Ogre.Matrix4*)">
Overridden from ShadowRenderable
</member>
        <member name="T:Ogre.ManualObject.ManualObjectSectionShadowRenderable">
Nested class to allow shadows. 
</member>
        <member name="M:Ogre.ManualObject.ManualObjectSection.getLights">
@copydoc Renderable::getLights. 
</member>
        <member name="M:Ogre.ManualObject.ManualObjectSection.getSquaredViewDepth(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
@copydoc Renderable::getSquaredViewDepth. 
</member>
        <member name="M:Ogre.ManualObject.ManualObjectSection.getWorldTransforms(Ogre.Matrix4*)">
@copydoc Renderable::getWorldTransforms. 
</member>
        <member name="M:Ogre.ManualObject.ManualObjectSection.getRenderOperation(Ogre.RenderOperation*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc Renderable::getRenderOperation. 
</member>
        <member name="M:Ogre.ManualObject.ManualObjectSection.getMaterial">
@copydoc Renderable::getMaterial. 
</member>
        <member name="M:Ogre.ManualObject.ManualObjectSection.get32BitIndices">
Get whether we need 32-bit indices
</member>
        <member name="M:Ogre.ManualObject.ManualObjectSection.set32BitIndices(System.Boolean)">
Set whether we need 32-bit indices
</member>
        <member name="M:Ogre.ManualObject.ManualObjectSection.setMaterialName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
update the material name in use
</member>
        <member name="M:Ogre.ManualObject.ManualObjectSection.getMaterialGroup">
Retrieve the material group in use
</member>
        <member name="M:Ogre.ManualObject.ManualObjectSection.getMaterialName">
Retrieve the material name in use
</member>
        <member name="M:Ogre.ManualObject.ManualObjectSection.getRenderOperation">
Retrieve render operation for manipulation
</member>
        <member name="T:Ogre.ManualObject.ManualObjectSection">
Built, renderable section of geometry
</member>
        <member name="M:Ogre.ManualObject.getShadowVolumeRenderableIterator(Ogre.ShadowTechnique,Ogre.Light!System.Runtime.CompilerServices.IsConst*,Ogre.HardwareIndexBufferSharedPtr*,System.Boolean,System.Single,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Implement this method to enable stencil shadows. 
</member>
        <member name="M:Ogre.ManualObject.hasEdgeList">
Overridden member from ShadowCaster. 
</member>
        <member name="M:Ogre.ManualObject.getEdgeList">
Implement this method to enable stencil shadows. 
</member>
        <member name="M:Ogre.ManualObject._updateRenderQueue(Ogre.RenderQueue*)">
@copydoc MovableObject::_updateRenderQueue. 
</member>
        <member name="M:Ogre.ManualObject.getBoundingRadius">
@copydoc MovableObject::getBoundingRadius. 
</member>
        <member name="M:Ogre.ManualObject.getBoundingBox">
@copydoc MovableObject::getBoundingBox. 
</member>
        <member name="M:Ogre.ManualObject.getMovableType">
@copydoc MovableObject::getMovableType. 
</member>
        <member name="M:Ogre.ManualObject.getKeepDeclarationOrder">
Gets whether or not the declaration order is to be kept or not.
		@return A flag indication if the declaration order will be kept when 
			queuing the renderables.

</member>
        <member name="M:Ogre.ManualObject.setKeepDeclarationOrder(System.Boolean)">
Sets whether or not to keep the original declaration order when 
			queuing the renderables.
		@remarks
			This overrides the default behavior of the rendering queue, 
			specifically stating the desired order of rendering. Might result in a 
			performance loss, but lets the user to have more direct control when 
			creating geometry through this class.
		@param keepOrder Whether to keep the declaration order or not.

</member>
        <member name="M:Ogre.ManualObject.getNumSections">
Retrieves the number of ManualObjectSection objects making up this ManualObject.

</member>
        <member name="M:Ogre.ManualObject.getSection(System.UInt32)">
Gets a pointer to a ManualObjectSection, i.e. a part of a ManualObject.

</member>
        <member name="M:Ogre.ManualObject.setBoundingBox(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the bounding box.
			@remarks Call this after having finished creating sections to modify the
				bounding box. E.g. if you're using ManualObject to create 2D overlays
				you can call things function to set an infinite bounding box so that
				the object always stays visible when attached.
			@see ManualObject::setUseIdentityProjection, ManualObject::setUseIdentityView,
				AxisAlignedBox::setInfinite 
</member>
        <member name="M:Ogre.ManualObject.getUseIdentityView">
Returns whether or not to use an 'identity' view.
		@remarks
			Usually ManualObjects will use a view matrix as determined
			by the active camera. However, if they want they can cancel this out
			and use an identity matrix, which means all geometry is assumed
			to be relative to camera space already. Useful for overlay rendering. 
			Normally you don't need to change this.
		@see ManualObject::setUseIdentityView

</member>
        <member name="M:Ogre.ManualObject.setUseIdentityView(System.Boolean)">
Sets whether or not to use an 'identity' view.
		@remarks
			Usually ManualObjects will use a view matrix as determined
			by the active camera. However, if they want they can cancel this out
			and use an identity matrix, which means all geometry is assumed
			to be relative to camera space already. Useful for overlay rendering. 
			Normally you don't need to change this. The default is false.
		@see ManualObject::getUseIdentityView

</member>
        <member name="M:Ogre.ManualObject.getUseIdentityProjection">
Returns whether or not to use an 'identity' projection.
		@remarks
			Usually ManualObjects will use a projection matrix as determined
			by the active camera. However, if they want they can cancel this out
			and use an identity projection, which effectively projects in 2D using
			a {-1, 1} view space. Useful for overlay rendering. Normally you don't
			need to change this.
		@see ManualObject::setUseIdentityProjection

</member>
        <member name="M:Ogre.ManualObject.setUseIdentityProjection(System.Boolean)">
Sets whether or not to use an 'identity' projection.
		@remarks
			Usually ManualObjects will use a projection matrix as determined
			by the active camera. However, if they want they can cancel this out
			and use an identity projection, which effectively projects in 2D using
			a {-1, 1} view space. Useful for overlay rendering. Normally you don't
			need to change this. The default is false.
		@see ManualObject::getUseIdentityProjection

</member>
        <member name="M:Ogre.ManualObject.convertToMesh(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Convert this object to a Mesh. 
		@remarks
			After you've finished building this object, you may convert it to 
			a Mesh if you want in order to be able to create many instances of
			it in the world (via Entity). This is optional, since this instance
			can be directly attached to a SceneNode itself, but of course only
			one instance of it can exist that way. 
		@note Only objects which use indexed geometry may be converted to a mesh.
		@param meshName The name to give the mesh
		@param groupName The resource group to create the mesh in

</member>
        <member name="M:Ogre.ManualObject.setMaterialName(System.UInt32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Alter the material for a subsection of this object after it has been
			specified.
		@remarks
			You specify the material to use on a section of this object during the
			call to begin(), however if you want to change the material afterwards
			you can do so by calling this method.
		@param subIndex The index of the subsection to alter
		@param name The name of the new material to use

</member>
        <member name="M:Ogre.ManualObject.end">
Finish defining the object and compile the final renderable version. 
		@note
			Will return a pointer to the finished section or NULL if the section was discarded (i.e. has zero vertices/indices).

</member>
        <member name="M:Ogre.ManualObject.quad(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
Add a set of 4 vertex indices to construct a quad (out of 2 
			triangles); this is a shortcut to calling index() 6 times, 
			or triangle() twice. It's only valid for triangle list operations.
		@note
			32-bit indexes are not supported on all cards and will only be used
            when required, if an index is &gt; 65535.
		@param i1, i2, i3 3 vertex indices from 0 to 4294967295 defining a face. 

</member>
        <member name="M:Ogre.ManualObject.triangle(System.UInt32,System.UInt32,System.UInt32)">
Add a set of 3 vertex indices to construct a triangle; this is a
			shortcut to calling index() 3 times. It is only valid for triangle 
			lists.
		@note
			32-bit indexes are not supported on all cards and will only be used
            when required, if an index is &gt; 65535.
		@param i1, i2, i3 3 vertex indices from 0 to 4294967295 defining a face. 

</member>
        <member name="M:Ogre.ManualObject.index(System.UInt32)">
Add a vertex index to construct faces / lines / points via indexing
			rather than just by a simple list of vertices. 
		@remarks
			You will have to call this 3 times for each face for a triangle list, 
			or use the alternative 3-parameter version. Other operation types
			require different numbers of indexes, @see RenderOperation::OperationType.
		@note
			32-bit indexes are not supported on all cards and will only be used
            when required, if an index is &gt; 65535.
		@param idx A vertex index from 0 to 4294967295. 

</member>
        <member name="M:Ogre.ManualObject.colour(System.Single,System.Single,System.Single,System.Single)">
Add a vertex colour to a vertex.
		@param r,g,b,a Colour components expressed as floating point numbers from 0-1

</member>
        <member name="M:Ogre.ManualObject.colour(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add a vertex colour to a vertex.

</member>
        <member name="M:Ogre.ManualObject.textureCoord(Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc ManualObject::textureCoord(Real)
</member>
        <member name="M:Ogre.ManualObject.textureCoord(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc ManualObject::textureCoord(Real)
</member>
        <member name="M:Ogre.ManualObject.textureCoord(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc ManualObject::textureCoord(Real)
</member>
        <member name="M:Ogre.ManualObject.textureCoord(System.Single,System.Single,System.Single,System.Single)">
@copydoc ManualObject::textureCoord(Real)
</member>
        <member name="M:Ogre.ManualObject.textureCoord(System.Single,System.Single,System.Single)">
@copydoc ManualObject::textureCoord(Real)
</member>
        <member name="M:Ogre.ManualObject.textureCoord(System.Single,System.Single)">
@copydoc ManualObject::textureCoord(Real)
</member>
        <member name="M:Ogre.ManualObject.textureCoord(System.Single)">
Add a texture coordinate to the current vertex.
		@remarks
			You can call this method multiple times between position() calls
			to add multiple texture coordinates to a vertex. Each one can have
			between 1 and 3 dimensions, depending on your needs, although 2 is
			most common. There are several versions of this method for the 
			variations in number of dimensions.

</member>
        <member name="M:Ogre.ManualObject.tangent(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add a vertex tangent to the current vertex.
		@remarks
			Vertex tangents are most often used for dynamic lighting, and 
			their components should be normalised. 
			Also, using tangent() you enable VES_TANGENT vertex semantic, which is not
			supported on old non-SM2 cards.

</member>
        <member name="M:Ogre.ManualObject.normal(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add a vertex normal to the current vertex.
		@remarks
			Vertex normals are most often used for dynamic lighting, and 
			their components should be normalised.

</member>
        <member name="M:Ogre.ManualObject.position(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add a vertex position, starting a new vertex at the same time. 
		@remarks A vertex position is slightly special among the other vertex data
			methods like normal() and textureCoord(), since calling it indicates
			the start of a new vertex. All other vertex data methods you call 
			after this are assumed to be adding more information (like normals or
			texture coordinates) to the last vertex started with position().

</member>
        <member name="M:Ogre.ManualObject.beginUpdate(System.UInt32)">
Start the definition of an update to a part of the object.
		@remarks
			Using this method, you can update an existing section of the object
			efficiently. You do not have the option of changing the operation type
			obviously, since it must match the one that was used before. 
		@note If your sections are changing size, particularly growing, use
			estimateVertexCount and estimateIndexCount to pre-size the buffers a little
			larger than the initial needs to avoid buffer reconstruction.
		@param sectionIndex The index of the section you want to update. The first
			call to begin() would have created section 0, the second section 1, etc.

</member>
        <member name="M:Ogre.ManualObject.getDynamic">
Gets whether this object is marked as dynamic 
</member>
        <member name="M:Ogre.ManualObject.setDynamic(System.Boolean)">
Use before defining geometry to indicate that you intend to update the
			geometry regularly and want the internal structure to reflect that.

</member>
        <member name="M:Ogre.ManualObject.begin(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.RenderOperation.OperationType,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Start defining a part of the object.
		@remarks
			Each time you call this method, you start a new section of the
			object with its own material and potentially its own type of
			rendering operation (triangles, points or lines for example).
		@param materialName The name of the material to render this part of the
			object with.
		@param opType The type of operation to use to render. 

</member>
        <member name="M:Ogre.ManualObject.estimateIndexCount(System.UInt32)">
Estimate the number of indices ahead of time.
		@remarks
			Calling this helps to avoid memory reallocation when you define
			indices. Also very handy when using beginUpdate() to manage dynamic
			data - you can make the index buffer a little larger than the
			initial need to allow for growth later with this method.

</member>
        <member name="M:Ogre.ManualObject.estimateVertexCount(System.UInt32)">
Estimate the number of vertices ahead of time.
		@remarks
			Calling this helps to avoid memory reallocation when you define
			vertices. Also very handy when using beginUpdate() to manage dynamic
			data - you can make the vertex buffers a little larger than their
			initial needs to allow for growth later with this method.

</member>
        <member name="M:Ogre.ManualObject.clear">
Completely clear the contents of the object.
		@remarks
			Clearing the contents of this object and rebuilding from scratch
			is not the optimal way to manage dynamic vertex data, since the 
			buffers are recreated. If you want to keep the same structure but
			update the content within that structure, use beginUpdate() instead 
			of clear() begin(). However if you do want to modify the structure 
			from time to time you can do so by clearing and re-specifying the data.

</member>
        <member name="T:Ogre.ManualObject">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Class providing a much simplified interface to generating manual
	 	objects with custom geometry.
	@remarks
		Building one-off geometry objects manually usually requires getting
		down and dirty with the vertex buffer and vertex declaration API, 
		which some people find a steep learning curve. This class gives you 
		a simpler interface specifically for the purpose of building a 
		3D object simply and quickly. Note that if you intend to instance your
		object you will still need to become familiar with the Mesh class. 
	@par
		This class draws heavily on the interface for OpenGL 
		immediate-mode (glBegin, glVertex, glNormal etc), since this
		is generally well-liked by people. There are a couple of differences
		in the results though - internally this class still builds hardware 
		buffers which can be re-used, so you can render the resulting object
		multiple times without re-issuing all the same commands again. 
		Secondly, the rendering is not immediate, it is still queued just like
		all OGRE objects. This makes this object more efficient than the 
		equivalent GL immediate-mode commands, so it's feasible to use it for
		large objects if you really want to.
	@par
		To construct some geometry with this object:
		  -# If you know roughly how many vertices (and indices, if you use them)
		     you're going to submit, call estimateVertexCount and estimateIndexCount.
			 This is not essential but will make the process more efficient by saving
			 memory reallocations.
		  -# Call begin() to begin entering data
		  -# For each vertex, call position(), normal(), textureCoord(), colour()
		     to define your vertex data. Note that each time you call position()
			 you start a new vertex. Note that the first vertex defines the 
			 components of the vertex - you can't add more after that. For example
			 if you didn't call normal() in the first vertex, you cannot call it
			 in any others. You ought to call the same combination of methods per
			 vertex.
		  -# If you want to define triangles (or lines/points) by indexing into the vertex list, 
			 you can call index() as many times as you need to define them.
			 If you don't do this, the class will assume you want triangles drawn
			 directly as defined by the vertex list, i.e. non-indexed geometry. Note
			 that stencil shadows are only supported on indexed geometry, and that
			 indexed geometry is a little faster; so you should try to use it.
		  -# Call end() to finish entering data.
		  -# Optionally repeat the begin-end cycle if you want more geometry 
		  	using different rendering operation types, or different materials
	    After calling end(), the class will organise the data for that section
		internally and make it ready to render with. Like any other 
		MovableObject you should attach the object to a SceneNode to make it 
		visible. Other aspects like the relative render order can be controlled
		using standard MovableObject methods like setRenderQueueGroup.
	@par
		You can also use beginUpdate() to alter the geometry later on if you wish.
		If you do this, you should call setDynamic(true) before your first call 
		to begin(), and also consider using estimateVertexCount / estimateIndexCount
		if your geometry is going to be growing, to avoid buffer recreation during
		growth.
	@par
		Note that like all OGRE geometry, triangles should be specified in 
		anti-clockwise winding order (whether you're doing it with just
		vertices, or using indexes too). That is to say that the front of the
		face is the one where the vertices are listed in anti-clockwise order.

</member>
        <member name="M:Ogre.LogManager.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.LogManager.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.LogManager.setLogDetail(Ogre.LoggingLevel)">
Sets the level of detail of the default log.

</member>
        <member name="M:Ogre.LogManager.stream(Ogre.LogMessageLevel,System.Boolean)">
Get a stream on the default log. 
</member>
        <member name="M:Ogre.LogManager.logMessage(Ogre.LogMessageLevel,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Log a message to the default log (signature for backward compatibility).

</member>
        <member name="M:Ogre.LogManager.logMessage(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.LogMessageLevel,System.Boolean)">
Log a message to the default log.

</member>
        <member name="M:Ogre.LogManager.setDefaultLog(Ogre.Log*)">
Sets the passed in log as the default log.
        @returns The previous default log.

</member>
        <member name="M:Ogre.LogManager.destroyLog(Ogre.Log*)">
Closes and removes a log. 
</member>
        <member name="M:Ogre.LogManager.destroyLog(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Closes and removes a named log. 
</member>
        <member name="M:Ogre.LogManager.getDefaultLog">
Returns a pointer to the default log.

</member>
        <member name="M:Ogre.LogManager.getLog(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves a log managed by this class.

</member>
        <member name="M:Ogre.LogManager.createLog(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean,System.Boolean)">
Creates a new log with the given name.
            @param
                name The name to give the log e.g. 'Ogre.log'
            @param
                defaultLog If true, this is the default log output will be
                sent to if the generic logging methods on this class are
                used. The first log created is always the default log unless
                this parameter is set.
            @param
                debuggerOutput If true, output to this log will also be
                routed to the debugger's output window.
            @param
                suppressFileOutput If true, this is a logical rather than a physical
				log and no file output will be written. If you do this you should
				register a LogListener so log output is not lost.

</member>
        <member name="F:Ogre.LogManager.mDefaultLog">
The default log to which output is done
</member>
        <member name="F:Ogre.LogManager.mLogs">
A list of all the logs the manager can access
</member>
        <member name="T:Ogre.LogManager">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

The log manager handles the creation and retrieval of logs for the
        application.
        @remarks
            This class will create new log files and will retrieve instances
            of existing ones. Other classes wishing to log output can either
            create a fresh log or retrieve an existing one to output to.
            One log is the default log, and is the one written to when the
            logging methods of this class are called.
		@par
			By default, Root will instantiate a LogManager (which becomes the 
			Singleton instance) on construction, and will create a default log
			based on the Root construction parameters. If you want more control,
			for example redirecting log output right from the start or suppressing
			debug output, you need to create a LogManager yourself before creating
			a Root instance, then create a default log. Root will detect that 
			you've created one yourself and won't create one of its own, thus
			using all your logging preferences from the first instance.

</member>
        <member name="T:Ogre.Log.Stream.Flush">
Simple type to indicate a flush of the stream to the log
</member>
        <member name="M:Ogre.Log.removeListener(Ogre.LogListener*)">
@remarks
    Unregister a listener from this log
@param
    A valid listener derived class

</member>
        <member name="M:Ogre.Log.addListener(Ogre.LogListener*)">
@remarks
    Register a listener to this log
@param
    A valid listener derived class

</member>
        <member name="M:Ogre.Log.getLogDetail">
Gets the level of the log detail.

</member>
        <member name="M:Ogre.Log.setTimeStampEnabled(System.Boolean)">
@remarks
    Enable or disable time stamps.

</member>
        <member name="M:Ogre.Log.setLogDetail(Ogre.LoggingLevel)">
@remarks
    Sets the level of the log detail.

</member>
        <member name="M:Ogre.Log.setDebugOutputEnabled(System.Boolean)">
@remarks
    Enable or disable outputting log messages to the debugger.

</member>
        <member name="M:Ogre.Log.stream(Ogre.LogMessageLevel,System.Boolean)">
Get a stream object targetting this log. 
</member>
        <member name="M:Ogre.Log.logMessage(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.LogMessageLevel,System.Boolean)">
Log a message to the debugger and to log file (the default is
            "<code>OGRE.log</code>"),

</member>
        <member name="M:Ogre.Log.isTimeStampEnabled">
Get whether time stamps are printed for this log
</member>
        <member name="M:Ogre.Log.isFileOutputSuppressed">
Get whether file output is suppressed for this log
</member>
        <member name="M:Ogre.Log.isDebugOutputEnabled">
Get whether debug output is enabled for this log
</member>
        <member name="M:Ogre.Log.getName">
Return the name of the log
</member>
        <member name="M:Ogre.Log.Dispose">
@remarks
Default destructor.

</member>
        <member name="M:Ogre.Log.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
@remarks
    Usual constructor - called by LogManager.

</member>
        <member name="M:Ogre.LogListener.messageLogged(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.LogMessageLevel,System.Boolean,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@remarks
    This is called whenever the log receives a message and is about to write it out
@param message
    The message to be logged
@param lml
    The message level the log is using
@param maskDebug
    If we are printing to the console or not
@param logName
    the name of this log (so you can have several listeners for different logs, and identify them)

</member>
        <member name="T:Ogre.LogListener">
@remarks Pure Abstract class, derive this class and register to the Log to listen to log messages 
</member>
        <member name="T:Ogre.LogMessageLevel">
The importance of a logged message.

</member>
        <member name="T:Ogre.LoggingLevel">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

The level of detail to which the log will go into.

</member>
        <member name="T:Ogre.LightFactory">
Factory object for creating Light instances 
</member>
        <member name="F:Ogre.Light.mCustomParameters">
Stores the custom parameters for the light
</member>
        <member name="F:Ogre.Light.mCustomShadowCameraSetup">
Pointer to a custom shadow camera setup
</member>
        <member name="F:Ogre.Light.mDerivedTransformDirty">
Is the derived transform dirty?
</member>
        <member name="F:Ogre.Light.msMovableType">
Shared class-level name for Movable type
</member>
        <member name="M:Ogre.Light.initialiseAnimableDictionary(std.vector&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc AnimableObject::initialiseAnimableDictionary
</member>
        <member name="M:Ogre.Light.getAnimableDictionaryName">
@copydoc AnimableObject::getAnimableDictionaryName
</member>
        <member name="M:Ogre.Light.update">
internal method for synchronising with parent node (if any)
</member>
        <member name="M:Ogre.Light._updateCustomGpuParameter(System.UInt16,Ogre.GpuProgramParameters.AutoConstantEntry!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.GpuProgramParameters*)">
Update a custom GpuProgramParameters constant which is derived from 
            information only this Light knows.
        @remarks
            This method allows a Light to map in a custom GPU program parameter
            based on it's own data. This is represented by a GPU auto parameter
            of ACT_LIGHT_CUSTOM, and to allow there to be more than one of these per
            Light, the 'data' field on the auto parameter will identify
            which parameter is being updated and on which light. The implementation 
			of this method must identify the parameter being updated, and call a 'setConstant' 
            method on the passed in GpuProgramParameters object.
        @par
            You do not need to override this method if you're using the standard
            sets of data associated with the Renderable as provided by setCustomParameter
            and getCustomParameter. By default, the implementation will map from the
            value indexed by the 'constantEntry.data' parameter to a value previously
            set by setCustomParameter. But custom Renderables are free to override
            this if they want, in any case.
        @param paramIndex The index of the constant being updated
		@param constantEntry The auto constant entry from the program parameters
        @param params The parameters object which this method should call to 
            set the updated parameters.

</member>
        <member name="M:Ogre.Light.getCustomParameter(System.UInt16)">
Gets the custom value associated with this Light at the given index.
        @param
            @see setCustomParaemter for full details.

</member>
        <member name="M:Ogre.Light.setCustomParameter(System.UInt16,Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets a custom parameter for this Light, which may be used to 
            drive calculations for this specific Renderable, like GPU program parameters.
        @remarks
            Calling this method simply associates a numeric index with a 4-dimensional
            value for this specific Light. This is most useful if the material
            which this Renderable uses a vertex or fragment program, and has an 
            ACT_LIGHT_CUSTOM parameter entry. This parameter entry can refer to the
            index you specify as part of this call, thereby mapping a custom
            parameter for this renderable to a program parameter.
        @param index The index with which to associate the value. Note that this
            does not have to start at 0, and can include gaps. It also has no direct
            correlation with a GPU program parameter index - the mapping between the
            two is performed by the ACT_LIGHT_CUSTOM entry, if that is used.
        @param value The value to associate.

</member>
        <member name="M:Ogre.Light._setCameraRelative(Ogre.Camera*)">
Set the camera which this light should be relative to, for camera-relative rendering
</member>
        <member name="M:Ogre.Light._deriveShadowFarClipDistance(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Derive a shadow camera far distance from either the light, or
		from the main camera if the light doesn't have its own setting.

</member>
        <member name="M:Ogre.Light.getShadowFarClipDistance">
Get the far clip plane distance to be used by the shadow camera, if
		this light casts texture shadows.
		@remarks May be zero if the light doesn't have it's own far distance set;
		use _deriveShadowfarDistance for a version guaranteed to give a result.

</member>
        <member name="M:Ogre.Light.setShadowFarClipDistance(System.Single)">
Set the far clip plane distance to be used by the shadow camera, if
		this light casts texture shadows.
			@remarks This is different from the 'shadow far distance', which is
			always measured from the main camera. This distance is the far clip plane
			of the light camera.
			@param far The distance, or -1 to use the main camera setting

</member>
        <member name="M:Ogre.Light._deriveShadowNearClipDistance(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Derive a shadow camera near distance from either the light, or
			from the main camera if the light doesn't have its own setting.

</member>
        <member name="M:Ogre.Light.getShadowNearClipDistance">
Get the near clip plane distance to be used by the shadow camera, if
		this light casts texture shadows.
		@remarks May be zero if the light doesn't have it's own near distance set;
			use _deriveShadowNearDistance for a version guaranteed to give a result.

</member>
        <member name="M:Ogre.Light.setShadowNearClipDistance(System.Single)">
Set the near clip plane distance to be used by the shadow camera, if
		this light casts texture shadows.
		@param near The distance, or -1 to use the main camera setting

</member>
        <member name="M:Ogre.Light.getShadowFarDistance">
Gets the maximum distance away from the camera that shadows
        by this light will be visible.

</member>
        <member name="M:Ogre.Light.resetShadowFarDistance">
Tells the light to use the shadow far distance of the SceneManager

</member>
        <member name="M:Ogre.Light.setShadowFarDistance(System.Single)">
Sets the maximum distance away from the camera that shadows
        by this light will be visible.
        @remarks
        Shadow techniques can be expensive, therefore it is a good idea
        to limit them to being rendered close to the camera if possible,
        and to skip the expense of rendering shadows for distance objects.
        This method allows you to set the distance at which shadows will no
        longer be rendered.
        @note
        Each shadow technique can interpret this subtely differently.
        For example, one technique may use this to eliminate casters,
        another might use it to attenuate the shadows themselves.
        You should tweak this value to suit your chosen shadow technique
        and scene setup.

</member>
        <member name="M:Ogre.Light._getIndexInFrame">
Gets the index at which this light is in the current render. 
		@remarks
			Lights will be present in the in a list for every renderable,
			detected and sorted appropriately, and sometimes it's useful to know 
			what position in that list a given light occupies. This can vary 
			from frame to frame (and object to object) so you should not use this
			value unless you're sure the context is correct.

</member>
        <member name="M:Ogre.Light.visitRenderables(Ogre.Renderable.Visitor*,System.Boolean)">
@copydoc MovableObject::visitRenderables
</member>
        <member name="M:Ogre.Light.getCustomShadowCameraSetup">
return a pointer to the custom shadow camera setup (null means use SceneManager global version). 
</member>
        <member name="M:Ogre.Light.resetCustomShadowCameraSetup">
Reset the shadow camera setup to the default. 
		@see ShadowCameraSetup

</member>
        <member name="M:Ogre.Light.setCustomShadowCameraSetup(Ogre.SharedPtr&lt;Ogre.ShadowCameraSetup&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set this light to use a custom shadow camera when rendering texture shadows.
		@remarks
			This changes the shadow camera setup for just this light,  you can set
			the shadow camera setup globally using SceneManager::setShadowCameraSetup
		@see ShadowCameraSetup

</member>
        <member name="M:Ogre.Light.createAnimableValue(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc AnimableObject::createAnimableValue
</member>
        <member name="M:Ogre.Light.getTypeFlags">
Override to return specific type flag
</member>
        <member name="M:Ogre.Light._getFrustumClipVolumes(Ogre.Camera!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst)">
Internal method for calculating the clip volumes outside of the 
            frustum which can be used to determine which objects are casting
            shadow on the frustum as a whole. 
        @remarks Each of the volumes is a pyramid for a point/spot light and
            a cuboid for a directional light. 

</member>
        <member name="M:Ogre.Light._getNearClipVolume(Ogre.Camera!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst)">
Internal method for calculating the 'near clip volume', which is
            the volume formed between the near clip rectangle of the 
            camera and the light.
        @remarks This volume is a pyramid for a point/spot light and
            a cuboid for a directional light. It can used to detect whether
            an object could be casting a shadow on the viewport. Note that
            the reference returned is to a shared volume which will be 
            reused across calls to this method.

</member>
        <member name="M:Ogre.Light.getAs4DVector(System.Boolean)">
Gets the details of this light as a 4D vector.
		@remarks
			Getting details of a light as a 4D vector can be useful for
			doing general calculations between different light types; for
			example the vector can represent both position lights (w=1.0f)
			and directional lights (w=0.0f) and be used in the same 
			calculations.
		@param cameraRelativeIfSet If set to true, returns data in camera-relative units if that's been set up (render use)

</member>
        <member name="M:Ogre.Light.getBoundingRadius">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.Light.setVisible(System.Boolean)">
Overridden from MovableObject.
        @remarks
            Although lights themselves are not 'visible', setting a light to invisible
            means it no longer affects the scene.

</member>
        <member name="M:Ogre.Light.getDerivedDirection">
Retrieves the direction of the light including any transform from nodes it is attached to. 
</member>
        <member name="M:Ogre.Light.getDerivedPosition(System.Boolean)">
Retrieves the position of the light including any transform from nodes it is attached to. 
		@param cameraRelativeIfSet If set to true, returns data in camera-relative units if that's been set up (render use)

</member>
        <member name="M:Ogre.Light.getMovableType">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.Light._updateRenderQueue(Ogre.RenderQueue*)">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.Light.getBoundingBox">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.Light._notifyMoved">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.Light._notifyAttached(Ogre.Node*,System.Boolean)">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.Light.getPowerScale">
Set the scaling factor which indicates the relative power of a 
			light.

</member>
        <member name="M:Ogre.Light.setPowerScale(System.Single)">
Set a scaling factor to indicate the relative power of a light.
		@remarks
			This factor is only useful in High Dynamic Range (HDR) rendering.
			You can bind it to a shader variable to take it into account,
			@see GpuProgramParameters
		@param power The power rating of this light, default is 1.0.

</member>
        <member name="M:Ogre.Light.setSpotlightFalloff(System.Single)">
Sets the falloff between the inner and outer cones of the spotlight.

</member>
        <member name="M:Ogre.Light.setSpotlightOuterAngle(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the angle covered by the spotlights outer cone.

</member>
        <member name="M:Ogre.Light.setSpotlightInnerAngle(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the angle covered by the spotlights inner cone.

</member>
        <member name="M:Ogre.Light.getSpotlightFalloff">
Returns the falloff between the inner and outer cones of the spotlight.

</member>
        <member name="M:Ogre.Light.getSpotlightOuterAngle">
Returns the angle covered by the spotlights outer cone.

</member>
        <member name="M:Ogre.Light.getSpotlightInnerAngle">
Returns the angle covered by the spotlights inner cone.

</member>
        <member name="M:Ogre.Light.setSpotlightRange(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Sets the range of a spotlight, i.e. the angle of the inner and outer cones and the rate of falloff between them.
            @param
                innerAngle Angle covered by the bright inner cone
                @node
                    The inner cone applicable only to Direct3D, it'll always treat as zero in OpenGL.
            @param
                outerAngle Angle covered by the outer cone
            @param
                falloff The rate of falloff between the inner and outer cones. 1.0 means a linear falloff, less means slower falloff, higher means faster falloff.

</member>
        <member name="M:Ogre.Light.getDirection">
Returns the light's direction.
            @remarks
                Applicable only to the spotlight and directional light types.

</member>
        <member name="M:Ogre.Light.setDirection(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the direction in which a light points.
            @remarks
                Applicable only to the spotlight and directional light types.
            @note
                This will be overridden if the light is attached to a SceneNode.

</member>
        <member name="M:Ogre.Light.setDirection(System.Single,System.Single,System.Single)">
Sets the direction in which a light points.
            @remarks
                Applicable only to the spotlight and directional light types.
            @note
                This will be overridden if the light is attached to a SceneNode.

</member>
        <member name="M:Ogre.Light.getPosition">
Returns the position of the light.
            @note
                Applicable to point lights and spotlights only.

</member>
        <member name="M:Ogre.Light.setPosition(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the position of the light.
            @remarks
                Applicable to point lights and spotlights only.
            @note
                This will be overridden if the light is attached to a SceneNode.

</member>
        <member name="M:Ogre.Light.setPosition(System.Single,System.Single,System.Single)">
Sets the position of the light.
            @remarks
                Applicable to point lights and spotlights only.
            @note
                This will be overridden if the light is attached to a SceneNode.

</member>
        <member name="M:Ogre.Light.getAttenuationQuadric">
Returns the quadric factor in the attenuation formula.

</member>
        <member name="M:Ogre.Light.getAttenuationLinear">
Returns the linear factor in the attenuation formula.

</member>
        <member name="M:Ogre.Light.getAttenuationConstant">
Returns the constant factor in the attenuation formula.

</member>
        <member name="M:Ogre.Light.getAttenuationRange">
Returns the absolute upper range of the light.

</member>
        <member name="M:Ogre.Light.setAttenuation(System.Single,System.Single,System.Single,System.Single)">
Sets the attenuation parameters of the light source i.e. how it diminishes with distance.
            @remarks
                Lights normally get fainter the further they are away. Also, each light is given a maximum range
                beyond which it cannot affect any objects.
            @par
                Light attenuation is not applicable to directional lights since they have an infinite range and
                constant intensity.
            @par
                This follows a standard attenuation approach - see any good 3D text for the details of what they mean
                since i don't have room here!
            @param
                range The absolute upper range of the light in world units
            @param
                constant The constant factor in the attenuation formula: 1.0 means never attenuate, 0.0 is complete attenuation
            @param
                linear The linear factor in the attenuation formula: 1 means attenuate evenly over the distance
            @param
                quadratic The quadratic factor in the attenuation formula: adds a curvature to the attenuation formula.

</member>
        <member name="M:Ogre.Light.getSpecularColour">
Returns the colour of specular light given off by this light source.

</member>
        <member name="M:Ogre.Light.setSpecularColour(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the colour of the specular light given off by this source.
            @remarks
                Material objects have ambient, diffuse and specular values which indicate how much of each type of
                light an object reflects. This value denotes the amount and colour of this type of light the light
                exudes into the scene. The actual appearance of objects is a combination of the two.
            @par
                Specular light affects the appearance of shiny highlights on objects, and is also dependent on the
                'shininess' Material value.

</member>
        <member name="M:Ogre.Light.setSpecularColour(System.Single,System.Single,System.Single)">
Sets the colour of the specular light given off by this source.
            @remarks
                Material objects have ambient, diffuse and specular values which indicate how much of each type of
                light an object reflects. This value denotes the amount and colour of this type of light the light
                exudes into the scene. The actual appearance of objects is a combination of the two.
            @par
                Specular light affects the appearance of shiny highlights on objects, and is also dependent on the
                'shininess' Material value.

</member>
        <member name="M:Ogre.Light.getDiffuseColour">
Returns the colour of the diffuse light given off by this light source (see setDiffuseColour for more info).

</member>
        <member name="M:Ogre.Light.setDiffuseColour(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the colour of the diffuse light given off by this source.
            @remarks
                Material objects have ambient, diffuse and specular values which indicate how much of each type of
                light an object reflects. This value denotes the amount and colour of this type of light the light
                exudes into the scene. The actual appearance of objects is a combination of the two.
            @par
                Diffuse light simulates the typical light emanating from light sources and affects the base colour
                of objects together with ambient light.

</member>
        <member name="M:Ogre.Light.setDiffuseColour(System.Single,System.Single,System.Single)">
Sets the colour of the diffuse light given off by this source.
            @remarks
                Material objects have ambient, diffuse and specular values which indicate how much of each type of
                light an object reflects. This value denotes the amount and colour of this type of light the light
                exudes into the scene. The actual appearance of objects is a combination of the two.
            @par
                Diffuse light simulates the typical light emanating from light sources and affects the base colour
                of objects together with ambient light.

</member>
        <member name="M:Ogre.Light.getType">
Returns the light type.

</member>
        <member name="M:Ogre.Light.setType(Ogre.Light.LightTypes)">
Sets the type of light - see LightTypes for more info.

</member>
        <member name="M:Ogre.Light.Dispose">
Standard destructor.

</member>
        <member name="M:Ogre.Light.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Normal constructor. Should not be called directly, but rather the SceneManager::createLight method should be used.

</member>
        <member name="M:Ogre.Light.#ctor">
Default constructor (for Python mainly).

</member>
        <member name="F:LT_SPOTLIGHT">
Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff
</member>
        <member name="F:LT_DIRECTIONAL">
Directional lights simulate parallel light beams from a distant source, hence have direction but no position
</member>
        <member name="F:LT_POINT">
Point light sources give off light equally in all directions, so require only position not direction
</member>
        <member name="T:Ogre.Light.LightTypes">
Defines the type of light
</member>
        <member name="M:Ogre.Light._calcTempSquareDist(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
internal method for calculating current squared distance from some world position
</member>
        <member name="F:Ogre.Light.tempSquareDist">
Temp tag used for sorting
</member>
        <member name="T:Ogre.Light">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Representation of a dynamic light source in the scene.
        @remarks
            Lights are added to the scene like any other object. They contain various
            parameters like type, position, attenuation (how light intensity fades with
            distance), colour etc.
        @par
            The defaults when a light is created is pure white diffuse light, with no
            attenuation (does not decrease with distance) and a range of 1000 world units.
        @par
            Lights are created by using the SceneManager::createLight method. They can subsequently be
            added to a SceneNode if required to allow them to move relative to a node in the scene. A light attached
            to a SceneNode is assumed to have a base position of (0,0,0) and a direction of (0,0,1) before modification
            by the SceneNode's own orientation. If not attached to a SceneNode,
            the light's position and direction is as set using setPosition and setDirection.
        @par
            Remember also that dynamic lights rely on modifying the colour of vertices based on the position of
            the light compared to an object's vertex normals. Dynamic lighting will only look good if the
            object being lit has a fair level of tessellation and the normals are properly set. This is particularly
            true for the spotlight which will only look right on highly tessellated models. In the future OGRE may be
            extended for certain scene types so an alternative to the standard dynamic lighting may be used, such
            as dynamic lightmaps.

</member>
        <member name="M:Ogre.DefaultShadowCameraSetup.getShadowCamera(Ogre.SceneManager!System.Runtime.CompilerServices.IsConst*,Ogre.Camera!System.Runtime.CompilerServices.IsConst*,Ogre.Viewport!System.Runtime.CompilerServices.IsConst*,Ogre.Light!System.Runtime.CompilerServices.IsConst*,Ogre.Camera*,System.UInt32)">
Default shadow camera setup
</member>
        <member name="M:Ogre.DefaultShadowCameraSetup.Dispose">
Destructor
</member>
        <member name="M:Ogre.DefaultShadowCameraSetup.#ctor">
Default constructor
</member>
        <member name="T:Ogre.DefaultShadowCameraSetup">
Implements default shadow camera setup
        @remarks
            This implements the default shadow camera setup algorithm.  This is what might
			be referred to as "normal" shadow mapping.  

</member>
        <member name="M:Ogre.ShadowCameraSetup.Dispose">
Need virtual destructor in case subclasses use it
</member>
        <member name="M:Ogre.ShadowCameraSetup.getShadowCamera(Ogre.SceneManager!System.Runtime.CompilerServices.IsConst*,Ogre.Camera!System.Runtime.CompilerServices.IsConst*,Ogre.Viewport!System.Runtime.CompilerServices.IsConst*,Ogre.Light!System.Runtime.CompilerServices.IsConst*,Ogre.Camera*,System.UInt32)">
Function to implement -- must set the shadow camera properties
</member>
        <member name="T:Ogre.ShadowCameraSetup">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

This class allows you to plug in new ways to define the camera setup when
		rendering and projecting shadow textures.
	@remarks
		The default projection used when rendering shadow textures is a uniform
		frustum. This is pretty straight forward but doesn't make the best use of 
		the space in the shadow map since texels closer to the camera will be larger, 
		resulting in 'jaggies'. There are several ways to distribute the texels
		in the shadow texture differently, and this class allows you to override
		that. 
	@par
		Ogre is provided with several alternative shadow camera setups, including
		LiSPSM (LiSPSMShadowCameraSetup) and Plane Optimal (PlaneOptimalShadowCameraSetup).
		Others can of course be written to incorporate other algorithms. All you 
		have to do is instantiate one of these classes and enable it using 
		SceneManager::setShadowCameraSetup (global) or Light::setCustomShadowCameraSetup
		(per light). In both cases the instance is wrapped in a SharedPtr which means
		it will  be deleted automatically when no more references to it exist.
	@note
        Shadow map matrices, being projective matrices, have 15 degrees of freedom.
		3 of these degrees of freedom are fixed by the light's position.  4 are used to
		affinely affect z values.  6 affinely affect u,v sampling.  2 are projective
		degrees of freedom.  This class is meant to allow custom methods for 
		handling optimization.

</member>
        <member name="M:Ogre.HighLevelGpuProgramManager.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.HighLevelGpuProgramManager.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.HighLevelGpuProgramManager.createProgram(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!S">
Create a new, unloaded HighLevelGpuProgram. 
		@par
			This method creates a new program of the type specified as the second and third parameters.
			You will have to call further methods on the returned program in order to 
			define the program fully before you can load it.
		@param name The identifying name of the program
        @param groupName The name of the resource group which this program is
            to be a member of
		@param language Code of the language to use (e.g. "cg")
		@param gptype The type of program to create

</member>
        <member name="M:Ogre.HighLevelGpuProgramManager.isLanguageSupported(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether a given high-level language is supported. 
</member>
        <member name="M:Ogre.HighLevelGpuProgramManager.removeFactory(Ogre.HighLevelGpuProgramFactory*)">
Remove a factory object for high-level programs of a given language. 
</member>
        <member name="M:Ogre.HighLevelGpuProgramManager.addFactory(Ogre.HighLevelGpuProgramFactory*)">
Add a new factory object for high-level programs of a given language. 
</member>
        <member name="M:Ogre.HighLevelGpuProgramManager.createImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.">
@copydoc ResourceManager::createImpl
</member>
        <member name="F:Ogre.HighLevelGpuProgramManager.mUnifiedFactory">
Factory for unified high-level programs
</member>
        <member name="F:Ogre.HighLevelGpuProgramManager.mNullFactory">
Factory for dealing with programs for languages we can't create
</member>
        <member name="F:Ogre.HighLevelGpuProgramManager.mFactories">
Factories capable of creating HighLevelGpuProgram instances
</member>
        <member name="T:Ogre.HighLevelGpuProgramManager">
This ResourceManager manages high-level vertex and fragment programs. 
	@remarks
		High-level vertex and fragment programs can be used instead of assembler programs
		as managed by GpuProgramManager; however they typically result in a GpuProgram
		being created as a derivative of the high-level program. High-level programs are
		easier to write, and can often be API-independent, unlike assembler programs. 
	@par
		This class not only manages the programs themselves, it also manages the factory
		classes which allow the creation of high-level programs using a variety of high-level
		syntaxes. Plugins can be created which register themselves as high-level program
		factories and as such the engine can be extended to accept virtually any kind of
		program provided a plugin is written.

</member>
        <member name="M:Ogre.HighLevelGpuProgramFactory.getLanguage">
Get the name of the language this factory creates programs for
</member>
        <member name="T:Ogre.HighLevelGpuProgramFactory">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

Interface definition for factories of HighLevelGpuProgram. 
</member>
        <member name="M:Ogre.HighLevelGpuProgramPtr.op_Assign(Ogre.GpuProgramPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Operator used to convert a GpuProgramPtr to a HighLevelGpuProgramPtr
</member>
        <member name="M:Ogre.HighLevelGpuProgramPtr.op_Assign(Ogre.SharedPtr&lt;Ogre.Resource&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Operator used to convert a ResourcePtr to a HighLevelGpuProgramPtr
</member>
        <member name="M:Ogre.HighLevelGpuProgram.getNamedConstants">
Override GpuProgram::getNamedConstants to ensure built
</member>
        <member name="M:Ogre.HighLevelGpuProgram.getConstantDefinitions">
Get the full list of GpuConstantDefinition instances.
		@note
		Only available if this parameters object has named parameters.

</member>
        <member name="M:Ogre.HighLevelGpuProgram._getBindingDelegate">
@copydoc GpuProgram::getBindingDelegate 
</member>
        <member name="M:Ogre.HighLevelGpuProgram.createParameters">
Creates a new parameters object compatible with this program definition. 
        @remarks
            Unlike low-level assembly programs, parameters objects are specific to the
            program and therefore must be created from it rather than by the 
            HighLevelGpuProgramManager. This method creates a new instance of a parameters
            object containing the definition of the parameters this program understands.

</member>
        <member name="M:Ogre.HighLevelGpuProgram.#ctor(Ogre.ResourceManager*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boo">
Constructor, should be used only by factory classes. 
</member>
        <member name="M:Ogre.HighLevelGpuProgram.unloadImpl">
@copydoc Resource::unloadImpl 
</member>
        <member name="M:Ogre.HighLevelGpuProgram.loadImpl">
@copydoc Resource::loadImpl 
</member>
        <member name="M:Ogre.HighLevelGpuProgram.buildConstantDefinitions">
Build the constant definition map, must be overridden.
		@note The implementation must fill in the (inherited) mConstantDefs field at a minimum, 
			and if the program requires that parameters are bound using logical 
			parameter indexes then the mFloatLogicalToPhysical and mIntLogicalToPhysical
			maps must also be populated.

</member>
        <member name="M:Ogre.HighLevelGpuProgram.populateParameterNames(Ogre.SharedPtr&lt;Ogre.GpuProgramParameters&gt;)">
Populate the passed parameters with name-&gt;index map
</member>
        <member name="M:Ogre.HighLevelGpuProgram.unloadHighLevelImpl">
Internal unload implementation, must be implemented by subclasses
</member>
        <member name="M:Ogre.HighLevelGpuProgram.createLowLevelImpl">
Internal method for creating an appropriate low-level program from this
        high-level program, must be implemented by subclasses. 
</member>
        <member name="M:Ogre.HighLevelGpuProgram.loadHighLevelImpl">
Internal load implementation, loads just the high-level portion, enough to 
            get parameters.

</member>
        <member name="M:Ogre.HighLevelGpuProgram.unloadHighLevel">
Internal unload high-level portion if loaded
</member>
        <member name="M:Ogre.HighLevelGpuProgram.loadHighLevel">
Internal load high-level portion if not loaded
</member>
        <member name="F:Ogre.HighLevelGpuProgram.mConstantDefsBuilt">
Have we built the name-&gt;index parameter map yet?
</member>
        <member name="F:Ogre.HighLevelGpuProgram.mAssemblerProgram">
The underlying assembler program
</member>
        <member name="F:Ogre.HighLevelGpuProgram.mHighLevelLoaded">
Whether the high-level program (and it's parameter defs) is loaded
</member>
        <member name="T:Ogre.HighLevelGpuProgram">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

Abstract base class representing a high-level program (a vertex or
        fragment program).
    @remarks
        High-level programs are vertex and fragment programs written in a high-level
        language such as Cg or HLSL, and as such do not require you to write assembler code
        like GpuProgram does. However, the high-level program does eventually 
        get converted (compiled) into assembler and then eventually microcode which is
        what runs on the GPU. As well as the convenience, some high-level languages like Cg allow
        you to write a program which will operate under both Direct3D and OpenGL, something
        which you cannot do with just GpuProgram (which requires you to write 2 programs and
        use each in a Technique to provide cross-API compatibility). Ogre will be creating
        a GpuProgram for you based on the high-level program, which is compiled specifically 
        for the API being used at the time, but this process is transparent.
    @par
        You cannot create high-level programs direct - use HighLevelGpuProgramManager instead.
        Plugins can register new implementations of HighLevelGpuProgramFactory in order to add
        support for new languages without requiring changes to the core Ogre API. To allow 
        custom parameters to be set, this class extends StringInterface - the application
        can query on the available custom parameters and get/set them without having to 
        link specifically with it.

</member>
        <member name="M:Ogre.HardwareOcclusionQuery.isStillOutstanding">
Lets you know when query is done, or still be processed by the Hardware
@return true if query isn't finished.

</member>
        <member name="M:Ogre.HardwareOcclusionQuery.getLastQuerysPixelcount">
Let's you get the last pixel count with out doing the hardware occlusion test
@return The last fragment count from the last test.
Remarks This function won't give you new values, just the old value.

</member>
        <member name="M:Ogre.HardwareOcclusionQuery.pullOcclusionQuery(System.UInt32*)">
      * Pulls the hardware occlusion query.
	  * @note Waits until the query result is available; use isStillOutstanding
	  *		if just want to test if the result is available.
      * @retval NumOfFragments will get the resulting number of fragments.
      * @return True if success or false if not.

</member>
        <member name="M:Ogre.HardwareOcclusionQuery.endOcclusionQuery">
Ends the hardware occlusion test

</member>
        <member name="M:Ogre.HardwareOcclusionQuery.Dispose">
Object destructor

</member>
        <member name="M:Ogre.HardwareOcclusionQuery.#ctor">
Object public member functions

Default object constructor


</member>
        <member name="T:Ogre.HardwareOcclusionQuery">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

 This is a abstract class that that provides the interface for the query class for 
 hardware occlusion.

 @author Lee Sandberg
 Updated on 13/8/2005 by Tuan Kuranes email: tuan.kuranes@free.fr

</member>
        <member name="T:Ogre.HardwarePixelBufferSharedPtr">
Shared pointer implementation used to share pixel buffers. 
</member>
        <member name="M:Ogre.HardwarePixelBuffer.getFormat">
Gets the native pixel format of this buffer
</member>
        <member name="M:Ogre.HardwarePixelBuffer.getDepth">
Gets the depth of this buffer
</member>
        <member name="M:Ogre.HardwarePixelBuffer.getHeight">
Gets the height of this buffer
</member>
        <member name="M:Ogre.HardwarePixelBuffer.getWidth">
Gets the width of this buffer
</member>
        <member name="M:Ogre.HardwarePixelBuffer.getRenderTarget(System.UInt32)">
Get a render target for this PixelBuffer, or a slice of it. The texture this
            was acquired from must have TU_RENDERTARGET set, otherwise it is possible to
            render to it and this method will throw an ERR_RENDERSYSTEM exception.
            @param slice    Which slice
            @returns A pointer to the render target. This pointer has the lifespan of this
            PixelBuffer.

</member>
        <member name="M:Ogre.HardwarePixelBuffer.blitToMemory(Ogre.PixelBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Convience function that blits this entire buffer to a pixelbox.
			The image is scaled as needed.
			@param src		PixelBox containing the source pixels and format in memory
			@note Only call this function when the buffer is unlocked. 

</member>
        <member name="M:Ogre.HardwarePixelBuffer.blitToMemory(Ogre.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.PixelBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copies a region of this pixelbuffer to normal memory.
		   	@param srcBox	Image::Box describing the source region of this buffer
		   	@param dst		PixelBox describing the destination pixels and format in memory
		   	@remarks The source and destination regions don't have to match, in which
		   	case scaling is done.
			@note Only call this function when the buffer is unlocked. 

</member>
        <member name="M:Ogre.HardwarePixelBuffer.blitFromMemory(Ogre.PixelBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Convenience function that blits a pixelbox from memory to the entire 
			buffer. The source image is scaled as needed.
			@param src		PixelBox containing the source pixels and format in memory
			@note Only call this function when the buffer is unlocked. 

</member>
        <member name="M:Ogre.HardwarePixelBuffer.blitFromMemory(Ogre.PixelBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copies a region from normal memory to a region of this pixelbuffer. The source
			image can be in any pixel format supported by OGRE, and in any size. 
		   	@param src		PixelBox containing the source pixels and format in memory
		   	@param dstBox	Image::Box describing the destination region in this buffer
            @remarks The source and destination regions dimensions don't have to match, in which
            case scaling is done. This scaling is generally done using a bilinear filter in hardware,
            but it is faster to pass the source image in the right dimensions.
			@note Only call this function when the buffer is unlocked. 

</member>
        <member name="M:Ogre.HardwarePixelBuffer.blit(Ogre.HardwarePixelBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Convenience function that blits the entire source pixel buffer to this buffer. 
			If source and destination dimensions don't match, scaling is done.
			@param src		PixelBox containing the source pixels and format in memory
			@note Only call this function when the buffer is unlocked. 

</member>
        <member name="M:Ogre.HardwarePixelBuffer.blit(Ogre.HardwarePixelBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copies a box from another PixelBuffer to a region of the 
        	this PixelBuffer. 
			@param dst		Source pixel buffer
        	@param srcBox	Image::Box describing the source region in src
        	@param dstBox	Image::Box describing the destination region in this buffer
			@remarks The source and destination regions dimensions don't have to match, in which
		   	case scaling is done. This scaling is generally done using a bilinear filter in hardware,
            but it is faster to pass the source image in the right dimensions.
			@note Only call this function when both  buffers are unlocked. 

</member>
        <member name="M:Ogre.HardwarePixelBuffer.writeData(System.UInt32,System.UInt32,System.Void!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
@copydoc HardwareBuffer::writeData
</member>
        <member name="M:Ogre.HardwarePixelBuffer.readData(System.UInt32,System.UInt32,System.Void*)">
@copydoc HardwareBuffer::readData
</member>
        <member name="M:Ogre.HardwarePixelBuffer.getCurrentLock">
Get the current locked region. This is the same value as returned
		    by lock(const Image::Box, LockOptions)
		    @returns PixelBox containing the locked region

</member>
        <member name="M:Ogre.HardwarePixelBuffer.lock(System.UInt32,System.UInt32,Ogre.HardwareBuffer.LockOptions)">
@copydoc HardwareBuffer::lock
</member>
        <member name="M:Ogre.HardwarePixelBuffer.lock(Ogre.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.HardwareBuffer.LockOptions)">
make every lock method from HardwareBuffer available.
        See http://www.research.att.com/~bs/bs_faq2.html#overloadderived

Lock the buffer for (potentially) reading / writing.
		    @param lockBox Region of the buffer to lock
		    @param options Locking options
		    @returns PixelBox containing the locked region, the pitches and
		    	the pixel format

</member>
        <member name="M:Ogre.HardwarePixelBuffer.#ctor(System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,Ogre.HardwareBuffer.Usage,System.Boolean,System.Boolean)">
Should be called by HardwareBufferManager
</member>
        <member name="M:Ogre.HardwarePixelBuffer._clearSliceRTT(System.UInt32)">
Internal implementation of unlock(), must be overridden in subclasses
Notify TextureBuffer of destruction of render target.
			Called by RenderTexture when destroyed.

</member>
        <member name="M:Ogre.HardwarePixelBuffer.lockImpl(System.UInt32,System.UInt32,Ogre.HardwareBuffer.LockOptions)">
Internal implementation of lock(), do not OVERRIDE or CALL this
for HardwarePixelBuffer implementations, but override the previous method
</member>
        <member name="M:Ogre.HardwarePixelBuffer.lockImpl(Ogre.Box!System.Runtime.CompilerServices.IsConst,Ogre.HardwareBuffer.LockOptions)">
Internal implementation of lock(), must be overridden in subclasses
</member>
        <member name="T:Ogre.HardwarePixelBuffer">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

Specialisation of HardwareBuffer for a pixel buffer. The
    	HardwarePixelbuffer abstracts an 1D, 2D or 3D quantity of pixels
    	stored by the rendering API. The buffer can be located on the card
    	or in main memory depending on its usage. One mipmap level of a
    	texture is an example of a HardwarePixelBuffer.

</member>
        <member name="M:Ogre.GpuProgramManager.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.GpuProgramManager.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.GpuProgramManager.getAvailableSharedParameters">
Get (const) access to the available shared parameter sets. 

</member>
        <member name="M:Ogre.GpuProgramManager.getSharedParameters(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieve a set of shared parameters, which can be used across many 
		GpuProgramParameters objects of different structures.

</member>
        <member name="M:Ogre.GpuProgramManager.createSharedParameters(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a new set of shared parameters, which can be used across many 
			GpuProgramParameters objects of different structures.
		@param name The name to give the shared parameters so you can refer to them
			later.

</member>
        <member name="M:Ogre.GpuProgramManager.getByName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Overrides the standard ResourceManager getByName method.
        @param name The name of the program to retrieve
        @param preferHighLevelPrograms If set to true (the default), high level programs will be
            returned in preference to low-level programs.

</member>
        <member name="M:Ogre.GpuProgramManager.create(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.GpuProgramType,std.basic_string&lt;System.SBy">
General create method, using specific create parameters
            instead of name / value pairs. 

</member>
        <member name="M:Ogre.GpuProgramManager.createProgramFromString(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!">
Create a GPU program from a string of assembly code.
        @remarks    
            Use this method in preference to the 'load' methods if you wish to define
            a GpuProgram, but not load it yet; useful for saving memory.
		@par
			The assembly code must be compatible with this manager - call the 
			getSupportedSyntax method for details of the supported syntaxes 
		@param name The identifying name to give this program, which can be used to
			retrieve this program later with getByName.
		@param groupName The name of the resource group
		@param code A string of assembly code which will form the program to run
		@param gptype The type of program to create.
        @param syntaxCode The name of the syntax to be used for this program e.g. arbvp1, vs_1_1

</member>
        <member name="M:Ogre.GpuProgramManager.createProgram(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Run">
Create a new, unloaded GpuProgram from a file of assembly. 
        @remarks    
            Use this method in preference to the 'load' methods if you wish to define
            a GpuProgram, but not load it yet; useful for saving memory.
		@par
			This method creates a new program of the type specified as the second parameter.
			As with all types of ResourceManager, this class will search for the file in
			all resource locations it has been configured to look in. 
		@param name The name of the program
		@param groupName The name of the resource group
		@param filename The file to load
        @param syntaxCode The name of the syntax to be used for this program e.g. arbvp1, vs_1_1
		@param gptype The type of program to create

</member>
        <member name="M:Ogre.GpuProgramManager.createParameters">
Creates a new GpuProgramParameters instance which can be used to bind
            parameters to your programs.
        @remarks
            Program parameters can be shared between multiple programs if you wish.

</member>
        <member name="M:Ogre.GpuProgramManager.isSyntaxSupported(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether a given syntax code (e.g. "ps_1_3", "fp20", "arbvp1") is supported. 
</member>
        <member name="M:Ogre.GpuProgramManager.getSupportedSyntax">
Returns the syntaxes that this manager supports. 
</member>
        <member name="M:Ogre.GpuProgramManager.loadFromString(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Ru">
Loads a GPU program from a string of assembly code.
		@remarks
			The assembly code must be compatible with this manager - call the 
			getSupportedSyntax method for details of the supported syntaxes 
		@param name The identifying name to give this program, which can be used to
			retrieve this program later with getByName.
		@param groupName The name of the resource group
		@param code A string of assembly code which will form the program to run
		@param gptype The type of program to create.
        @param syntaxCode The name of the syntax to be used for this program e.g. arbvp1, vs_1_1

</member>
        <member name="M:Ogre.GpuProgramManager.load(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.Comp">
Loads a GPU program from a file of assembly. 
		@remarks
			This method creates a new program of the type specified as the second parameter.
			As with all types of ResourceManager, this class will search for the file in
			all resource locations it has been configured to look in.
		@param name The name of the GpuProgram
		@param groupName The name of the resource group
		@param filename The file to load
		@param gptype The type of program to create
        @param syntaxCode The name of the syntax to be used for this program e.g. arbvp1, vs_1_1

</member>
        <member name="M:Ogre.GpuProgramManager.createImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.ManualRes">
Specialised create method with specific parameters
</member>
        <member name="T:Ogre.GpuProgramManager">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

</member>
        <member name="T:Ogre.EntityFactory">
Factory object for creating Entity instances 
</member>
        <member name="M:Ogre.Entity.getSkipAnimationStateUpdate">
Entity's skeleton's AnimationState will not be automatically updated when set to true.
		 Useful if you wish to handle AnimationState updates manually.

</member>
        <member name="M:Ogre.Entity.setSkipAnimationStateUpdate(System.Boolean)">
Entity's skeleton's AnimationState will not be automatically updated when set to true.
			Useful if you wish to handle AnimationState updates manually.

</member>
        <member name="M:Ogre.Entity._getMeshLodFactorTransformed">
Get the lod strategy transformation of the mesh lod factor. 
</member>
        <member name="M:Ogre.Entity.visitRenderables(Ogre.Renderable.Visitor*,System.Boolean)">
@copydoc MovableObject::visitRenderables
</member>
        <member name="M:Ogre.Entity.backgroundLoadingComplete(Ogre.Resource*)">
Resource::Listener hook to notify Entity that a delay-loaded Mesh is
			complete.

</member>
        <member name="M:Ogre.Entity._deinitialise">
Tear down the internal structures of this Entity, rendering it uninitialised. 
</member>
        <member name="M:Ogre.Entity._initialise(System.Boolean)">
Try to initialise the Entity from the underlying resources.
		@remarks
			This method builds the internal structures of the Entity based on it
			resources (Mesh, Skeleton). This may or may not succeed if the 
			resources it references have been earmarked for background loading,
			so you should check isInitialised afterwards to see if it was sucessful.
		@param forceReinitialise If true, this forces the Entity to tear down it's
			internal structures and try to rebuild them. Useful if you changed the
			content of a Mesh or Skeleton at runtime.

</member>
        <member name="M:Ogre.Entity.isInitialised">
Has this Entity been initialised yet?
		@remarks	
			If this returns false, it means this Entity hasn't been completely
			constructed yet from the underlying resources (Mesh, Skeleton), which 
			probably means they were delay-loaded and aren't available yet. This
			Entity won't render until it has been successfully initialised, nor
			will many of the manipulation methods function.

</member>
        <member name="M:Ogre.Entity._markBuffersUsedForAnimation">
Mark just this vertex data as animated.

</member>
        <member name="M:Ogre.Entity._getBuffersMarkedForAnimation">
Are buffers already marked as vertex animated? 
</member>
        <member name="M:Ogre.Entity.chooseVertexDataForBinding(System.Boolean)">
Choose which vertex data to bind to the renderer
</member>
        <member name="T:Ogre.Entity.VertexDataBindChoice">
Identify which vertex data we should be sending to the renderer
</member>
        <member name="M:Ogre.Entity.getVertexDataForBinding">
Retrieve the VertexData which should be used for GPU binding
</member>
        <member name="M:Ogre.Entity.getTypeFlags">
Override to return specific type flag
</member>
        <member name="M:Ogre.Entity._getVertexAnimTempBufferInfo">
Advanced method to get the temp buffer information for software
		morph animation.

</member>
        <member name="M:Ogre.Entity._getSkelAnimTempBufferInfo">
Advanced method to get the temp buffer information for software
		skeletal animation.

</member>
        <member name="M:Ogre.Entity._getHardwareVertexAnimVertexData">
Advanced method to get the hardware morph vertex information
        @note
            The positions/normals of the returned vertex data is in object space.

</member>
        <member name="M:Ogre.Entity._getSoftwareVertexAnimVertexData">
Advanced method to get the temporarily blended software vertex animation information
        @remarks
            Internal engine will eliminate software animation if possible, this
            information is unreliable unless added request for software animation
            via addSoftwareAnimationRequest.
        @note
            The positions/normals of the returned vertex data is in object space.

</member>
        <member name="M:Ogre.Entity._getSkelAnimVertexData">
Advanced method to get the temporarily blended skeletal vertex information
		for entities which are software skinned.
        @remarks
            Internal engine will eliminate software animation if possible, this
            information is unreliable unless added request for software animation
            via addSoftwareAnimationRequest.
        @note
            The positions/normals of the returned vertex data is in object space.

</member>
        <member name="M:Ogre.Entity._isSkeletonAnimated">
Tests if skeleton was animated.

</member>
        <member name="M:Ogre.Entity._isAnimated">
Tests if any animation applied to this entity.
        @remarks
            An entity is animated if any animation state is enabled, or any manual bone
            applied to the skeleton.

</member>
        <member name="M:Ogre.Entity._updateAnimation">
Advanced method to perform all the updates required for an animated entity.
		@remarks
		You don't normally need to call this, but it's here in case you wish
		to manually update the animation of an Entity at a specific point in
		time. Animation will not be updated more than once a frame no matter
		how many times you call this method.

</member>
        <member name="M:Ogre.Entity.refreshAvailableAnimationState">
Updates the internal animation state set to include the latest
		available animations from the attached skeleton.
		@remarks
		Use this method if you manually add animations to a skeleton, or have
		linked the skeleton to another for animation purposes since creating
		this entity.
		@note
		If you have called getAnimationState prior to calling this method,
		the pointers will still remain valid.

</member>
        <member name="M:Ogre.Entity.getSkeletonInstanceSharingSet">
Returns a pointer to the set of entities which share a SkeletonInstance.
If this instance does not share it's SkeletonInstance with other instances NULL will be returned

</member>
        <member name="M:Ogre.Entity.sharesSkeletonInstance">
Returns whether this entity shares it's SkeltonInstance with other entity instances.

</member>
        <member name="M:Ogre.Entity.stopSharingSkeletonInstance">
Stops sharing the SkeletonInstance with other entities.

</member>
        <member name="M:Ogre.Entity.hasVertexAnimation">
Returns whether or not this entity is either morph or pose animated.

</member>
        <member name="M:Ogre.Entity.shareSkeletonInstanceWith(Ogre.Entity*)">
Shares the SkeletonInstance with the supplied entity.
		*   Note that in order for this to work, both entities must have the same
		*   Skeleton.

</member>
        <member name="M:Ogre.Entity.removeSoftwareAnimationRequest(System.Boolean)">
Removes a request for software animation
        @remarks
            Calling this decrements the entity's internal counter of the number
            of requests for software animation.  If the counter is already zero
            then calling this method throws an exception.  The 'normalsAlso'
            flag if set to 'true' will also decrement the internal counter of
            number of requests for software animation of normals.

</member>
        <member name="M:Ogre.Entity.addSoftwareAnimationRequest(System.Boolean)">
Add a request for software animation
        @remarks
            Tells the entity to perform animation calculations for skeletal/vertex
            animations in software, regardless of the current setting of
            isHardwareAnimationEnabled().  Software animation will be performed
            any time one or more requests have been made.  If 'normalsAlso' is
            'true', then the entity will also do software blending on normal
            vectors, in addition to positions. This advanced method useful for
            situations in which access to actual mesh vertices is required,
            such as accurate collision detection or certain advanced shading
            techniques. When software animation is no longer needed,
            the caller of this method should always remove the request by calling
            removeSoftwareAnimationRequest(), passing the same value for
            'normalsAlso'.

</member>
        <member name="M:Ogre.Entity.getSoftwareAnimationNormalsRequests">
Returns the number of requests that have been made for software animation of normals
        @remarks
            If non-zero, and getSoftwareAnimationRequests() also returns non-zero,
            then software animation of normals will be performed in updateAnimation
            regardless of the current setting of isHardwareAnimationEnabled or any
            internal optimise for eliminate software animation. Currently it is not
            possible to force software animation of only normals. Consequently this
            value is always less than or equal to that returned by getSoftwareAnimationRequests().
            Requests for software animation of normals are made by calling the
            addSoftwareAnimationRequest() method with 'true' as the parameter.

</member>
        <member name="M:Ogre.Entity.getSoftwareAnimationRequests">
Returns the number of requests that have been made for software animation
        @remarks
            If non-zero then software animation will be performed in updateAnimation
            regardless of the current setting of isHardwareAnimationEnabled or any
            internal optimise for eliminate software animation. Requests for software
            animation are made by calling the addSoftwareAnimationRequest() method.

</member>
        <member name="M:Ogre.Entity._notifyAttached(Ogre.Node*,System.Boolean)">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.Entity.isHardwareAnimationEnabled">
Returns whether or not hardware animation is enabled.
		@remarks
		Because fixed-function indexed vertex blending is rarely supported
		by existing graphics cards, hardware animation can only be done if
		the vertex programs in the materials used to render an entity support
		it. Therefore, this method will only return true if all the materials
		assigned to this entity have vertex programs assigned, and all those
		vertex programs must support 'includes_morph_animation true' if using
        morph animation, 'includes_pose_animation true' if using pose animation
        and 'includes_skeletal_animation true' if using skeletal animation.

</member>
        <member name="M:Ogre.Entity.getSkeleton">
Get this Entity's personal skeleton instance. 
</member>
        <member name="M:Ogre.Entity.hasSkeleton">
Returns whether or not this entity is skeletally animated. 
</member>
        <member name="M:Ogre.Entity._getNumBoneMatrices">
Internal method for retrieving bone matrix information. 
</member>
        <member name="M:Ogre.Entity._getBoneMatrices">
Internal method for retrieving bone matrix information. 
</member>
        <member name="M:Ogre.Entity.getShadowVolumeRenderableIterator(Ogre.ShadowTechnique,Ogre.Light!System.Runtime.CompilerServices.IsConst*,Ogre.HardwareIndexBufferSharedPtr*,System.Boolean,System.Single,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Overridden member from ShadowCaster. 
</member>
        <member name="M:Ogre.Entity.hasEdgeList">
Overridden member from ShadowCaster. 
</member>
        <member name="M:Ogre.Entity.getEdgeList">
Overridden member from ShadowCaster. 
</member>
        <member name="M:Ogre.Entity.getWorldBoundingSphere(System.Boolean)">
@copy MovableObject::getWorldBoundingSphere 
</member>
        <member name="M:Ogre.Entity.getWorldBoundingBox(System.Boolean)">
@copy MovableObject::getWorldBoundingBox 
</member>
        <member name="M:Ogre.Entity.getBoundingRadius">
@see MovableObject::getBoundingRadius 
</member>
        <member name="M:Ogre.Entity.getAttachedObjectIterator">
Gets an iterator to the list of objects attached to bones on this entity. 
</member>
        <member name="M:Ogre.Entity.detachAllObjectsFromBone">
Detach all MovableObjects previously attached using attachObjectToBone
</member>
        <member name="M:Ogre.Entity.detachObjectFromBone(Ogre.MovableObject*)">
Detaches an object by pointer.
		@remarks
		Use this method to destroy a MovableObject which is attached to a bone of belonging this entity.
		But sometimes the object may be not in the child object list because it is a lod entity,
		this method can safely detect and ignore in this case and won't raise an exception.

</member>
        <member name="M:Ogre.Entity.detachObjectFromBone(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Detach a MovableObject previously attached using attachObjectToBone.
            If the movable object name is not found then an exception is raised.
        @param movableName is the name of the movable object to be detached.

</member>
        <member name="M:Ogre.Entity.attachObjectToBone(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.MovableObject*,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Attaches another object to a certain bone of the skeleton which this entity uses.
		@remarks
		This method can be used to attach another object to an animated part of this entity,
		by attaching it to a bone in the skeleton (with an offset if required). As this entity
		is animated, the attached object will move relative to the bone to which it is attached.
		@par
		An exception is thrown if the movable object is already attached to the bone, another bone or scenenode.
		If the entity has no skeleton or the bone name cannot be found then an exception is thrown.
		@param boneName The name of the bone (in the skeleton) to attach this object
		@param pMovable Pointer to the object to attach
		@param offsetOrientation An adjustment to the orientation of the attached object, relative to the bone.
		@param offsetPosition An adjustment to the position of the attached object, relative to the bone.
		@returns The TagPoint to which the object has been attached

</member>
        <member name="M:Ogre.Entity.setPolygonModeOverrideable(System.Boolean)">
Sets whether the polygon mode of this entire entity may be
		overridden by the camera detail settings.

</member>
        <member name="M:Ogre.Entity.setMaterialLodBias(System.Single,System.UInt16,System.UInt16)">
Sets a level-of-detail bias for the material detail of this entity.
		@remarks
		Level of detail reduction is normally applied automatically based on the Material
		settings. However, it is possible to influence this behaviour for this entity
		by adjusting the LOD bias. This 'nudges' the material level of detail used for this
		entity up or down depending on your requirements. You might want to use this
		if there was a particularly important entity in your scene which you wanted to
		detail better than the others, such as a player model.
		@par
		There are three parameters to this method; the first is a factor to apply; it
		defaults to 1.0 (no change), by increasing this to say 2.0, this entity would
		take twice as long to use a lower detail material, whilst at 0.5 this entity
		would use lower detail versions twice as quickly. The other 2 parameters are
		hard limits which let you set the maximum and minimum level-of-detail index
		to use, after all other calculations have been made. This lets you say that
		this entity should never be simplified, or that it can only use LODs below
		a certain level even when right next to the camera.
		@param factor Proportional factor to apply to the distance at which LOD is changed.
		Higher values increase the distance at which higher LODs are displayed (2.0 is
		twice the normal distance, 0.5 is half).
		@param maxDetailIndex The index of the maximum LOD this entity is allowed to use (lower
		indexes are higher detail: index 0 is the original full detail model).
		@param minDetailIndex The index of the minimum LOD this entity is allowed to use (higher
		indexes are lower detail. Use something like 99 if you want unlimited LODs (the actual
		LOD will be limited by the number of lod indexes used in the Material)

</member>
        <member name="M:Ogre.Entity.setMeshLodBias(System.Single,System.UInt16,System.UInt16)">
Sets a level-of-detail bias for the mesh detail of this entity.
		@remarks
		Level of detail reduction is normally applied automatically based on the Mesh
		settings. However, it is possible to influence this behaviour for this entity
		by adjusting the LOD bias. This 'nudges' the mesh level of detail used for this
		entity up or down depending on your requirements. You might want to use this
		if there was a particularly important entity in your scene which you wanted to
		detail better than the others, such as a player model.
		@par
		There are three parameters to this method; the first is a factor to apply; it
		defaults to 1.0 (no change), by increasing this to say 2.0, this model would
		take twice as long to reduce in detail, whilst at 0.5 this entity would use lower
		detail versions twice as quickly. The other 2 parameters are hard limits which
		let you set the maximum and minimum level-of-detail version to use, after all
		other calculations have been made. This lets you say that this entity should
		never be simplified, or that it can only use LODs below a certain level even
		when right next to the camera.
		@param factor Proportional factor to apply to the distance at which LOD is changed.
		Higher values increase the distance at which higher LODs are displayed (2.0 is
		twice the normal distance, 0.5 is half).
		@param maxDetailIndex The index of the maximum LOD this entity is allowed to use (lower
		indexes are higher detail: index 0 is the original full detail model).
		@param minDetailIndex The index of the minimum LOD this entity is allowed to use (higher
		indexes are lower detail). Use something like 99 if you want unlimited LODs (the actual
		LOD will be limited by the number in the Mesh)

</member>
        <member name="M:Ogre.Entity.getCurrentLodIndex">
Returns the current LOD used to render

</member>
        <member name="M:Ogre.Entity.getNumManualLodLevels">
Returns the number of manual levels of detail that this entity supports.
        @remarks
            This number never includes the original entity, it is difference
            with Mesh::getNumLodLevels.

</member>
        <member name="M:Ogre.Entity.getManualLodLevel(System.UInt32)">
Gets a pointer to the entity representing the numbered manual level of detail.
        @remarks
            The zero-based index never includes the original entity, unlike
			Mesh::getLodLevel.

</member>
        <member name="M:Ogre.Entity.getDisplaySkeleton">
Returns whether or not the entity is currently displaying its skeleton.

</member>
        <member name="M:Ogre.Entity.setDisplaySkeleton(System.Boolean)">
Tells the Entity whether or not it should display it's skeleton, if it has one.

</member>
        <member name="M:Ogre.Entity.getAllAnimationStates">
For entities based on animated meshes, gets the AnimationState objects for all animations.
		@returns
		In case the entity is animated, this functions returns the pointer to a AnimationStateSet
		containing all animations of the entries. If the entity is not animated, it returns 0.
		@remarks
		You animate an entity by updating the animation state objects. Each of these represents the
		current state of each animation available to the entity. The AnimationState objects are
		initialised from the Mesh object.

</member>
        <member name="M:Ogre.Entity.getAnimationState(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
For entities based on animated meshes, gets the AnimationState object for a single animation.
		@remarks
		You animate an entity by updating the animation state objects. Each of these represents the
		current state of each animation available to the entity. The AnimationState objects are
		initialised from the Mesh object.

</member>
        <member name="M:Ogre.Entity.getMovableType">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.Entity._updateRenderQueue(Ogre.RenderQueue*)">
Overridden - see MovableObject.

</member>
        <member name="M:Ogre.Entity.getChildObjectsBoundingBox">
merge all the child object Bounds a return it
</member>
        <member name="M:Ogre.Entity.getBoundingBox">
Overridden - see MovableObject.

</member>
        <member name="M:Ogre.Entity.setRenderQueueGroupAndPriority(System.Byte,System.UInt16)">
Overridden - see MovableObject.
</member>
        <member name="M:Ogre.Entity.setRenderQueueGroup(System.Byte)">
Overridden - see MovableObject.
</member>
        <member name="M:Ogre.Entity._notifyCurrentCamera(Ogre.Camera*)">
Overridden - see MovableObject.

</member>
        <member name="M:Ogre.Entity.setMaterial(Ogre.MaterialPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the material to use for the whole of this entity.
			@remarks
				This is a shortcut method to set all the materials for all
				subentities of this entity. Only use this method is you want to
				set the same material for all subentities or if you know there
				is only one. Otherwise call getSubEntity() and call the same
				method on the individual SubEntity.

</member>
        <member name="M:Ogre.Entity.setMaterialName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the material to use for the whole of this entity.
		@remarks
		This is a shortcut method to set all the materials for all
		subentities of this entity. Only use this method is you want to
		set the same material for all subentities or if you know there
		is only one. Otherwise call getSubEntity() and call the same
		method on the individual SubEntity.

</member>
        <member name="M:Ogre.Entity.clone(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Clones this entity and returns a pointer to the clone.
		@remarks
		Useful method for duplicating an entity. The new entity must be
		given a unique name, and is not attached to the scene in any way
		so must be attached to a SceneNode to be visible (exactly as
		entities returned from SceneManager::createEntity).
		@param
		newName Name for the new entity.

</member>
        <member name="M:Ogre.Entity.getNumSubEntities">
Retrieves the number of SubEntity objects making up this entity.

</member>
        <member name="M:Ogre.Entity.getSubEntity(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets a pointer to a SubEntity by name
		@remarks - names should be initialized during a Mesh creation.

</member>
        <member name="M:Ogre.Entity.getSubEntity(System.UInt32)">
Gets a pointer to a SubEntity, ie a part of an Entity.

</member>
        <member name="M:Ogre.Entity.getMesh">
Gets the Mesh that this Entity is based on.

</member>
        <member name="M:Ogre.Entity.Dispose">
Default destructor.

</member>
        <member name="M:Ogre.Entity.EntityShadowRenderable.isVisible">
Overridden from ShadowRenderable
</member>
        <member name="M:Ogre.Entity.EntityShadowRenderable.rebindPositionBuffer(Ogre.VertexData!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Rebind the source positions (for temp buffer users)
</member>
        <member name="M:Ogre.Entity.EntityShadowRenderable.getWorldTransforms(Ogre.Matrix4*)">
Overridden from ShadowRenderable
</member>
        <member name="F:Ogre.Entity.EntityShadowRenderable.mSubEntity">
Link to SubEntity, only present if SubEntity has it's own geometry
</member>
        <member name="T:Ogre.Entity.EntityShadowRenderable">
Nested class to allow entity shadows. 
</member>
        <member name="F:Ogre.Entity.mFullBoundingBox">
Bounding box that 'contains' all the mesh of each child entity
</member>
        <member name="D:Ogre.Entity.ChildObjectList">
Contains the child objects (attached to bones) indexed by name
</member>
        <member name="M:Ogre.Entity.tempSkelAnimBuffersBound(System.Boolean)">
Are software skeleton animation temp buffers bound?
</member>
        <member name="M:Ogre.Entity.tempVertexAnimBuffersBound">
Are software vertex animation temp buffers bound?
</member>
        <member name="M:Ogre.Entity.initHardwareAnimationElements(Ogre.VertexData*,System.UInt16)">
Initialise the hardware animation elements for given vertex data
</member>
        <member name="M:Ogre.Entity.applyVertexAnimation(System.Boolean,System.Boolean)">
Apply vertex animation
</member>
        <member name="M:Ogre.Entity.reevaluateVertexProcessing">
Trigger reevaluation of the kind of vertex processing in use
</member>
        <member name="M:Ogre.Entity.detachAllObjectsImpl">
internal implementation of detaching all 'child' objects of this entity
</member>
        <member name="M:Ogre.Entity.detachObjectImpl(Ogre.MovableObject*)">
internal implementation of detaching a 'child' object of this entity and clear the parent node of the child entity
</member>
        <member name="M:Ogre.Entity.attachObjectImpl(Ogre.MovableObject*,Ogre.TagPoint*)">
internal implementation of attaching a 'child' object to this entity and assign the parent node to the child entity
</member>
        <member name="M:Ogre.Entity.buildSubEntityList(Ogre.MeshPtr*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Ogre.SubEntity**&gt;*)">
Builds a list of SubEntities based on the SubMeshes contained in the Mesh. 
</member>
        <member name="F:Ogre.Entity.mMeshStateCount">
Mesh state count, used to detect differences
</member>
        <member name="F:Ogre.Entity.mLastParentXform">
Last parent xform
</member>
        <member name="F:Ogre.Entity.mInitialised">
Has this entity been initialised yet?
</member>
        <member name="F:Ogre.Entity.mSkeletonInstance">
This Entity's personal copy of the skeleton, if skeletally animated

</member>
        <member name="D:Ogre.Entity.LODEntityList">
List of LOD Entity instances (for manual LODs).
		We don't know when the mesh is using manual LODs whether one LOD to the next will have the
		same number of SubMeshes, therefore we have to allow a separate Entity list
		with each alternate one.

</member>
        <member name="F:Ogre.Entity.mMaxMaterialLodIndex">
Index of maximum detail LOD (NB lower index is higher detail)
</member>
        <member name="F:Ogre.Entity.mMinMaterialLodIndex">
Index of minimum detail LOD (NB higher index is lower detail)
</member>
        <member name="F:Ogre.Entity.mMaterialLodFactorTransformed">
LOD bias factor, transformed for optimisation when calculating adjusted lod value
</member>
        <member name="F:Ogre.Entity.mMaterialLodFactor">
LOD bias factor, not transformed
</member>
        <member name="F:Ogre.Entity.mMaxMeshLodIndex">
Index of maximum detail LOD (NB lower index is higher detail)
</member>
        <member name="F:Ogre.Entity.mMinMeshLodIndex">
Index of minimum detail LOD (NB higher index is lower detail)
</member>
        <member name="F:Ogre.Entity.mMeshLodFactorTransformed">
LOD bias factor, transformed for optimisation when calculating adjusted lod value
</member>
        <member name="F:Ogre.Entity.mMeshLodIndex">
The LOD number of the mesh to use, calculated by _notifyCurrentCamera
</member>
        <member name="F:Ogre.Entity.mSkipAnimStateUpdates">
Flag indicating whether to skip automatic updating of the Skeleton's AnimationState
</member>
        <member name="F:Ogre.Entity.mSoftwareAnimationNormalsRequests">
Counter indicating number of requests for software blended normals.
</member>
        <member name="F:Ogre.Entity.mSoftwareAnimationRequests">
Counter indicating number of requests for software animation.
</member>
        <member name="F:Ogre.Entity.mVertexProgramInUse">
Flag indicating whether we have a vertex program in use on any of our subentities
</member>
        <member name="F:Ogre.Entity.mHardwarePoseCount">
Number of hardware poses supported by materials
</member>
        <member name="F:Ogre.Entity.mHardwareAnimation">
Flag indicating whether hardware animation is supported by this entities materials
</member>
        <member name="F:Ogre.Entity.mDisplaySkeleton">
Flag determines whether or not to display skeleton
</member>
        <member name="M:Ogre.Entity.cacheBoneMatrices">
Private method to cache bone matrices from skeleton
</member>
        <member name="F:Ogre.Entity.mSharedSkeletonEntities">
A set of all the entities which shares a single SkeletonInstance.
This is only created if the entity is in fact sharing it's SkeletonInstance with
other Entities.

</member>
        <member name="F:Ogre.Entity.mFrameBonesLastUpdated">
Records the last frame in which the bones was updated
It's a pointer because it can be shared between different entities with
a shared skeleton.
</member>
        <member name="M:Ogre.Entity.updateAnimation">
Perform all the updates required for an animated entity
</member>
        <member name="F:Ogre.Entity.mFrameAnimationLastUpdated">
Records the last frame in which animation was updated
</member>
        <member name="F:Ogre.Entity.mBoneMatrices">
Cached bone matrices in skeleton local space, might shares with other entity instances.
</member>
        <member name="F:Ogre.Entity.mBoneWorldMatrices">
Cached bone matrices, including any world transform
</member>
        <member name="M:Ogre.Entity.bindMissingHardwarePoseBuffers(Ogre.VertexData!System.Runtime.CompilerServices.IsConst*,Ogre.VertexData*)">
Ensure that any unbound  pose animation buffers are bound to a safe
			default.
			@param srcData Original vertex data containing original positions
			@param destData Hardware animation vertex data to be checked

</member>
        <member name="M:Ogre.Entity.restoreBuffersForUnusedAnimation(System.Boolean)">
Internal method to restore original vertex data where we didn't
			perform any vertex animation this frame.

</member>
        <member name="M:Ogre.Entity.markBuffersUnusedForAnimation">
Mark all vertex data as so far unanimated.

</member>
        <member name="M:Ogre.Entity.prepareTempBlendBuffers">
Internal method for preparing this Entity for use in animation. 
</member>
        <member name="M:Ogre.Entity.cloneVertexDataRemoveBlendInfo(Ogre.VertexData!System.Runtime.CompilerServices.IsConst*)">
Internal method to clone vertex data definitions but to remove blend buffers. 
</member>
        <member name="M:Ogre.Entity.extractTempBufferInfo(Ogre.VertexData*,Ogre.TempBlendedBufferInfo*)">
Internal method for extracting metadata out of source vertex data
		for fast assignment of temporary buffers later. 
</member>
        <member name="M:Ogre.Entity.findSubEntityForVertexData(Ogre.VertexData!System.Runtime.CompilerServices.IsConst*)">
Internal method - given vertex data which could be from the Mesh or
		any SubMesh, finds the corresponding SubEntity. 
</member>
        <member name="M:Ogre.Entity.findBlendedVertexData(Ogre.VertexData!System.Runtime.CompilerServices.IsConst*)">
Internal method - given vertex data which could be from the Mesh or
		any submesh, finds the temporary blend copy. 
</member>
        <member name="F:Ogre.Entity.mPreparedForShadowVolumes">
Have the temp buffers already had their geometry prepared for use in rendering shadow volumes?
</member>
        <member name="F:Ogre.Entity.mVertexAnimationAppliedThisFrame">
Have we applied any vertex animation to shared geometry?
</member>
        <member name="F:Ogre.Entity.mHardwareVertexAnimVertexData">
Vertex data details for hardware vertex anim of shared geometry
- separate since we need to s/w anim for shadows whilst still altering
  the vertex data for hardware morphing (pos2 binding)
</member>
        <member name="F:Ogre.Entity.mSoftwareVertexAnimVertexData">
Vertex data details for software vertex anim of shared geometry
</member>
        <member name="F:Ogre.Entity.mTempVertexAnimInfo">
Temp buffer details for software vertex anim of shared geometry
</member>
        <member name="F:Ogre.Entity.mSkelAnimVertexData">
Vertex data details for software skeletal anim of shared geometry
</member>
        <member name="F:Ogre.Entity.mTempSkelAnimInfo">
Temp buffer details for software skeletal anim of shared geometry
</member>
        <member name="F:Ogre.Entity.mAnimationState">
State of animation for animable meshes
</member>
        <member name="D:Ogre.Entity.SubEntityList">
List of SubEntities (point to SubMeshes).

</member>
        <member name="F:Ogre.Entity.mMesh">
The Mesh that this Entity is based on.

</member>
        <member name="M:Ogre.Entity.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.MeshPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Private constructor - specify name (the usual constructor used).

</member>
        <member name="M:Ogre.Entity.#ctor">
Private constructor (instances cannot be created directly).

</member>
        <member name="T:Ogre.Entity">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Defines an instance of a discrete, movable object based on a Mesh.
	@remarks
	Ogre generally divides renderable objects into 2 groups, discrete
	(separate) and relatively small objects which move around the world,
	and large, sprawling geometry which makes up generally immovable
	scenery, aka 'level geometry'.
	@par
	The Mesh and SubMesh classes deal with the definition of the geometry
	used by discrete movable objects. Entities are actual instances of
	objects based on this geometry in the world. Therefore there is
	usually a single set Mesh for a car, but there may be multiple
	entities based on it in the world. Entities are able to override
	aspects of the Mesh it is defined by, such as changing material
	properties per instance (so you can have many cars using the same
	geometry but different textures for example). Because a Mesh is split
	into SubMeshes for this purpose, the Entity class is a grouping class
	(much like the Mesh class) and much of the detail regarding
	individual changes is kept in the SubEntity class. There is a 1:1
	relationship between SubEntity instances and the SubMesh instances
	associated with the Mesh the Entity is based on.
	@par
	Entity and SubEntity classes are never created directly. Use the
	createEntity method of the SceneManager (passing a model name) to
	create one.
	@par
	Entities are included in the scene by associating them with a
	SceneNode, using the attachEntity method. See the SceneNode class
	for full information.
	@note
	No functions were declared virtual to improve performance.

</member>
        <member name="M:Ogre.HardwareBufferManager.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.HardwareBufferManager.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.HardwareBufferManager._notifyIndexBufferDestroyed(Ogre.HardwareIndexBuffer*)">
@copydoc HardwareBufferManagerInterface::_notifyIndexBufferDestroyed 
</member>
        <member name="M:Ogre.HardwareBufferManager._notifyVertexBufferDestroyed(Ogre.HardwareVertexBuffer*)">
@copydoc HardwareBufferManagerInterface::_notifyVertexBufferDestroyed 
</member>
        <member name="M:Ogre.HardwareBufferManager._forceReleaseBufferCopies(Ogre.HardwareVertexBuffer*)">
@copydoc HardwareBufferManagerInterface::_forceReleaseBufferCopies 
</member>
        <member name="M:Ogre.HardwareBufferManager._forceReleaseBufferCopies(Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc HardwareBufferManagerInterface::_forceReleaseBufferCopies 
</member>
        <member name="M:Ogre.HardwareBufferManager._releaseBufferCopies(System.Boolean)">
@copydoc HardwareBufferManagerInterface::_releaseBufferCopies 
</member>
        <member name="M:Ogre.HardwareBufferManager._freeUnusedBufferCopies">
@copydoc HardwareBufferManagerInterface::_freeUnusedBufferCopies 
</member>
        <member name="M:Ogre.HardwareBufferManager.touchVertexBufferCopy(Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc HardwareBufferManagerInterface::touchVertexBufferCopy 
</member>
        <member name="M:Ogre.HardwareBufferManager.releaseVertexBufferCopy(Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc HardwareBufferManagerInterface::releaseVertexBufferCopy 
</member>
        <member name="M:Ogre.HardwareBufferManager.allocateVertexBufferCopy(Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.HardwareBufferManagerBase.BufferLicenseType,Ogre.HardwareBufferLicensee*,System.Boolean)">
@copydoc HardwareBufferManagerInterface::allocateVertexBufferCopy 
</member>
        <member name="M:Ogre.HardwareBufferManager.registerVertexBufferSourceAndCopy(Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc HardwareBufferManagerInterface::registerVertexBufferSourceAndCopy 
</member>
        <member name="M:Ogre.HardwareBufferManager.destroyVertexBufferBinding(Ogre.VertexBufferBinding*)">
@copydoc HardwareBufferManagerInterface::destroyVertexBufferBinding 
</member>
        <member name="M:Ogre.HardwareBufferManager.createVertexBufferBinding">
@copydoc HardwareBufferManagerInterface::createVertexBufferBinding 
</member>
        <member name="M:Ogre.HardwareBufferManager.destroyVertexDeclaration(Ogre.VertexDeclaration*)">
@copydoc HardwareBufferManagerInterface::destroyVertexDeclaration 
</member>
        <member name="M:Ogre.HardwareBufferManager.createVertexDeclaration">
@copydoc HardwareBufferManagerInterface::createVertexDeclaration 
</member>
        <member name="M:Ogre.HardwareBufferManager.createRenderToVertexBuffer">
@copydoc HardwareBufferManagerInterface::createRenderToVertexBuffer 
</member>
        <member name="M:Ogre.HardwareBufferManager.createIndexBuffer(Ogre.HardwareIndexBuffer.IndexType,System.UInt32,Ogre.HardwareBuffer.Usage,System.Boolean)">
@copydoc HardwareBufferManagerInterface::createIndexBuffer 
</member>
        <member name="M:Ogre.HardwareBufferManager.createVertexBuffer(System.UInt32,System.UInt32,Ogre.HardwareBuffer.Usage,System.Boolean)">
@copydoc HardwareBufferManagerInterface::createVertexBuffer 
</member>
        <member name="T:Ogre.HardwareBufferManager">
Singleton wrapper for hardware buffer manager. 
</member>
        <member name="M:Ogre.HardwareBufferManagerBase._notifyIndexBufferDestroyed(Ogre.HardwareIndexBuffer*)">
Notification that a hardware index buffer has been destroyed
</member>
        <member name="M:Ogre.HardwareBufferManagerBase._notifyVertexBufferDestroyed(Ogre.HardwareVertexBuffer*)">
Notification that a hardware vertex buffer has been destroyed
</member>
        <member name="M:Ogre.HardwareBufferManagerBase._forceReleaseBufferCopies(Ogre.HardwareVertexBuffer*)">
Internal method that forces the release of copies of a given buffer.
        @remarks
            This usually means that the buffer which the copies are based on has
            been changed in some fundamental way, and the owner of the original 
            wishes to make that known so that new copies will reflect the
            changes.
        @param sourceBuffer the source buffer as a pointer.  Any buffer copies created from the source buffer
            are deleted.

</member>
        <member name="M:Ogre.HardwareBufferManagerBase._forceReleaseBufferCopies(Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method that forces the release of copies of a given buffer.
        @remarks
            This usually means that the buffer which the copies are based on has
            been changed in some fundamental way, and the owner of the original 
            wishes to make that known so that new copies will reflect the
            changes.
        @param sourceBuffer the source buffer as a shared pointer.  Any buffer copies created from the source buffer
            are deleted.

</member>
        <member name="M:Ogre.HardwareBufferManagerBase._releaseBufferCopies(System.Boolean)">
Internal method for releasing all temporary buffers which have been 
           allocated using BLT_AUTOMATIC_RELEASE; is called by OGRE.
        @param forceFreeUnused If true, free all unused temporary buffers.
            If false, auto detect and free all unused temporary buffers based on
            temporary buffers utilization.

</member>
        <member name="M:Ogre.HardwareBufferManagerBase._freeUnusedBufferCopies">
Free all unused vertex buffer copies.
        @remarks
            This method free all temporary vertex buffers that not in used.
            In normally, temporary vertex buffers are subsequently stored and can
            be made available for other purposes later without incurring the cost
            of construction / destruction. But in some cases you want to free them
            to save hardware memory (e.g. application was runs in a long time, you
            might free temporary buffers periodically to avoid memory overload).

</member>
        <member name="M:Ogre.HardwareBufferManagerBase.touchVertexBufferCopy(Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tell engine that the vertex buffer copy intent to reuse.
        @remarks
            Ogre internal keep an expired delay counter of BLT_AUTOMATIC_RELEASE
            buffers, when the counter count down to zero, it'll release for other
            purposes later. But you can use this function to reset the counter to
            the internal configured value, keep the buffer not get released for
            some frames.
        @param bufferCopy The buffer copy. The caller is expected to keep this
            buffer copy for use.

</member>
        <member name="M:Ogre.HardwareBufferManagerBase.releaseVertexBufferCopy(Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Manually release a vertex buffer copy for others to subsequently use.
        @remarks
            Only required if the original call to allocateVertexBufferCopy
            included a licenseType of BLT_MANUAL_RELEASE. 
        @param bufferCopy The buffer copy. The caller is expected to delete
            or at least no longer use this reference, since another user may
            well begin to modify the contents of the buffer.

</member>
        <member name="M:Ogre.HardwareBufferManagerBase.allocateVertexBufferCopy(Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.HardwareBufferManagerBase.BufferLicenseType,Ogre.HardwareBufferLicensee*,System.Boolean)">
Allocates a copy of a given vertex buffer.
        @remarks
            This method allocates a temporary copy of an existing vertex buffer.
            This buffer is subsequently stored and can be made available for 
            other purposes later without incurring the cost of construction / 
            destruction.
        @param sourceBuffer The source buffer to use as a copy
        @param licenseType The type of license required on this buffer - automatic
            release causes this class to release licenses every frame so that 
            they can be reallocated anew.
        @param licensee Pointer back to the class requesting the copy, which must
            implement HardwareBufferLicense in order to be notified when the license
            expires.
        @param copyData If true, the current data is copied as well as the 
            structure of the buffer

</member>
        <member name="M:Ogre.HardwareBufferManagerBase.registerVertexBufferSourceAndCopy(Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Registers a vertex buffer as a copy of another.
		@remarks
			This is useful for registering an existing buffer as a temporary buffer
			which can be allocated just like a copy.

</member>
        <member name="M:Ogre.HardwareBufferManagerBase.destroyVertexBufferBinding(Ogre.VertexBufferBinding*)">
Destroys a VertexBufferBinding. 
</member>
        <member name="M:Ogre.HardwareBufferManagerBase.createVertexBufferBinding">
Creates a new VertexBufferBinding. 
</member>
        <member name="M:Ogre.HardwareBufferManagerBase.destroyVertexDeclaration(Ogre.VertexDeclaration*)">
Destroys a vertex declaration. 
</member>
        <member name="M:Ogre.HardwareBufferManagerBase.createVertexDeclaration">
Creates a new vertex declaration. 
</member>
        <member name="M:Ogre.HardwareBufferManagerBase.createRenderToVertexBuffer">
Create a render to vertex buffer.
		@remarks The parameters (such as vertex size etc) are determined later
			and are allocated when needed.

</member>
        <member name="M:Ogre.HardwareBufferManagerBase.createIndexBuffer(Ogre.HardwareIndexBuffer.IndexType,System.UInt32,Ogre.HardwareBuffer.Usage,System.Boolean)">
Create a hardware index buffer.
        @remarks Note that because buffers can be shared, they are reference
            counted so you do not need to worry about destroying them this will be done
            automatically.
		@param itype The type in index, either 16- or 32-bit, depending on how many vertices
			you need to be able to address
		@param numIndexes The number of indexes in the buffer
        @param usage One or more members of the HardwareBuffer::Usage enumeration.
		@param useShadowBuffer If set to true, this buffer will be 'shadowed' by one stored in 
            system memory rather than GPU or AGP memory. You should set this flag if you intend 
            to read data back from the index buffer, because reading data from a buffer
			in the GPU or AGP memory is very expensive, and is in fact impossible if you
            specify HBU_WRITE_ONLY for the main buffer. If you use this option, all 
            reads and writes will be done to the shadow buffer, and the shadow buffer will
            be synchronised with the real buffer at an appropriate time.

</member>
        <member name="M:Ogre.HardwareBufferManagerBase.createVertexBuffer(System.UInt32,System.UInt32,Ogre.HardwareBuffer.Usage,System.Boolean)">
Create a hardware vertex buffer.
        @remarks
            This method creates a new vertex buffer; this will act as a source of geometry
            data for rendering objects. Note that because the meaning of the contents of
            the vertex buffer depends on the usage, this method does not specify a
            vertex format; the user of this buffer can actually insert whatever data 
            they wish, in any format. However, in order to use this with a RenderOperation,
            the data in this vertex buffer will have to be associated with a semantic element
            of the rendering pipeline, e.g. a position, or texture coordinates. This is done 
            using the VertexDeclaration class, which itself contains VertexElement structures
            referring to the source data.
        @remarks Note that because vertex buffers can be shared, they are reference
            counted so you do not need to worry about destroying themm this will be done
            automatically.
        @param vertexSize The size in bytes of each vertex in this buffer; you must calculate
            this based on the kind of data you expect to populate this buffer with.
        @param numVerts The number of vertices in this buffer.
        @param usage One or more members of the HardwareBuffer::Usage enumeration; you are
            strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to 
            update regularly, consider HBU_DYNAMIC_WRITE_ONLY and useShadowBuffer=true.
		@param useShadowBuffer If set to true, this buffer will be 'shadowed' by one stored in 
            system memory rather than GPU or AGP memory. You should set this flag if you intend 
            to read data back from the vertex buffer, because reading data from a buffer
			in the GPU or AGP memory is very expensive, and is in fact impossible if you
            specify HBU_WRITE_ONLY for the main buffer. If you use this option, all 
            reads and writes will be done to the shadow buffer, and the shadow buffer will
            be synchronised with the real buffer at an appropriate time.

</member>
        <member name="M:Ogre.HardwareBufferManagerBase.makeBufferCopy(Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.HardwareBuffer.Usage,System.Boolean)">
Creates  a new buffer as a copy of the source, does not copy data
</member>
        <member name="F:Ogre.HardwareBufferManagerBase.EXPIRED_DELAY_FRAME_THRESHOLD">
Frame delay for BLT_AUTOMATIC_RELEASE temporary buffers
</member>
        <member name="F:Ogre.HardwareBufferManagerBase.UNDER_USED_FRAME_THRESHOLD">
Number of frames to wait before free unused temporary buffers
</member>
        <member name="F:Ogre.HardwareBufferManagerBase.mUnderUsedFrameCount">
Number of frames elapsed since temporary buffers utilization was above half the available
</member>
        <member name="F:Ogre.HardwareBufferManagerBase.mTempVertexBufferLicenses">
Map of currently licensed temporary buffers
</member>
        <member name="D:Ogre.HardwareBufferManagerBase.TemporaryVertexBufferLicenseMap">
Map from temporary buffer to details of a license
</member>
        <member name="F:Ogre.HardwareBufferManagerBase.mFreeTempVertexBufferMap">
Map of current available temp buffers 
</member>
        <member name="D:Ogre.HardwareBufferManagerBase.FreeTemporaryVertexBufferMap">
Map from original buffer to temporary buffers
</member>
        <member name="T:Ogre.HardwareBufferManagerBase.VertexBufferLicense">
Struct holding details of a license to use a temporary shared buffer. 
</member>
        <member name="F:BLT_AUTOMATIC_RELEASE">
Licensee can have license revoked
</member>
        <member name="F:BLT_MANUAL_RELEASE">
Licensee will only release buffer when it says so
</member>
        <member name="M:Ogre.HardwareBufferManagerBase.destroyVertexBufferBindingImpl(Ogre.VertexBufferBinding*)">
Internal method for destroys a VertexBufferBinding, may be overridden by certain rendering APIs
</member>
        <member name="M:Ogre.HardwareBufferManagerBase.createVertexBufferBindingImpl">
Internal method for creates a new VertexBufferBinding, may be overridden by certain rendering APIs
</member>
        <member name="M:Ogre.HardwareBufferManagerBase.destroyVertexDeclarationImpl(Ogre.VertexDeclaration*)">
Internal method for destroys a vertex declaration, may be overridden by certain rendering APIs
</member>
        <member name="M:Ogre.HardwareBufferManagerBase.createVertexDeclarationImpl">
Internal method for creates a new vertex declaration, may be overridden by certain rendering APIs
</member>
        <member name="M:Ogre.HardwareBufferManagerBase.destroyAllBindings">
Internal method for destroys all vertex buffer bindings
</member>
        <member name="M:Ogre.HardwareBufferManagerBase.destroyAllDeclarations">
Internal method for destroys all vertex declarations
</member>
        <member name="D:Ogre.HardwareBufferManagerBase.VertexBufferList">
WARNING: The following two members should place before all other members.
            Members destruct order is very important here, because destructing other
            members will cause notify back to this class, and then will access to this
            two members.

</member>
        <member name="T:Ogre.HardwareBufferManagerBase">
Base definition of a hardware buffer manager.
	@remarks
		This class is deliberately not a Singleton, so that multiple types can 
		exist at once. The Singleton is wrapped via the Decorator pattern
		in HardwareBufferManager, below. Each concrete implementation should
		provide a subclass of HardwareBufferManagerBase, which does the actual
		work, and also a very simple subclass of HardwareBufferManager which 
		simply constructs the instance of the HardwareBufferManagerBase subclass 
		and passes it to the HardwareBufferManager superclass as a delegate. 
		This subclass must also delete the implementation instance it creates.

</member>
        <member name="M:Ogre.TempBlendedBufferInfo.buffersCheckedOut(System.Boolean,System.Boolean)">
Detect currently have buffer copies checked out and touch it 
</member>
        <member name="M:Ogre.TempBlendedBufferInfo.licenseExpired(Ogre.HardwareBuffer*)">
Overridden member from HardwareBufferLicensee. 
</member>
        <member name="M:Ogre.TempBlendedBufferInfo.bindTempCopies(Ogre.VertexData*,System.Boolean)">
Utility method, binds dest copies into a given VertexData struct
</member>
        <member name="M:Ogre.TempBlendedBufferInfo.checkoutTempCopies(System.Boolean,System.Boolean)">
Utility method, checks out temporary copies of src into dest
</member>
        <member name="M:Ogre.TempBlendedBufferInfo.extractFrom(Ogre.VertexData!System.Runtime.CompilerServices.IsConst*)">
Utility method, extract info from the given VertexData
</member>
        <member name="F:Ogre.TempBlendedBufferInfo.posNormalShareBuffer">
Both positions and normals are contained in the same buffer
</member>
        <member name="T:Ogre.TempBlendedBufferInfo">
Structure for recording the use of temporary blend buffers 
</member>
        <member name="M:Ogre.HardwareBufferLicensee.licenseExpired(Ogre.HardwareBuffer*)">
This method is called when the buffer license is expired and is about
        to be returned to the shared pool. 
</member>
        <member name="T:Ogre.HardwareBufferLicensee">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

Abstract interface representing a 'licensee' of a hardware buffer copy.
    remarks
        Often it's useful to have temporary buffers which are used for working
        but are not necessarily needed permanently. However, creating and 
        destroying buffers is expensive, so we need a way to share these 
        working areas, especially those based on existing fixed buffers. 
        This class represents a licensee of one of those temporary buffers, 
        and must be implemented by any user of a temporary buffer if they 
        wish to be notified when the license is expired. 

</member>
        <member name="M:Ogre.RenderToVertexBuffer.setRenderToBufferMaterialName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the material name which is used to render the geometry into
the vertex buffer

</member>
        <member name="M:Ogre.RenderToVertexBuffer.getRenderToBufferMaterial">
Get the material which is used to render the geometry into the
vertex buffer.

</member>
        <member name="M:Ogre.RenderToVertexBuffer.getSourceRenderable">
Get the source renderable of this object

</member>
        <member name="M:Ogre.RenderToVertexBuffer.setSourceRenderable(Ogre.Renderable*)">
Set the source renderable of this object. During the first (and 
perhaps later) update of this object, this object's data will be
used as input)

</member>
        <member name="M:Ogre.RenderToVertexBuffer.reset">
Reset the vertex buffer to the initial state. In the next update,
the source renderable will be used as input.

</member>
        <member name="M:Ogre.RenderToVertexBuffer.update(Ogre.SceneManager*)">
Update the contents of this vertex buffer by rendering

</member>
        <member name="M:Ogre.RenderToVertexBuffer.getRenderOperation(Ogre.RenderOperation*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get the render operation for this buffer 

</member>
        <member name="M:Ogre.RenderToVertexBuffer.getResetsEveryUpdate">
Does this object reset its buffer each time it updates?

</member>
        <member name="M:Ogre.RenderToVertexBuffer.setResetsEveryUpdate(System.Boolean)">
Set wether this object resets its buffers each time it updates.

</member>
        <member name="M:Ogre.RenderToVertexBuffer.setOperationType(Ogre.RenderOperation.OperationType)">
Set the type of primitives that this object generates

</member>
        <member name="M:Ogre.RenderToVertexBuffer.getOperationType">
What type of primitives does this object generate?

</member>
        <member name="M:Ogre.RenderToVertexBuffer.setMaxVertexCount(System.UInt32)">
Set the maximum number of vertices that the buffer will hold

</member>
        <member name="M:Ogre.RenderToVertexBuffer.getMaxVertexCount">
Get the maximum number of vertices that the buffer will hold

</member>
        <member name="M:Ogre.RenderToVertexBuffer.getVertexDeclaration">
            Get the vertex declaration that the pass will output.
        @remarks
            Use this object to set the elements of the buffer. Object will calculate
            buffers on its own. Only one source allowed!

</member>
        <member name="M:Ogre.RenderToVertexBuffer.Dispose">
D'tor 
</member>
        <member name="M:Ogre.RenderToVertexBuffer.#ctor">
C'tor 
</member>
        <member name="T:Ogre.RenderToVertexBuffer">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

        An object which renders geometry to a vertex.
    @remarks
        This is especially useful together with geometry shaders, as you can
        render procedural geometry which will get saved to a vertex buffer for
        reuse later, without regenerating it again. You can also create shaders
        that run on previous results of those shaders, creating stateful 
        shaders.

</member>
        <member name="M:Ogre.ControllerManager.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.ControllerManager.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.ControllerManager.setElapsedTime(System.Single)">
Set the elapsed time.
        @remarks
            Normally elapsed time accumulated all frames time (which speed relative to time
            factor) since the rendering loop started. This method allows your to change that to
            special time, so some elapsed-time-based globally effect is repeatable.
        @param elapsedTime The new elapsed time

</member>
        <member name="M:Ogre.ControllerManager.getElapsedTime">
Return the elapsed time.
        @remarks
            See setElapsedTime for full information on the meaning of this value.

</member>
        <member name="M:Ogre.ControllerManager.setFrameDelay(System.Single)">
Sets a constant frame rate.
		@remarks
			This function is useful when rendering a sequence to
			files that should create a film clip with constant frame
			rate.
			It will ensure that scrolling textures and animations
			move at a constant frame rate.
		@param fd The delay in seconds wanted between each frame 
			(1.0f / 25.0f means a seconds worth of animation is done 
			in 25 frames).

</member>
        <member name="M:Ogre.ControllerManager.getFrameDelay">
Gets the constant that is added to time lapsed between each frame.
		@remarks
			See setFrameDelay for full information on the meaning of this value.

</member>
        <member name="M:Ogre.ControllerManager.setTimeFactor(System.Single)">
Set the relative speed to update frame time based controllers.
        @remarks
            Normally any controllers which use time as an input (FrameTimeController) are updated
            automatically in line with the real passage of time. This method allows you to change
            that, so that controllers are told that the time is passing slower or faster than it
            actually is. Use this to globally speed up / slow down the effect of time-based controllers.
        @param tf The virtual speed of time (1.0 is real time).

</member>
        <member name="M:Ogre.ControllerManager.getTimeFactor">
Return relative speed of time as perceived by time based controllers.
        @remarks
            See setTimeFactor for full information on the meaning of this value.

</member>
        <member name="M:Ogre.ControllerManager.createGpuProgramTimerParam(Ogre.SharedPtr&lt;Ogre.GpuProgramParameters&gt;,System.UInt32,System.Single)">
Creates a controller for passing a frame time value through to a vertex / fragment program parameter.
        @remarks
            The destination parameter is expected to be a float, and the '.x' attribute will be populated
            with the appropriately scaled time value.
        @param params The parameters to update
        @param paramIndex The index of the parameter to update; if you want a named parameter, then
            retrieve the index beforehand using GpuProgramParameters::getParamIndex
        @param factor The factor by which to adjust the time elapsed by before passing it to the program

</member>
        <member name="M:Ogre.ControllerManager.createTextureWaveTransformer(Ogre.TextureUnitState*,Ogre.TextureUnitState.TextureTransformType,Ogre.WaveformType,System.Single,System.Single,System.Single,System.Single)">
Creates a very flexible time-based texture transformation which can alter the scale, position or
            rotation of a texture based on a wave function.
            @param
                layer The texture layer to affect
            @param
                ttype The type of transform, either translate (scroll), scale (stretch) or rotate (spin)
            @param
                waveType The shape of the wave, see WaveformType enum for details
            @param
                base The base value of the output
            @param
                frequency The speed of the wave in cycles per second
            @param
                phase The offset of the start of the wave, e.g. 0.5 to start half-way through the wave
            @param
                amplitude Scales the output so that instead of lying within 0..1 it lies within 0..1*amplitude for exaggerated effects

</member>
        <member name="M:Ogre.ControllerManager.createTextureRotater(Ogre.TextureUnitState*,System.Single)">
Creates a basic time-based texture coordinate modifier designed for creating rotating textures.
            @return
                This simple method allows you to easily create constant-speed rotating textures. If you want more
                control, look up the ControllerManager::createTextureWaveTransformer for more complex wave-based
                scrollers / stretchers / rotators.
            @param
                layer The texture layer to rotate.
            @param
                vSpeed Speed of rotation, in complete anticlockwise revolutions per second

</member>
        <member name="M:Ogre.ControllerManager.createTextureVScroller(Ogre.TextureUnitState*,System.Single)">
Creates a basic time-based texture v coordinate modifier designed for creating scrolling textures.
            @remarks
                This simple method allows you to easily create constant-speed v scrolling textures. If you want more
                control, look up the ControllerManager::createTextureWaveTransformer for more complex wave-based
                scrollers / stretchers / rotators.
            @param
                layer The texture layer to animate.            
            @param
                vSpeed Speed of vertical (v-coord) scroll, in complete wraps per second

</member>
        <member name="M:Ogre.ControllerManager.createTextureUScroller(Ogre.TextureUnitState*,System.Single)">
Creates a basic time-based texture u coordinate modifier designed for creating scrolling textures.
            @remarks
                This simple method allows you to easily create constant-speed u scrolling textures. If you want more
                control, look up the ControllerManager::createTextureWaveTransformer for more complex wave-based
                scrollers / stretchers / rotators.
            @param
                layer The texture layer to animate.
            @param
                uSpeed Speed of horizontal (u-coord) scroll, in complete wraps per second

</member>
        <member name="M:Ogre.ControllerManager.createTextureUVScroller(Ogre.TextureUnitState*,System.Single)">
Creates a basic time-based texture uv coordinate modifier designed for creating scrolling textures.
            @remarks
                This simple method allows you to easily create constant-speed uv scrolling textures. If you want to 
				specify different speed values for horizontal and vertical scroll, use the specific methods
				ControllerManager::createTextureUScroller and ControllerManager::createTextureVScroller.
				If you want more control, look up the ControllerManager::createTextureWaveTransformer 
				for more complex wave-based scrollers / stretchers / rotators.
            @param
                layer The texture layer to animate.
            @param
                speed Speed of horizontal (u-coord) and vertical (v-coord) scroll, in complete wraps per second

</member>
        <member name="M:Ogre.ControllerManager.createTextureAnimator(Ogre.TextureUnitState*,System.Single)">
Creates a texture layer animator controller.
            @remarks
                This helper method creates the Controller, ControllerValue and ControllerFunction classes required
                to animate a texture.
            @param
                layer TextureUnitState object to animate
            @param
                sequenceTime The amount of time in seconds it will take to loop through all the frames.

</member>
        <member name="M:Ogre.ControllerManager.getPassthroughControllerFunction">
Retrieve a simple passthrough controller function. 
</member>
        <member name="M:Ogre.ControllerManager.getFrameTimeSource">
Returns a ControllerValue which provides the time since the last frame as a control value source.
            @remarks
                A common source value to use to feed into a controller is the time since the last frame. This method
                returns a pointer to a common source value which provides this information.
            @par
                Remember the value will only be up to date after the RenderSystem::beginFrame method is called.
            @see
                RenderSystem::beginFrame

</member>
        <member name="M:Ogre.ControllerManager.updateAllControllers">
Updates all the registered controllers.

</member>
        <member name="M:Ogre.ControllerManager.clearControllers">
Destroys all the controllers in existence.

</member>
        <member name="M:Ogre.ControllerManager.createFrameTimePassthroughController(Ogre.SharedPtr&lt;Ogre.ControllerValue&lt;System.Single&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a new controller use frame time source and passthrough controller function.

</member>
        <member name="M:Ogre.ControllerManager.createController(Ogre.SharedPtr&lt;Ogre.ControllerValue&lt;System.Single&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.SharedPtr&lt;Ogre.ControllerValue&lt;System.Single&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.SharedPtr&lt;Ogre.ControllerFunction&lt;System.Single&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a new controller and registers it with the manager.

</member>
        <member name="F:Ogre.ControllerManager.mPassthroughFunction">
Global predefined controller
</member>
        <member name="F:Ogre.ControllerManager.mFrameTimeController">
Global predefined controller
</member>
        <member name="T:Ogre.ControllerManager">
Class for managing Controller instances.
        @remarks
            This class is responsible to keeping tabs on all the Controller instances registered
            and updating them when requested. It also provides a number of convenience methods
            for creating commonly used controllers (such as texture animators).

</member>
        <member name="D:Ogre.ControllerValueRealPtr">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

</member>
        <member name="M:Ogre.TextureUnitState.ensureLoaded(System.UInt32)">
Internal method for ensuring the texture for a given frame is loaded. 
</member>
        <member name="M:Ogre.TextureUnitState.ensurePrepared(System.UInt32)">
Internal method for ensuring the texture for a given frame is prepared. 
</member>
        <member name="M:Ogre.TextureUnitState.createEffectController(Ogre.TextureUnitState.TextureEffect*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for creating texture effect controller.

</member>
        <member name="M:Ogre.TextureUnitState.createAnimController">
Internal method for creating animation controller.

</member>
        <member name="M:Ogre.TextureUnitState.recalcTextureMatrix">
Internal method for calculating texture matrix.

</member>
        <member name="F:Ogre.TextureUnitState.mCompositorRefName">
The data that references the compositor
</member>
        <member name="F:Ogre.TextureUnitState.mCompositorRefMrtIndex">
The index of the referenced texture if referencing an MRT in a compositor
</member>
        <member name="F:Ogre.TextureUnitState.mContentType">
Content type of texture (normal loaded texture, auto-texture)
</member>
        <member name="F:Ogre.TextureUnitState.mBindingType">
Binding type (fragment or vertex pipeline)
</member>
        <member name="F:Ogre.TextureUnitState.mMipmapBias">
Mipmap bias (always float, not Real)
</member>
        <member name="F:Ogre.TextureUnitState.mMaxAniso">
Texture anisotropy
</member>
        <member name="F:Ogre.TextureUnitState.mMipFilter">
Texture filtering - mipmapping
</member>
        <member name="F:Ogre.TextureUnitState.mMagFilter">
Texture filtering - magnification
</member>
        <member name="F:Ogre.TextureUnitState.mMinFilter">
Texture filtering - minification
</member>
        <member name="F:Ogre.TextureUnitState.mAnimDuration">
Duration of animation in seconds
</member>
        <member name="F:Ogre.TextureUnitState.mCurrentFrame">
The current animation frame.
</member>
        <member name="M:Ogre.TextureUnitState._getAnimController">
Gets the animation controller (as created because of setAnimatedTexture)
			if it exists.

</member>
        <member name="M:Ogre.TextureUnitState._setTexturePtr(Ogre.TexturePtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Set the texture pointer for a given frame (internal use only!). 
</member>
        <member name="M:Ogre.TextureUnitState._setTexturePtr(Ogre.TexturePtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the texture pointer for the current frame (internal use only!). 
</member>
        <member name="M:Ogre.TextureUnitState._getTexturePtr(System.UInt32)">
Get the texture pointer for a given frame. 
</member>
        <member name="M:Ogre.TextureUnitState._getTexturePtr">
Get the texture pointer for the current frame. 
</member>
        <member name="M:Ogre.TextureUnitState._notifyParent(Ogre.Pass*)">
Notify this object that its parent has changed 
</member>
        <member name="M:Ogre.TextureUnitState.applyTextureAliases(std.map&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.less&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.Comp">
Applies texture names to Texture Unit State with matching texture name aliases.
            If no matching aliases are found then the TUS state does not change.
        @remarks
            Cubic, 1d, 2d, and 3d textures are determined from current state of the Texture Unit.
            Assumes animated frames are sequentially numbered in the name.
            If matching texture aliases are found then true is returned.

        @param
            aliasList is a map container of texture alias, texture name pairs
        @param
            apply set true to apply the texture aliases else just test to see if texture alias matches are found.
        @return
            True if matching texture aliases were found in the Texture Unit State.

</member>
        <member name="M:Ogre.TextureUnitState.getTextureNameAlias">
gets the Texture Name Alias of the Texture Unit.

</member>
        <member name="M:Ogre.TextureUnitState.setTextureNameAlias(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the alias name used for texture frame names
        @param name can be any sequence of characters and does not have to be unique           

</member>
        <member name="M:Ogre.TextureUnitState.getName">
get the name of the Texture Unit State
</member>
        <member name="M:Ogre.TextureUnitState.setName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the name of the Texture Unit State
        @remarks
            The name of the Texture Unit State is optional.  Its usefull in material scripts where a material could inherit
            from another material and only want to modify a particalar Texture Unit State.

</member>
        <member name="M:Ogre.TextureUnitState._notifyNeedsRecompile">
Tells the class that it needs recompilation. 
</member>
        <member name="M:Ogre.TextureUnitState.hasViewRelativeTextureCoordinateGeneration">
Returns whether this unit has texture coordinate generation that depends on the camera
</member>
        <member name="M:Ogre.TextureUnitState._unload">
Internal method for unloading this object as part of Material::unload 
</member>
        <member name="M:Ogre.TextureUnitState._load">
Internal method for loading this object as part of Material::load 
</member>
        <member name="M:Ogre.TextureUnitState._unprepare">
Internal method for undoing the preparation this object as part of Material::unprepare
</member>
        <member name="M:Ogre.TextureUnitState._prepare">
Internal method for preparing this object for load, as part of Material::prepare
</member>
        <member name="M:Ogre.TextureUnitState.getParent">
Gets the parent Pass object
</member>
        <member name="M:Ogre.TextureUnitState.getReferencedMRTIndex">
Gets the MRT index of the texture in the compositor that this texture references 
</member>
        <member name="M:Ogre.TextureUnitState.getReferencedTextureName">
Gets the name of the texture in the compositor that this texture references 
</member>
        <member name="M:Ogre.TextureUnitState.getReferencedCompositorName">
Gets the name of the compositor that this texture referneces 
</member>
        <member name="M:Ogre.TextureUnitState.setCompositorReference(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Set the compositor reference for this texture unit state.
		@remarks 
			Only valid when content type is compositor.
		@param compositorName the name of the compositor to reference
		@param textureName the name of the texture to reference
		@param mrtIndex the index of the wanted texture, if referencing an MRT

</member>
        <member name="M:Ogre.TextureUnitState.getTextureMipmapBias">
Gets the bias value applied to the mipmap calculation.
		@see TextureUnitState::setTextureMipmapBias

</member>
        <member name="M:Ogre.TextureUnitState.setTextureMipmapBias(System.Single)">
Sets the bias value applied to the mipmap calculation.
		@remarks
			You can alter the mipmap calculation by biasing the result with a 
			single floating point value. After the mip level has been calculated,
			this bias value is added to the result to give the final mip level.
			Lower mip levels are larger (higher detail), so a negative bias will
			force the larger mip levels to be used, and a positive bias
			will cause smaller mip levels to be used. The bias values are in 
			mip levels, so a -1 bias will force mip levels one larger than by the
			default calculation.
		@param bias The bias value as described above, can be positive or negative.

</member>
        <member name="M:Ogre.TextureUnitState.setTextureAnisotropy(System.UInt32)">
Sets the anisotropy level to be used for this texture level.
        @par maxAniso The maximal anisotropy level, should be between 2 and the maximum supported by hardware (1 is the default, ie. no anisotrophy).
        @note
        This option applies in both the fixed function and the programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.setTextureFiltering(Ogre.FilterOptions,Ogre.FilterOptions,Ogre.FilterOptions)">
Set a the detailed filtering options on this texture unit. 
        @params minFilter The filtering to use when reducing the size of the texture. 
            Can be FO_POINT, FO_LINEAR or FO_ANISOTROPIC
        @params magFilter The filtering to use when increasing the size of the texture
            Can be FO_POINT, FO_LINEAR or FO_ANISOTROPIC
        @params mipFilter The filtering to use between mip levels
            Can be FO_NONE (turns off mipmapping), FO_POINT or FO_LINEAR (trilinear filtering)

</member>
        <member name="M:Ogre.TextureUnitState.setTextureFiltering(Ogre.FilterType,Ogre.FilterOptions)">
Set a single filtering option on this texture unit. 
        @params ftype The filtering type to set
        @params opts The filtering option to set

</member>
        <member name="M:Ogre.TextureUnitState.setTextureFiltering(Ogre.TextureFilterOptions)">
Set the texture filtering for this unit, using the simplified interface.
        @remarks
            You also have the option of specifying the minification, magnification
            and mip filter individually if you want more control over filtering
            options. See the alternative setTextureFiltering methods for details.
        @note
        This option applies in both the fixed function and the programmable pipeline.
        @param filterType The high-level filter type to use.

</member>
        <member name="M:Ogre.TextureUnitState.retryTextureLoad">
Tells the unit to retry loading the texture if it had failed to load.

</member>
        <member name="M:Ogre.TextureUnitState.isTextureLoadFailing">
Tests if the texture associated with this unit has failed to load.

</member>
        <member name="M:Ogre.TextureUnitState.setBlank">
Sets this texture layer to be blank.

</member>
        <member name="M:Ogre.TextureUnitState.isBlank">
Determines if this texture layer is currently blank.
        @note
        This can happen if a texture fails to load or some other non-fatal error. Worth checking after
        setting texture name.

</member>
        <member name="M:Ogre.TextureUnitState.removeEffect(Ogre.TextureUnitState.TextureEffectType!System.Runtime.CompilerServices.IsConst)">
Removes a single effect applied to this texture layer.
        @note
        Because you can only have 1 effect of each type (e.g. 1 texture coordinate generation) applied
        to a layer, only the effect type is required.

</member>
        <member name="M:Ogre.TextureUnitState.removeAllEffects">
Removes all effects applied to this texture layer.

</member>
        <member name="M:Ogre.TextureUnitState.setProjectiveTexturing(System.Boolean,Ogre.Frustum!System.Runtime.CompilerServices.IsConst*)">
Enables or disables projective texturing on this texture unit.
        @remarks
            Projective texturing allows you to generate texture coordinates 
            based on a Frustum, which gives the impression that a texture is
            being projected onto the surface. Note that once you have called
            this method, the texture unit continues to monitor the Frustum you 
            passed in and the projection will change if you can alter it. It also
            means that you must ensure that the Frustum object you pass a pointer
            to remains in existence for as long as this TextureUnitState does.
        @par
            This effect cannot be combined with other texture generation effects, 
            such as environment mapping. It also has no effect on passes which 
            have a vertex program enabled - projective texturing has to be done
            in the vertex program instead.
        @param enabled Whether to enable / disable
        @param projectionSettings The Frustum which will be used to derive the 
            projection parameters.

</member>
        <member name="M:Ogre.TextureUnitState.setTransformAnimation(Ogre.TextureUnitState.TextureTransformType!System.Runtime.CompilerServices.IsConst,Ogre.WaveformType!System.Runtime.CompilerServices.IsConst,System.Single,System.Single,System.Single,System.Single)">
Sets up a general time-relative texture modification effect.
        @note
        This can be called multiple times for different values of ttype, but only the latest effect
        applies if called multiple time for the same ttype.
        @param
        ttype The type of transform, either translate (scroll), scale (stretch) or rotate (spin)
        @param
        waveType The shape of the wave, see WaveformType enum for details
        @param
        base The base value for the function (range of output = {base, base + amplitude})
        @param
        frequency The speed of the wave in cycles per second
        @param
        phase The offset of the start of the wave, e.g. 0.5 to start half-way through the wave
        @param
        amplitude Scales the output so that instead of lying within 0..1 it lies within 0..1*amplitude for exaggerated effects
        @note
        This option has no effect in the programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.setRotateAnimation(System.Single)">
Sets up an animated texture rotation for this layer.
        @note
        Useful for constant rotations (for varying rotations, see setTransformAnimation).
        @param
        speed The number of complete anticlockwise revolutions per second (use -ve for clockwise)
        @note
        This option has no effect in the programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.setScrollAnimation(System.Single,System.Single)">
Sets up an animated scroll for the texture layer.
        @note
        Useful for creating constant scrolling effects on a texture layer (for varying scrolls, see setTransformAnimation).
        @param
        uSpeed The number of horizontal loops per second (+ve=moving right, -ve = moving left)
        @param
        vSpeed The number of vertical loops per second (+ve=moving up, -ve= moving down)
        @note
        This option has no effect in the programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.setEnvironmentMap(System.Boolean,Ogre.TextureUnitState.EnvMapType)">
Turns on/off texture coordinate effect that makes this layer an environment map.
        @remarks
        Environment maps make an object look reflective by using the object's vertex normals relative
        to the camera view to generate texture coordinates.
        @par
        The vectors generated can either be used to address a single 2D texture which
        is a 'fish-eye' lens view of a scene, or a 3D cubic environment map which requires 6 textures
        for each side of the inside of a cube. The type depends on what texture you set up - if you use the
        setTextureName method then a 2D fisheye lens texture is required, whereas if you used setCubicTextureName
        then a cubic environemnt map will be used.
        @par
        This effect works best if the object has lots of gradually changing normals. The texture also
        has to be designed for this effect - see the example spheremap.png included with the sample
        application for a 2D environment map; a cubic map can be generated by rendering 6 views of a
        scene to each of the cube faces with orthoganal views.
        @note
        Enabling this disables any other texture coordinate generation effects.
        However it can be combined with texture coordinate modification functions, which then operate on the
        generated coordinates rather than static model texture coordinates.
        @param
        enable True to enable, false to disable
        @param
        planar If set to true, instead of being based on normals the environment effect is based on
        vertex positions. This is good for planar surfaces.
        @note
        This option has no effect in the programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.addEffect(Ogre.TextureUnitState.TextureEffect*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Generic method for setting up texture effects.
        @remarks
        Allows you to specify effects directly by using the TextureEffectType enumeration. The
        arguments that go with it depend on the effect type. Only one effect of
        each type can be applied to a texture layer.
        @par
        This method is used internally by Ogre but it is better generally for applications to use the
        more intuitive specialised methods such as setEnvironmentMap and setScroll.
        @note
        This option has no effect in the programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.setAlphaOperation(Ogre.LayerBlendOperationEx,Ogre.LayerBlendSource,Ogre.LayerBlendSource,System.Single,System.Single,System.Single)">
Sets the alpha operation to be applied to this texture.
        @remarks
        This works in exactly the same way as setColourOperation, except
        that the effect is applied to the level of alpha (i.e. transparency)
        of the texture rather than its colour. When the alpha of a texel (a pixel
        on a texture) is 1.0, it is opaque, wheras it is fully transparent if the
        alpha is 0.0. Please refer to the setColourOperation method for more info.
        @param
        op The operation to be used, e.g. modulate (multiply), add, subtract
        @param
        source1 The source of the first alpha value to the operation e.g. texture alpha
        @param
        source2 The source of the second alpha value to the operation e.g. current surface alpha
        @param
        arg1 Manually supplied alpha value (only required if source1 = LBS_MANUAL)
        @param
        arg2 Manually supplied alpha value (only required if source2 = LBS_MANUAL)
        @param
        manualBlend Manually supplied 'blend' value - only required for operations
        which require manual blend e.g. LBX_BLEND_MANUAL
        @see
        setColourOperation
        @note
        This option has no effect in the programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.getColourBlendFallbackDest">
Get the multipass fallback for colour blending operation destination factor.

</member>
        <member name="M:Ogre.TextureUnitState.getColourBlendFallbackSrc">
Get the multipass fallback for colour blending operation source factor.

</member>
        <member name="M:Ogre.TextureUnitState.getAlphaBlendMode">
Get multitexturing alpha blending mode.

</member>
        <member name="M:Ogre.TextureUnitState.getColourBlendMode">
Get multitexturing colour blending mode.

</member>
        <member name="M:Ogre.TextureUnitState.setColourOpMultipassFallback(Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst,Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst)">
Sets the multipass fallback operation for this layer, if you used TextureUnitState::setColourOperationEx
        and not enough multitexturing hardware is available.
        @remarks
        Because some effects exposed using TextureUnitState::setColourOperationEx are only supported under
        multitexturing hardware, if the hardware is lacking the system must fallback on multipass rendering,
        which unfortunately doesn't support as many effects. This method is for you to specify the fallback
        operation which most suits you.
        @par
        You'll notice that the interface is the same as the Material::setSceneBlending method; this is
        because multipass rendering IS effectively scene blending, since each layer is rendered on top
        of the last using the same mechanism as making an object transparent, it's just being rendered
        in the same place repeatedly to get the multitexture effect.
        @par
        If you use the simpler (and hence less flexible) TextureUnitState::setColourOperation method you
        don't need to call this as the system sets up the fallback for you.
        @note
        This option has no effect in the programmable pipeline, because there is no multipass fallback
        and multitexture blending is handled by the fragment shader.

</member>
        <member name="M:Ogre.TextureUnitState.setColourOperation(Ogre.LayerBlendOperation!System.Runtime.CompilerServices.IsConst)">
Determines how this texture layer is combined with the one below it (or the diffuse colour of
        the geometry if this is layer 0).
        @remarks
        This method is the simplest way to blend tetxure layers, because it requires only one parameter,
        gives you the most common blending types, and automatically sets up 2 blending methods: one for
        if single-pass multitexturing hardware is available, and another for if it is not and the blending must
        be achieved through multiple rendering passes. It is, however, quite limited and does not expose
        the more flexible multitexturing operations, simply because these can't be automatically supported in
        multipass fallback mode. If want to use the fancier options, use TextureUnitState::setColourOperationEx,
        but you'll either have to be sure that enough multitexturing units will be available, or you should
        explicitly set a fallback using TextureUnitState::setColourOpMultipassFallback.
        @note
        The default method is LBO_MODULATE for all layers.
        @note
        This option has no effect in the programmable pipeline.
        @param
        op One of the LayerBlendOperation enumerated blending types.

</member>
        <member name="M:Ogre.TextureUnitState.setColourOperationEx(Ogre.LayerBlendOperationEx,Ogre.LayerBlendSource,Ogre.LayerBlendSource,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Setting advanced blending options.
        @remarks
        This is an extended version of the TextureUnitState::setColourOperation method which allows
        extremely detailed control over the blending applied between this and earlier layers.
        See the IMPORTANT note below about the issues between mulitpass and multitexturing that
        using this method can create.
        @par
        Texture colour operations determine how the final colour of the surface appears when
        rendered. Texture units are used to combine colour values from various sources (ie. the
        diffuse colour of the surface from lighting calculations, combined with the colour of
        the texture). This method allows you to specify the 'operation' to be used, ie. the
        calculation such as adds or multiplies, and which values to use as arguments, such as
        a fixed value or a value from a previous calculation.
        @par
        The defaults for each layer are:
        <ul><li>op = LBX_MODULATE</li><li>source1 = LBS_TEXTURE</li><li>source2 = LBS_CURRENT</li></ul>
        ie. each layer takes the colour results of the previous layer, and multiplies them
        with the new texture being applied. Bear in mind that colours are RGB values from
        0.0 - 1.0 so multiplying them together will result in values in the same range,
        'tinted' by the multiply. Note however that a straight multiply normally has the
        effect of darkening the textures - for this reason there are brightening operations
        like LBO_MODULATE_X2. See the LayerBlendOperation and LayerBlendSource enumerated
        types for full details.
        @note
        Because of the limitations on some underlying APIs (Direct3D included)
        the LBS_TEXTURE argument can only be used as the first argument, not the second.
        @par
        The final 3 parameters are only required if you decide to pass values manually
        into the operation, i.e. you want one or more of the inputs to the colour calculation
        to come from a fixed value that you supply. Hence you only need to fill these in if
        you supply LBS_MANUAL to the corresponding source, or use the LBX_BLEND_MANUAL
        operation.
        @warning
        Ogre tries to use multitexturing hardware to blend texture layers
        together. However, if it runs out of texturing units (e.g. 2 of a GeForce2, 4 on a
        GeForce3) it has to fall back on multipass rendering, i.e. rendering the same object
        multiple times with different textures. This is both less efficient and there is a smaller
        range of blending operations which can be performed. For this reason, if you use this method
        you MUST also call TextureUnitState::setColourOpMultipassFallback to specify which effect you
        want to fall back on if sufficient hardware is not available.
        @note
        This has no effect in the programmable pipeline.
        @param
        If you wish to avoid having to do this, use the simpler TextureUnitState::setColourOperation method
        which allows less flexible blending options but sets up the multipass fallback automatically,
        since it only allows operations which have direct multipass equivalents.
        @param
        op The operation to be used, e.g. modulate (multiply), add, subtract
        @param
        source1 The source of the first colour to the operation e.g. texture colour
        @param
        source2 The source of the second colour to the operation e.g. current surface colour
        @param
        arg1 Manually supplied colour value (only required if source1 = LBS_MANUAL)
        @param
        arg2 Manually supplied colour value (only required if source2 = LBS_MANUAL)
        @param
        manualBlend Manually supplied 'blend' value - only required for operations
        which require manual blend e.g. LBX_BLEND_MANUAL

</member>
        <member name="M:Ogre.TextureUnitState.getTextureBorderColour">
Sets the texture border colour.
        @note
            The default is ColourValue::Black, and this value only used when addressing mode
            is TAM_BORDER.

</member>
        <member name="M:Ogre.TextureUnitState.setTextureBorderColour(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the texture border colour.
        @note
            The default is ColourValue::Black, and this value only used when addressing mode
            is TAM_BORDER.
        @note
            This applies for both the fixed-function and programmable pipelines.

</member>
        <member name="M:Ogre.TextureUnitState.setTextureAddressingMode(Ogre.TextureUnitState.UVWAddressingMode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the texture addressing mode, i.e. what happens at uv values above 1.0.
        @note
        The default is TAM_WRAP i.e. the texture repeats over values of 1.0.
        @note
        This applies for both the fixed-function and programmable pipelines.

</member>
        <member name="M:Ogre.TextureUnitState.setTextureAddressingMode(Ogre.TextureUnitState.TextureAddressingMode,Ogre.TextureUnitState.TextureAddressingMode,Ogre.TextureUnitState.TextureAddressingMode)">
Sets the texture addressing mode, i.e. what happens at uv values above 1.0.
        @note
        The default is TAM_WRAP i.e. the texture repeats over values of 1.0.
        @note
        This applies for both the fixed-function and programmable pipelines.

</member>
        <member name="M:Ogre.TextureUnitState.setTextureAddressingMode(Ogre.TextureUnitState.TextureAddressingMode)">
Sets the texture addressing mode, i.e. what happens at uv values above 1.0.
        @note
        The default is TAM_WRAP i.e. the texture repeats over values of 1.0.
		@note This is a shortcut method which sets the addressing mode for all
			coordinates at once; you can also call the more specific method
			to set the addressing mode per coordinate.
        @note
        This applies for both the fixed-function and programmable pipelines.

</member>
        <member name="M:Ogre.TextureUnitState.getTextureAddressingMode">
Gets the texture addressing mode for a given coordinate, 
		 	i.e. what happens at uv values above 1.0.
        @note
        	The default is TAM_WRAP i.e. the texture repeats over values of 1.0.

</member>
        <member name="M:Ogre.TextureUnitState.setTextureRotate(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the anticlockwise rotation factor applied to texture coordinates.
        @remarks
        This sets a fixed rotation angle - if you wish to animate this, see the
        ControllerManager::createTextureRotater method.
        @note
        Has no effect in the programmable pipeline.
        @param
        angle The angle of rotation (anticlockwise).

</member>
        <member name="M:Ogre.TextureUnitState.setTextureScale(System.Single,System.Single)">
Sets the scaling factor applied to texture coordinates.
        @remarks
        This method sets the scale element of the texture transformation, and is easier to use than
        setTextureTransform if you are combining translation, scaling and rotation in your texture transformation. Again if you want
        to animate these values you need to use a Controller (see ControllerManager and it's methods for
        more information).
        @note
        Has no effect in the programmable pipeline.
        @param
        uScale The value by which the texture is to be scaled horizontally.
        @param
        vScale The value by which the texture is to be scaled vertically.

</member>
        <member name="M:Ogre.TextureUnitState.setTextureVScale(System.Single)">
As setTextureScale, but sets only V value.
        @note
        Has no effect in the programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.setTextureUScale(System.Single)">
As setTextureScale, but sets only U value.
        @note
        Has no effect in the programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.setTextureVScroll(System.Single)">
As setTextureScroll, but sets only V value.
        @note
        Has no effect in the programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.setTextureUScroll(System.Single)">
As setTextureScroll, but sets only U value.
        @note
        Has no effect in the programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.setTextureScroll(System.Single,System.Single)">
Sets the translation offset of the texture, ie scrolls the texture.
        @remarks
        This method sets the translation element of the texture transformation, and is easier to use than setTextureTransform if
        you are combining translation, scaling and rotation in your texture transformation. Again if you want
        to animate these values you need to use a Controller
        @note
        Has no effect in the programmable pipeline.
        @param u The amount the texture should be moved horizontally (u direction).
        @param v The amount the texture should be moved vertically (v direction).
        @see
        ControllerManager, Controller

</member>
        <member name="M:Ogre.TextureUnitState.getTextureTransform">
Gets the current texture transformation matrix.
        @remarks
        Causes a reclaculation of the matrix if any parameters have been changed via
        setTextureScroll, setTextureScale and setTextureRotate.
        @note
        Has no effect in the programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.setTextureCoordSet(System.UInt32)">
Sets the index of the set of texture co-ords this layer uses.
        @note
        Default is 0 for all layers. Only change this if you have provided multiple texture co-ords per
        vertex.
        @note
        Applies to both fixed-function and programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.getTextureCoordSet">
Gets the index of the set of texture co-ords this layer uses.
        @note
        Applies to both fixed-function and programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.isHardwareGammaEnabled">
@copydoc Texture::isHardwareGammaEnabled
</member>
        <member name="M:Ogre.TextureUnitState.setHardwareGammaEnabled(System.Boolean)">
@copydoc Texture::setHardwareGammaEnabled
</member>
        <member name="M:Ogre.TextureUnitState.getIsAlpha">
Gets whether this texture is requested to be loaded as alpha if single channel

</member>
        <member name="M:Ogre.TextureUnitState.setIsAlpha(System.Boolean)">
Sets whether this texture is requested to be loaded as alpha if single channel

</member>
        <member name="M:Ogre.TextureUnitState.getNumMipmaps">
Gets how many mipmaps have been requested for the texture.

</member>
        <member name="M:Ogre.TextureUnitState.setNumMipmaps(System.Int32)">
Sets how many mipmaps have been requested for the texture.

</member>
        <member name="M:Ogre.TextureUnitState.getDesiredFormat">
Gets the desired pixel format when load the texture.

</member>
        <member name="M:Ogre.TextureUnitState.setDesiredFormat(Ogre.PixelFormat)">
Sets the desired pixel format when load the texture.

</member>
        <member name="M:Ogre.TextureUnitState.getTextureType">
Returns the type of this texture.
        @note
        Applies to both fixed-function and programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.is3D">
Returns true if this texture layer uses a composite 3D cubic texture.
        @note
        Applies to both fixed-function and programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.isCubic">
Returns true if this texture unit is either a series of 6 2D textures, each
            in it's own frame, or is a full 3D cube map. You can tell which by checking
            getTextureType.
        @note
        Applies to both fixed-function and programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.getContentType">
Get the type of content this TextureUnitState references. 
</member>
        <member name="M:Ogre.TextureUnitState.setContentType(Ogre.TextureUnitState.ContentType)">
Set the type of content this TextureUnitState references.
		@remarks
			The default is to reference a standard named texture, but this unit
			can also reference automated content like a shadow texture.

</member>
        <member name="M:Ogre.TextureUnitState.getBindingType">
Gets the type of unit these texture settings should be bound to.  

</member>
        <member name="M:Ogre.TextureUnitState.setBindingType(Ogre.TextureUnitState.BindingType)">
Sets the type of unit these texture settings should be bound to. 
		@remarks
			Some render systems, when implementing vertex texture fetch, separate
			the binding of textures for use in the vertex program versus those
			used in fragment programs. This setting allows you to target the
			vertex processing unit with a texture binding, in those cases. For
			rendersystems which have a unified binding for the vertex and fragment
			units, this setting makes no difference.

</member>
        <member name="F:CONTENT_COMPOSITOR">
A compositor texture, automatically linked to active viewport's chain
</member>
        <member name="F:CONTENT_SHADOW">
A shadow texture, automatically bound by engine
</member>
        <member name="F:CONTENT_NAMED">
Normal texture identified by name
</member>
        <member name="T:Ogre.TextureUnitState.ContentType">
Enum identifying the type of content this texture unit contains.

</member>
        <member name="F:BT_VERTEX">
Vertex processing unit - indicates this unit will be used for 
				a vertex texture fetch.

</member>
        <member name="F:BT_FRAGMENT">
Regular fragment processing unit - the default. 
</member>
        <member name="T:Ogre.TextureUnitState.BindingType">
The type of unit to bind the texture settings to. 
</member>
        <member name="M:Ogre.TextureUnitState.getNumFrames">
Gets the number of frames for a texture.
        @note
        Applies to both fixed-function and programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.deleteFrameTextureName(System.UInt32!System.Runtime.CompilerServices.IsConst)">
deletes a specific texture frame.  The texture used is not deleted but the
            texture will no longer be used by the Texture Unit.  An exception is raised
            if the frame number exceeds the number of actual frames.
        @param frameNumber The frame number of the texture to be deleted.
        @note
        Applies to both fixed-function and programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.addFrameTextureName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add a Texture name to the end of the frame container.
        @param name The name of the texture
        @note
        Applies to both fixed-function and programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.setFrameTextureName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Sets the name of the texture associated with a frame.
        @param name The name of the texture
        @param frameNumber The frame the texture name is to be placed in
        @note
        Throws an exception if frameNumber exceeds the number of stored frames.
        Applies to both fixed-function and programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.getFrameTextureName(System.UInt32)">
Gets the name of the texture associated with a frame number.
            Throws an exception if frameNumber exceeds the number of stored frames.
        @note
        Applies to both fixed-function and programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.getCurrentFrame">
Gets the active frame in an animated or multi-image texture layer.
        @note
        Applies to both fixed-function and programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.setCurrentFrame(System.UInt32)">
Changes the active frame in an animated or multi-image texture.
        @remarks
        An animated texture (or a cubic texture where the images are not combined for 3D use) is made up of
        a number of frames. This method sets the active frame.
        @note
        Applies to both fixed-function and programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.getTextureDimensions(System.UInt32)">
Returns the width and height of the texture in the given frame.

</member>
        <member name="M:Ogre.TextureUnitState.setAnimatedTextureName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.UInt32,System.Single)">
Sets the names of the texture images for an animated texture.
        @remarks
        This an alternative method to the one where you specify a single name and let the system derive
        the names of each frame, incase your images can't conform to this naming standard.
        @par
        Animated textures are just a series of images making up the frames of the animation. All the images
        must be the same size, and you must provide their names as an array in the first parameter.
        You can change the active frame on a texture layer by calling the setCurrentFrame method.
        @note
        If you can make your texture images conform to a naming standard of basicName_frame.ext, you
        can call the alternative setAnimatedTextureName method which just takes a base name instead.
        @note
        Applies to both fixed-function and programmable pipeline.
        @param
        names Pointer to array of names of the textures to use, in frame order.
        @param
        numFrames The number of frames in the sequence.
        @param
        duration The length of time it takes to display the whole animation sequence, in seconds.
        If 0, no automatic transition occurs.

</member>
        <member name="M:Ogre.TextureUnitState.setAnimatedTextureName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.Single)">
Sets the names of the texture images for an animated texture.
        @remarks
        Animated textures are just a series of images making up the frames of the animation. All the images
        must be the same size, and their names must have a frame number appended before the extension, e.g.
        if you specify a name of "wall.jpg" with 3 frames, the image names must be "wall_0.jpg", "wall_1.jpg"
        and "wall_2.jpg".
        @par
        You can change the active frame on a texture layer by calling the setCurrentFrame method.
        @note
        If you can't make your texture images conform to the naming standard layed out here, you
        can call the alternative setAnimatedTextureName method which takes an array of names instead.
        @note
        Applies to both fixed-function and programmable pipeline.
        @param
        name The base name of the textures to use e.g. wall.jpg for frames wall_0.jpg, wall_1.jpg etc.
        @param
        numFrames The number of frames in the sequence.
        @param
        duration The length of time it takes to display the whole animation sequence, in seconds.
        If 0, no automatic transition occurs.

</member>
        <member name="M:Ogre.TextureUnitState.setTextureName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.TextureType)">
Sets this texture layer to use a single texture, given the
        name of the texture to use on this layer.
        @note
        Applies to both fixed-function and programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.getTextureName">
Get the name of current texture image for this layer.
        @remarks
        This will either always be a single name for this layer,
        or will be the name of the current frame for an animated
        or otherwise multi-frame texture.
        @note
        Applies to both fixed-function and programmable pipeline.

</member>
        <member name="M:Ogre.TextureUnitState.#ctor(Ogre.Pass*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Name-based constructor.
        @param
        name The basic name of the texture e.g. brickwall.jpg, stonefloor.png
        @param
        texCoordSet The index of the texture coordinate set to use.

</member>
        <member name="M:Ogre.TextureUnitState.Dispose">
Default destructor.

</member>
        <member name="M:Ogre.TextureUnitState.#ctor(Ogre.Pass*)">
Default constructor.

</member>
        <member name="D:Ogre.TextureUnitState.EffectMap">
Texture effects in a multimap paired array

</member>
        <member name="T:Ogre.TextureUnitState.TextureEffect">
Internal structure defining a texture effect.

</member>
        <member name="T:Ogre.TextureUnitState.TextureCubeFace">
Enum identifying the frame indexes for faces of a cube map (not the composite 3D type.

</member>
        <member name="T:Ogre.TextureUnitState.UVWAddressingMode">
Texture addressing mode for each texture coordinate. 
</member>
        <member name="F:TAM_BORDER">
Texture coordinates outside the range [0.0, 1.0] are set to the border colour
</member>
        <member name="F:TAM_CLAMP">
Texture clamps at 1.0
</member>
        <member name="F:TAM_MIRROR">
Texture mirrors (flips) at joins over 1.0
</member>
        <member name="F:TAM_WRAP">
Texture wraps at values over 1.0
</member>
        <member name="T:Ogre.TextureUnitState.TextureAddressingMode">
Texture addressing modes - default is TAM_WRAP.
        @note
            These settings are relevant in both the fixed-function and the
            programmable pipeline.

</member>
        <member name="T:Ogre.TextureUnitState.TextureTransformType">
Useful enumeration when dealing with procedural transforms.
        @note
            Note that these have no effect when using the programmable pipeline, since their
            effect is overridden by the vertex / fragment programs.

</member>
        <member name="F:ENV_NORMAL">
Envmap intended to supply normal vectors for cube mapping
</member>
        <member name="F:ENV_REFLECTION">
Envmap intended to supply reflection vectors for cube mapping
</member>
        <member name="F:ENV_CURVED">
Envmap based on dot of vector from camera to vertex and vertex normal, good for curves
</member>
        <member name="F:ENV_PLANAR">
Envmap based on vector from camera to vertex position, good for planar geometry
</member>
        <member name="T:Ogre.TextureUnitState.EnvMapType">
Enumeration to specify type of envmap.
        @note
            Note that these have no effect when using the programmable pipeline, since their
            effect is overridden by the vertex / fragment programs.

</member>
        <member name="F:ET_TRANSFORM">
More complex transform
</member>
        <member name="F:ET_ROTATE">
Constant rotation
</member>
        <member name="F:ET_VSCROLL">
Constant u/v scrolling effect
</member>
        <member name="F:ET_USCROLL">
Constant u scrolling effect
</member>
        <member name="F:ET_UVSCROLL">
Constant u/v scrolling effect
</member>
        <member name="F:ET_PROJECTIVE_TEXTURE">
Generate texture coords based on a frustum
</member>
        <member name="F:ET_ENVIRONMENT_MAP">
Generate all texture coords based on angle between camera and vertex
</member>
        <member name="T:Ogre.TextureUnitState.TextureEffectType">
Definition of the broad types of texture effect you can apply to a texture unit.
        @note
            Note that these have no effect when using the programmable pipeline, since their
            effect is overridden by the vertex / fragment programs.

</member>
        <member name="T:Ogre.TextureUnitState">
\addtogroup Core
	*  @{

\addtogroup Materials
	*  @{

Class representing the state of a single texture unit during a Pass of a
        Technique, of a Material.
    @remarks
        Texture units are pipelines for retrieving texture data for rendering onto
        your objects in the world. Using them is common to both the fixed-function and 
        the programmable (vertex and fragment program) pipeline, but some of the 
        settings will only have an effect in the fixed-function pipeline (for example, 
        setting a texture rotation will have no effect if you use the programmable
        pipeline, because this is overridden by the fragment program). The effect
        of each setting as regards the 2 pipelines is commented in each setting.
    @par
        When I use the term 'fixed-function pipeline' I mean traditional rendering
        where you do not use vertex or fragment programs (shaders). Programmable 
        pipeline means that for this pass you are using vertex or fragment programs.

</member>
        <member name="M:Ogre.TexturePtr.op_Assign(Ogre.SharedPtr&lt;Ogre.Resource&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Operator used to convert a ResourcePtr to a TexturePtr
</member>
        <member name="M:Ogre.Texture.getSourceFileType">
Identify the source file type as a string, either from the extension
			or from a magic number.

</member>
        <member name="M:Ogre.Texture.unloadImpl">
Default implementation of unload which calls freeInternalResources 
</member>
        <member name="M:Ogre.Texture.freeInternalResourcesImpl">
Implementation of freeing internal texture resources 

</member>
        <member name="M:Ogre.Texture.createInternalResourcesImpl">
Implementation of creating internal texture resources 

</member>
        <member name="M:Ogre.Texture.calculateSize">
@copydoc Resource::calculateSize
</member>
        <member name="M:Ogre.Texture.convertToImage(Ogre.Image*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Populate an Image with the contents of this texture. 
		@param destImage The target image (contents will be overwritten)
		@param includeMipMaps Whether to embed mipmaps in the image

</member>
        <member name="M:Ogre.Texture.getBuffer(System.UInt32,System.UInt32)">
Return hardware pixel buffer for a surface. This buffer can then
			be used to copy data from and to a particular level of the texture.
			@param face 	Face number, in case of a cubemap texture. Must be 0
							for other types of textures.
                            For cubemaps, this is one of 
                            +X (0), -X (1), +Y (2), -Y (3), +Z (4), -Z (5)
			@param mipmap	Mipmap level. This goes from 0 for the first, largest
							mipmap level to getNumMipmaps()-1 for the smallest.
			@returns	A shared pointer to a hardware pixel buffer
			@remarks	The buffer is invalidated when the resource is unloaded or destroyed.
						Do not use it after the lifetime of the containing texture.

</member>
        <member name="M:Ogre.Texture.getNumFaces">
Return the number of faces this texture has. This will be 6 for a cubemap
        	texture and 1 for a 1D, 2D or 3D one.

</member>
        <member name="M:Ogre.Texture.getTreatLuminanceAsAlpha">
Gets whether luminace pixel format will treated as alpha format when load this texture.

</member>
        <member name="M:Ogre.Texture.setTreatLuminanceAsAlpha(System.Boolean)">
Sets whether luminace pixel format will treated as alpha format when load this texture.

</member>
        <member name="M:Ogre.Texture.setDesiredBitDepths(System.UInt16,System.UInt16)">
Sets desired bit depth for integer and float pixel format.

</member>
        <member name="M:Ogre.Texture.getDesiredFloatBitDepth">
gets desired bit depth for float pixel format textures.

</member>
        <member name="M:Ogre.Texture.setDesiredFloatBitDepth(System.UInt16)">
Sets desired bit depth for float pixel format textures.
        @note
            Available values: 0, 16 and 32, where 0 (the default) means keep original format
            as it is. This value is number of bits for a channel of the pixel.

</member>
        <member name="M:Ogre.Texture.getDesiredIntegerBitDepth">
gets desired bit depth for integer pixel format textures.

</member>
        <member name="M:Ogre.Texture.setDesiredIntegerBitDepth(System.UInt16)">
Sets desired bit depth for integer pixel format textures.
        @note
            Available values: 0, 16 and 32, where 0 (the default) means keep original format
            as it is. This value is number of bits for the pixel.

</member>
        <member name="M:Ogre.Texture.hasAlpha">
Returns true if the texture has an alpha layer. 
</member>
        <member name="M:Ogre.Texture.setFormat(Ogre.PixelFormat)">
Sets the pixel format for the texture surface; can only be set before load(). 
</member>
        <member name="M:Ogre.Texture.getSrcFormat">
Returns the pixel format of the original input texture (may differ due to
            hardware requirements and pixel format convertion).

</member>
        <member name="M:Ogre.Texture.getDesiredFormat">
Returns the desired pixel format for the texture surface. 
</member>
        <member name="M:Ogre.Texture.getFormat">
Returns the pixel format for the texture surface. 
</member>
        <member name="M:Ogre.Texture._loadImages(std.vector&lt;Ogre.Image!System.Runtime.CompilerServices.IsConst**&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method to load the texture from a set of images. 
		@note Do NOT call this method unless you are inside the load() routine
			already, e.g. a ManualResourceLoader. It is not threadsafe and does
			not check or update resource loading status.

</member>
        <member name="M:Ogre.Texture.loadRawData(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16,System.UInt16,Ogre.PixelFormat)">
Loads the data from a raw stream.
		@note Important: only call this from outside the load() routine of a 
			Resource. Don't call it within (including ManualResourceLoader) - use
			_loadImages() instead. This method is designed to be external, 
			performs locking and checks the load status before loading.
		@param stream Data stream containing the raw pixel data
		@param uWidth Width of the image
		@param uHeight Height of the image
		@param eFormat The format of the pixel data

</member>
        <member name="M:Ogre.Texture.loadImage(Ogre.Image!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Loads the data from an image.
		@note Important: only call this from outside the load() routine of a 
			Resource. Don't call it within (including ManualResourceLoader) - use
			_loadImages() instead. This method is designed to be external, 
			performs locking and checks the load status before loading.

</member>
        <member name="M:Ogre.Texture.copyToTexture(Ogre.TexturePtr*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copies (and maybe scales to fit) the contents of this texture to
			another texture. 
</member>
        <member name="M:Ogre.Texture.freeInternalResources">
Frees internal texture resources for this texture. 

</member>
        <member name="M:Ogre.Texture.createInternalResources">
Creates the internal texture resources for this texture. 
        @remarks
            This method creates the internal texture resources (pixel buffers, 
            texture surfaces etc) required to begin using this texture. You do
            not need to call this method directly unless you are manually creating
            a texture, in which case something must call it, after having set the
            size and format of the texture (e.g. the ManualResourceLoader might
            be the best one to call it). If you are not defining a manual texture,
            or if you use one of the self-contained load...() methods, then it will be
            called for you.

</member>
        <member name="M:Ogre.Texture.setUsage(System.Int32)">
Sets the TextureUsage indentifier for this Texture; only useful before load()
			
			@param u is a combination of TU_STATIC, TU_DYNAMIC, TU_WRITE_ONLY 
				TU_AUTOMIPMAP and TU_RENDERTARGET (see TextureUsage enum). You are
            	strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to 
            	update regularly, consider HBU_DYNAMIC_WRITE_ONLY.

</member>
        <member name="M:Ogre.Texture.getUsage">
Returns the TextureUsage indentifier for this Texture

</member>
        <member name="M:Ogre.Texture.setDepth(System.UInt32)">
Set the depth of the texture (only applicable for 3D textures);
            ; can only do this before load();

</member>
        <member name="M:Ogre.Texture.setWidth(System.UInt32)">
Set the width of the texture; can only do this before load();

</member>
        <member name="M:Ogre.Texture.setHeight(System.UInt32)">
Set the height of the texture; can only do this before load();

</member>
        <member name="M:Ogre.Texture.getSrcDepth">
Returns the original depth of the input texture (only applicable for 3D textures).

</member>
        <member name="M:Ogre.Texture.getSrcWidth">
Returns the width of the original input texture (may differ due to hardware requirements).

</member>
        <member name="M:Ogre.Texture.getSrcHeight">
Returns the height of the original input texture (may differ due to hardware requirements).

</member>
        <member name="M:Ogre.Texture.getDepth">
Returns the depth of the texture (only applicable for 3D textures).

</member>
        <member name="M:Ogre.Texture.getWidth">
Returns the width of the texture.

</member>
        <member name="M:Ogre.Texture.getHeight">
Returns the height of the texture.

</member>
        <member name="M:Ogre.Texture.getFSAAHint">
Get the multisample AA hint if this texture is a rendertarget.

</member>
        <member name="M:Ogre.Texture.getFSAA">
Get the level of multisample AA to be used if this texture is a 
		rendertarget.

</member>
        <member name="M:Ogre.Texture.setFSAA(System.UInt32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the level of multisample AA to be used if this texture is a 
			rendertarget.
		@note This option will be ignored if TU_RENDERTARGET is not part of the
			usage options on this texture, or if the hardware does not support it. 
		@param fsaa The number of samples
		@param fsaaHint Any hinting text (@see Root::createRenderWindow)

</member>
        <member name="M:Ogre.Texture.isHardwareGammaEnabled">
Gets whether this texture will be set up so that on sampling it, 
		hardware gamma correction is applied.

</member>
        <member name="M:Ogre.Texture.setHardwareGammaEnabled(System.Boolean)">
Sets whether this texture will be set up so that on sampling it, 
			hardware gamma correction is applied.
		@remarks
			24-bit textures are often saved in gamma colour space; this preserves
			precision in the 'darks'. However, if you're performing blending on 
			the sampled colours, you really want to be doing it in linear space. 
			One way is to apply a gamma correction value on loading (see setGamma),
			but this means you lose precision in those dark colours. An alternative
			is to get the hardware to do the gamma correction when reading the 
			texture and converting it to a floating point value for the rest of
			the pipeline. This option allows you to do that; it's only supported
			in relatively recent hardware (others will ignore it) but can improve
			the quality of colour reproduction.
		@note
			Must be called before any 'load' method since it may affect the
			construction of the underlying hardware resources.
			Also note this only useful on textures using 8-bit colour channels.

</member>
        <member name="M:Ogre.Texture.setGamma(System.Single)">
Sets the gamma adjustment factor applied to this texture on loading the
			data.
            @note
                Must be called before any 'load' method. This gamma factor will
				be premultiplied in and may reduce the precision of your textures.
				You can use setHardwareGamma if supported to apply gamma on 
				sampling the texture instead.

</member>
        <member name="M:Ogre.Texture.getGamma">
Returns the gamma adjustment factor applied to this texture on loading.

</member>
        <member name="M:Ogre.Texture.getMipmapsHardwareGenerated">
Are mipmaps hardware generated?
		@remarks
			Will only be accurate after texture load, or createInternalResources

</member>
        <member name="M:Ogre.Texture.setNumMipmaps(System.UInt32)">
Sets the number of mipmaps to be used for this texture.
            @note
                Must be set before calling any 'load' method.

</member>
        <member name="M:Ogre.Texture.getNumMipmaps">
Gets the number of mipmaps to be used for this texture.

</member>
        <member name="M:Ogre.Texture.getTextureType">
Gets the type of texture 

</member>
        <member name="M:Ogre.Texture.setTextureType(Ogre.TextureType)">
Sets the type of texture; can only be changed before load() 

</member>
        <member name="T:Ogre.Texture">
Abstract class representing a Texture resource.
        @remarks
            The actual concrete subclass which will exist for a texture
            is dependent on the rendering system in use (Direct3D, OpenGL etc).
            This class represents the commonalities, and is the one 'used'
            by programmers even though the real implementation could be
            different in reality. Texture objects are created through
            the 'create' method of the TextureManager concrete subclass.

</member>
        <member name="T:Ogre.TextureMipmap">
Enum identifying special mipmap numbers

</member>
        <member name="F:MIP_DEFAULT">
Use TextureManager default
</member>
        <member name="F:MIP_UNLIMITED">
Generate mipmaps up to 1x1
</member>
        <member name="T:Ogre.TextureType">
Enum identifying the texture type

</member>
        <member name="F:TEX_TYPE_CUBE_MAP">
3D cube map, used in combination with 3D texture coordinates
</member>
        <member name="F:TEX_TYPE_3D">
3D volume texture, used in combination with 3D texture coordinates
</member>
        <member name="F:TEX_TYPE_2D">
2D texture, used in combination with 2D texture coordinates (default)
</member>
        <member name="F:TEX_TYPE_1D">
1D texture, used in combination with 1D texture coordinates
</member>
        <member name="T:Ogre.TextureUsage">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

Enum identifying the texture usage

</member>
        <member name="F:TU_DEFAULT">
default to automatic mipmap generation static textures
</member>
        <member name="F:TU_RENDERTARGET">
this texture will be a render target, i.e. used as a target for render to texture
setting this flag will ignore all other texture usages except TU_AUTOMIPMAP
</member>
        <member name="F:TU_AUTOMIPMAP">
mipmaps will be automatically generated for this texture
</member>
        <member name="F:TU_STATIC">
@copydoc HardwareBuffer::Usage
</member>
        <member name="M:Ogre.Image.getFileExtFromMagic(Ogre.SharedPtr&lt;Ogre.DataStream&gt;)">
Static function to get an image type string from a stream via magic numbers
</member>
        <member name="M:Ogre.Image.resize(System.UInt16,System.UInt16,Ogre.Image.Filter)">
Resize a 2D image, applying the appropriate filter. 
</member>
        <member name="M:Ogre.Image.scale(Ogre.PixelBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.PixelBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Image.Filter)">
Scale a 1D, 2D or 3D image volume. 
			@param 	src			PixelBox containing the source pointer, dimensions and format
			@param 	dst			PixelBox containing the destination pointer, dimensions and format
			@param 	filter		Which filter to use
			@remarks 	This function can do pixel format conversion in the process.
			@note	dst and src can point to the same PixelBox object without any problem

</member>
        <member name="M:Ogre.Image.freeMemory">
Delete all the memory held by this image, if owned by this image (not dynamic)
</member>
        <member name="M:Ogre.Image.getPixelBox(System.UInt32,System.UInt32)">
Get a PixelBox encapsulating the image data of a mipmap

</member>
        <member name="M:Ogre.Image.getColourAt(System.Int32,System.Int32,System.Int32)">
Get colour value from a certain location in the image. The z coordinate
is only valid for cubemaps and volume textures. This uses the first (largest)
mipmap.

</member>
        <member name="M:Ogre.Image.applyGamma(System.Byte*,System.Single,System.UInt32,System.Byte)">
Does gamma adjustment.
            @note
                Basic algo taken from Titan Engine, copyright (c) 2000 Ignacio 
                Castano Iguado

</member>
        <member name="M:Ogre.Image.getHasAlpha">
Returns true if the image has an alpha component.

</member>
        <member name="M:Ogre.Image.getBPP">
Returns the number of bits per pixel.

</member>
        <member name="M:Ogre.Image.getFormat">
Returns the image format.

</member>
        <member name="M:Ogre.Image.getRowSpan">
Gets the physical width in bytes of each row of pixels.

</member>
        <member name="M:Ogre.Image.getNumFaces">
Get the number of faces of the image. This is usually 6 for a cubemap, and
		    1 for a normal image.

</member>
        <member name="M:Ogre.Image.getDepth">
Gets the depth of the image.

</member>
        <member name="M:Ogre.Image.getHeight">
Gets the height of the image in pixels.

</member>
        <member name="M:Ogre.Image.getWidth">
Gets the width of the image in pixels.

</member>
        <member name="M:Ogre.Image.hasFlag(Ogre.ImageFlags!System.Runtime.CompilerServices.IsConst)">
Returns true if the image has the appropriate flag set.

</member>
        <member name="M:Ogre.Image.getNumMipmaps">
Returns the number of mipmaps contained in the image.

</member>
        <member name="M:Ogre.Image.getSize">
Returns the size of the data buffer.

</member>
        <member name="M:Ogre.Image.getData">
Returns a pointer to the internal image buffer.
		@remarks
			Be careful with this method. You will almost certainly
			prefer to use getPixelBox, especially with complex images
			which include many faces or custom mipmaps.


Returns a const pointer to the internal image buffer.
		@remarks
			Be careful with this method. You will almost certainly
			prefer to use getPixelBox, especially with complex images
			which include many faces or custom mipmaps.

</member>
        <member name="M:Ogre.Image.encode(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Encode the image and return a stream to the data. 
			@param formatextension An extension to identify the image format
				to encode into, e.g. "jpg" or "png"

</member>
        <member name="M:Ogre.Image.save(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Save the image as a file. 
		@remarks
			Saving and loading are implemented by back end (sometimes third 
			party) codecs.  Implemented saving functionality is more limited
			than loading in some cases.	Particulary DDS file format support 
			is currently limited to true colour or single channel float32, 
			square, power of two textures with no mipmaps.  Volumetric support
			is currently limited to DDS files.

</member>
        <member name="M:Ogre.Image.combineTwoImagesAsRGBA(Ogre.Image!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Image!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.PixelFormat)">
Utility method to combine 2 separate images into this one, with the first
			image source supplying the RGB channels, and the second image supplying the 
			alpha channel (as luminance or separate alpha). 
		@param rgb Image supplying the RGB channels (any alpha is ignored)
		@param alpha Image supplying the alpha channel. If a luminance image the
			single channel is used directly, if an RGB image then the values are
			converted to greyscale.
		@param format The destination format

</member>
        <member name="M:Ogre.Image.loadTwoImagesAsRGBA(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.PixelFormat,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!Sys">
Utility method to combine 2 separate images into this one, with the first
		image source supplying the RGB channels, and the second image supplying the 
		alpha channel (as luminance or separate alpha). 
		@param rgbStream Stream of image supplying the RGB channels (any alpha is ignored)
		@param alphaStream Stream of image supplying the alpha channel. If a luminance image the
			single channel is used directly, if an RGB image then the values are
			converted to greyscale.
		@param format The destination format
		@param rgbType The type of the RGB image. Used to decide what decompression
			codec to use. Can be left blank if the stream data includes
			a header to identify the data.
		@param alphaType The type of the alpha image. Used to decide what decompression
			codec to use. Can be left blank if the stream data includes
			a header to identify the data.

</member>
        <member name="M:Ogre.Image.loadTwoImagesAsRGBA(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.C">
Utility method to combine 2 separate images into this one, with the first
		image source supplying the RGB channels, and the second image supplying the 
		alpha channel (as luminance or separate alpha). 
		@param rgbFilename Filename of image supplying the RGB channels (any alpha is ignored)
		@param alphaFilename Filename of image supplying the alpha channel. If a luminance image the
			single channel is used directly, if an RGB image then the values are
			converted to greyscale.
		@param groupName The resource group from which to load the images
		@param format The destination format

</member>
        <member name="M:Ogre.Image.load(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Loads an image file.
            @remarks
                This method loads an image into memory. Any format for which 
				and associated ImageCodec is registered can be loaded. 
				This can include complex formats like DDS with embedded custom 
				mipmaps, cube faces and volume textures.
                The type can be determined by calling getFormat().             
            @param
                strFileName Name of a file file to load.
            @param
                groupName Name of the resource group to search for the image
            @note
                The memory associated with this buffer is destroyed with the
                Image object.

</member>
        <member name="M:Ogre.Image.flipAroundX">
Flips (mirrors) the image around the X-axis.
            @remarks
                An example of an original and flipped image:
                <pre>
                        flip axis
                            |
                originalimg|gmilanigiro
                00000000000|00000000000
                00000000000|00000000000
                00000000000|00000000000
                00000000000|00000000000
                00000000000|00000000000
                </pre></member>
        <member name="M:Ogre.Image.flipAroundY">
Flips (mirrors) the image around the Y-axis. 
            @remarks
                An example of an original and flipped image:
                <pre>                
                originalimg
                00000000000
                00000000000
                00000000000
                00000000000
                00000000000
                ------------&gt; flip axis
                00000000000
                00000000000
                00000000000
                00000000000
                00000000000
                originalimg
                </pre></member>
        <member name="M:Ogre.Image.op_Assign(Ogre.Image!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator - copies all the data from the target image.

</member>
        <member name="M:Ogre.Image.Dispose">
Standard destructor.

</member>
        <member name="M:Ogre.Image.#ctor(Ogre.Image!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy-constructor - copies all the data from the target image.

</member>
        <member name="M:Ogre.Image.#ctor">
Standard constructor.

</member>
        <member name="T:Ogre.Image">
Class representing an image file.
        @remarks
            The Image class usually holds uncompressed image data and is the
            only object that can be loaded in a texture. Image  objects handle 
            image data decoding themselves by the means of locating the correct 
            Codec object for each data type.
        @par
            Typically, you would want to use an Image object to load a texture
            when extra processing needs to be done on an image before it is
            loaded or when you want to blit to an existing texture.

</member>
        <member name="T:Ogre.ImageFlags">
\addtogroup Core
	*  @{

\addtogroup Image
	*  @{

</member>
        <member name="M:Ogre.PixelUtil.bulkPixelConversion(Ogre.PixelBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.PixelBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Convert pixels from one format to another. No dithering or filtering is being done. Converting
          	from RGB to luminance takes the R channel. 
		 	@param	src			PixelBox containing the source pixels, pitches and format
		 	@param	dst			PixelBox containing the destination pixels, pitches and format
		 	@remarks The source and destination boxes must have the same
         	dimensions. In case the source and destination format match, a plain copy is done.

</member>
        <member name="M:Ogre.PixelUtil.bulkPixelConversion(System.Void*,Ogre.PixelFormat,System.Void*,Ogre.PixelFormat,System.UInt32)">
Convert consecutive pixels from one format to another. No dithering or filtering is being done. 
         	Converting from RGB to luminance takes the R channel.  In case the source and destination format match,
         	just a copy is done.
         	@param	src			Pointer to source region
         	@param	srcFormat	Pixel format of source region
         	@param   dst			Pointer to destination region
         	@param	dstFormat	Pixel format of destination region

</member>
        <member name="M:Ogre.PixelUtil.unpackColour(System.Single*,System.Single*,System.Single*,System.Single*,Ogre.PixelFormat,System.Void!System.Runtime.CompilerServices.IsConst*)">
Unpack a colour value from memory
        	@param r,g,b,a	The colour is returned here (as float)
        	@param pf		Pixelformat in which to read the colour
        	@param src		Source memory location

</member>
        <member name="M:Ogre.PixelUtil.unpackColour(System.Byte*,System.Byte*,System.Byte*,System.Byte*,Ogre.PixelFormat,System.Void!System.Runtime.CompilerServices.IsConst*)">
Unpack a colour value from memory
        	@param r,g,b,a	The colour is returned here (as byte)
        	@param pf		Pixelformat in which to read the colour
        	@param src		Source memory location
        	@remarks 	This function returns the colour components in 8 bit precision,
        		this will lose precision when coming from PF_A2R10G10B10 or floating
        		point formats.  

</member>
        <member name="M:Ogre.PixelUtil.unpackColour(Ogre.ColourValue*,Ogre.PixelFormat,System.Void!System.Runtime.CompilerServices.IsConst*)">
Unpack a colour value from memory
        	@param colour	The colour is returned here
        	@param pf		Pixelformat in which to read the colour
        	@param src		Source memory location

</member>
        <member name="M:Ogre.PixelUtil.packColour(System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,Ogre.PixelFormat!System.Runtime.CompilerServices.IsConst,System.Void*)">
Pack a colour value to memory
        	@param r,g,b,a	The four colour components, range 0.0f to 1.0f
        					(an exception to this case exists for floating point pixel
        					formats, which don't clamp to 0.0f..1.0f)
        	@param pf		Pixelformat in which to write the colour
        	@param dest		Destination memory location

</member>
        <member name="M:Ogre.PixelUtil.packColour(System.Byte!System.Runtime.CompilerServices.IsConst,System.Byte!System.Runtime.CompilerServices.IsConst,System.Byte!System.Runtime.CompilerServices.IsConst,System.Byte!System.Runtime.CompilerServices.IsConst,Ogre.PixelFormat!System.Runtime.CompilerServices.IsConst,System.Void*)">
Pack a colour value to memory
        	@param r,g,b,a	The four colour components, range 0x00 to 0xFF
        	@param pf		Pixelformat in which to write the colour
        	@param dest		Destination memory location

</member>
        <member name="M:Ogre.PixelUtil.packColour(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.PixelFormat!System.Runtime.CompilerServices.IsConst,System.Void*)">
Pack a colour value to memory
        	@param colour	The colour
        	@param pf		Pixelformat in which to write the colour
        	@param dest		Destination memory location

</member>
        <member name="M:Ogre.PixelUtil.getFormatForBitDepths(Ogre.PixelFormat,System.UInt16,System.UInt16)">
Returns the similar format but acoording with given bit depths.
            @param fmt      The original foamt.
            @param integerBits Preferred bit depth (pixel bits) for integer pixel format.
                            Available values: 0, 16 and 32, where 0 (the default) means as it is.
            @param floatBits Preferred bit depth (channel bits) for float pixel format.
                            Available values: 0, 16 and 32, where 0 (the default) means as it is.
            @returns        The format that similar original format with bit depth according
                            with preferred bit depth, or original format if no convertion occuring.

</member>
        <member name="M:Ogre.PixelUtil.getBNFExpressionOfPixelFormats(System.Boolean)">
Gets the BNF expression of the pixel-formats.
            @note                   The string returned by this function is intented to use as a BNF expression
                                    to work with Compiler2Pass.
            @param  accessibleOnly  If true, only accessible pixel format will take into account, otherwise all
                                    pixel formats list in PixelFormat enumeration will being returned.
            @returns                A string contains the BNF expression.

</member>
        <member name="M:Ogre.PixelUtil.getFormatFromName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
Gets the format from given name.
            @param  name            The string of format name
            @param  accessibleOnly  If true, non-accessible format will treat as invalid format,
                                    otherwise, all supported format are valid.
            @param  caseSensitive   Should be set true if string match should use case sensitivity.
            @returns                The format match the format name, or PF_UNKNOWN if is invalid name.

</member>
        <member name="M:Ogre.PixelUtil.getComponentCount(Ogre.PixelFormat)">
Returns the component count for a certain pixel format. Returns 3(no alpha) or 
            4 (has alpha) in case there is no clear component type like with compressed formats.

</member>
        <member name="M:Ogre.PixelUtil.getComponentType(Ogre.PixelFormat)">
Returns the component type for a certain pixel format. Returns PCT_BYTE
            in case there is no clear component type like with compressed formats.
            This is one of PCT_BYTE, PCT_SHORT, PCT_FLOAT16, PCT_FLOAT32.

</member>
        <member name="M:Ogre.PixelUtil.isAccessible(Ogre.PixelFormat)">
Returns wether the format can be packed or unpacked with the packColour()
        and unpackColour() functions. This is generally not true for compressed and
        depth formats as they are special. It can only be true for formats with a
        fixed element size.
          @returns 
               true if yes, otherwise false

</member>
        <member name="M:Ogre.PixelUtil.getFormatName(Ogre.PixelFormat)">
Gets the name of an image format

</member>
        <member name="M:Ogre.PixelUtil.getBitShifts(Ogre.PixelFormat,System.Byte*)">
Gives the bit shifts for R, G, B and A component
		@note			Only valid for native endian formats

</member>
        <member name="M:Ogre.PixelUtil.getBitMasks(Ogre.PixelFormat,System.UInt32*)">
Gives the masks for the R, G, B and A component
		  @note			Only valid for native endian formats

</member>
        <member name="M:Ogre.PixelUtil.getBitDepths(Ogre.PixelFormat,System.Int32*)">
Gives the number of bits (RGBA) for a format. See remarks.          
          @remarks      For non-colour formats (dxt, depth) this returns [0,0,0,0].

</member>
        <member name="M:Ogre.PixelUtil.isValidExtent(System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat)">
Return wether a certain image extent is valid for this image format.
			@param width
				The width of the area
			@param height
				The height of the area
			@param depth
				The depth of the area
			@param format
				The format of the area
			@remarks For non-compressed formats, this is always true. For DXT formats,
			only sizes with a width and height multiple of 4 and depth 1 are allowed.

</member>
        <member name="M:Ogre.PixelUtil.isLuminance(Ogre.PixelFormat)">
Shortcut method to determine if the format is a luminance format. 
</member>
        <member name="M:Ogre.PixelUtil.isNativeEndian(Ogre.PixelFormat)">
Shortcut method to determine if the format is in native endian format. 
</member>
        <member name="M:Ogre.PixelUtil.isDepth(Ogre.PixelFormat)">
Shortcut method to determine if the format is a depth format. 
</member>
        <member name="M:Ogre.PixelUtil.isCompressed(Ogre.PixelFormat)">
Shortcut method to determine if the format is compressed 
</member>
        <member name="M:Ogre.PixelUtil.isFloatingPoint(Ogre.PixelFormat)">
Shortcut method to determine if the format is floating point 
</member>
        <member name="M:Ogre.PixelUtil.hasAlpha(Ogre.PixelFormat)">
Shortcut method to determine if the format has an alpha component 
</member>
        <member name="M:Ogre.PixelUtil.getFlags(Ogre.PixelFormat)">
Returns the property flags for this pixel format
          @returns
               A bitfield combination of PFF_HASALPHA, PFF_ISCOMPRESSED,
               PFF_FLOAT, PFF_DEPTH, PFF_NATIVEENDIAN, PFF_LUMINANCE
          @remarks
               This replaces the seperate functions for formatHasAlpha, formatIsFloat, ...

</member>
        <member name="M:Ogre.PixelUtil.getMemorySize(System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat)">
Returns the size in memory of a region with the given extents and pixel
			format with consecutive memory layout.
			@param width
				The width of the area
			@param height
				The height of the area
			@param depth
				The depth of the area
			@param format
				The format of the area
		  	@returns
		  		The size in bytes
			@remarks
				In case that the format is non-compressed, this simply returns
				width*height*depth*PixelUtil::getNumElemBytes(format). In the compressed
				case, this does serious magic.

</member>
        <member name="M:Ogre.PixelUtil.getNumElemBits(Ogre.PixelFormat)">
Returns the size in bits of an element of the given pixel format.
          @returns
               The size in bits of an element. See Remarks.
           @remarks
               Passing PF_UNKNOWN will result in returning a size of 0 bits.

</member>
        <member name="M:Ogre.PixelUtil.getNumElemBytes(Ogre.PixelFormat)">
Returns the size in bytes of an element of the given pixel format.
         @returns
               The size in bytes of an element. See Remarks.
         @remarks
               Passing PF_UNKNOWN will result in returning a size of 0 bytes.

</member>
        <member name="T:Ogre.PixelUtil">
Some utility functions for packing and unpacking pixel data

</member>
        <member name="M:Ogre.PixelBox.getSubVolume(Ogre.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return a subvolume of this PixelBox.
      		@param def	Defines the bounds of the subregion to return
      		@returns	A pixel box describing the region and the data in it
      		@remarks	This function does not copy any data, it just returns
      			a PixelBox object with a data pointer pointing somewhere inside 
      			the data of object.
      		@throws	Exception(ERR_INVALIDPARAMS) if def is not fully contained

</member>
        <member name="M:Ogre.PixelBox.getConsecutiveSize">
Return the size (in bytes) this image would take if it was
        	laid out consecutive in memory

</member>
        <member name="M:Ogre.PixelBox.isConsecutive">
Return whether this buffer is laid out consecutive in memory (ie the pitches
         	are equal to the dimensions)

</member>
        <member name="M:Ogre.PixelBox.getSliceSkip">
Get the number of elements between one past the right bottom pixel of
         	one slice and the left top pixel of the next slice. (IE this is zero if slices
         	are consecutive).

</member>
        <member name="M:Ogre.PixelBox.getRowSkip">
Get the number of elements between one past the rightmost pixel of 
         	one row and the leftmost pixel of the next row. (IE this is zero if rows
         	are consecutive).

</member>
        <member name="M:Ogre.PixelBox.setConsecutive">
Set the rowPitch and slicePitch so that the buffer is laid out consecutive 
         	in memory.

</member>
        <member name="F:Ogre.PixelBox.slicePitch">
Number of elements between the top left pixel of one (depth) slice and 
         	the top left pixel of the next. This can be a negative value. Must be a multiple of
         	rowPitch. This value must always be equal to getWidth()*getHeight() (consecutive) 
			for compressed formats.

</member>
        <member name="F:Ogre.PixelBox.rowPitch">
Number of elements between the leftmost pixel of one row and the left
         	pixel of the next. This value must always be equal to getWidth() (consecutive) 
			for compressed formats.

</member>
        <member name="F:Ogre.PixelBox.format">
The pixel format 
</member>
        <member name="F:Ogre.PixelBox.data">
The data pointer 
</member>
        <member name="M:Ogre.PixelBox.#ctor(System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Void*)">
Constructor providing width, height and depth. This constructor
    		assumes the pixel data is laid out consecutively in memory. (this
    		means row after row, slice after slice, with no space in between)
    		@param width	    Width of the region
    		@param height	    Height of the region
    		@param depth	    Depth of the region
    		@param pixelFormat	Format of this buffer
    		@param pixelData    Pointer to the actual data

</member>
        <member name="M:Ogre.PixelBox.#ctor(Ogre.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.PixelFormat,System.Void*)">
Constructor providing extents in the form of a Box object. This constructor
    		assumes the pixel data is laid out consecutively in memory. (this
    		means row after row, slice after slice, with no space in between)
    		@param extents	    Extents of the region defined by data
    		@param pixelFormat	Format of this buffer
    		@param pixelData	Pointer to the actual data

</member>
        <member name="M:Ogre.PixelBox.#ctor">
Parameter constructor for setting the members manually
</member>
        <member name="T:Ogre.PixelBox">
A primitive describing a volume (3D), image (2D) or line (1D) of pixels in memory.
     	In case of a rectangle, depth must be 1. 
     	Pixels are stored as a succession of "depth" slices, each containing "height" rows of 
     	"width" pixels.

</member>
        <member name="T:Ogre.PixelComponentType">
Pixel component format 
</member>
        <member name="T:Ogre.PixelFormatFlags">
Flags defining some on/off properties of pixel formats

</member>
        <member name="T:Ogre.PixelFormat">
\addtogroup Core
	*  @{

\addtogroup Image
	*  @{

The pixel format used for images, textures, and render surfaces 
</member>
        <member name="F:PF_PVRTC_RGBA4">
PVRTC (PowerVR) RGBA 4 bpp
</member>
        <member name="F:PF_PVRTC_RGB4">
PVRTC (PowerVR) RGB 4 bpp
</member>
        <member name="F:PF_PVRTC_RGBA2">
PVRTC (PowerVR) RGBA 2 bpp
</member>
        <member name="F:PF_PVRTC_RGB2">
PVRTC (PowerVR) RGB 2 bpp
</member>
        <member name="F:PF_DXT5">
DDS (DirectDraw Surface) DXT5 format
</member>
        <member name="F:PF_DXT4">
DDS (DirectDraw Surface) DXT4 format
</member>
        <member name="F:PF_DXT3">
DDS (DirectDraw Surface) DXT3 format
</member>
        <member name="F:PF_DXT2">
DDS (DirectDraw Surface) DXT2 format
</member>
        <member name="F:PF_DXT1">
DDS (DirectDraw Surface) DXT1 format
</member>
        <member name="F:PF_A2B10G10R10">
32-bit pixel format, 10 bits for blue, green and red, 2 bits for alpha.
</member>
        <member name="F:PF_A2R10G10B10">
32-bit pixel format, 2 bits for alpha, 10 bits for red, green and blue.
</member>
        <member name="F:PF_BYTE_RGBA">
4 byte pixel format, 1 byte for red, 1 byte for green, 1 byte for blue, and one byte for alpha
</member>
        <member name="F:PF_BYTE_BGRA">
4 byte pixel format, 1 byte for blue, 1 byte for green, 1 byte for red and one byte for alpha
</member>
        <member name="F:PF_BYTE_BGR">
3 byte pixel format, 1 byte for blue, 1 byte for green, 1 byte for red
</member>
        <member name="F:PF_BYTE_RGB">
3 byte pixel format, 1 byte for red, 1 byte for green, 1 byte for blue
</member>
        <member name="F:PF_X8B8G8R8">
32-bit pixel format, 8 bits for blue, 8 bits for green, 8 bits for red
like PF_A8B8G8R8, but alpha will get discarded
</member>
        <member name="F:PF_X8R8G8B8">
32-bit pixel format, 8 bits for red, 8 bits for green, 8 bits for blue
like PF_A8R8G8B8, but alpha will get discarded
</member>
        <member name="F:PF_R8G8B8A8">
32-bit pixel format, 8 bits for red, green, blue and alpha.
</member>
        <member name="F:PF_B8G8R8A8">
32-bit pixel format, 8 bits for blue, green, red and alpha.
</member>
        <member name="F:PF_A8B8G8R8">
32-bit pixel format, 8 bits for blue, green, red and alpha.
</member>
        <member name="F:PF_A8R8G8B8">
32-bit pixel format, 8 bits for alpha, red, green and blue.
</member>
        <member name="F:PF_B8G8R8">
24-bit pixel format, 8 bits for blue, green and red.
</member>
        <member name="F:PF_R8G8B8">
24-bit pixel format, 8 bits for red, green and blue.
</member>
        <member name="F:PF_A1R5G5B5">
16-bit pixel format, 5 bits for blue, green, red and 1 for alpha.
</member>
        <member name="F:PF_A4R4G4B4">
16-bit pixel format, 4 bits for alpha, red, green and blue.
</member>
        <member name="F:PF_R3G3B2">
8-bit pixel format, 2 bits blue, 3 bits green, 3 bits red.
</member>
        <member name="F:PF_B5G6R5">
16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.
</member>
        <member name="F:PF_R5G6B5">
16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.
</member>
        <member name="F:PF_BYTE_LA">
2 byte pixel format, 1 byte luminance, 1 byte alpha
</member>
        <member name="F:PF_A4L4">
8-bit pixel format, 4 bits alpha, 4 bits luminance.
</member>
        <member name="F:PF_A8">
8-bit pixel format, all bits alpha.
</member>
        <member name="F:PF_L16">
16-bit pixel format, all bits luminace.
</member>
        <member name="F:PF_L8">
8-bit pixel format, all bits luminace.
</member>
        <member name="F:PF_UNKNOWN">
Unknown pixel format.
</member>
        <member name="M:Ogre.WaveformControllerFunction.calculate(System.Single)">
Overridden function.

</member>
        <member name="M:Ogre.WaveformControllerFunction.#ctor(Ogre.WaveformType,System.Single,System.Single,System.Single,System.Single,System.Boolean,System.Single)">
Default constructor, requires at least a wave type, other parameters can be defaulted unless required.
            @param
                deltaInput If true, signifies that the input will be a delta value such that the function should
                add it to an internal counter before calculating the output.
			@param
				dutyCycle Used in PWM mode to specify the pulse width.

</member>
        <member name="M:Ogre.WaveformControllerFunction.getAdjustedInput(System.Single)">
Overridden from ControllerFunction. 
</member>
        <member name="T:Ogre.WaveformControllerFunction">
Predefined controller function based on a waveform.
        @remarks
            A waveform function translates parametric input to parametric output based on a wave. The factors
            affecting the function are:
            - wave type - the shape of the wave
            - base - the base value of the output from the wave
            - frequency - the speed of the wave in cycles per second
            - phase - the offset of the start of the wave, e.g. 0.5 to start half-way through the wave
            - amplitude - scales the output so that instead of lying within [0,1] it lies within [0,1] * amplitude
			- duty cycle - the active width of a PWM signal
        @par
            Note that for simplicity of integration with the rest of the controller insfrastructure, the output of
            the wave is parametric i.e. 0..1, rather than the typical wave output of [-1,1]. To compensate for this, the
            traditional output of the wave is scaled by the following function before output:
        @par
            output = (waveoutput + 1) * 0.5
        @par
            Hence a wave output of -1 becomes 0, a wave ouput of 1 becomes 1, and a wave output of 0 becomes 0.5.

</member>
        <member name="M:Ogre.ScaleControllerFunction.calculate(System.Single)">
Overridden method.

</member>
        <member name="M:Ogre.ScaleControllerFunction.#ctor(System.Single,System.Boolean)">
Constructor, requires a scale factor.
            @param
                scalefactor The multiplier applied to the input to produce the output.
            @param
                deltaInput If true, signifies that the input will be a delta value such that the function should
                 add it to an internal counter before calculating the output.

</member>
        <member name="T:Ogre.ScaleControllerFunction">
Predefined controller function which simply scales an input to an output value.

</member>
        <member name="M:Ogre.AnimationControllerFunction.setSequenceTime(System.Single)">
Set the sequence duration value manually. 
</member>
        <member name="M:Ogre.AnimationControllerFunction.setTime(System.Single)">
Set the time value manually. 
</member>
        <member name="M:Ogre.AnimationControllerFunction.calculate(System.Single)">
Overridden function.

</member>
        <member name="M:Ogre.AnimationControllerFunction.#ctor(System.Single,System.Single)">
Constructor.
            @param
                sequenceTime The amount of time in seconds it takes to loop through the whole animation sequence.
            @param
                timeOffset The offset in seconds at which to start (default is start at 0)

</member>
        <member name="T:Ogre.AnimationControllerFunction">
Predefined controller function for dealing with animation.

</member>
        <member name="M:Ogre.PassthroughControllerFunction.calculate(System.Single)">
Overriden function.

</member>
        <member name="M:Ogre.PassthroughControllerFunction.#ctor(System.Boolean)">
Constructor.
		@param
		sequenceTime The amount of time in seconds it takes to loop through the whole animation sequence.
		@param
		timeOffset The offset in seconds at which to start (default is start at 0)

</member>
        <member name="T:Ogre.PassthroughControllerFunction">
Predefined controller function which just passes through the original source
	directly to dest.

</member>
        <member name="M:Ogre.FloatGpuParameterControllerValue.#ctor(Ogre.SharedPtr&lt;Ogre.GpuProgramParameters&gt;,System.UInt32)">
Constructor.
		    @param
				params The parameters object to access
            @param
                index The index of the parameter to be set

</member>
        <member name="F:Ogre.FloatGpuParameterControllerValue.mParamIndex">
The index of the parameter to e read or set
</member>
        <member name="F:Ogre.FloatGpuParameterControllerValue.mParams">
The parameters to access
</member>
        <member name="T:Ogre.FloatGpuParameterControllerValue">
Predefined controller value for setting a single floating-
	    point value in a constant parameter of a vertex or fragment program.
    @remarks
		Any value is accepted, it is propagated into the 'x'
		component of the constant register identified by the index. If you
		need to use named parameters, retrieve the index from the param
		object before setting this controller up.
	@note
		Retrieving a value from the program parameters is not currently 
		supported, therefore do not use this controller value as a source,
		only as a target.

</member>
        <member name="M:Ogre.TexCoordModifierControllerValue.#ctor(Ogre.TextureUnitState*,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
Constructor.
            @param
                t TextureUnitState to apply the modification to.
            @param
                translateU If true, the u coordinates will be translated by the modification.
            @param
                translateV If true, the v coordinates will be translated by the modification.
            @param
                scaleU If true, the u coordinates will be scaled by the modification.
            @param
                scaleV If true, the v coordinates will be scaled by the modification.
            @param
                rotate If true, the texture will be rotated by the modification.

</member>
        <member name="T:Ogre.TexCoordModifierControllerValue">
Predefined controller value for getting / setting a texture coordinate modifications (scales and translates).
        @remarks
            Effects can be applied to the scale or the offset of the u or v coordinates, or both. If separate
            modifications are required to u and v then 2 instances are required to control both independently, or 4
            if you ant separate u and v scales as well as separate u and v offsets.
        @par
            Because of the nature of this value, it can accept values outside the 0..1 parametric range.

</member>
        <member name="M:Ogre.TextureFrameControllerValue.setValue(System.Single)">
Sets the frame number as a parametric value in the range [0,1]; the actual frame number is value * (numFrames-1).

</member>
        <member name="M:Ogre.TextureFrameControllerValue.getValue">
Gets the frame number as a parametric value in the range [0,1]

</member>
        <member name="T:Ogre.TextureFrameControllerValue">
Predefined controller value for getting / setting the frame number of a texture layer

</member>
        <member name="T:Ogre.FrameTimeControllerValue">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

Predefined controller value for getting the latest frame time.

</member>
        <member name="M:Ogre.FrameListener.frameEnded(Ogre.FrameEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called just after a frame has been rendered.
		@remarks
			This event happens after all render targets have been fully updated
			and the buffers switched.
            @return
                True to continue with the next frame, false to drop
                out of the rendering loop.

</member>
        <member name="M:Ogre.FrameListener.frameRenderingQueued(Ogre.FrameEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called after all render targets have had their rendering commands 
			issued, but before render windows have been asked to flip their 
			buffers over.
		@remarks
			The usefulness of this event comes from the fact that rendering 
			commands are queued for the GPU to process. These can take a little
			while to finish, and so while that is happening the CPU can be doing
			useful things. Once the request to 'flip buffers' happens, the thread
			requesting it will block until the GPU is ready, which can waste CPU
			cycles. Therefore, it is often a good idea to use this callback to 
			perform per-frame processing. Of course because the frame's rendering
			commands have already been issued, any changes you make will only
			take effect from the next frame, but in most cases that's not noticeable.
		@return
			True to continue rendering, false to drop out of the rendering loop.

</member>
        <member name="M:Ogre.FrameListener.frameStarted(Ogre.FrameEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when a frame is about to begin rendering.
		@remarks
			This event happens before any render targets have begun updating. 
            @return
                True to go ahead, false to abort rendering and drop
                out of the rendering loop.

</member>
        <member name="T:Ogre.FrameListener">
A interface class defining a listener which can be used to receive
        notifications of frame events.
        @remarks
            A 'listener' is an interface designed to be called back when
            particular events are called. This class defines the
            interface relating to frame events. In order to receive
            notifications of frame events, you should create a subclass of
            FrameListener and override the methods for which you would like
            to customise the resulting processing. You should then call
            Root::addFrameListener passing an instance of this class.
            There is no limit to the number of frame listeners you can register,
            allowing you to register multiple listeners for different purposes.
            Frame events only occur when Ogre is in continuous rendering mode,
            i.e. after Root::startRendering is called. If the application is
            doing ad-hoc rendering without entering a rendering loop, frame
            events are not generated. Note that a frame event occurs once for
            all rendering targets, not once per target.

</member>
        <member name="F:Ogre.FrameEvent.timeSinceLastFrame">
Elapsed time in seconds since the last event of the same type,
            i.e. time for a complete frame.
            @remarks
                This may not be the elapsed time but the average
                elapsed time between recently fired events of the same type.

</member>
        <member name="T:Ogre.FrameEvent">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

Struct containing information about a frame event.

</member>
        <member name="M:Ogre.ConfigFile.clear">
Clear the settings 
</member>
        <member name="M:Ogre.ConfigFile.getSettingsIterator(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get an iterator over all the available settings in a section 
</member>
        <member name="M:Ogre.ConfigFile.getSectionIterator">
Get an iterator over all the available sections in the config file 
</member>
        <member name="D:Ogre.ConfigFile.SettingsBySection">
Gets an iterator for stepping through all the keys / values in the file. 
</member>
        <member name="M:Ogre.ConfigFile.getMultiSetting(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets all settings from the file with the named key. 
</member>
        <member name="M:Ogre.ConfigFile.getSetting(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.Compi">
Gets the first setting from the file with the named key. 
        @param key The name of the setting
        @param section The name of the section it must be in (if any)
		@param defaultValue The value to return if the setting is not found

</member>
        <member name="M:Ogre.ConfigFile.loadFromResourceSystem(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.R">
load from a filename (using resource group locations)
</member>
        <member name="M:Ogre.ConfigFile.loadDirect(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
load from a filename (not using resource group locations)
</member>
        <member name="M:Ogre.ConfigFile.load(Ogre.SharedPtr&lt;Ogre.DataStream&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
load from a data stream
</member>
        <member name="M:Ogre.ConfigFile.load(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerSer">
load from a filename (using resource group locations)
</member>
        <member name="M:Ogre.ConfigFile.load(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
load from a filename (not using resource group locations)
</member>
        <member name="T:Ogre.ConfigFile">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

Class for quickly loading settings from a text file.
        @remarks
            This class is designed to quickly parse a simple file containing
            key/value pairs, mainly for use in configuration settings.
        @par
            This is a very simplified approach, no multiple values per key
            are allowed, no grouping or context is being kept etc.
        @par
            By default the key/values pairs are tokenised based on a
            separator of Tab, the colon (:) or equals (=) character. Each
            key - value pair must end in a carriage return.
        @par
            Settings can be optionally grouped in sections, using a header
            beforehand of the form [SectionName]. 

</member>
        <member name="M:Ogre.Camera.getOrientationForViewUpdate">
Get the derived orientation of this frustum. 
</member>
        <member name="M:Ogre.Camera.getPositionForViewUpdate">
Get the derived position of this frustum. 
</member>
        <member name="M:Ogre.Camera.synchroniseBaseSettingsWith(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Synchronise core camera settings with another. 
		@remarks
			Copies the position, orientation, clip distances, projection type, 
			FOV, focal length and aspect ratio from another camera. Other settings like query flags, 
			reflection etc are preserved.

</member>
        <member name="M:Ogre.Camera.getUseRenderingDistance">
Get whether this camera should use the 'rendering distance' on
			objects to exclude distant objects from the final image.

</member>
        <member name="M:Ogre.Camera.setUseRenderingDistance(System.Boolean)">
Set whether this camera should use the 'rendering distance' on
			objects to exclude distant objects from the final image. The
			default behaviour is to use it.
		@param use True to use the rendering distance, false not to.

</member>
        <member name="M:Ogre.Camera.getViewMatrix(System.Boolean)">
Specialised version of getViewMatrix allowing caller to differentiate
			whether the custom culling frustum should be allowed or not. 
		@remarks
			The default behaviour of the standard getViewMatrix is to delegate to 
			the alternate culling frustum, if it is set. This is expected when 
			performing CPU calculations, but the final rendering must be performed
			using the real view matrix in order to display the correct debug view.

</member>
        <member name="M:Ogre.Camera.getViewMatrix">
@copydoc Frustum::getViewMatrix
</member>
        <member name="M:Ogre.Camera.getFarClipDistance">
@copydoc Frustum::getFarClipDistance
</member>
        <member name="M:Ogre.Camera.getNearClipDistance">
@copydoc Frustum::getNearClipDistance
</member>
        <member name="M:Ogre.Camera.projectSphere(Ogre.Sphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*,System.Single*,System.Single*)">
@copydoc Frustum::projectSphere
</member>
        <member name="M:Ogre.Camera.getFrustumPlane(System.UInt16)">
@copydoc Frustum::getFrustumPlane
</member>
        <member name="M:Ogre.Camera.getWorldSpaceCorners">
@copydoc Frustum::getWorldSpaceCorners
</member>
        <member name="M:Ogre.Camera.isVisible(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.FrustumPlane*)">
@copydoc Frustum::isVisible
</member>
        <member name="M:Ogre.Camera.isVisible(Ogre.Sphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.FrustumPlane*)">
@copydoc Frustum::isVisible
</member>
        <member name="M:Ogre.Camera.isVisible(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.FrustumPlane*)">
@copydoc Frustum::isVisible
</member>
        <member name="M:Ogre.Camera.forwardIntersect(Ogre.Plane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Ogre.Vector4&gt;*)">
Forward projects frustum rays to find forward intersection with plane.
		 @remarks
		    Forward projection may lead to intersections at infinity.

</member>
        <member name="M:Ogre.Camera.getCullingFrustum">
Returns the custom culling frustum in use. 
</member>
        <member name="M:Ogre.Camera.setCullingFrustum(Ogre.Frustum*)">
Tells the camera to use a separate Frustum instance to perform culling.
		@remarks
			By calling this method, you can tell the camera to perform culling
			against a different frustum to it's own. This is mostly useful for
			debug cameras that allow you to show the culling behaviour of another
			camera, or a manual frustum instance. 
		@param frustum Pointer to a frustum to use; this can either be a manual
			Frustum instance (which you can attach to scene nodes like any other
			MovableObject), or another camera. If you pass 0 to this method it
			reverts the camera to normal behaviour.

</member>
        <member name="M:Ogre.Camera.getAutoAspectRatio">
Retrieves if AutoAspectRatio is currently set or not

</member>
        <member name="M:Ogre.Camera.setAutoAspectRatio(System.Boolean)">
If set to true a viewport that owns this frustum will be able to 
            recalculate the aspect ratio whenever the frustum is resized.
        @remarks
            You should set this to true only if the frustum / camera is used by 
            one viewport at the same time. Otherwise the aspect ratio for other 
            viewports may be wrong.

</member>
        <member name="M:Ogre.Camera._notifyViewport(Ogre.Viewport*)">
Notifies this camera that a viewport is using it.
</member>
        <member name="M:Ogre.Camera.getViewport">
Get the last viewport which was attached to this camera. 
        @note This is not guaranteed to be the only viewport which is
        using this camera, just the last once which was created referring
        to it.

</member>
        <member name="M:Ogre.Camera.getAutoTrackOffset">
Get the auto tracking offset for this camera, if it is auto tracking. 
</member>
        <member name="M:Ogre.Camera.getAutoTrackTarget">
Get the auto tracking target for this camera, if any. 
</member>
        <member name="M:Ogre.Camera.getBoundingRadius">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.Camera.getWindowPlanes">
Gets the window clip planes, only applicable if isWindowSet == true
</member>
        <member name="M:Ogre.Camera.isWindowSet">
Returns if a viewport window is being used
</member>
        <member name="M:Ogre.Camera.resetWindow">
Cancel view window.
</member>
        <member name="M:Ogre.Camera.setWindow(System.Single,System.Single,System.Single,System.Single)">
Sets the viewing window inside of viewport.
        @remarks
        This method can be used to set a subset of the viewport as the rendering
        target. 
        @param Left Relative to Viewport - 0 corresponds to left edge, 1 - to right edge (default - 0).
        @param Top Relative to Viewport - 0 corresponds to top edge, 1 - to bottom edge (default - 0).
        @param Right Relative to Viewport - 0 corresponds to left edge, 1 - to right edge (default - 1).
        @param Bottom Relative to Viewport - 0 corresponds to top edge, 1 - to bottom edge (default - 1).

</member>
        <member name="M:Ogre.Camera._autoTrack">
Internal method used by OGRE to update auto-tracking cameras. 
</member>
        <member name="M:Ogre.Camera._getLodBiasInverse">
Internal method for OGRE to use for LOD calculations. 
</member>
        <member name="M:Ogre.Camera.getCameraToViewportBoxVolume(System.Single,System.Single,System.Single,System.Single,Ogre.PlaneBoundedVolume*,System.Boolean)">
Gets a world-space list of planes enclosing a volume based on a viewport
			rectangle. 
		@remarks
			Can be useful for populating a PlaneBoundedVolumeListSceneQuery, e.g. 
			for a rubber-band selection. 
		@param screenLeft, screenTop, screenRight, screenBottom The bounds of the
			on-screen rectangle, expressed in normalised screen coordinates [0,1]
		@param outVolume The plane list to populate with the result
		@param includeFarPlane If true, the volume is truncated by the camera far plane, 
			by default it is left open-ended

</member>
        <member name="M:Ogre.Camera.getCameraToViewportBoxVolume(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
Gets a world-space list of planes enclosing a volume based on a viewport
			rectangle. 
		@remarks
			Can be useful for populating a PlaneBoundedVolumeListSceneQuery, e.g. 
			for a rubber-band selection. 
		@param screenLeft, screenTop, screenRight, screenBottom The bounds of the
			on-screen rectangle, expressed in normalised screen coordinates [0,1]
		@param includeFarPlane If true, the volume is truncated by the camera far plane, 
			by default it is left open-ended

</member>
        <member name="M:Ogre.Camera.getCameraToViewportRay(System.Single,System.Single,Ogre.Ray*)">
Gets a world space ray as cast from the camera through a viewport position.
        @param screenx, screeny The x and y position at which the ray should intersect the viewport, 
            in normalised screen coordinates [0,1]
		@param outRay Ray instance to populate with result

</member>
        <member name="M:Ogre.Camera.getCameraToViewportRay(System.Single,System.Single)">
Gets a world space ray as cast from the camera through a viewport position.
        @param screenx, screeny The x and y position at which the ray should intersect the viewport, 
            in normalised screen coordinates [0,1]

</member>
        <member name="M:Ogre.Camera.getLodCamera">
Get a pointer to the camera which should be used to determine 
			LOD settings. 
		@remarks
			If setLodCamera hasn't been called with a different camera, this
			method will return 'this'. 

</member>
        <member name="M:Ogre.Camera.setLodCamera(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Get a pointer to the camera which should be used to determine 
			LOD settings. 
		@remarks
			Sometimes you don't want the LOD of a render to be based on the camera
			that's doing the rendering, you want it to be based on a different
			camera. A good example is when rendering shadow maps, since they will 
			be viewed from the perspective of another camera. Therefore this method
			lets you associate a different camera instance to use to determine the LOD.
		@par
			To revert the camera to determining LOD based on itself, call this method with 
			a pointer to itself. 

</member>
        <member name="M:Ogre.Camera.getLodBias">
Returns the level-of-detail bias factor currently applied to this camera. 
		@remarks
			See Camera::setLodBias for more details.

</member>
        <member name="M:Ogre.Camera.setLodBias(System.Single)">
Sets the level-of-detail factor for this Camera.
		@remarks
			This method can be used to influence the overall level of detail of the scenes 
			rendered using this camera. Various elements of the scene have level-of-detail
			reductions to improve rendering speed at distance; this method allows you 
			to hint to those elements that you would like to adjust the level of detail that
			they would normally use (up or down). 
		@par
			The most common use for this method is to reduce the overall level of detail used
			for a secondary camera used for sub viewports like rear-view mirrors etc.
			Note that scene elements are at liberty to ignore this setting if they choose,
			this is merely a hint.
		@param factor The factor to apply to the usual level of detail calculation. Higher
			values increase the detail, so 2.0 doubles the normal detail and 0.5 halves it.

</member>
        <member name="M:Ogre.Camera.setAutoTracking(System.Boolean,Ogre.SceneNode*,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Enables / disables automatic tracking of a SceneNode.
        @remarks
            If you enable auto-tracking, this Camera will automatically rotate to
            look at the target SceneNode every frame, no matter how 
            it or SceneNode move. This is handy if you want a Camera to be focused on a
            single object or group of objects. Note that by default the Camera looks at the 
            origin of the SceneNode, if you want to tweak this, e.g. if the object which is
            attached to this target node is quite big and you want to point the camera at
            a specific point on it, provide a vector in the 'offset' parameter and the 
            camera's target point will be adjusted.
        @param enabled If true, the Camera will track the SceneNode supplied as the next 
            parameter (cannot be null). If false the camera will cease tracking and will
            remain in it's current orientation.
        @param target Pointer to the SceneNode which this Camera will track. Make sure you don't
            delete this SceneNode before turning off tracking (e.g. SceneManager::clearScene will
            delete it so be careful of this). Can be null if and only if the enabled param is false.
        @param offset If supplied, the camera targets this point in local space of the target node
            instead of the origin of the target node. Good for fine tuning the look at point.

</member>
        <member name="M:Ogre.Camera.getMovableType">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.Camera.getRealRight">
Gets the real world right vector of the camera, including any
            rotation inherited from a node attachment. 
</member>
        <member name="M:Ogre.Camera.getRealUp">
Gets the real world up vector of the camera, including any
            rotation inherited from a node attachment. 
</member>
        <member name="M:Ogre.Camera.getRealDirection">
Gets the real world direction vector of the camera, including any
            rotation inherited from a node attachment. 
</member>
        <member name="M:Ogre.Camera.getRealPosition">
Gets the real world position of the camera, including any
            translation inherited from a node attachment. 
</member>
        <member name="M:Ogre.Camera.getRealOrientation">
Gets the real world orientation of the camera, including any
            rotation inherited from a node attachment 
</member>
        <member name="M:Ogre.Camera.getDerivedRight">
Gets the derived right vector of the camera, including any
            rotation inherited from a node attachment and reflection matrix. 
</member>
        <member name="M:Ogre.Camera.getDerivedUp">
Gets the derived up vector of the camera, including any
            rotation inherited from a node attachment and reflection matrix. 
</member>
        <member name="M:Ogre.Camera.getDerivedDirection">
Gets the derived direction vector of the camera, including any
            rotation inherited from a node attachment and reflection matrix. 
</member>
        <member name="M:Ogre.Camera.getDerivedPosition">
Gets the derived position of the camera, including any
            translation inherited from a node attachment and reflection matrix. 
</member>
        <member name="M:Ogre.Camera.getDerivedOrientation">
Gets the derived orientation of the camera, including any
            rotation inherited from a node attachment and reflection matrix. 
</member>
        <member name="M:Ogre.Camera._getNumRenderedBatches">
Internal method to retrieve the number of visible batches in the last render.

</member>
        <member name="M:Ogre.Camera._getNumRenderedFaces">
Internal method to retrieve the number of visible faces in the last render.

</member>
        <member name="M:Ogre.Camera._notifyRenderedBatches(System.UInt32)">
Internal method to notify camera of the visible batches in the last render.

</member>
        <member name="M:Ogre.Camera._notifyRenderedFaces(System.UInt32)">
Internal method to notify camera of the visible faces in the last render.

</member>
        <member name="M:Ogre.op_LeftShift(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Camera!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Function for outputting to a stream.

</member>
        <member name="M:Ogre.Camera._renderScene(Ogre.Viewport*,System.Boolean)">
Tells the Camera to contact the SceneManager to render from it's viewpoint.
        @param vp The viewport to render to
        @param includeOverlays Whether or not any overlay objects should be included

</member>
        <member name="M:Ogre.Camera.setOrientation(Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the camera's orientation.

</member>
        <member name="M:Ogre.Camera.getOrientation">
Returns the camera's current orientation.

</member>
        <member name="M:Ogre.Camera.setFixedYawAxis(System.Boolean,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tells the camera whether to yaw around it's own local Y axis or a 
			fixed axis of choice.
            @remarks
                This method allows you to change the yaw behaviour of the camera
				- by default, the camera yaws around a fixed Y axis. This is 
				often what you want - for example if you're making a first-person 
				shooter, you really don't want the yaw axis to reflect the local 
				camera Y, because this would mean a different yaw axis if the 
				player is looking upwards rather than when they are looking
                straight ahead. You can change this behaviour by calling this 
				method, which you will want to do if you are making a completely
				free camera like the kind used in a flight simulator. 
            @param
                useFixed If true, the axis passed in the second parameter will 
				always be the yaw axis no matter what the camera orientation. 
				If false, the camera yaws around the local Y.
            @param
                fixedAxis The axis to use if the first parameter is true.

</member>
        <member name="M:Ogre.Camera.rotate(Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Rotate the camera around an arbitrary axis using a Quaternion.

</member>
        <member name="M:Ogre.Camera.rotate(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Rotate the camera around an arbitrary axis.

</member>
        <member name="M:Ogre.Camera.pitch(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Pitches the camera up/down anticlockwise around it's local z axis.

</member>
        <member name="M:Ogre.Camera.yaw(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Rotates the camera anticlockwise around it's local y axis.

</member>
        <member name="M:Ogre.Camera.roll(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Rolls the camera anticlockwise, around its local z axis.

</member>
        <member name="M:Ogre.Camera.lookAt(System.Single,System.Single,System.Single)">
Points the camera at a location in worldspace.
            @remarks
                This is a helper method to automatically generate the
                direction vector for the camera, based on it's current position
                and the supplied look-at point.
            @param
                x
            @param
                y
            @param
                z Co-ordinates of the point to look at.

</member>
        <member name="M:Ogre.Camera.lookAt(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Points the camera at a location in worldspace.
            @remarks
                This is a helper method to automatically generate the
                direction vector for the camera, based on it's current position
                and the supplied look-at point.
            @param
                targetPoint A vector specifying the look at point.

</member>
        <member name="M:Ogre.Camera.getRight">
Gets the camera's right vector.

</member>
        <member name="M:Ogre.Camera.getUp">
Gets the camera's up vector.

</member>
        <member name="M:Ogre.Camera.setDirection(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the camera's direction vector.

</member>
        <member name="M:Ogre.Camera.setDirection(System.Single,System.Single,System.Single)">
Sets the camera's direction vector.
            @remarks
                Note that the 'up' vector for the camera will automatically be recalculated based on the
                current 'up' vector (i.e. the roll will remain the same).

</member>
        <member name="M:Ogre.Camera.moveRelative(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Moves the camera's position by the vector offset provided along it's own axes (relative to orientation).

</member>
        <member name="M:Ogre.Camera.move(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Moves the camera's position by the vector offset provided along world axes.

</member>
        <member name="M:Ogre.Camera.getPosition">
Retrieves the camera's position.

</member>
        <member name="M:Ogre.Camera.setPosition(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the camera's position.

</member>
        <member name="M:Ogre.Camera.setPosition(System.Single,System.Single,System.Single)">
Sets the camera's position.

</member>
        <member name="M:Ogre.Camera.getPolygonMode">
Retrieves the level of detail that the camera will render.

</member>
        <member name="M:Ogre.Camera.setPolygonMode(Ogre.PolygonMode)">
Sets the level of rendering detail required from this camera.
            @remarks
                Each camera is set to render at full detail by default, that is
                with full texturing, lighting etc. This method lets you change
                that behaviour, allowing you to make the camera just render a
                wireframe view, for example.

</member>
        <member name="M:Ogre.Camera.getName">
Gets the camera's name.

</member>
        <member name="M:Ogre.Camera.getSceneManager">
Returns a pointer to the SceneManager this camera is rendering through.

</member>
        <member name="M:Ogre.Camera.removeListener(Ogre.Camera.Listener*)">
Remove a listener to this camera
</member>
        <member name="M:Ogre.Camera.addListener(Ogre.Camera.Listener*)">
Add a listener to this camera
</member>
        <member name="M:Ogre.Camera.Dispose">
Standard destructor.

</member>
        <member name="M:Ogre.Camera.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.SceneManager*)">
Standard constructor.

</member>
        <member name="M:Ogre.Camera.getRayForwardIntersect(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*,System.Single)">
Helper function for forwardIntersect that intersects rays with canonical plane 
</member>
        <member name="M:Ogre.Camera.setWindowImpl">
Do actual window setting, using parameters set in SetWindow call
        @remarks
            The method will called on demand.

</member>
        <member name="M:Ogre.Camera.invalidateView">
Signal to update view information.
</member>
        <member name="M:Ogre.Camera.invalidateFrustum">
Signal to update frustum information.
</member>
        <member name="F:Ogre.Camera.mLodCamera">
Camera to use for LOD calculation
</member>
        <member name="F:Ogre.Camera.mUseRenderingDistance">
Whether or not the rendering distance of objects should take effect for this camera
</member>
        <member name="F:Ogre.Camera.mCullFrustum">
Custom culling frustum
</member>
        <member name="F:Ogre.Camera.mAutoAspectRatio">
Whether aspect ratio will automatically be recalculated 
            when a viewport changes its size

</member>
        <member name="F:Ogre.Camera.mLastViewport">
The last viewport to be added using this camera
</member>
        <member name="F:Ogre.Camera.mWindowClipPlanes">
Windowed viewport clip planes 
</member>
        <member name="F:Ogre.Camera.mWindowSet">
Is viewing window used.
</member>
        <member name="F:Ogre.Camera.mWLeft">
Viewing window. 
        @remarks
        Generalize camera class for the case, when viewing frustum doesn't cover all viewport.

</member>
        <member name="F:Ogre.Camera.mSceneLodFactorInv">
Inverted scene LOD factor, can be used by Renderables to adjust their LOD
</member>
        <member name="F:Ogre.Camera.mAutoTrackOffset">
Tracking offset for fine tuning
</member>
        <member name="F:Ogre.Camera.mAutoTrackTarget">
SceneNode which this Camera will automatically track
</member>
        <member name="F:Ogre.Camera.msMovableType">
Shared class-level name for Movable type
</member>
        <member name="F:Ogre.Camera.mVisBatchesLastRender">
Stored number of visible faces in the last render
</member>
        <member name="F:Ogre.Camera.mVisFacesLastRender">
Stored number of visible faces in the last render
</member>
        <member name="F:Ogre.Camera.mSceneDetail">
Rendering type
</member>
        <member name="F:Ogre.Camera.mYawFixedAxis">
Fixed axis to yaw around
</member>
        <member name="F:Ogre.Camera.mYawFixed">
Whether to yaw around a fixed axis.
</member>
        <member name="F:Ogre.Camera.mRealOrientation">
Real world orientation/position of the camera
</member>
        <member name="F:Ogre.Camera.mDerivedOrientation">
Derived orientation/position of the camera, including reflection
</member>
        <member name="F:Ogre.Camera.mPosition">
Camera position - default (0,0,0)
</member>
        <member name="F:Ogre.Camera.mOrientation">
Camera orientation, quaternion style
</member>
        <member name="F:Ogre.Camera.mSceneMgr">
Scene manager responsible for the scene
</member>
        <member name="F:Ogre.Camera.mName">
Camera name
</member>
        <member name="M:Ogre.Camera.Listener.cameraDestroyed(Ogre.Camera*)">
Called when the camera is being destroyed
</member>
        <member name="M:Ogre.Camera.Listener.cameraPostRenderScene(Ogre.Camera*)">
Called after the scene has been rendered with this camera
</member>
        <member name="M:Ogre.Camera.Listener.cameraPreRenderScene(Ogre.Camera*)">
Called prior to the scene being rendered with this camera
</member>
        <member name="T:Ogre.Camera.Listener">
Listener interface so you can be notified of Camera events. 

</member>
        <member name="T:Ogre.Camera">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

A viewpoint from which the scene will be rendered.
        @remarks
            OGRE renders scenes from a camera viewpoint into a buffer of
            some sort, normally a window or a texture (a subclass of
            RenderTarget). OGRE cameras support both perspective projection (the default,
            meaning objects get smaller the further away they are) and
            orthographic projection (blueprint-style, no decrease in size
            with distance). Each camera carries with it a style of rendering,
            e.g. full textured, flat shaded, wireframe), field of view,
            rendering distances etc, allowing you to use OGRE to create
            complex multi-window views if required. In addition, more than
            one camera can point at a single render target if required,
            each rendering to a subset of the target, allowing split screen
            and picture-in-picture views.
        @par
            Cameras maintain their own aspect ratios, field of view, and frustum,
            and project co-ordinates into a space measured from -1 to 1 in x and y,
            and 0 to 1 in z. At render time, the camera will be rendering to a
            Viewport which will translate these parametric co-ordinates into real screen
            co-ordinates. Obviously it is advisable that the viewport has the same
            aspect ratio as the camera to avoid distortion (unless you want it!).
        @par
            Note that a Camera can be attached to a SceneNode, using the method
            SceneNode::attachObject. If this is done the Camera will combine it's own
            position/orientation settings with it's parent SceneNode. 
            This is useful for implementing more complex Camera / object
            relationships i.e. having a camera attached to a world object.

</member>
        <member name="M:Ogre.Ray.intersects(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tests whether this ray intersects the given box. 
		@returns A pair structure where the first element indicates whether
			an intersection occurs, and if true, the second element will
			indicate the distance along the ray at which it intersects. 
			This can be converted to a point in space by calling getPoint().

</member>
        <member name="M:Ogre.Ray.intersects(Ogre.Sphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tests whether this ray intersects the given sphere. 
		@returns A pair structure where the first element indicates whether
			an intersection occurs, and if true, the second element will
			indicate the distance along the ray at which it intersects. 
			This can be converted to a point in space by calling getPoint().

</member>
        <member name="M:Ogre.Ray.intersects(Ogre.PlaneBoundedVolume!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tests whether this ray intersects the given plane bounded volume. 
        @returns A pair structure where the first element indicates whether
        an intersection occurs, and if true, the second element will
        indicate the distance along the ray at which it intersects. 
        This can be converted to a point in space by calling getPoint().

</member>
        <member name="M:Ogre.Ray.intersects(Ogre.Plane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tests whether this ray intersects the given plane. 
		@returns A pair structure where the first element indicates whether
			an intersection occurs, and if true, the second element will
			indicate the distance along the ray at which it intersects. 
			This can be converted to a point in space by calling getPoint().

</member>
        <member name="M:Ogre.Ray.op_Multiply(System.Single)">
Gets the position of a point t units along the ray. 
</member>
        <member name="M:Ogre.Ray.getPoint(System.Single)">
Gets the position of a point t units along the ray. 
</member>
        <member name="M:Ogre.Ray.getDirection">
Gets the direction of the ray. 
</member>
        <member name="M:Ogre.Ray.setDirection(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the direction of the ray. 
</member>
        <member name="M:Ogre.Ray.getOrigin">
Gets the origin of the ray. 
</member>
        <member name="M:Ogre.Ray.setOrigin(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the origin of the ray. 
</member>
        <member name="T:Ogre.Ray">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

Representation of a ray in space, i.e. a line with an origin and direction. 
</member>
        <member name="M:Ogre.PlaneBoundedVolume.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Intersection test with a Ray
        @returns std::pair of hit (bool) and distance
        @remarks May return false positives but will never miss an intersection.

</member>
        <member name="M:Ogre.PlaneBoundedVolume.intersects(Ogre.Sphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Intersection test with Sphere
        @remarks May return false positives but will never miss an intersection.

</member>
        <member name="M:Ogre.PlaneBoundedVolume.intersects(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Intersection test with AABB
        @remarks May return false positives but will never miss an intersection.

</member>
        <member name="M:Ogre.PlaneBoundedVolume.#ctor(Ogre.Plane.Side)">
Constructor, determines which side is deemed to be 'outside' 
</member>
        <member name="F:Ogre.PlaneBoundedVolume.planes">
Publicly accessible plane list, you can modify this direct
</member>
        <member name="T:Ogre.PlaneBoundedVolume">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

Represents a convex volume bounded by planes.

</member>
        <member name="M:Ogre.Frustum.getOrientationMode">
Get the orientation mode of the frustum.
             @remarks
                Getting the orientation of a frustum is only supported on
                iPhone at this time.  An exception is thrown on other platforms.

</member>
        <member name="M:Ogre.Frustum.setOrientationMode(Ogre.OrientationMode)">
Set the orientation mode of the frustum. Default is OR_DEGREE_0
             @remarks
                Setting the orientation of a frustum is only supported on
                iPhone at this time.  An exception is thrown on other platforms.

</member>
        <member name="M:Ogre.Frustum.getPlaneBoundedVolume">
Gets a world-space list of planes enclosing the frustum.

</member>
        <member name="M:Ogre.Frustum.getOrientationForViewUpdate">
Get the derived orientation of this frustum. 
</member>
        <member name="M:Ogre.Frustum.getPositionForViewUpdate">
Get the derived position of this frustum. 
</member>
        <member name="F:Ogre.Frustum.INFINITE_FAR_PLANE_ADJUST">
Small constant used to reduce far plane projection to avoid inaccuracies
</member>
        <member name="M:Ogre.Frustum.visitRenderables(Ogre.Renderable.Visitor*,System.Boolean)">
@copydoc MovableObject::visitRenderables
</member>
        <member name="M:Ogre.Frustum.isCustomNearClipPlaneEnabled">
Is a custom near clip plane in use? 
</member>
        <member name="M:Ogre.Frustum.disableCustomNearClipPlane">
Disables any custom near clip plane. 
</member>
        <member name="M:Ogre.Frustum.enableCustomNearClipPlane(Ogre.Plane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Links the frustum to a custom near clip plane, which can be used
			to clip geometry in a custom manner without using user clip planes.
		@remarks
			There are several applications for clipping a scene arbitrarily by
			a single plane; the most common is when rendering a reflection to  
			a texture, and you only want to render geometry that is above the 
			water plane (to do otherwise results in artefacts). Whilst it is
			possible to use user clip planes, they are not supported on all
			cards, and sometimes are not hardware accelerated when they are
			available. Instead, where a single clip plane is involved, this
			technique uses a 'fudging' of the near clip plane, which is 
			available and fast on all hardware, to perform as the arbitrary
			clip plane. This does change the shape of the frustum, leading 
			to some depth buffer loss of precision, but for many of the uses of
			this technique that is not an issue.
		@note This technique only works for perspective projection.
		@param plane The plane to link to to perform the clipping. This plane
			must continue to exist while the camera is linked to it; do not
			destroy it before the frustum. 

</member>
        <member name="M:Ogre.Frustum.enableCustomNearClipPlane(Ogre.MovablePlane!System.Runtime.CompilerServices.IsConst*)">
Links the frustum to a custom near clip plane, which can be used
			to clip geometry in a custom manner without using user clip planes.
		@remarks
			There are several applications for clipping a scene arbitrarily by
			a single plane; the most common is when rendering a reflection to 
			a texture, and you only want to render geometry that is above the 
			water plane (to do otherwise results in artefacts). Whilst it is
			possible to use user clip planes, they are not supported on all
			cards, and sometimes are not hardware accelerated when they are
			available. Instead, where a single clip plane is involved, this
			technique uses a 'fudging' of the near clip plane, which is 
			available and fast on all hardware, to perform as the arbitrary
			clip plane. This does change the shape of the frustum, leading 
			to some depth buffer loss of precision, but for many of the uses of
			this technique that is not an issue.
		@par 
			This version of the method links to a plane, rather than requiring
			a by-value plane definition, and therefore you can 
			make changes to the plane (e.g. by moving / rotating the node it is
			attached to) and they will automatically affect this object.
		@note This technique only works for perspective projection.
		@param plane The plane to link to to perform the clipping. This plane
			must continue to exist while the camera is linked to it; do not
			destroy it before the frustum. 

</member>
        <member name="M:Ogre.Frustum.projectSphere(Ogre.Sphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*,System.Single*,System.Single*)">
Project a sphere onto the near plane and get the bounding rectangle. 
        @param sphere The world-space sphere to project
        @param radius Radius of the sphere
        @param left, top, right, bottom Pointers to destination values, these
            will be completed with the normalised device coordinates (in the 
            range {-1,1})
        @returns true if the sphere was projected to a subset of the near plane,
            false if the entire near plane was contained

</member>
        <member name="M:Ogre.Frustum.getReflectionPlane">
Returns the reflection plane of the frustum if appropriate
</member>
        <member name="M:Ogre.Frustum.getReflectionMatrix">
Returns the reflection matrix of the frustum if appropriate
</member>
        <member name="M:Ogre.Frustum.isReflected">
Returns whether this frustum is being reflected
</member>
        <member name="M:Ogre.Frustum.disableReflection">
Disables reflection modification previously turned on with enableReflection 
</member>
        <member name="M:Ogre.Frustum.enableReflection(Ogre.MovablePlane!System.Runtime.CompilerServices.IsConst*)">
Modifies this frustum so it always renders from the reflection of itself through the
        plane specified. Note that this version of the method links to a plane
		so that changes to it are picked up automatically. It is important that
		this plane continues to exist whilst this object does; do not destroy
		the plane before the frustum.
        @remarks
        This is obviously useful for performing planar reflections. 

</member>
        <member name="M:Ogre.Frustum.enableReflection(Ogre.Plane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Modifies this frustum so it always renders from the reflection of itself through the
        plane specified.
        @remarks
        This is obviously useful for performing planar reflections. 

</member>
        <member name="M:Ogre.Frustum.getOrthoWindowWidth">
Gets the orthographic window width, for use with orthographic rendering only. 
		@note This is calculated from the orthographic height and the aspect ratio

</member>
        <member name="M:Ogre.Frustum.getOrthoWindowHeight">
Gets the orthographic window height, for use with orthographic rendering only. 

</member>
        <member name="M:Ogre.Frustum.setOrthoWindowWidth(System.Single)">
Sets the orthographic window width, for use with orthographic rendering only. 
		@note The height of the window will be calculated from the aspect ratio. 
		@param w The width of the view window in world units

</member>
        <member name="M:Ogre.Frustum.setOrthoWindowHeight(System.Single)">
Sets the orthographic window height, for use with orthographic rendering only. 
		@note The width of the window will be calculated from the aspect ratio. 
		@param h The height of the view window in world units

</member>
        <member name="M:Ogre.Frustum.setOrthoWindow(System.Single,System.Single)">
Sets the orthographic window settings, for use with orthographic rendering only. 
		@note Calling this method will recalculate the aspect ratio, use 
			setOrthoWindowHeight or setOrthoWindowWidth alone if you wish to 
			preserve the aspect ratio but just fit one or other dimension to a 
			particular size.
		@param w, h The dimensions of the view window in world units

</member>
        <member name="M:Ogre.Frustum.getProjectionType">
Retrieves info on the type of projection used (orthographic or perspective).

</member>
        <member name="M:Ogre.Frustum.setProjectionType(Ogre.ProjectionType)">
Sets the type of projection to use (orthographic or perspective). Default is perspective.

</member>
        <member name="M:Ogre.Frustum.getWorldSpaceCorners">
Gets the world space corners of the frustum.
        @remarks
            The corners are ordered as follows: top-right near, 
            top-left near, bottom-left near, bottom-right near, 
            top-right far, top-left far, bottom-left far, bottom-right far.

</member>
        <member name="M:Ogre.Frustum.getLights">
Overridden from Renderable 
</member>
        <member name="M:Ogre.Frustum.getSquaredViewDepth(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Overridden from Renderable 
</member>
        <member name="M:Ogre.Frustum.getWorldTransforms(Ogre.Matrix4*)">
Overridden from Renderable 
</member>
        <member name="M:Ogre.Frustum.getRenderOperation(Ogre.RenderOperation*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Overridden from Renderable 
</member>
        <member name="M:Ogre.Frustum.getMaterial">
Overridden from Renderable 
</member>
        <member name="M:Ogre.Frustum._notifyCurrentCamera(Ogre.Camera*)">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.Frustum.getMovableType">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.Frustum._updateRenderQueue(Ogre.RenderQueue*)">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.Frustum.getBoundingRadius">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.Frustum.getBoundingBox">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.Frustum.getTypeFlags">
Overridden from MovableObject::getTypeFlags
</member>
        <member name="M:Ogre.Frustum.isVisible(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.FrustumPlane*)">
Tests whether the given vertex is visible in the Frustum.
            @param
                vert Vertex to be checked (world space)
            @param
                culledBy Optional pointer to an int which will be filled by the plane number which culled
                the box if the result was false;
            @returns
                If the box was visible, true is returned.
            @par
                Otherwise, false is returned.

</member>
        <member name="M:Ogre.Frustum.isVisible(Ogre.Sphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.FrustumPlane*)">
Tests whether the given container is visible in the Frustum.
            @param
                bound Bounding sphere to be checked (world space)
            @param
                culledBy Optional pointer to an int which will be filled by the plane number which culled
                the box if the result was false;
            @returns
                If the sphere was visible, true is returned.
            @par
                Otherwise, false is returned.

</member>
        <member name="M:Ogre.Frustum.isVisible(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.FrustumPlane*)">
Tests whether the given container is visible in the Frustum.
            @param
                bound Bounding box to be checked (world space)
            @param
                culledBy Optional pointer to an int which will be filled by the plane number which culled
                the box if the result was false;
            @returns
                If the box was visible, true is returned.
            @par
                Otherwise, false is returned.

</member>
        <member name="M:Ogre.Frustum.getFrustumPlane(System.UInt16)">
Retrieves a specified plane of the frustum (world space).
            @remarks
                Gets a reference to one of the planes which make up the frustum frustum, e.g. for clipping purposes.

</member>
        <member name="M:Ogre.Frustum.getFrustumPlanes">
Retrieves the clipping planes of the frustum (world space).
        @remarks
            The clipping planes are ordered as declared in enumerate constants FrustumPlane.

</member>
        <member name="M:Ogre.Frustum.isCustomProjectionMatrixEnabled">
Returns whether a custom projection matrix is in use
</member>
        <member name="M:Ogre.Frustum.setCustomProjectionMatrix(System.Boolean,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set whether to use a custom projection matrix on this frustum.
		@remarks
			This is an advanced method which allows you to manually set
			the projection matrix on this frustum, rather than having it 
			calculate itself based on it's position and orientation. 
		@note
			After enabling a custom projection matrix, the frustum will no 
			longer update on its own based on field of view and near / far
			distance changes. You are completely responsible for keeping the 
			projection matrix up to date if those values change. The custom 
			matrix will be returned from getProjectionMatrix and derivative
			functions.
		@param enable If true, the custom projection matrix passed as the 
			second parameter will be used in preference to an auto calculated 
			one. If	false, the frustum will revert to auto calculating the 
			projection matrix.
		@param projectionMatrix The custom view matrix to use
		@see Frustum::setCustomViewMatrix

</member>
        <member name="M:Ogre.Frustum.isCustomViewMatrixEnabled">
Returns whether a custom view matrix is in use
</member>
        <member name="M:Ogre.Frustum.setCustomViewMatrix(System.Boolean,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set whether to use a custom view matrix on this frustum.
		@remarks
			This is an advanced method which allows you to manually set
			the view matrix on this frustum, rather than having it calculate
			itself based on it's position and orientation. 
		@note
			After enabling a custom view matrix, the frustum will no longer
			update on its own based on position / orientation changes. You 
			are completely responsible for keeping the view matrix up to date.
			The custom matrix will be returned from getViewMatrix.
		@param enable If true, the custom view matrix passed as the second 
			parameter will be used in preference to an auto calculated one. If
			false, the frustum will revert to auto calculating the view matrix.
		@param viewMatrix The custom view matrix to use, the matrix must be an
            affine matrix.
		@see Frustum::setCustomProjectionMatrix, Matrix4::isAffine

</member>
        <member name="M:Ogre.Frustum.calcViewMatrixRelative(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Matrix4*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculate a view matrix for this frustum, relative to a potentially dynamic point. 
			Mainly for use by OGRE internally when using camera-relative rendering
			for frustums that are not the centre (e.g. texture projection)

</member>
        <member name="M:Ogre.Frustum.getViewMatrix">
Gets the view matrix for this frustum. Mainly for use by OGRE internally.

</member>
        <member name="M:Ogre.Frustum.getProjectionMatrix">
Gets the normal projection matrix for this frustum, ie the 
        projection matrix which conforms to standard right-handed rules and
        uses depth range [-1,+1].
        @remarks
            This differs from the rendering-API dependent getProjectionMatrixRS
            in that it always returns a right-handed projection matrix with depth
            range [-1,+1], result no matter what rendering API is being used - this
            is required for some uniform algebra for example.

</member>
        <member name="M:Ogre.Frustum.getProjectionMatrixWithRSDepth">
Gets the depth-adjusted projection matrix for the current rendersystem,
			but one which still conforms to right-hand rules.
        @remarks
            This differs from the rendering-API dependent getProjectionMatrix
            in that it always returns a right-handed projection matrix result 
            no matter what rendering API is being used - this is required for
            vertex and fragment programs for example. However, the resulting depth
            range may still vary between render systems since D3D uses [0,1] and 
            GL uses [-1,1], and the range must be kept the same between programmable
            and fixed-function pipelines.

</member>
        <member name="M:Ogre.Frustum.getProjectionMatrixRS">
Gets the projection matrix for this frustum adjusted for the current
			rendersystem specifics (may be right or left-handed, depth range
			may vary).
        @remarks
            This method retrieves the rendering-API dependent version of the projection
            matrix. If you want a 'typical' projection matrix then use 
            getProjectionMatrix.


</member>
        <member name="M:Ogre.Frustum.getFrustumExtents(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get the extents of the frustum in view space. 
</member>
        <member name="M:Ogre.Frustum.resetFrustumExtents">
Reset the frustum extents to be automatically derived from other params. 
</member>
        <member name="M:Ogre.Frustum.setFrustumExtents(System.Single,System.Single,System.Single,System.Single)">
Manually set the extents of the frustum.
		@param left, right, top, bottom The position where the side clip planes intersect
			the near clip plane, in eye space

</member>
        <member name="M:Ogre.Frustum.getFocalLength">
Returns focal length of frustum.

</member>
        <member name="M:Ogre.Frustum.setFocalLength(System.Single)">
Sets frustum focal length (used in stereo rendering).
            @param
                focalLength The distance to the focal plane from the frustum in world coordinates.

</member>
        <member name="M:Ogre.Frustum.getFrustumOffset">
Retrieves the frustum offsets.

</member>
        <member name="M:Ogre.Frustum.setFrustumOffset(System.Single,System.Single)">
Sets frustum offsets, used in stereo rendering.
            @remarks
                You can set both horizontal and vertical plane offsets of "eye"; in
                stereo rendering frustum is moved in horizontal plane. To be able to
                render from two "eyes" you'll need two cameras rendering on two
                RenderTargets.
            @par
                The frustum offsets is in world coordinates, and default to (0, 0) - no offsets.
            @param
                horizontal The horizontal plane offset.
            @param
                vertical The vertical plane offset.

</member>
        <member name="M:Ogre.Frustum.setFrustumOffset(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets frustum offsets, used in stereo rendering.
            @remarks
                You can set both horizontal and vertical plane offsets of "eye"; in
                stereo rendering frustum is moved in horizontal plane. To be able to
                render from two "eyes" you'll need two cameras rendering on two
                RenderTargets.
            @par
                The frustum offsets is in world coordinates, and default to (0, 0) - no offsets.
            @param
                offset The horizontal and vertical plane offsets.

</member>
        <member name="M:Ogre.Frustum.getAspectRatio">
Retreives the current aspect ratio.

</member>
        <member name="M:Ogre.Frustum.setAspectRatio(System.Single)">
Sets the aspect ratio for the frustum viewport.
            @remarks
                The ratio between the x and y dimensions of the rectangular area visible through the frustum
                is known as aspect ratio: aspect = width / height .
            @par
                The default for most fullscreen windows is 1.3333 - this is also assumed by Ogre unless you
                use this method to state otherwise.

</member>
        <member name="M:Ogre.Frustum.getFarClipDistance">
Retrieves the distance from the frustum to the far clipping plane.

</member>
        <member name="M:Ogre.Frustum.setFarClipDistance(System.Single)">
Sets the distance to the far clipping plane.
            @remarks
                The view frustum is a pyramid created from the frustum position and the edges of the viewport.
                This method sets the distance for the far end of that pyramid. 
                Different applications need different values: e.g. a flight sim
                needs a much further far clipping plane than a first-person 
                shooter. An important point here is that the larger the ratio 
                between near and far clipping planes, the lower the accuracy of
                the Z-buffer used to depth-cue pixels. This is because the
                Z-range is limited to the size of the Z buffer (16 or 32-bit) 
                and the max values must be spread over the gap between near and
                far clip planes. As it happens, you can affect the accuracy far 
                more by altering the near distance rather than the far distance, 
                but keep this in mind.
            @param
                far The distance to the far clipping plane from the frustum in 
                world coordinates.If you specify 0, this means an infinite view
                distance which is useful especially when projecting shadows; but
                be careful not to use a near distance too close.

</member>
        <member name="M:Ogre.Frustum.getNearClipDistance">
Sets the position of the near clipping plane.

</member>
        <member name="M:Ogre.Frustum.setNearClipDistance(System.Single)">
Sets the position of the near clipping plane.
            @remarks
                The position of the near clipping plane is the distance from the frustums position to the screen
                on which the world is projected. The near plane distance, combined with the field-of-view and the
                aspect ratio, determines the size of the viewport through which the world is viewed (in world
                co-ordinates). Note that this world viewport is different to a screen viewport, which has it's
                dimensions expressed in pixels. The frustums viewport should have the same aspect ratio as the
                screen viewport it renders into to avoid distortion.
            @param
                near The distance to the near clipping plane from the frustum in world coordinates.

</member>
        <member name="M:Ogre.Frustum.getFOVy">
Retrieves the frustums Y-dimension Field Of View (FOV).

</member>
        <member name="M:Ogre.Frustum.setFOVy(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the Y-dimension Field Of View (FOV) of the frustum.
            @remarks
                Field Of View (FOV) is the angle made between the frustum's position, and the edges
                of the 'screen' onto which the scene is projected. High values (90+ degrees) result in a wide-angle,
                fish-eye kind of view, low values (30- degrees) in a stretched, telescopic kind of view. Typical values
                are between 45 and 60 degrees.
            @par
                This value represents the VERTICAL field-of-view. The horizontal field of view is calculated from
                this depending on the dimensions of the viewport (they will only be the same if the viewport is square).
            @note
                Setting the FOV overrides the value supplied for frustum::setNearClipPlane.

</member>
        <member name="F:Ogre.Frustum.mLastLinkedObliqueProjPlane">
Record of the last world-space oblique depth projection plane info used
</member>
        <member name="F:Ogre.Frustum.mLinkedObliqueProjPlane">
Pointer to oblique projection plane (automatically updated)
</member>
        <member name="F:Ogre.Frustum.mObliqueProjPlane">
Fixed oblique projection plane
</member>
        <member name="F:Ogre.Frustum.mObliqueDepthProjection">
Is this frustum using an oblique depth projection?
</member>
        <member name="F:Ogre.Frustum.mLastLinkedReflectionPlane">
Record of the last world-space reflection plane info used
</member>
        <member name="F:Ogre.Frustum.mLinkedReflectPlane">
Pointer to a reflection plane (automatically updated)
</member>
        <member name="F:Ogre.Frustum.mReflectPlane">
Fixed reflection plane
</member>
        <member name="F:Ogre.Frustum.mReflectMatrix">
Derived reflection matrix
</member>
        <member name="F:Ogre.Frustum.mReflect">
Is this frustum to act as a reflection of itself?
</member>
        <member name="F:Ogre.Frustum.msMovableType">
Shared class-level name for Movable type
</member>
        <member name="M:Ogre.Frustum.invalidateView">
Signal to update view information.
</member>
        <member name="M:Ogre.Frustum.invalidateFrustum">
Signal to update frustum information.
</member>
        <member name="M:Ogre.Frustum.updateWorldSpaceCornersImpl">
Implementation of updateWorldSpaceCorners (called if out of date)
</member>
        <member name="M:Ogre.Frustum.updateFrustumPlanesImpl">
Implementation of updateFrustumPlanes (called if out of date)
</member>
        <member name="M:Ogre.Frustum.updateViewImpl">
Implementation of updateView (called if out of date)
</member>
        <member name="M:Ogre.Frustum.updateFrustumImpl">
Implementation of updateFrustum (called if out of date)
</member>
        <member name="M:Ogre.Frustum.updateView">
Update view if out of date
</member>
        <member name="M:Ogre.Frustum.updateFrustum">
Update frustum if out of date
</member>
        <member name="F:Ogre.Frustum.mOrientationMode">
Frustum orientation mode
</member>
        <member name="F:Ogre.Frustum.mLeft">
Frustum extents
</member>
        <member name="F:Ogre.Frustum.mFrustumExtentsManuallySet">
Have the frustum extents been manually set?
</member>
        <member name="F:Ogre.Frustum.mCustomProjMatrix">
Are we using a custom projection matrix?
</member>
        <member name="F:Ogre.Frustum.mCustomViewMatrix">
Are we using a custom view matrix?
</member>
        <member name="F:Ogre.Frustum.mRecalcVertexData">
Something re the vertex data has changed
</member>
        <member name="F:Ogre.Frustum.mRecalcWorldSpaceCorners">
Something re the world space corners has changed
</member>
        <member name="F:Ogre.Frustum.mRecalcFrustumPlanes">
Something re the frustum planes has changed
</member>
        <member name="F:Ogre.Frustum.mRecalcView">
Something re the view pos has changed
</member>
        <member name="F:Ogre.Frustum.mRecalcFrustum">
Something's changed in the frustum shape?
</member>
        <member name="F:Ogre.Frustum.mViewMatrix">
Pre-calced view matrix
</member>
        <member name="F:Ogre.Frustum.mProjMatrix">
Pre-calced standard projection matrix
</member>
        <member name="F:Ogre.Frustum.mProjMatrixRSDepth">
Pre-calced standard projection matrix but with render system depth range
</member>
        <member name="F:Ogre.Frustum.mProjMatrixRS">
Pre-calced projection matrix for the specific render system
</member>
        <member name="F:Ogre.Frustum.mLastParentOrientation">
Stored versions of parent orientation / position
</member>
        <member name="F:Ogre.Frustum.mFrustumPlanes">
The 6 main clipping planes
</member>
        <member name="F:Ogre.Frustum.mFocalLength">
Focal length of frustum (for stereo rendering, defaults to 1.0)
</member>
        <member name="F:Ogre.Frustum.mFrustumOffset">
Off-axis frustum center offset - default (0.0, 0.0)
</member>
        <member name="F:Ogre.Frustum.mOrthoHeight">
Ortho height size (world units)
</member>
        <member name="F:Ogre.Frustum.mAspect">
x/y viewport ratio - default 1.3333
</member>
        <member name="F:Ogre.Frustum.mNearDist">
Near clip distance - default 100
</member>
        <member name="F:Ogre.Frustum.mFarDist">
Far clip distance - default 10000
</member>
        <member name="F:Ogre.Frustum.mFOVy">
y-direction field-of-view (default 45)
</member>
        <member name="F:Ogre.Frustum.mProjType">
Orthographic or perspective?
</member>
        <member name="T:Ogre.Frustum">
A frustum represents a pyramid, capped at the near and far end which is
        used to represent either a visible area or a projection area. Can be used
        for a number of applications.

</member>
        <member name="T:Ogre.FrustumPlane">
Worldspace clipping planes.

</member>
        <member name="T:Ogre.ProjectionType">
Specifies perspective (realistic) or orthographic (architectural) projection.

</member>
        <member name="T:Ogre.OrientationMode">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

Specifies orientation mode.

</member>
        <member name="M:Ogre.MovablePlane.visitRenderables(Ogre.Renderable.Visitor*,System.Boolean)">
@copydoc MovableObject::visitRenderables
</member>
        <member name="M:Ogre.MovablePlane._getDerivedPlane">
Get the derived plane as transformed by its parent node. 
</member>
        <member name="M:Ogre.MovablePlane.getMovableType">
Overridden from MovableObject
</member>
        <member name="M:Ogre.MovablePlane._updateRenderQueue(Ogre.RenderQueue*)">
Overridden from MovableObject
</member>
        <member name="M:Ogre.MovablePlane.getBoundingRadius">
Overridden from MovableObject
</member>
        <member name="M:Ogre.MovablePlane.getBoundingBox">
Overridden from MovableObject
</member>
        <member name="M:Ogre.MovablePlane._notifyCurrentCamera(Ogre.Camera*)">
Overridden from MovableObject
</member>
        <member name="M:Ogre.MovablePlane.#ctor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Construct a plane through a normal, and a distance to move the plane along the normal.
</member>
        <member name="T:Ogre.MovablePlane">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Definition of a Plane that may be attached to a node, and the derived
        details of it retrieved simply.
    @remarks
        This plane is not here for rendering purposes, it's to allow you to attach
        planes to the scene in order to have them move and follow nodes on their
        own, which is useful if you're using the plane for some kind of calculation,
        e.g. reflection.

</member>
        <member name="F:Ogre.Bone.mBindDerivedInversePosition">
The inversed derived position of the bone in the binding pose
</member>
        <member name="F:Ogre.Bone.mBindDerivedInverseOrientation">
The inversed derived orientation of the bone in the binding pose
</member>
        <member name="F:Ogre.Bone.mBindDerivedInverseScale">
The inversed derived scale of the bone in the binding pose
</member>
        <member name="F:Ogre.Bone.mCreator">
Pointer back to creator, for child creation (not smart ptr so child does not preserve parent)
</member>
        <member name="M:Ogre.Bone.createChildImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
See Node. 
</member>
        <member name="M:Ogre.Bone.createChildImpl">
See Node. 
</member>
        <member name="F:Ogre.Bone.mManuallyControlled">
Bones set as manuallyControlled are not reseted in Skeleton::reset() 
</member>
        <member name="F:Ogre.Bone.mHandle">
The numeric handle of this bone
</member>
        <member name="M:Ogre.Bone.needUpdate(System.Boolean)">
@see Node::needUpdate
</member>
        <member name="M:Ogre.Bone._getBindingPoseInverseOrientation">
Gets the inverted binding pose orientation. 
</member>
        <member name="M:Ogre.Bone._getBindingPoseInversePosition">
Gets the inverted binding pose position. 
</member>
        <member name="M:Ogre.Bone._getBindingPoseInverseScale">
Gets the inverted binding pose scale. 
</member>
        <member name="M:Ogre.Bone._getOffsetTransform(Ogre.Matrix4*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the transform which takes bone space to current from the binding pose. 
        @remarks
            Internal use only.

</member>
        <member name="M:Ogre.Bone.isManuallyControlled">
Getter for mManuallyControlled Flag 
</member>
        <member name="M:Ogre.Bone.setManuallyControlled(System.Boolean)">
Sets whether or not this bone is manually controlled. 
        @remarks
            Manually controlled bones can be altered by the application at runtime, 
            and their positions will not be reset by the animation routines. Note 
            that you should also make sure that there are no AnimationTrack objects
            referencing this bone, or if there are, you should disable them using
            pAnimation-&gt;destroyTrack(pBone-&gt;getHandle());

</member>
        <member name="M:Ogre.Bone.reset">
Resets the position and orientation of this Bone to the original binding position.
        @remarks
            Bones are bound to the mesh in a binding pose. They are then modified from this
            position during animation. This method returns the bone to it's original position and
            orientation.

</member>
        <member name="M:Ogre.Bone.setBindingPose">
Sets the current position / orientation to be the 'binding pose' ie the layout in which 
            bones were originally bound to a mesh.

</member>
        <member name="M:Ogre.Bone.getHandle">
Gets the numeric handle for this bone (unique within the skeleton). 
</member>
        <member name="M:Ogre.Bone.createChild(System.UInt16,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a new Bone as a child of this bone.
        @remarks
            This method creates a new bone which will inherit the transforms of this
            bone, with the handle specified.
            @param 
                handle The numeric handle to give the new bone; must be unique within the Skeleton.
            @param
                translate Initial translation offset of child relative to parent
            @param
                rotate Initial rotation relative to parent

</member>
        <member name="M:Ogre.Bone.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16,Ogre.Skeleton*)">
Constructor, not to be used directly (use Bone::createChild or Skeleton::createBone) 
</member>
        <member name="M:Ogre.Bone.#ctor(System.UInt16,Ogre.Skeleton*)">
Constructor, not to be used directly (use Bone::createChild or Skeleton::createBone) 
</member>
        <member name="T:Ogre.Bone">
\addtogroup Core
	*  @{

\addtogroup Animation
	*  @{

A bone in a skeleton.
    @remarks
        See Skeleton for more information about the principles behind skeletal animation.
        This class is a node in the joint hierarchy. Mesh vertices also have assignments
        to bones to define how they move in relation to the skeleton.

</member>
        <member name="M:Ogre.Node.getUserObjectBindings">
Return an instance of user objects binding associated with this class.
		You can use it to associate one or more custom objects with this class instance.
		@see UserObjectBindings::setUserAny.


Return an instance of user objects binding associated with this class.
		You can use it to associate one or more custom objects with this class instance.
		@see UserObjectBindings::setUserAny.		

</member>
        <member name="M:Ogre.Node.getUserAny">
@deprecated use UserObjectBindings::getUserAny via getUserObjectBindings() instead.
		Retrieves the custom user value associated with this object.

</member>
        <member name="M:Ogre.Node.setUserAny(Ogre.Any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@deprecated use UserObjectBindings::setUserAny via getUserObjectBindings() instead.
		Sets any kind of user value on this object.
		@remarks
		This method allows you to associate any user value you like with 
		this Node. This can be a pointer back to one of your own
		classes for instance.

</member>
        <member name="M:Ogre.Node.processQueuedUpdates">
Process queued 'needUpdate' calls. 
</member>
        <member name="M:Ogre.Node.queueNeedUpdate(Ogre.Node*)">
Queue a 'needUpdate' call to a node safely.
		@remarks
			You can't call needUpdate() during the scene graph update, e.g. in
			response to a Node::Listener hook, because the graph is already being 
			updated, and update flag changes cannot be made reliably in that context. 
			Call this method if you need to queue a needUpdate call in this case.

</member>
        <member name="M:Ogre.Node.getDebugRenderable(System.Single)">
Get a debug renderable for rendering the Node.  
</member>
        <member name="M:Ogre.Node.cancelUpdate(Ogre.Node*)">
Called by children to notify their parent that they no longer need an update. 
</member>
        <member name="M:Ogre.Node.requestUpdate(Ogre.Node*,System.Boolean)">
Called by children to notify their parent that they need an update. 
		@param forceParentUpdate Even if the node thinks it has already told it's
			parent, tell it anyway

</member>
        <member name="M:Ogre.Node.needUpdate(System.Boolean)">
To be called in the event of transform changes to this node that require it's recalculation.
        @remarks
            This not only tags the node state as being 'dirty', it also requests it's parent to 
            know about it's dirtiness so it will get an update next time.
		@param forceParentUpdate Even if the node thinks it has already told it's
			parent, tell it anyway

</member>
        <member name="M:Ogre.Node.getSquaredViewDepth(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Helper function, get the squared view depth.  
</member>
        <member name="M:Ogre.Node.getInitialScale">
Gets the initial position of this node, see setInitialState for more info. 
</member>
        <member name="M:Ogre.Node.getInitialOrientation">
Gets the initial orientation of this node, see setInitialState for more info. 
</member>
        <member name="M:Ogre.Node.convertLocalToWorldOrientation(Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the world orientation of an orientation in the node local space
			useful for simple transforms that don't require a child node.
</member>
        <member name="M:Ogre.Node.convertWorldToLocalOrientation(Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the local orientation, relative to this node, of the given world-space orientation 
</member>
        <member name="M:Ogre.Node.convertLocalToWorldPosition(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the world position of a point in the node local space
			useful for simple transforms that don't require a child node.
</member>
        <member name="M:Ogre.Node.convertWorldToLocalPosition(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the local position, relative to this node, of the given world-space position 
</member>
        <member name="M:Ogre.Node.getInitialPosition">
Gets the initial position of this node, see setInitialState for more info. 
        @remarks
            Also resets the cumulative animation weight used for blending.

</member>
        <member name="M:Ogre.Node.resetToInitialState">
Resets the position / orientation / scale of this node to it's initial state, see setInitialState for more info. 
</member>
        <member name="M:Ogre.Node.setInitialState">
Sets the current transform of this node to be the 'initial state' ie that
            position / orientation / scale to be used as a basis for delta values used
            in keyframe animation.
        @remarks
            You never need to call this method unless you plan to animate this node. If you do
            plan to animate it, call this method once you've loaded the node with it's base state,
            ie the state on which all keyframes are based.
        @par
            If you never call this method, the initial state is the identity transform, ie do nothing.

</member>
        <member name="M:Ogre.Node.getListener">
Gets the current listener for this Node.

</member>
        <member name="M:Ogre.Node.setListener(Ogre.Node.Listener*)">
Sets a listener for this Node.
		@remarks
			Note for size and performance reasons only one listener per node is
			allowed.

</member>
        <member name="M:Ogre.Node._update(System.Boolean,System.Boolean)">
Internal method to update the Node.
            @note
                Updates this node and any relevant children to incorporate transforms etc.
                Don't call this yourself unless you are writing a SceneManager implementation.
            @param
                updateChildren If true, the update cascades down to all children. Specify false if you wish to
                update children separately, e.g. because of a more selective SceneManager implementation.
            @param
                parentHasChanged This flag indicates that the parent xform has changed,
                    so the child should retrieve the parent's xform and combine it with its own
                    even if it hasn't changed itself.

</member>
        <member name="M:Ogre.Node._getFullTransform">
Gets the full transformation matrix for this node.
            @remarks
                This method returns the full transformation matrix
                for this node, including the effect of any parent node
                transformations, provided they have been updated using the Node::_update method.
                This should only be called by a SceneManager which knows the
                derived transforms have been updated before calling this method.
                Applications using Ogre should just use the relative transforms.

</member>
        <member name="M:Ogre.Node._getDerivedScale">
Gets the scaling factor of the node as derived from all parents.

</member>
        <member name="M:Ogre.Node._getDerivedPosition">
Gets the position of the node as derived from all parents.

</member>
        <member name="M:Ogre.Node._getDerivedOrientation">
Gets the orientation of the node as derived from all parents.

</member>
        <member name="M:Ogre.Node._setDerivedOrientation(Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the final world orientation of the node directly.
		@remarks 
		It's advisable to use the local setOrientation if possible, this simply does
		the conversion for you.

</member>
        <member name="M:Ogre.Node._setDerivedPosition(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the final world position of the node directly.
		@remarks 
			It's advisable to use the local setPosition if possible

</member>
        <member name="M:Ogre.Node.removeAllChildren">
Removes all child Nodes attached to this node. Does not delete the nodes, just detaches them from
            this parent, potentially to be reattached elsewhere.

</member>
        <member name="M:Ogre.Node.removeChild(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Drops the named child from this node. 
        @remarks
            Does not delete the node, just detaches it from
            this parent, potentially to be reattached elsewhere.

</member>
        <member name="M:Ogre.Node.removeChild(Ogre.Node*)">
Drops the specified child from this node. 
        @remarks
        Does not delete the node, just detaches it from
        this parent, potentially to be reattached elsewhere. 
        There is also an alternate version which drops a named
        child from this node.

</member>
        <member name="M:Ogre.Node.removeChild(System.UInt16)">
Drops the specified child from this node. 
        @remarks
            Does not delete the node, just detaches it from
            this parent, potentially to be reattached elsewhere. 
            There is also an alternate version which drops a named
            child from this node.

</member>
        <member name="M:Ogre.Node.getChildIterator">
Retrieves an iterator for efficiently looping through all children of this node.
        @remarks
            Using this is faster than repeatedly calling getChild if you want to go through
            all (or most of) the children of this node.
            Note that the returned iterator is only valid whilst no children are added or
            removed from this node. Thus you should not store this returned iterator for
            later use, nor should you add / remove children whilst iterating through it;
            store up changes for later. Note that calling methods on returned items in 
            the iterator IS allowed and does not invalidate the iterator.


Retrieves an iterator for efficiently looping through all children of this node.
        @remarks
            Using this is faster than repeatedly calling getChild if you want to go through
            all (or most of) the children of this node.
            Note that the returned iterator is only valid whilst no children are added or
            removed from this node. Thus you should not store this returned iterator for
            later use, nor should you add / remove children whilst iterating through it;
            store up changes for later. Note that calling methods on returned items in 
            the iterator IS allowed and does not invalidate the iterator.

</member>
        <member name="M:Ogre.Node.getChild(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets a pointer to a named child node.

</member>
        <member name="M:Ogre.Node.getChild(System.UInt16)">
Gets a pointer to a child node.
        @remarks
            There is an alternate getChild method which returns a named child.

</member>
        <member name="M:Ogre.Node.numChildren">
Reports the number of child nodes under this one.

</member>
        <member name="M:Ogre.Node.addChild(Ogre.Node*)">
Adds a (precreated) child scene node to this node. If it is attached to another node,
            it must be detached first.
        @param child The Node which is to become a child node of this one

</member>
        <member name="M:Ogre.Node.createChild(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a new named Node as a child of this node.
        @remarks
            This creates a child node with a given name, which allows you to look the node up from 
            the parent which holds this collection of nodes.
            @param
                translate Initial translation offset of child relative to parent
            @param
                rotate Initial rotation relative to parent

</member>
        <member name="M:Ogre.Node.createChild(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates an unnamed new Node as a child of this node.
        @param
            translate Initial translation offset of child relative to parent
        @param
            rotate Initial rotation relative to parent

</member>
        <member name="M:Ogre.Node.getLocalAxes">
Gets a matrix whose columns are the local axes based on
            the nodes orientation relative to it's parent. 
</member>
        <member name="M:Ogre.Node.rotate(Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Node.TransformSpace)">
Rotate the node around an aritrary axis using a Quarternion.

</member>
        <member name="M:Ogre.Node.rotate(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Node.TransformSpace)">
Rotate the node around an arbitrary axis.

</member>
        <member name="M:Ogre.Node.yaw(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Node.TransformSpace)">
Rotate the node around the Y-axis.

</member>
        <member name="M:Ogre.Node.pitch(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Node.TransformSpace)">
Rotate the node around the X-axis.

</member>
        <member name="M:Ogre.Node.roll(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Node.TransformSpace)">
Rotate the node around the Z-axis.

</member>
        <member name="M:Ogre.Node.translate(Ogre.Matrix3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single,Ogre.Node.TransformSpace)">
Moves the node along arbitrary axes.
            @remarks
            This method translates the node by a vector which is relative to
            a custom set of axes.
            @param 
                axes A 3x3 Matrix containg 3 column vectors each representing the
                axes X, Y and Z respectively. In this format the standard cartesian
                axes would be expressed as
                <pre>
                1 0 0
                0 1 0
                0 0 1
                </pre>
                i.e. the identity matrix.
            @param 
                x,y,z Translation components relative to the axes above.
            @param
                relativeTo The space which this transform is relative to.

</member>
        <member name="M:Ogre.Node.translate(Ogre.Matrix3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Node.TransformSpace)">
Moves the node along arbitrary axes.
            @remarks
                This method translates the node by a vector which is relative to
                a custom set of axes.
            @param 
                axes A 3x3 Matrix containg 3 column vectors each representing the
                axes X, Y and Z respectively. In this format the standard cartesian
                axes would be expressed as:
                <pre>
                1 0 0
                0 1 0
                0 0 1
                </pre>
                i.e. the identity matrix.
            @param 
                move Vector relative to the axes above.
            @param
            relativeTo The space which this transform is relative to.

</member>
        <member name="M:Ogre.Node.translate(System.Single,System.Single,System.Single,Ogre.Node.TransformSpace)">
Moves the node along the Cartesian axes.
            @par
                This method moves the node by the supplied vector along the
                world Cartesian axes, i.e. along world x,y,z
            @param 
                x
            @param
                y
            @param
                z Real x, y and z values representing the translation.
            @param
            relativeTo The space which this transform is relative to.

</member>
        <member name="M:Ogre.Node.translate(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Node.TransformSpace)">
Moves the node along the Cartesian axes.
            @par
                This method moves the node by the supplied vector along the
                world Cartesian axes, i.e. along world x,y,z
            @param 
                d Vector with x,y,z values representing the translation.
            @param
                relativeTo The space which this transform is relative to.

</member>
        <member name="M:Ogre.Node.scale(System.Single,System.Single,System.Single)">
Scales the node, combining it's current scale with the passed in scaling factor. 
        @remarks
            This method applies an extra scaling factor to the node's existing scale, (unlike setScale
            which overwrites it) combining it's current scale with the new one. E.g. calling this 
            method twice with Vector3(2,2,2) would have the same effect as setScale(Vector3(4,4,4)) if
            the existing scale was 1.
        @par
            Note that like rotations, scalings are oriented around the node's origin.

</member>
        <member name="M:Ogre.Node.scale(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Scales the node, combining it's current scale with the passed in scaling factor. 
        @remarks
            This method applies an extra scaling factor to the node's existing scale, (unlike setScale
            which overwrites it) combining it's current scale with the new one. E.g. calling this 
            method twice with Vector3(2,2,2) would have the same effect as setScale(Vector3(4,4,4)) if
            the existing scale was 1.
        @par
            Note that like rotations, scalings are oriented around the node's origin.

</member>
        <member name="M:Ogre.Node.getInheritScale">
Returns true if this node is affected by scaling factors applied to the parent node. 
        @remarks
            See setInheritScale for more info.

</member>
        <member name="M:Ogre.Node.setInheritScale(System.Boolean)">
Tells the node whether it should inherit scaling factors from it's parent node.
        @remarks
            Scaling factors, unlike other transforms, are not always inherited by child nodes.
            Whether or not scalings affect the size of the child nodes depends on the setInheritScale
            option of the child. In some cases you want a scaling factor of a parent node to apply to
            a child node (e.g. where the child node is a part of the same object, so you want it to be
            the same relative size based on the parent's size), but not in other cases (e.g. where the
            child node is just for positioning another object, you want it to maintain it's own size).
            The default is to inherit as with other transforms.
        @param inherit If true, this node's scale will be affected by its parent's scale. If false,
            it will not be affected.

</member>
        <member name="M:Ogre.Node.getInheritOrientation">
Returns true if this node is affected by orientation applied to the parent node. 
        @remarks
            Orientations, unlike other transforms, are not always inherited by child nodes.
            Whether or not orientations affect the orientation of the child nodes depends on
            the setInheritOrientation option of the child. In some cases you want a orientating
            of a parent node to apply to a child node (e.g. where the child node is a part of
            the same object, so you want it to be the same relative orientation based on the
            parent's orientation), but not in other cases (e.g. where the child node is just
            for positioning another object, you want it to maintain it's own orientation).
            The default is to inherit as with other transforms.
        @remarks
            See setInheritOrientation for more info.

</member>
        <member name="M:Ogre.Node.setInheritOrientation(System.Boolean)">
Tells the node whether it should inherit orientation from it's parent node.
        @remarks
            Orientations, unlike other transforms, are not always inherited by child nodes.
            Whether or not orientations affect the orientation of the child nodes depends on
            the setInheritOrientation option of the child. In some cases you want a orientating
            of a parent node to apply to a child node (e.g. where the child node is a part of
            the same object, so you want it to be the same relative orientation based on the
            parent's orientation), but not in other cases (e.g. where the child node is just
            for positioning another object, you want it to maintain it's own orientation).
            The default is to inherit as with other transforms.
        @param inherit If true, this node's orientation will be affected by its parent's orientation.
            If false, it will not be affected.

</member>
        <member name="M:Ogre.Node.getScale">
Gets the scaling factor of this node.

</member>
        <member name="M:Ogre.Node.setScale(System.Single,System.Single,System.Single)">
Sets the scaling factor applied to this node.
        @remarks
            Scaling factors, unlike other transforms, are not always inherited by child nodes.
            Whether or not scalings affect the size of the child nodes depends on the setInheritScale
            option of the child. In some cases you want a scaling factor of a parent node to apply to
            a child node (e.g. where the child node is a part of the same object, so you want it to be
            the same relative size based on the parent's size), but not in other cases (e.g. where the
            child node is just for positioning another object, you want it to maintain it's own size).
            The default is to inherit as with other transforms.
        @par
            Note that like rotations, scalings are oriented around the node's origin.

</member>
        <member name="M:Ogre.Node.setScale(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the scaling factor applied to this node.
        @remarks
            Scaling factors, unlike other transforms, are not always inherited by child nodes.
            Whether or not scalings affect the size of the child nodes depends on the setInheritScale
            option of the child. In some cases you want a scaling factor of a parent node to apply to
            a child node (e.g. where the child node is a part of the same object, so you want it to be
            the same relative size based on the parent's size), but not in other cases (e.g. where the
            child node is just for positioning another object, you want it to maintain it's own size).
            The default is to inherit as with other transforms.
        @par
            Note that like rotations, scalings are oriented around the node's origin.

</member>
        <member name="M:Ogre.Node.getPosition">
Gets the position of the node relative to it's parent.

</member>
        <member name="M:Ogre.Node.setPosition(System.Single,System.Single,System.Single)">
Sets the position of the node relative to it's parent.

</member>
        <member name="M:Ogre.Node.setPosition(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the position of the node relative to it's parent.

</member>
        <member name="M:Ogre.Node.resetOrientation">
Resets the nodes orientation (local axes as world axes, no rotation).
        @remarks
            Orientations, unlike other transforms, are not always inherited by child nodes.
            Whether or not orientations affect the orientation of the child nodes depends on
            the setInheritOrientation option of the child. In some cases you want a orientating
            of a parent node to apply to a child node (e.g. where the child node is a part of
            the same object, so you want it to be the same relative orientation based on the
            parent's orientation), but not in other cases (e.g. where the child node is just
            for positioning another object, you want it to maintain it's own orientation).
            The default is to inherit as with other transforms.
        @par
            Note that rotations are oriented around the node's origin.

</member>
        <member name="M:Ogre.Node.setOrientation(System.Single,System.Single,System.Single,System.Single)">
Sets the orientation of this node via quaternion parameters.
        @remarks
            Orientations, unlike other transforms, are not always inherited by child nodes.
            Whether or not orientations affect the orientation of the child nodes depends on
            the setInheritOrientation option of the child. In some cases you want a orientating
            of a parent node to apply to a child node (e.g. where the child node is a part of
            the same object, so you want it to be the same relative orientation based on the
            parent's orientation), but not in other cases (e.g. where the child node is just
            for positioning another object, you want it to maintain it's own orientation).
            The default is to inherit as with other transforms.
        @par
            Note that rotations are oriented around the node's origin.

</member>
        <member name="M:Ogre.Node.setOrientation(Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the orientation of this node via a quaternion.
        @remarks
            Orientations, unlike other transforms, are not always inherited by child nodes.
            Whether or not orientations affect the orientation of the child nodes depends on
            the setInheritOrientation option of the child. In some cases you want a orientating
            of a parent node to apply to a child node (e.g. where the child node is a part of
            the same object, so you want it to be the same relative orientation based on the
            parent's orientation), but not in other cases (e.g. where the child node is just
            for positioning another object, you want it to maintain it's own orientation).
            The default is to inherit as with other transforms.
        @par
            Note that rotations are oriented around the node's origin.

</member>
        <member name="M:Ogre.Node.getOrientation">
Returns a quaternion representing the nodes orientation.

</member>
        <member name="M:Ogre.Node.getParent">
Gets this node's parent (NULL if this is the root).

</member>
        <member name="M:Ogre.Node.getName">
Returns the name of the node. 
</member>
        <member name="M:Ogre.Node.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor, should only be called by parent, not directly.
        @remarks
            Assigned a name.

</member>
        <member name="M:Ogre.Node.#ctor">
Constructor, should only be called by parent, not directly.
        @remarks
            Generates a name.

</member>
        <member name="F:Ogre.Node.mUserObjectBindings">
User objects binding.
</member>
        <member name="F:Ogre.Node.mCachedTransform">
Cached derived transform as a 4x4 matrix
</member>
        <member name="F:Ogre.Node.mInitialScale">
The scale to use as a base for keyframe animation
</member>
        <member name="F:Ogre.Node.mInitialOrientation">
The orientation to use as a base for keyframe animation
</member>
        <member name="F:Ogre.Node.mInitialPosition">
The position to use as a base for keyframe animation
</member>
        <member name="M:Ogre.Node.createChildImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for creating a new child node - must be overridden per subclass. 
</member>
        <member name="M:Ogre.Node.createChildImpl">
Internal method for creating a new child node - must be overridden per subclass. 
</member>
        <member name="M:Ogre.Node.updateFromParentImpl">
Class-specific implementation of _updateFromParent.
		@remarks
			Splitting the implementation of the update away from the update call
			itself allows the detail to be overridden without disrupting the 
			general sequence of updateFromParent (e.g. raising events)

</member>
        <member name="M:Ogre.Node._updateFromParent">
Triggers the node to update it's combined transforms.
            @par
                This method is called internally by Ogre to ask the node
                to update it's complete transformation based on it's parents
                derived transform.

</member>
        <member name="F:Ogre.Node.mDerivedScale">
Cached combined scale.
            @par
                This member is the position derived by combining the
                local transformations and those of it's parents.
                This is updated when _updateFromParent is called by the
                SceneManager or the nodes parent.

</member>
        <member name="F:Ogre.Node.mDerivedPosition">
Cached combined position.
            @par
                This member is the position derived by combining the
                local transformations and those of it's parents.
                This is updated when _updateFromParent is called by the
                SceneManager or the nodes parent.

</member>
        <member name="F:Ogre.Node.mDerivedOrientation">
Cached combined orientation.
            @par
                This member is the orientation derived by combining the
                local transformations and those of it's parents.
                This is updated when _updateFromParent is called by the
                SceneManager or the nodes parent.

</member>
        <member name="M:Ogre.Node.setParent(Ogre.Node*)">
Only available internally - notification of parent.
</member>
        <member name="F:Ogre.Node.mInheritScale">
Stores whether this node inherits scale from it's parent
</member>
        <member name="F:Ogre.Node.mInheritOrientation">
Stores whether this node inherits orientation from it's parent
</member>
        <member name="F:Ogre.Node.mScale">
Stores the scaling factor applied to this node
</member>
        <member name="F:Ogre.Node.mPosition">
Stores the position/translation of the node relative to its parent.
</member>
        <member name="F:Ogre.Node.mOrientation">
Stores the orientation of the node relative to it's parent.
</member>
        <member name="F:Ogre.Node.msNameGenerator">
Incremented count for next name extension
</member>
        <member name="F:Ogre.Node.mName">
Friendly name of this node, can be automatically generated if you don't care
</member>
        <member name="F:Ogre.Node.mQueuedForUpdate">
Flag indicating that the node has been queued for update
</member>
        <member name="F:Ogre.Node.mParentNotified">
Flag indicating that parent has been notified about update request
</member>
        <member name="F:Ogre.Node.mNeedChildUpdate">
Flag indicating that all children need to be updated
</member>
        <member name="F:Ogre.Node.mNeedParentUpdate">
Flag to indicate own transform from parent is out of date
</member>
        <member name="F:Ogre.Node.mChildrenToUpdate">
List of children which need updating, used if self is not out of date but children are
</member>
        <member name="F:Ogre.Node.mChildren">
Collection of pointers to direct children; hashmap for efficiency
</member>
        <member name="F:Ogre.Node.mParent">
Pointer to parent node
</member>
        <member name="T:Ogre.Node.DebugRenderable">
Inner class for displaying debug renderable for Node. 
</member>
        <member name="M:Ogre.Node.Listener.nodeDetached(Ogre.Node!System.Runtime.CompilerServices.IsConst*)">
Node has been detached from a parent 
</member>
        <member name="M:Ogre.Node.Listener.nodeAttached(Ogre.Node!System.Runtime.CompilerServices.IsConst*)">
Node has been attached to a parent 
</member>
        <member name="M:Ogre.Node.Listener.nodeDestroyed(Ogre.Node!System.Runtime.CompilerServices.IsConst*)">
Node is being destroyed 
</member>
        <member name="M:Ogre.Node.Listener.nodeUpdated(Ogre.Node!System.Runtime.CompilerServices.IsConst*)">
Called when a node gets updated.
			@remarks
				Note that this happens when the node's derived update happens,
				not every time a method altering it's state occurs. There may 
				be several state-changing calls but only one of these calls, 
				when the node graph is fully updated.

</member>
        <member name="T:Ogre.Node.Listener">
Listener which gets called back on Node events.

</member>
        <member name="F:TS_WORLD">
Transform is relative to world space

Transform is relative to world space
</member>
        <member name="F:TS_PARENT">
Transform is relative to the space of the parent node

Transform is relative to the space of the parent node
</member>
        <member name="F:TS_LOCAL">
Transform is relative to the local space

Transform is relative to the local space
</member>
        <member name="T:Ogre.Node.TransformSpace">
Enumeration denoting the spaces which a transform can be relative to.

</member>
        <member name="T:Ogre.Node">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Class representing a general-purpose node an articulated scene graph.
        @remarks
            A node in the scene graph is a node in a structured tree. A node contains
            information about the transformation which will apply to
            it and all of it's children. Child nodes can have transforms of their own, which
            are combined with their parent's transformations.
        @par
            This is an abstract class - concrete classes are based on this for specific purposes,
            e.g. SceneNode, Bone

</member>
        <member name="F:Ogre.MeshLodUsage.edgeData">
Edge list for this LOD level (may be derived from manual mesh)
</member>
        <member name="F:Ogre.MeshLodUsage.manualMesh">
Hard link to mesh to avoid looking up each time
</member>
        <member name="F:Ogre.MeshLodUsage.manualGroup">
Only relevant if mIsLodManual is true, the name of the group of the alternative mesh
</member>
        <member name="F:Ogre.MeshLodUsage.manualName">
Only relevant if mIsLodManual is true, the name of the alternative mesh to use
</member>
        <member name="F:Ogre.MeshLodUsage.value">
Value used by to determine when this lod applies.
		@remarks
			May be interpretted differently by different strategies.
            Transformed from user-supplied values with LodStrategy::transformUserValue.

</member>
        <member name="F:Ogre.MeshLodUsage.userValue">
User-supplied values used to determine when th is lod applies.
        @remarks
            This is required in case the lod strategy changes.

</member>
        <member name="M:Ogre.MeshPtr.destroy">
Override destroy since we need to delete Mesh after fully defined
</member>
        <member name="M:Ogre.MeshPtr.op_Assign(Ogre.SharedPtr&lt;Ogre.Resource&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Operator used to convert a ResourcePtr to a MeshPtr
</member>
        <member name="M:Ogre.Mesh.setLodStrategy(Ogre.LodStrategy*)">
Set the lod strategy used by this mesh. 
</member>
        <member name="M:Ogre.Mesh.getLodStrategy">
Get lod strategy used by this mesh. 
</member>
        <member name="M:Ogre.Mesh.getPoseList">
Get pose list 
</member>
        <member name="M:Ogre.Mesh.getPoseIterator">
Get an iterator over all the poses defined. 

Get an iterator over all the poses defined. 
</member>
        <member name="M:Ogre.Mesh.removeAllPoses">
Destroy all poses 
</member>
        <member name="M:Ogre.Mesh.removePose(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroy a pose by name.
		@note This will invalidate any animation tracks referring to this pose or those after it.

</member>
        <member name="M:Ogre.Mesh.removePose(System.UInt16)">
Destroy a pose by index.
		@note This will invalidate any animation tracks referring to this pose or those after it.

</member>
        <member name="M:Ogre.Mesh.getPose(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieve an existing Pose by name.
</member>
        <member name="M:Ogre.Mesh.getPose(System.UInt16)">
Retrieve an existing Pose by index.
</member>
        <member name="M:Ogre.Mesh.getPoseCount">
Get the number of poses.
</member>
        <member name="M:Ogre.Mesh.createPose(System.UInt16,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a new Pose for this mesh or one of its submeshes.
  	    @param target The target geometry index; 0 is the shared Mesh geometry, 1+ is the
			dedicated SubMesh geometry belonging to submesh index + 1.
		@param name Name to give the pose, which is optional
		@returns A new Pose ready for population

</member>
        <member name="M:Ogre.Mesh._getAnimationTypesDirty">
Are the derived animation types out of date? 
</member>
        <member name="M:Ogre.Mesh._determineAnimationTypes">
Internal method which, if animation types have not been determined,
			scans any vertex animations and determines the type for each set of
			vertex data (cannot have 2 different types).

</member>
        <member name="M:Ogre.Mesh.updateMaterialForAllSubMeshes">
Iterates through all submeshes and requests them 
            to apply their texture aliases to the material they use.
        @remarks
            The submesh will only apply texture aliases to the material if matching
            texture alias names are found in the material.  If a match is found, the
            submesh will automatically clone the original material and then apply its
            texture to the new material.
        @par
            This method is normally called by the protected method loadImpl when a 
            mesh if first loaded.

</member>
        <member name="M:Ogre.Mesh.getVertexDataByTrackHandle(System.UInt16)">
Gets a pointer to a vertex data element based on a morph animation 
			track handle.
		@remarks
			0 means the shared vertex data, 1+ means a submesh vertex data (index+1)

</member>
        <member name="M:Ogre.Mesh.removeAllAnimations">
Removes all morph Animations from this mesh. 
</member>
        <member name="M:Ogre.Mesh.getAnimation(System.UInt16)">
Gets a single morph animation by index. 

</member>
        <member name="M:Ogre.Mesh.getNumAnimations">
Gets the number of morph animations in this mesh. 
</member>
        <member name="M:Ogre.Mesh.removeAnimation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Removes vertex Animation from this mesh. 
</member>
        <member name="M:Ogre.Mesh.hasAnimation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether this mesh contains the named vertex animation. 
</member>
        <member name="M:Ogre.Mesh._getAnimationImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal access to the named vertex Animation object - returns null 
			if it does not exist. 
		@param name The name of the animation

</member>
        <member name="M:Ogre.Mesh.getAnimation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the named vertex Animation object. 
		@param name The name of the animation

</member>
        <member name="M:Ogre.Mesh.createAnimation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Creates a new Animation object for vertex animating this mesh. 
        @param name The name of this animation
        @param length The length of the animation in seconds

</member>
        <member name="M:Ogre.Mesh.getSharedVertexDataAnimationType">
Gets the type of vertex animation the shared vertex data of this mesh supports.

</member>
        <member name="M:Ogre.Mesh.getAutoBuildEdgeLists">
Sets whether or not this Mesh should automatically build edge lists
            when asked for them, or whether it should never build them if
            they are not already provided.

</member>
        <member name="M:Ogre.Mesh.setAutoBuildEdgeLists(System.Boolean)">
Sets whether or not this Mesh should automatically build edge lists
            when asked for them, or whether it should never build them if
            they are not already provided.
        @remarks
            This allows you to create meshes which do not have edge lists calculated, 
            because you never want to use them. This value defaults to 'true'
            for mesh formats which did not include edge data, and 'false' for 
            newer formats, where edge lists are expected to have been generated
            in advance.

</member>
        <member name="M:Ogre.Mesh.getSubMeshNameMap">
Gets a reference to the optional name assignments of the SubMeshes. 
</member>
        <member name="M:Ogre.Mesh.softwareVertexPoseBlend(System.Single,std.map&lt;System.UInt32,Ogre.Vector3,std.less&lt;System.UInt32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.VertexData*)">
Performs a software vertex pose blend, of the kind used for
            morph animation although it can be used for other purposes. 
        @remarks
			This function will apply a weighted offset to the positions in the 
			incoming vertex data (therefore this is a read/write operation, and 
			if you expect to call it more than once with the same data, then
			you would be best to suppress hardware uploads of the position buffer
			for the duration)
        @param weight Parametric weight to scale the offsets by
		@param vertexOffsetMap Potentially sparse map of vertex index -&gt; offset
		@param targetVertexData VertexData destination; assumed to have a separate position
			buffer already bound, and the number of vertices must agree with the
			number in start and end

</member>
        <member name="M:Ogre.Mesh.softwareVertexMorph(System.Single,Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.VertexData*)">
Performs a software vertex morph, of the kind used for
            morph animation although it can be used for other purposes. 
        @remarks
			This function will linearly interpolate positions between two
			source buffers, into a third buffer.
        @param t Parametric distance between the start and end buffer positions
        @param b1 Vertex buffer containing VET_FLOAT3 entries for the start positions
		@param b2 Vertex buffer containing VET_FLOAT3 entries for the end positions
		@param targetVertexData VertexData destination; assumed to have a separate position
			buffer already bound, and the number of vertices must agree with the
			number in start and end

</member>
        <member name="M:Ogre.Mesh.softwareVertexBlend(Ogre.VertexData!System.Runtime.CompilerServices.IsConst*,Ogre.VertexData!System.Runtime.CompilerServices.IsConst*,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.Boolean)">
Performs a software indexed vertex blend, of the kind used for
            skeletal animation although it can be used for other purposes. 
        @remarks
        This function is supplied to update vertex data with blends 
        done in software, either because no hardware support is available, 
        or that you need the results of the blend for some other CPU operations.
        @param sourceVertexData VertexData class containing positions, normals,
            blend indices and blend weights.
        @param targetVertexData VertexData class containing target position
            and normal buffers which will be updated with the blended versions.
            Note that the layout of the source and target position / normal 
            buffers must be identical, ie they must use the same buffer indexes
        @param blendMatrices Pointer to an array of matrix pointers to be used to blend,
            indexed by blend indices in the sourceVertexData
        @param numMatrices Number of matrices in the blendMatrices, it might be used
            as a hint for optimisation.
        @param blendNormals If true, normals are blended as well as positions

</member>
        <member name="M:Ogre.Mesh.prepareMatricesForVertexBlend(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst**,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*,std.vector&lt;System.UInt16&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Prepare matrices for software indexed vertex blend.
            @remarks
                This function organise bone indexed matrices to blend indexed matrices,
                so software vertex blending can access to the matrix via blend index
                directly.
            @param blendMatrices Pointer to an array of matrix pointers to store
                prepared results, which indexed by blend index
            @param boneMatrices Pointer to an array of matrices to be used to blend,
                which indexed by bone index
            @param indexMap The index map used to translate blend index to bone index

</member>
        <member name="M:Ogre.Mesh.isEdgeListBuilt">
Returns whether this mesh has an attached edge list. 
</member>
        <member name="M:Ogre.Mesh.isPreparedForShadowVolumes">
Returns whether this mesh has already had it's geometry prepared for use in 
            rendering shadow volumes. 
</member>
        <member name="M:Ogre.Mesh.getEdgeList(System.UInt16)">
Return the edge list for this mesh, building it if required. 
        @remarks
            You must ensure that the Mesh as been prepared for shadow volume 
            rendering if you intend to use this information for that purpose.
        @lodIndex The LOD at which to get the edge list, 0 being the highest.


Return the edge list for this mesh, building it if required. 
        @remarks
            You must ensure that the Mesh as been prepared for shadow volume 
            rendering if you intend to use this information for that purpose.
        @lodIndex The LOD at which to get the edge list, 0 being the highest.

</member>
        <member name="M:Ogre.Mesh.prepareForShadowVolume">
This method prepares the mesh for generating a renderable shadow volume. 
        @remarks
            Preparing a mesh to generate a shadow volume involves firstly ensuring that the 
            vertex buffer containing the positions for the mesh is a standalone vertex buffer,
            with no other components in it. This method will therefore break apart any existing
            vertex buffers this mesh holds if position is sharing a vertex buffer. 
            Secondly, it will double the size of this vertex buffer so that there are 2 copies of 
            the position data for the mesh. The first half is used for the original, and the second 
            half is used for the 'extruded' version of the mesh. The vertex count of the main 
            VertexData used to render the mesh will remain the same though, so as not to add any 
            overhead to regular rendering of the object.
            Both copies of the position are required in one buffer because shadow volumes stretch 
            from the original mesh to the extruded version. 
        @par
            Because shadow volumes are rendered in turn, no additional
            index buffer space is allocated by this method, a shared index buffer allocated by the
            shadow rendering algorithm is used for addressing this extended vertex buffer.

</member>
        <member name="M:Ogre.Mesh.freeEdgeList">
Destroys and frees the edge lists this mesh has built. 
</member>
        <member name="M:Ogre.Mesh.buildEdgeList">
Builds an edge list for this mesh, which can be used for generating a shadow volume
            among other things.

</member>
        <member name="M:Ogre.Mesh.suggestTangentVectorBuildParams(Ogre.VertexElementSemantic,System.UInt16*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Ask the mesh to suggest parameters to a future buildTangentVectors call, 
			should you wish to use texture coordinates to store the tangents. 
        @remarks
            This helper method will suggest source and destination texture coordinate sets
            for a call to buildTangentVectors. It will detect when there are inappropriate
            conditions (such as multiple geometry sets which don't agree). 
            Moreover, it will return 'true' if it detects that there are aleady 3D 
            coordinates in the mesh, and therefore tangents may have been prepared already.
		@param targetSemantic The semantic you intend to use to store the tangents
			if they are not already present;
			most likely options are VES_TEXTURE_COORDINATES or VES_TANGENT; you should
			use texture coordinates if you want compatibility with older, pre-SM2
			graphics cards, and the tangent binding otherwise.
        @param outSourceCoordSet Reference to a source texture coordinate set which 
            will be populated
        @param outIndex Reference to a destination element index (e.g. texture coord set)
			which will be populated

</member>
        <member name="M:Ogre.Mesh.buildTangentVectors(Ogre.VertexElementSemantic,System.UInt16,System.UInt16,System.Boolean,System.Boolean,System.Boolean)">
This method builds a set of tangent vectors for a given mesh into a 3D texture coordinate buffer.
        @remarks
            Tangent vectors are vectors representing the local 'X' axis for a given vertex based
            on the orientation of the 2D texture on the geometry. They are built from a combination
            of existing normals, and from the 2D texture coordinates already baked into the model.
            They can be used for a number of things, but most of all they are useful for 
            vertex and fragment programs, when you wish to arrive at a common space for doing
            per-pixel calculations.
        @par
            The prerequisites for calling this method include that the vertex data used by every
            SubMesh has both vertex normals and 2D texture coordinates.
		@param targetSemantic The semantic to store the tangents in. Defaults to 
			the explicit tangent binding, but note that this is only usable on more
			modern hardware (Shader Model 2), so if you need portability with older
			cards you should change this to a texture coordinate binding instead.
        @param sourceTexCoordSet The texture coordinate index which should be used as the source
            of 2D texture coordinates, with which to calculate the tangents.
        @param index The element index, ie the texture coordinate set which should be used to store the 3D
            coordinates representing a tangent vector per vertex, if targetSemantic is 
			VES_TEXTURE_COORDINATES. If this already exists, it will be overwritten.
		@param splitMirrored Sets whether or not to split vertices when a mirrored tangent space
			transition is detected (matrix parity differs). @see TangentSpaceCalc::setSplitMirrored
		@param splitRotated Sets whether or not to split vertices when a rotated tangent space
			is detected. @see TangentSpaceCalc::setSplitRotated
		@param storeParityInW If true, store tangents as a 4-vector and include parity in w

</member>
        <member name="M:Ogre.Mesh._updateCompiledBoneAssignments">
Internal method, be called once to update the compiled bone assignments.
        @remarks
            The OGRE engine calls this method automatically. It updates the compiled bone
            assignments if requested.

</member>
        <member name="M:Ogre.Mesh._compileBoneAssignments">
Internal method, be called once to compile bone assignments into geometry buffer. 
        @remarks
            The OGRE engine calls this method automatically. It compiles the information 
            submitted as bone assignments into a format usable in realtime. It also 
            eliminates excessive bone assignments (max is OGRE_MAX_BLEND_WEIGHTS)
            and re-normalises the remaining assignments.

</member>
        <member name="M:Ogre.Mesh._rationaliseBoneAssignments(System.UInt32,std.multimap&lt;System.UInt32,Ogre.VertexBoneAssignment_s,std.less&lt;System.UInt32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Rationalises the passed in bone assignment list.
        @remarks
            OGRE supports up to 4 bone assignments per vertex. The reason for this limit
            is that this is the maximum number of assignments that can be passed into
            a hardware-assisted blending algorithm. This method identifies where there are
            more than 4 bone assignments for a given vertex, and eliminates the bone
            assignments with the lowest weights to reduce to this limit. The remaining
            weights are then re-balanced to ensure that they sum to 1.0.
        @param vertexCount The number of vertices.
        @param assignments The bone assignment list to rationalise. This list will be modified and
            entries will be removed where the limits are exceeded.
        @returns The maximum number of bone assignments per vertex found, clamped to [1-4]

</member>
        <member name="M:Ogre.Mesh.isIndexBufferShadowed">
Gets whether or not this meshes index buffers are shadowed. 
</member>
        <member name="M:Ogre.Mesh.isVertexBufferShadowed">
Gets whether or not this meshes vertex buffers are shadowed. 
</member>
        <member name="M:Ogre.Mesh.getIndexBufferUsage">
Gets the usage setting for this meshes index buffers. 
</member>
        <member name="M:Ogre.Mesh.getVertexBufferUsage">
Gets the usage setting for this meshes vertex buffers. 
</member>
        <member name="M:Ogre.Mesh.setIndexBufferPolicy(Ogre.HardwareBuffer.Usage,System.Boolean)">
Sets the policy for the index buffers to be used when loading
			this Mesh.
		@remarks
			By default, when loading the Mesh, static, write-only vertex and index buffers 
			will be used where possible in order to improve rendering performance. 
			However, such buffers
			cannot be manipulated on the fly by CPU code (although shader code can). If you
			wish to use the CPU to modify these buffers, you should call this method. Note,
			however, that it only takes effect after the Mesh has been reloaded. Note that you
			still have the option of manually repacing the buffers in this mesh with your
			own if you see fit too, in which case you don't need to call this method since it
			only affects buffers created by the mesh itself.
		@par
			You can define the approach to a Mesh by changing the default parameters to 
			MeshManager::load if you wish; this means the Mesh is loaded with those options
			the first time instead of you having to reload the mesh after changing these options.
		@param usage The usage flags, which by default are 
			HardwareBuffer::HBU_STATIC_WRITE_ONLY
		@param shadowBuffer If set to true, the index buffers will be created with a
            system memory shadow buffer. You should set this if you want to be able to
			read from the buffer, because reading from a hardware buffer is a no-no.

</member>
        <member name="M:Ogre.Mesh.setVertexBufferPolicy(Ogre.HardwareBuffer.Usage,System.Boolean)">
Sets the policy for the vertex buffers to be used when loading
			this Mesh.
		@remarks
			By default, when loading the Mesh, static, write-only vertex and index buffers 
			will be used where possible in order to improve rendering performance. 
			However, such buffers
			cannot be manipulated on the fly by CPU code (although shader code can). If you
			wish to use the CPU to modify these buffers, you should call this method. Note,
			however, that it only takes effect after the Mesh has been reloaded. Note that you
			still have the option of manually repacing the buffers in this mesh with your
			own if you see fit too, in which case you don't need to call this method since it
			only affects buffers created by the mesh itself.
		@par
			You can define the approach to a Mesh by changing the default parameters to 
			MeshManager::load if you wish; this means the Mesh is loaded with those options
			the first time instead of you having to reload the mesh after changing these options.
		@param usage The usage flags, which by default are 
			HardwareBuffer::HBU_STATIC_WRITE_ONLY
		@param shadowBuffer If set to true, the vertex buffers will be created with a
            system memory shadow buffer. You should set this if you want to be able to
			read from the buffer, because reading from a hardware buffer is a no-no.

</member>
        <member name="M:Ogre.Mesh.removeLodLevels">
Removes all LOD data from this Mesh. 
</member>
        <member name="M:Ogre.Mesh._setSubMeshLodFaceList(System.UInt16,System.UInt16,Ogre.IndexData*)">
Internal methods for loading LOD, do not use. 
</member>
        <member name="M:Ogre.Mesh._setLodUsage(System.UInt16,Ogre.MeshLodUsage*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal methods for loading LOD, do not use. 
</member>
        <member name="M:Ogre.Mesh._setLodInfo(System.UInt16,System.Boolean)">
Internal methods for loading LOD, do not use. 
</member>
        <member name="M:Ogre.Mesh.isLodManual">
Returns true if this mesh is using manual LOD.
		@remarks
			A mesh can either use automatically generated LOD, or it can use alternative
			meshes as provided by an artist. A mesh can only use either all manual LODs 
			or all generated LODs, not a mixture of both.

</member>
        <member name="M:Ogre.Mesh.getLodIndex(System.Single)">
Retrieves the level of detail index for the given lod value. 
		@note The value passed in is the 'transformed' value. If you are dealing with
		an original source value (e.g. distance), use LodStrategy::transformUserValue
		to turn this into a lookup value.

</member>
        <member name="M:Ogre.Mesh.updateManualLodLevel(System.UInt16,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Changes the alternate mesh to use as a manual LOD at the given index.
		@remarks
			Note that the index of a LOD may change if you insert other LODs. If in doubt,
			use getLodIndex().
		@param index The index of the level to be changed
		@param meshName The name of the mesh which will be the lower level detail version.

</member>
        <member name="M:Ogre.Mesh.createManualLodLevel(System.Single,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds a new manual level-of-detail entry to this Mesh.
		@remarks
			As an alternative to generating lower level of detail versions of a mesh, you can
			use your own manually modelled meshes as lower level versions. This lets you 
			have complete control over the LOD, and in addition lets you scale down other
			aspects of the model which cannot be done using the generated method; for example, 
			you could use less detailed materials and / or use less bones in the skeleton if
			this is an animated mesh. Therefore for complex models you are likely to be better off
			modelling your LODs yourself and using this method, whilst for models with fairly
			simple materials and no animation you can just use the generateLodLevels method.
		@param value The value from which this Lod will apply.
		@param meshName The name of the mesh which will be the lower level detail version.

</member>
        <member name="M:Ogre.Mesh.getLodLevel(System.UInt16)">
Gets details of the numbered level of detail entry. 
</member>
        <member name="M:Ogre.Mesh.getNumLodLevels">
Returns the number of levels of detail that this mesh supports. 
		@remarks
			This number includes the original model.

</member>
        <member name="M:Ogre.Mesh.generateLodLevels(std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ProgressiveMesh.VertexReductionQuota,System.Single)">
Automatically generates lower level of detail versions of this mesh for use
			when a simpler version of the model is acceptable for rendering.
		@remarks
			There are 2 ways that you can create level-of-detail (LOD) versions of a mesh;
			the first is to call this method, which does fairly extensive calculations to
			work out how to simplify the mesh whilst having the minimum affect on the model.
			The alternative is to actually create simpler versions of the mesh yourself in 
			a modelling tool, and having exported them, tell the 'master' mesh to use these
			alternative meshes for lower detail versions; this is done by calling the 
			createManualLodLevel method.
		@par
			As well as creating the lower detail versions of the mesh, this method will
			also associate them with depth values. As soon as an object is at least as far
			away from the camera as the depth value associated with it's LOD, it will drop 
			to that level of detail. 
		@par
			I recommend calling this method before mesh export, not at runtime.
		@param lodValues A list of lod values indicating the values at which new lods should be
		generated. These are 'user values', before being potentially 
		transformed by the strategy, so for the distance strategy this is an
		unsquared distance for example.
		@param reductionMethod The way to determine the number of vertices collapsed per LOD
		@param reductionValue Meaning depends on reductionMethod, typically either the proportion
			of remaining vertices to collapse or a fixed number of vertices.

</member>
        <member name="M:Ogre.Mesh.getBoneAssignments">
Gets a const reference to the list of bone assignments

</member>
        <member name="M:Ogre.Mesh.getBoneAssignmentIterator">
Gets an iterator for access all bone assignments. 

</member>
        <member name="M:Ogre.Mesh._notifySkeleton(Ogre.SkeletonPtr*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal notification, used to tell the Mesh which Skeleton to use without loading it. 
        @remarks
            This is only here for unusual situation where you want to manually set up a
            Skeleton. Best to let OGRE deal with this, don't call it yourself unless you
            really know what you're doing.

</member>
        <member name="M:Ogre.Mesh.clearBoneAssignments">
Removes all bone assignments for this mesh. 
        @remarks
            This method is for modifying weights to the shared geometry of the Mesh. To assign
            weights to the per-SubMesh geometry, see the equivalent methods on SubMesh.

</member>
        <member name="M:Ogre.Mesh.addBoneAssignment(Ogre.VertexBoneAssignment_s!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assigns a vertex to a bone with a given weight, for skeletal animation. 
        @remarks    
            This method is only valid after calling setSkeletonName.
            Since this is a one-off process there exists only 'addBoneAssignment' and
            'clearBoneAssignments' methods, no 'editBoneAssignment'. You should not need
            to modify bone assignments during rendering (only the positions of bones) and OGRE
            reserves the right to do some internal data reformatting of this information, depending
            on render system requirements.
        @par
            This method is for assigning weights to the shared geometry of the Mesh. To assign
            weights to the per-SubMesh geometry, see the equivalent methods on SubMesh.

</member>
        <member name="M:Ogre.Mesh._refreshAnimationState(Ogre.AnimationStateSet*)">
Refresh an animation set suitable for use with this mesh. 
		@remarks
		Only recommended for use inside the engine, not by applications.

</member>
        <member name="M:Ogre.Mesh._initAnimationState(Ogre.AnimationStateSet*)">
Initialise an animation set suitable for use with this mesh. 
        @remarks
            Only recommended for use inside the engine, not by applications.

</member>
        <member name="M:Ogre.Mesh.getSkeletonName">
Gets the name of any linked Skeleton 
</member>
        <member name="M:Ogre.Mesh.getSkeleton">
Gets a pointer to any linked Skeleton. 
        @returns Weak reference to the skeleton - copy this if you want to hold a strong pointer.

</member>
        <member name="M:Ogre.Mesh.hasVertexAnimation">
Returns whether or not this mesh has some kind of vertex animation. 

</member>
        <member name="M:Ogre.Mesh.hasSkeleton">
Returns true if this Mesh has a linked Skeleton. 
</member>
        <member name="M:Ogre.Mesh.setSkeletonName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the name of the skeleton this Mesh uses for animation.
        @remarks
            Meshes can optionally be assigned a skeleton which can be used to animate
            the mesh through bone assignments. The default is for the Mesh to use no
            skeleton. Calling this method with a valid skeleton filename will cause the
            skeleton to be loaded if it is not already (a single skeleton can be shared
            by many Mesh objects).
        @param skelName The name of the .skeleton file to use, or an empty string to use
            no skeleton

</member>
        <member name="M:Ogre.Mesh._setBoundingSphereRadius(System.Single)">
Manually set the bounding radius. 
        @remarks
            Calling this method is required when building manual meshes now, because OGRE can no longer 
            update the bounds for you, because it cannot necessarily read vertex data back from 
            the vertex buffers which this mesh uses (they very well might be write-only, and even
            if they are not, reading data from a hardware buffer is a bottleneck).

</member>
        <member name="M:Ogre.Mesh._setBounds(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Manually set the bounding box for this Mesh.
            @remarks
            Calling this method is required when building manual meshes now, because OGRE can no longer 
            update the bounds for you, because it cannot necessarily read vertex data back from 
            the vertex buffers which this mesh uses (they very well might be write-only, and even
            if they are not, reading data from a hardware buffer is a bottleneck).
            @param pad If true, a certain padding will be added to the bounding box to separate it from the mesh

</member>
        <member name="M:Ogre.Mesh.getBoundingSphereRadius">
Gets the radius of the bounding sphere surrounding this mesh. 
</member>
        <member name="M:Ogre.Mesh.getBounds">
Get the axis-aligned bounding box for this mesh.

</member>
        <member name="M:Ogre.Mesh.clone(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Makes a copy of this mesh object and gives it a new name.
            @remarks
                This is useful if you want to tweak an existing mesh without affecting the original one. The
                newly cloned mesh is registered with the MeshManager under the new name.
            @param newName The name to give the clone
            @param newGroup Optional name of the new group to assign the clone to;
                if you leave this blank, the clone will be assigned to the same
                group as this Mesh.

</member>
        <member name="F:Ogre.Mesh.sharedBlendIndexToBoneIndexMap">
Shared index map for translating blend index to bone index.
            @remarks
                This index map can be shared among multiple submeshes. SubMeshes might not have
                their own IndexMap, they might share this one.
            @par
                We collect actually used bones of all bone assignments, and build the
                blend index in 'packed' form, then the range of the blend index in vertex
                data VES_BLEND_INDICES element is continuous, with no gaps. Thus, by
                minimising the world matrix array constants passing to GPU, we can support
                more bones for a mesh when hardware skinning is used. The hardware skinning
                support limit is applied to each set of vertex data in the mesh, in other words, the
                hardware skinning support limit is applied only to the actually used bones of each
                SubMeshes, not all bones across the entire Mesh.
            @par
                Because the blend index is different to the bone index, therefore, we use
                the index map to translate the blend index to bone index.
            @par
                The use of shared or non-shared index map is determined when
                model data is converted to the OGRE .mesh format.

</member>
        <member name="F:Ogre.Mesh.sharedVertexData">
Shared vertex data.
            @remarks
                This vertex data can be shared among multiple submeshes. SubMeshes may not have
                their own VertexData, they may share this one.
            @par
                The use of shared or non-shared buffers is determined when
                model data is converted to the OGRE .mesh format.

</member>
        <member name="M:Ogre.Mesh.getSubMeshIterator">
Gets an iterator over the available submeshes
</member>
        <member name="M:Ogre.Mesh.destroySubMesh(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroy a SubMesh with the given name. 
		 @note This will invalidate the contents of any existing Entity, or
		 any other object that is referring to the SubMesh list. Entity will
		 detect this and reinitialise, but it is still a disruptive action.

</member>
        <member name="M:Ogre.Mesh.destroySubMesh(System.UInt16)">
Destroy a SubMesh with the given index. 
		 @note This will invalidate the contents of any existing Entity, or
		 any other object that is referring to the SubMesh list. Entity will
		 detect this and reinitialise, but it is still a disruptive action.

</member>
        <member name="M:Ogre.Mesh.getSubMesh(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets a SubMesh by name

</member>
        <member name="M:Ogre.Mesh.getSubMesh(System.UInt16)">
Gets a pointer to the submesh indicated by the index.

</member>
        <member name="M:Ogre.Mesh.getNumSubMeshes">
Gets the number of sub meshes which comprise this mesh.

</member>
        <member name="M:Ogre.Mesh._getSubMeshIndex(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the index of a submesh with a given name.
        @remarks
            Useful if you identify the SubMeshes by name (using nameSubMesh)
            but wish to have faster repeat access.

</member>
        <member name="M:Ogre.Mesh.unnameSubMesh(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Removes a name from a SubMesh

</member>
        <member name="M:Ogre.Mesh.nameSubMesh(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16)">
Gives a name to a SubMesh

</member>
        <member name="M:Ogre.Mesh.createSubMesh(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a new SubMesh and gives it a name

</member>
        <member name="M:Ogre.Mesh.createSubMesh">
Creates a new SubMesh.
            @remarks
                Method for manually creating geometry for the mesh.
                Note - use with extreme caution - you must be sure that
                you have set up the geometry properly.

</member>
        <member name="M:Ogre.Mesh.#ctor(Ogre.ResourceManager*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.Manua">
Default constructor - used by MeshManager
            @warning
                Do not call this method directly.

</member>
        <member name="M:Ogre.Mesh.calculateSize">
@copydoc Resource::calculateSize
</member>
        <member name="M:Ogre.Mesh.unloadImpl">
@copydoc Resource::unloadImpl
</member>
        <member name="M:Ogre.Mesh.postLoadImpl">
@copydoc Resource::postLoadImpl
</member>
        <member name="M:Ogre.Mesh.loadImpl">
@copydoc Resource::loadImpl
</member>
        <member name="M:Ogre.Mesh.unprepareImpl">
Destroys data cached by prepareImpl.

</member>
        <member name="M:Ogre.Mesh.prepareImpl">
Loads the mesh from disk.  This call only performs IO, it
            does not parse the bytestream or check for any errors therein.
            It also does not set up submeshes, etc.  You have to call load()
            to do that.

</member>
        <member name="F:Ogre.Mesh.mPoseList">
List of available poses for shared and dedicated geometryPoseList
</member>
        <member name="F:Ogre.Mesh.mAnimationTypesDirty">
Do we need to scan animations for animation types?
</member>
        <member name="F:Ogre.Mesh.mSharedVertexDataAnimationType">
The vertex animation type associated with the shared vertex data
</member>
        <member name="D:Ogre.Mesh.AnimationList">
Storage of morph animations, lookup by name
</member>
        <member name="M:Ogre.Mesh.compileBoneAssignments(std.multimap&lt;System.UInt32,Ogre.VertexBoneAssignment_s,std.less&lt;System.UInt32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16,std.vector&lt;System.UInt16&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.VertexData*)">
Compile bone assignments into blend index and weight buffers. 
</member>
        <member name="M:Ogre.Mesh.buildIndexMap(std.multimap&lt;System.UInt32,Ogre.VertexBoneAssignment_s,std.less&lt;System.UInt32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.UInt16&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.UInt16&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Build the index map between bone index and blend index 
</member>
        <member name="F:Ogre.Mesh.mBoneAssignmentsOutOfDate">
Flag indicating that bone assignments need to be recompiled
</member>
        <member name="F:Ogre.Mesh.mSkeletonName">
Optional linked skeleton
</member>
        <member name="F:Ogre.Mesh.mBoundRadius">
Local bounding sphere radius (centered on object)
</member>
        <member name="F:Ogre.Mesh.mAABB">
Local bounding box volume
</member>
        <member name="D:Ogre.Mesh.SubMeshNameMap">
A hashmap used to store optional SubMesh names.
			Translates a name into SubMesh index

</member>
        <member name="M:Ogre.Mesh.organiseTangentsBuffer(Ogre.VertexData*,Ogre.VertexElementSemantic,System.UInt16,System.UInt16)">
Internal method for making the space for a vertex element to hold tangents. 
</member>
        <member name="F:Ogre.Mesh.mSubMeshList">
A list of submeshes which make up this mesh.
            Each mesh is made up of 1 or more submeshes, which
            are each based on a single material and can have their
            own vertex data (they may not - they can share vertex data
            from the Mesh, depending on preference).

</member>
        <member name="D:Ogre.Mesh.VertexBoneAssignmentList">
Multimap of vertex bone assignments (orders by vertex index)
</member>
        <member name="T:Ogre.MeshLodUsage">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

Resource holding data about 3D mesh.
        @remarks
            This class holds the data used to represent a discrete
            3-dimensional object. Mesh data usually contains more
            than just vertices and triangle information; it also
            includes references to materials (and the faces which use them),
            level-of-detail reduction information, convex hull definition,
            skeleton/bones information, keyframe animation etc.
            However, it is important to note the emphasis on the word
            'discrete' here. This class does not cover the large-scale
            sprawling geometry found in level / landscape data.
        @par
            Multiple world objects can (indeed should) be created from a
            single mesh object - see the Entity class for more info.
            The mesh object will have it's own default
            material properties, but potentially each world instance may
            wish to customise the materials from the original. When the object
            is instantiated into a scene node, the mesh material properties
            will be taken by default but may be changed. These properties
            are actually held at the SubMesh level since a single mesh may
            have parts with different materials.
        @par
            As described above, because the mesh may have sections of differing
            material properties, a mesh is inherently a compound construct,
            consisting of one or more SubMesh objects.
            However, it strongly 'owns' it's SubMeshes such that they
            are loaded / unloaded at the same time. This is contrary to
            the approach taken to hierarchically related (but loosely owned)
            scene nodes, where data is loaded / unloaded separately. Note
            also that mesh sub-sections (when used in an instantiated object)
            share the same scene node as the parent.


A way of recording the way each LODs is recorded this Mesh. 
</member>
        <member name="T:Ogre.LinkedSkeletonAnimationSource">
Link to another skeleton to share animations
</member>
        <member name="M:Ogre.SkeletonPtr.op_Assign(Ogre.SharedPtr&lt;Ogre.Resource&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Operator used to convert a ResourcePtr to a SkeletonPtr
</member>
        <member name="M:Ogre.Skeleton.calculateSize">
@copydoc Resource::calculateSize
</member>
        <member name="M:Ogre.Skeleton.unloadImpl">
@copydoc Resource::unloadImpl

</member>
        <member name="M:Ogre.Skeleton.loadImpl">
@copydoc Resource::loadImpl

</member>
        <member name="M:Ogre.Skeleton._dumpContents(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Debugging method
</member>
        <member name="M:Ogre.Skeleton.deriveRootBone">
Internal method which parses the bones to derive the root bone. 
        @remarks
            Must be const because called in getRootBone but mRootBone is mutable
            since lazy-updated.

</member>
        <member name="F:Ogre.Skeleton.mLinkedSkeletonAnimSourceList">
List of references to other skeletons to use animations from 
</member>
        <member name="D:Ogre.Skeleton.AnimationList">
Storage of animations, lookup by name
</member>
        <member name="F:Ogre.Skeleton.mManualBonesDirty">
Manual bones dirty?
</member>
        <member name="F:Ogre.Skeleton.mManualBones">
Manual bones
</member>
        <member name="F:Ogre.Skeleton.mNextAutoHandle">
Bone automatic handles
</member>
        <member name="F:Ogre.Skeleton.mRootBones">
Pointer to root bones (can now have multiple roots)
</member>
        <member name="D:Ogre.Skeleton.BoneListByName">
Lookup by bone name
</member>
        <member name="F:Ogre.Skeleton.mBoneList">
Storage of bones, indexed by bone handle
</member>
        <member name="M:Ogre.Skeleton._buildMapBoneByName(Ogre.Skeleton!System.Runtime.CompilerServices.IsConst*,std.vector&lt;System.UInt16&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Build the bone handle map to use with Skeleton::_mergeSkeletonAnimations.
        @remarks
            Identically bones are determine by name.

</member>
        <member name="M:Ogre.Skeleton._buildMapBoneByHandle(Ogre.Skeleton!System.Runtime.CompilerServices.IsConst*,std.vector&lt;System.UInt16&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Build the bone handle map to use with Skeleton::_mergeSkeletonAnimations.
        @remarks
            Identically bones are determine by handle.

</member>
        <member name="M:Ogre.Skeleton._mergeSkeletonAnimations(Ogre.Skeleton!System.Runtime.CompilerServices.IsConst*,std.vector&lt;System.UInt16&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Merge animations from another Skeleton object into this skeleton.
        @remarks
            This function allow merge two structures compatible skeletons. The
            'compatible' here means identically bones will have same hierarchy,
            but skeletons are not necessary to have same number of bones (if
            number bones of source skeleton's more than this skeleton, they will
            copied as is, except that duplicate names are unallowed; and in the
            case of bones missing in source skeleton, nothing happen for those
            bones).
        @par
            There are also unnecessary to have same binding poses, this function
            will adjust keyframes of the source skeleton to match this skeleton
            automatically.
        @par
            It's useful for export skeleton animations seperately. i.e. export
            mesh and 'master' skeleton at the same time, and then other animations
            will export seperately (even if used completely difference binding
            pose), finally, merge seperately exported animations into 'master'
            skeleton.
        @param
            source Pointer to source skeleton. It'll keep unmodified.
        @param
            boneHandleMap A map to translate identically bone's handle from source
            skeleton to this skeleton. If mapped bone handle doesn't exists in this
            skeleton, it'll created. You can populate bone handle map manually, or
            use predefined functions build bone handle map for you. (@see 
            _buildMapBoneByHandle, _buildMapBoneByName)
        @param
            animations A list name of animations to merge, if empty, all animations
            of source skeleton are used to merge. Note that the animation names
            must not presented in this skeleton, and will NOT pick up animations
            in linked skeletons (@see addLinkedSkeletonAnimationSource).

</member>
        <member name="D:Ogre.Skeleton.BoneHandleMap">
Map to translate bone handle from one skeleton to another skeleton.
</member>
        <member name="M:Ogre.Skeleton.hasManualBones">
Are there any manually controlled bones?
</member>
        <member name="M:Ogre.Skeleton.getManualBonesDirty">
Have manual bones been modified since the skeleton was last updated?
</member>
        <member name="M:Ogre.Skeleton._notifyManualBoneStateChange(Ogre.Bone*)">
Internal method for notifying that a bone is manual
</member>
        <member name="M:Ogre.Skeleton._notifyManualBonesDirty">
Internal method for marking the manual bones as dirty
</member>
        <member name="M:Ogre.Skeleton.getLinkedSkeletonAnimationSourceIterator">
Get an iterator over the linked skeletons used as animation sources
</member>
        <member name="M:Ogre.Skeleton.removeAllLinkedSkeletonAnimationSources">
Remove all links to other skeletons for the purposes of sharing animation
</member>
        <member name="M:Ogre.Skeleton.addLinkedSkeletonAnimationSource(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Allows you to use the animations from another Skeleton object to animate
			this skeleton.
		@remarks
			If you have skeletons of identical structure (that means identically
			named bones with identical handles, and with the same hierarchy), but
			slightly different proportions or binding poses, you can re-use animations
			from one in the other. Because animations are actually stored as
			changes to bones from their bind positions, it's possible to use the
			same animation data for different skeletons, provided the skeletal
			structure matches and the 'deltas' stored in the keyframes apply
			equally well to the other skeletons bind position (so they must be
			roughly similar, but don't have to be identical). You can use the 
			'scale' option to adjust the translation and scale keyframes where
			there are large differences in size between the skeletons.
		@note
			This method takes a skeleton name, rather than a more specific 
			animation name, for two reasons; firstly it allows some validation 
			of compatibility of skeletal structure, and secondly skeletons are
			the unit of loading. Linking a skeleton to another in this way means
			that the linkee will be prevented from being destroyed until the 
			linker is destroyed.

			You cannot set up cyclic relationships, e.g. SkeletonA uses SkeletonB's
			animations, and SkeletonB uses SkeletonA's animations. This is because
			it would set up a circular dependency which would prevent proper 
			unloading - make one of the skeletons the 'master' in this case.
		@param skelName Name of the skeleton to link animations from. This 
			skeleton will be loaded immediately if this skeleton is already 
			loaded, otherwise it will be loaded when this skeleton is.
		@param scale A scale factor to apply to translation and scaling elements
			of the keyframes in the other skeleton when applying the animations
			to this one. Compensates for skeleton size differences.

</member>
        <member name="M:Ogre.Skeleton.optimiseAllAnimations(System.Boolean)">
Optimise all of this skeleton's animations.
		@see Animation::optimise
        @param
            preservingIdentityNodeTracks If true, don't destroy identity node tracks.

</member>
        <member name="M:Ogre.Skeleton._updateTransforms">
Updates all the derived transforms in the skeleton
</member>
        <member name="M:Ogre.Skeleton.setBlendMode(Ogre.SkeletonAnimationBlendMode)">
Sets the animation blending mode this skeleton will use. 
</member>
        <member name="M:Ogre.Skeleton.getBlendMode">
Gets the animation blending mode which this skeleton will use. 
</member>
        <member name="M:Ogre.Skeleton.getAnimation(System.UInt16)">
Gets a single animation by index. 
		@remarks
			Will NOT pick up animations in linked skeletons 
			(@see addLinkedSkeletonAnimationSource).

</member>
        <member name="M:Ogre.Skeleton.getNumAnimations">
Gets the number of animations on this skeleton. 
</member>
        <member name="M:Ogre.Skeleton._getBoneMatrices(Ogre.Matrix4*)">
Populates the passed in array with the bone matrices based on the current position.
        @remarks
            Internal use only. The array pointed to by the passed in pointer must
            be at least as large as the number of bones.
            Assumes animation has already been updated.

</member>
        <member name="M:Ogre.Skeleton._refreshAnimationState(Ogre.AnimationStateSet*)">
Refresh an animation set suitable for use with this skeleton. 
		@remarks
			Only recommended for use inside the engine, not by applications.

</member>
        <member name="M:Ogre.Skeleton._initAnimationState(Ogre.AnimationStateSet*)">
Initialise an animation set suitable for use with this skeleton. 
        @remarks
            Only recommended for use inside the engine, not by applications.

</member>
        <member name="M:Ogre.Skeleton.setAnimationState(Ogre.AnimationStateSet!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Changes the state of the skeleton to reflect the application of the passed in collection of animations.
        @remarks
            Animating a skeleton involves both interpolating between keyframes of a specific animation,
            and blending between the animations themselves. Calling this method sets the state of
            the skeleton so that it reflects the combination of all the passed in animations, at the
            time index specified for each, using the weights specified. Note that the weights between 
            animations do not have to sum to 1.0, because some animations may affect only subsets
            of the skeleton. If the weights exceed 1.0 for the same area of the skeleton, the 
            movement will just be exaggerated.
            @param 

</member>
        <member name="M:Ogre.Skeleton.removeAnimation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Removes an Animation from this skeleton. 
</member>
        <member name="M:Ogre.Skeleton.hasAnimation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether this skeleton contains the named animation. 
</member>
        <member name="M:Ogre.Skeleton._getAnimationImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.LinkedSkeletonAnimationSource!System.Runtime.CompilerServices.IsConst**)">
Internal accessor for animations (returns null if animation does not exist)
</member>
        <member name="M:Ogre.Skeleton.getAnimation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.LinkedSkeletonAnimationSource!System.Runtime.CompilerServices.IsConst**)">
Returns the named Animation object. 
		@remarks
			Will pick up animations in linked skeletons 
			(@see addLinkedSkeletonAnimationSource). 
		@param name The name of the animation
		@param linker Optional pointer to a pointer to the linked skeleton animation
			where this is coming from.

</member>
        <member name="M:Ogre.Skeleton.createAnimation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Creates a new Animation object for animating this skeleton. 
        @param name The name of this animation
        @param length The length of the animation in seconds

</member>
        <member name="M:Ogre.Skeleton.reset(System.Boolean)">
Resets the position and orientation of all bones in this skeleton to their original binding position.
        @remarks
            A skeleton is bound to a mesh in a binding pose. Bone positions are then modified from this
            position during animation. This method returns all the bones to their original position and
            orientation.
        @param resetManualBones If set to true, causes the state of manual bones to be reset
            too, which is normally not done to allow the manual state to persist even 
            when keyframe animation is applied.

</member>
        <member name="M:Ogre.Skeleton.setBindingPose">
Sets the current position / orientation to be the 'binding pose' i.e. the layout in which 
            bones were originally bound to a mesh.

</member>
        <member name="M:Ogre.Skeleton.hasBone(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether this skeleton contains the named bone. 
</member>
        <member name="M:Ogre.Skeleton.getBone(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets a bone by it's name. 
</member>
        <member name="M:Ogre.Skeleton.getBone(System.UInt16)">
Gets a bone by it's handle. 
</member>
        <member name="M:Ogre.Skeleton.getBoneIterator">
Get an iterator over all the bones in the skeleton
</member>
        <member name="M:Ogre.Skeleton.getRootBoneIterator">
Get an iterator over the root bones in the skeleton, ie those with no parents
</member>
        <member name="M:Ogre.Skeleton.getRootBone">
Gets the root bone of the skeleton: deprecated in favour of getRootBoneIterator. 
        @remarks
            The system derives the root bone the first time you ask for it. The root bone is the
            only bone in the skeleton which has no parent. The system locates it by taking the
            first bone in the list and going up the bone tree until there are no more parents,
            and saves this top bone as the root. If you are building the skeleton manually using
            createBone then you must ensure there is only one bone which is not a child of 
            another bone, otherwise your skeleton will not work properly. If you use createBone
            only once, and then use Bone::createChild from then on, then inherently the first
            bone you create will by default be the root.

</member>
        <member name="M:Ogre.Skeleton.getNumBones">
Returns the number of bones in this skeleton. 
</member>
        <member name="M:Ogre.Skeleton.createBone(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16)">
Creates a brand new Bone owned by this Skeleton. 
        @remarks
            This method creates an unattached new Bone for this skeleton and assigns it a 
            specific name and handle. Unless this is to be a root bone (there may be more than one of 
			these), you must attach it to another Bone in the skeleton using addChild for it to be any use.
            For this reason you will likely be better off creating child bones using the
            Bone::createChild method instead, once you have created the root bone. 
        @param name The name to give to this new bone - must be unique within this skeleton. 
        @param handle The handle to give to this new bone - must be unique within this skeleton. 

</member>
        <member name="M:Ogre.Skeleton.createBone(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a brand new Bone owned by this Skeleton. 
        @remarks
            This method creates an unattached new Bone for this skeleton and assigns it a 
            specific name.Unless this is to be a root bone (there may be more than one of 
			these), you must attach it to another Bone in the skeleton using addChild for it to be any use.
            For this reason you will likely be better off creating child bones using the
            Bone::createChild method instead, once you have created the root bone. 
        @param name The name to give to this new bone - must be unique within this skeleton. 
            Note that the way OGRE looks up bones is via a numeric handle, so if you name a
            Bone this way it will be given an automatic sequential handle. The name is just
            for your convenience, although it is recommended that you only use the handle to 
            retrieve the bone in performance-critical code.

</member>
        <member name="M:Ogre.Skeleton.createBone(System.UInt16)">
Creates a brand new Bone owned by this Skeleton. 
        @remarks
            This method creates an unattached new Bone for this skeleton and assigns it a 
            specific handle. Unless this is to be a root bone (there may be more than one of 
			these), you must attach it to another Bone in the skeleton using addChild for it to be any use. 
            For this reason you will likely be better off creating child bones using the
            Bone::createChild method instead, once you have created a root bone. 
        @param handle The handle to give to this new bone - must be unique within this skeleton. 
            You should also ensure that all bone handles are eventually contiguous (this is to simplify
            their compilation into an indexed array of transformation matrices). For this reason
            it is advised that you use the simpler createBone method which automatically assigns a
            sequential handle starting from 0.

</member>
        <member name="M:Ogre.Skeleton.createBone">
Creates a brand new Bone owned by this Skeleton. 
        @remarks
            This method creates an unattached new Bone for this skeleton.
			Unless this is to be a root bone (there may be more than one of 
			these), you must attach it to another Bone in the skeleton using addChild for it to be any use.
            For this reason you will likely be better off creating child bones using the
            Bone::createChild method instead, once you have created the root bone. 
        @par
            Note that this method automatically generates a handle for the bone, which you
            can retrieve using Bone::getHandle. If you wish the new Bone to have a specific
            handle, use the alternate form of this method which takes a handle as a parameter,
            although you should note the restrictions.

</member>
        <member name="M:Ogre.Skeleton.#ctor(Ogre.ResourceManager*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.M">
Constructor, don't call directly, use SkeletonManager.
        @remarks
            On creation, a Skeleton has a no bones, you should create them and link
            them together appropriately. 

</member>
        <member name="M:Ogre.Skeleton.#ctor">
Internal constructor for use by SkeletonInstance only
</member>
        <member name="T:Ogre.Skeleton">
A collection of Bone objects used to animate a skinned mesh.
    @remarks
        Skeletal animation works by having a collection of 'bones' which are 
        actually just joints with a position and orientation, arranged in a tree structure.
        For example, the wrist joint is a child of the elbow joint, which in turn is a
        child of the shoulder joint. Rotating the shoulder automatically moves the elbow
        and wrist as well due to this hierarchy.
    @par
        So how does this animate a mesh? Well every vertex in a mesh is assigned to one or more
        bones which affects it's position when the bone is moved. If a vertex is assigned to 
        more than one bone, then weights must be assigned to determine how much each bone affects
        the vertex (actually a weight of 1.0 is used for single bone assignments). 
        Weighted vertex assignments are especially useful around the joints themselves
        to avoid 'pinching' of the mesh in this region. 
    @par
        Therefore by moving the skeleton using preset animations, we can animate the mesh. The
        advantage of using skeletal animation is that you store less animation data, especially
        as vertex counts increase. In addition, you are able to blend multiple animations together
        (e.g. walking and looking around, running and shooting) and provide smooth transitions
        between animations without incurring as much of an overhead as would be involved if you
        did this on the core vertex data.
    @par
        Skeleton definitions are loaded from datafiles, namely the .skeleton file format. They
        are loaded on demand, especially when referenced by a Mesh.

</member>
        <member name="T:Ogre.SkeletonAnimationBlendMode">
\addtogroup Core
	*  @{

\addtogroup Animation
	*  @{


</member>
        <member name="F:ANIMBLEND_CUMULATIVE">
Animations are applied by calculating a weighted cumulative total
</member>
        <member name="F:ANIMBLEND_AVERAGE">
Animations are applied by calculating a weighted average of all animations
</member>
        <member name="M:Ogre.ProgressiveMesh.dumpContents(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal debugging method 
</member>
        <member name="M:Ogre.ProgressiveMesh.collapse(Ogre.ProgressiveMesh.PMVertex*)">
Internal method, collapses vertex onto it's saved collapse target. 
        @remarks
            This updates the working triangle list to drop a triangle and recalculates
            the edge collapse costs around the collapse target. 
            This also updates all the working vertex lists for the relevant buffer. 

</member>
        <member name="M:Ogre.ProgressiveMesh.bakeNewLOD(Ogre.IndexData*)">
Internal method builds an new LOD based on the current state
</member>
        <member name="M:Ogre.ProgressiveMesh.getNextCollapser">
Internal method for getting the index of next best vertex to collapse
</member>
        <member name="M:Ogre.ProgressiveMesh.computeAllCosts">
Internal method to compute edge collapse costs for all buffers /
</member>
        <member name="M:Ogre.ProgressiveMesh.computeEdgeCostAtVertex(System.UInt32)">
Internal method evaluates all collapse costs from this vertex for every buffer and returns the worst
</member>
        <member name="M:Ogre.ProgressiveMesh.computeEdgeCostAtVertexForBuffer(std._Vector_iterator&lt;Ogre.ProgressiveMesh.PMWorkingData,std.allocator&lt;Ogre.ProgressiveMesh.PMWorkingData&gt;&gt;,System.UInt32)">
Internal method evaluates all collapse costs from this vertex and picks the lowest for a single buffer
</member>
        <member name="M:Ogre.ProgressiveMesh.computeEdgeCollapseCost(Ogre.ProgressiveMesh.PMVertex*,Ogre.ProgressiveMesh.PMVertex*)">
Internal calculation method for deriving a collapse cost  from u to v
</member>
        <member name="M:Ogre.ProgressiveMesh.initialiseEdgeCollapseCosts">
Internal method for initialising the edge collapse costs
</member>
        <member name="M:Ogre.ProgressiveMesh.addWorkingData(Ogre.VertexData!System.Runtime.CompilerServices.IsConst*,Ogre.IndexData!System.Runtime.CompilerServices.IsConst*)">
Internal method for building PMWorkingData from geometry data
</member>
        <member name="F:Ogre.ProgressiveMesh.mWorstCosts">
The worst collapse cost from all vertex buffers for each vertex
</member>
        <member name="F:Ogre.ProgressiveMesh.mWorkingData">
Multiple copies, 1 per vertex buffer
</member>
        <member name="T:Ogre.ProgressiveMesh.PMWorkingData">
Data used to calculate the collapse costs
</member>
        <member name="T:Ogre.ProgressiveMesh.PMVertex">
A vertex in the progressive mesh, holds info like collapse cost etc. 
		This vertex can actually represent several vertices in the final model, because
		vertices along texture seams etc will have been duplicated. In order to properly
		evaluate the surface properties, a single common vertex is used for these duplicates,
		and the faces hold the detail of the duplicated vertices.

</member>
        <member name="T:Ogre.ProgressiveMesh.PMTriangle">
A triangle in the progressive mesh, holds extra info like face normal. 
</member>
        <member name="T:Ogre.ProgressiveMesh.PMFaceVertex">
A vertex as used by a face. This records the index of the actual vertex which is used
		by the face, and a pointer to the common vertex used for surface evaluation. 
</member>
        <member name="M:Ogre.ProgressiveMesh.build(System.UInt16,std.vector&lt;Ogre.IndexData**&gt;*,Ogre.ProgressiveMesh.VertexReductionQuota,System.Single)">
Builds the progressive mesh with the specified number of levels.
        @param numLevels The number of levels to include in the output excluding the full detail version.
        @param outList Pointer to a list of LOD geometry data which will be completed by the application.
			Each entry is a reduced form of the mesh, in decreasing order of detail.
		@param quota The way to derive the number of vertices removed at each LOD
		@param reductionValue Either the proportion of vertices to remove at each level, or a fixed
			number of vertices to remove at each level, depending on the value of quota

</member>
        <member name="M:Ogre.ProgressiveMesh.addExtraVertexPositionBuffer(Ogre.VertexData!System.Runtime.CompilerServices.IsConst*)">
Adds an extra vertex position buffer. 
        @remarks
            As well as the main vertex buffer, the client of this class may add extra versions
            of the vertex buffer which will also be taken into account when the cost of 
            simplifying the mesh is taken into account. This is because the cost of
            simplifying an animated mesh cannot be calculated from just the reference position,
            multiple positions needs to be assessed in order to find the best simplification option.
		@par
			DO NOT pass write-only, unshadowed buffers to this method! They will not
			work. Pass only shadowed buffers, or better yet perform mesh reduction as
			an offline process using DefaultHardwareBufferManager to manage vertex
			buffers in system memory.
        @param buffer Pointer to x/y/z buffer with vertex positions. The number of vertices
            must be the same as in the original GeometryData passed to the constructor.

</member>
        <member name="M:Ogre.ProgressiveMesh.#ctor(Ogre.VertexData!System.Runtime.CompilerServices.IsConst*,Ogre.IndexData!System.Runtime.CompilerServices.IsConst*)">
Constructor, takes the geometry data and index buffer. 
		@remarks
			DO NOT pass write-only, unshadowed buffers to this method! They will not
			work. Pass only shadowed buffers, or better yet perform mesh reduction as
			an offline process using DefaultHardwareBufferManager to manage vertex
			buffers in system memory.

</member>
        <member name="F:VRQ_PROPORTIONAL">
A proportion of the remaining number of vertices are removed at each reduction
</member>
        <member name="F:VRQ_CONSTANT">
A set number of vertices are removed at each reduction
</member>
        <member name="T:Ogre.ProgressiveMesh.VertexReductionQuota">
The way to derive the quota of vertices which are reduced at each LOD. 
</member>
        <member name="T:Ogre.ProgressiveMesh">
\addtogroup Core
	*  @{

\addtogroup LOD
	*  @{

This class reduces the complexity of the geometry it is given.
        This class is dedicated to reducing the number of triangles in a given mesh
        taking into account seams in both geometry and texture co-ordinates and meshes 
        which have multiple frames.
    @par
        The primary use for this is generating LOD versions of Mesh objects, but it can be
        used by any geometry provider. The only limitation at the moment is that the 
        provider uses a common vertex buffer for all LODs and one index buffer per LOD.
        Therefore at the moment this class can only handle indexed geometry.
    @par
        NB the interface of this class will certainly change when compiled vertex buffers are
        supported.

</member>
        <member name="T:Ogre.VertexBoneAssignment_s">
\addtogroup Core
	*  @{

\addtogroup Animation
	*  @{

Records the assignment of a single vertex to a single bone with the corresponding weight.
    @remarks
        This simple struct simply holds a vertex index, bone index and weight representing the
        assignment of a vertex to a bone for skeletal animation. There may be many of these
        per vertex if blended vertex assignments are allowed.

</member>
        <member name="T:Ogre.BillboardSetFactory">
Factory object for creating BillboardSet instances 
</member>
        <member name="M:Ogre.BillboardSet.notifyBillboardDataChanged">
When billboard set is not auto updating its GPU buffer, the user is responsible to inform it
			about any billboard changes in order to reflect them at the rendering stage.
			Calling this method will cause GPU buffers update in the next render queue update.

</member>
        <member name="M:Ogre.BillboardSet.getAutoUpdate">
Return the auto update state of this billboard set.
</member>
        <member name="M:Ogre.BillboardSet.setAutoUpdate(System.Boolean)">
Set the auto update state of this billboard set.
		@remarks
			This methods controls the updating policy of the vertex buffer.
			By default auto update is true so the vertex buffer is being update every time this billboard set
			is about to be rendered. This behavior best fit when the billboards of this set changes frequently.
			When using static or semi-static billboards, it is recommended to set auto update to false.
			In that case one should call notifyBillboardDataChanged method to reflect changes made to the
			billboards data.			

</member>
        <member name="M:Ogre.BillboardSet.getTypeFlags">
Override to return specific type flag
</member>
        <member name="M:Ogre.BillboardSet.isPointRenderingEnabled">
Returns whether point rendering is enabled. 
</member>
        <member name="M:Ogre.BillboardSet.setPointRenderingEnabled(System.Boolean)">
Set whether or not the BillboardSet will use point rendering
			rather than manually generated quads.
		@remarks
			By default a billboardset is rendered by generating geometry for a
			textured quad in memory, taking into account the size and 
			orientation settings, and uploading it to the video card. 
			The alternative is to use hardware point rendering, which means that
			only one position needs to be sent per billboard rather than 4 and
			the hardware sorts out how this is rendered based on the render
			state.
		@par
			Using point rendering is faster than generating quads manually, but
			is more restrictive. The following restrictions apply:
			\li Only the BBT_POINT type is supported
			\li Size and appearance of each billboard is controlled by the 
				material (Pass::setPointSize, Pass::setPointSizeAttenuation, 
				Pass::setPointSpritesEnabled)
			\li Per-billboard size is not supported (stems from the above)
			\li Per-billboard rotation is not supported, this can only be 
				controlled through texture unit rotation
			\li Only BBO_CENTER origin is supported
			\li Per-billboard texture coordinates are not supported

		@par
			You will almost certainly want to enable in your material pass
			both point attenuation and point sprites if you use this option. 
		@param enabled True to enable point rendering, false otherwise

</member>
        <member name="M:Ogre.BillboardSet.getTextureCoords(System.UInt16*)">
getTextureCoords() returns the current texture coordinate rects in 
            effect. By default, there is only one texture coordinate rect in the 
            set, spanning the entire texture from 0 through 1 in each direction.
          @see
            BillboardSet::setTextureCoords()

</member>
        <member name="M:Ogre.BillboardSet.setTextureStacksAndSlices(System.Byte,System.Byte)">
setTextureStacksAndSlices() will generate texture coordinate rects as if the 
            texture for the billboard set contained 'stacks' rows of 'slices' 
            images each, all equal size. Thus, if the texture size is 512x512 
            and 'stacks' is 4 and 'slices' is 8, each sub-rectangle of the texture 
            would be 128 texels tall and 64 texels wide.
          @remarks
            This function is short-hand for creating a regular set and calling 
            setTextureCoords() yourself. The numbering used for Billboard::setTexcoordIndex() 
            counts first across, then down, so top-left is 0, the one to the right 
            of that is 1, and the lower-right is stacks*slices-1.
          @see
            BillboardSet::setTextureCoords()

</member>
        <member name="M:Ogre.BillboardSet.setTextureCoords(Ogre.TRect&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*,System.UInt16)">
BillboardSet can use custom texture coordinates for various billboards. 
            This is useful for selecting one of many particle images out of a tiled 
            texture sheet, or doing flipbook animation within a single texture.
          @par
            The generic functionality is setTextureCoords(), which will copy the 
            texture coordinate rects you supply into internal storage for the 
            billboard set. If your texture sheet is a square grid, you can also 
            use setTextureStacksAndSlices() for more convenience, which will construct 
            the set of texture coordinates for you.
          @par
            When a Billboard is created, it can be assigned a texture coordinate 
            set from within the sets you specify (that set can also be re-specified 
            later). When drawn, the billboard will use those texture coordinates, 
            rather than the full 0-1 range.
          @par
          @param coords is a vector of texture coordinates (in UV space) to choose 
            from for each billboard created in the set.
          @param numCoords is how many such coordinate rectangles there are to 
            choose from.
          @remarks
            Set 'coords' to 0 and/or 'numCoords' to 0 to reset the texture coord 
            rects to the initial set of a single rectangle spanning 0 through 1 in 
            both U and V (i e, the entire texture).
          @see
            BillboardSet::setTextureStacksAndSlices()
            Billboard::setTexcoordIndex()

</member>
        <member name="M:Ogre.BillboardSet.setBillboardsInWorldSpace(System.Boolean)">
Sets whether billboards should be treated as being in world space. 
        @remarks
            This is most useful when you are driving the billboard set from 
            an external data source.

</member>
        <member name="M:Ogre.BillboardSet._getSortMode">
Gets the sort mode of this billboard set 
</member>
        <member name="M:Ogre.BillboardSet._sortBillboards(Ogre.Camera*)">
Sort the billboard set. Only called when enabled via setSortingEnabled 
</member>
        <member name="M:Ogre.BillboardSet.visitRenderables(Ogre.Renderable.Visitor*,System.Boolean)">
@copydoc MovableObject::visitRenderables
</member>
        <member name="M:Ogre.BillboardSet.getLights">
@copydoc Renderable::getLights 
</member>
        <member name="M:Ogre.BillboardSet._updateBounds">
Update the bounds of the billboardset 
</member>
        <member name="M:Ogre.BillboardSet.getSquaredViewDepth(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Overridden, see Renderable 
</member>
        <member name="M:Ogre.BillboardSet.getMovableType">
Overridden from MovableObject 
</member>
        <member name="M:Ogre.BillboardSet.getUseAccurateFacing">
Gets whether or not billboards use an 'accurate' facing model
            based on the vector from each billboard to the camera, rather than 
            an optimised version using just the camera direction.

</member>
        <member name="M:Ogre.BillboardSet.setUseAccurateFacing(System.Boolean)">
Sets whether or not billboards should use an 'accurate' facing model
            based on the vector from each billboard to the camera, rather than 
            an optimised version using just the camera direction.
        @remarks
            By default, the axes for all billboards are calculated using the 
            camera's view direction, not the vector from the camera position to
            the billboard. The former is faster, and most of the time the difference
            is not noticeable. However for some purposes (e.g. very large, static
            billboards) the changing billboard orientation when rotating the camera
            can be off putting, therefore you can enable this option to use a
            more expensive, but more accurate version.
        @param acc True to use the slower but more accurate model. Default is false.

</member>
        <member name="M:Ogre.BillboardSet.getCommonUpVector">
Gets the common up-vector for all billboards (BBT_PERPENDICULAR_SELF and BBT_PERPENDICULAR_COMMON) 
</member>
        <member name="M:Ogre.BillboardSet.setCommonUpVector(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Use this to specify the common up-vector given to billboards of type BBT_PERPENDICULAR_SELF or BBT_PERPENDICULAR_COMMON.
        @remarks
            Use BBT_PERPENDICULAR_SELF or BBT_PERPENDICULAR_COMMON when you want oriented billboards
            perpendicular to specify direction vector (or, Z axis), and doesn't face to camera.
            In this case, we need an additional up-vector to determine the billboard X and Y axis.
            The generated billboard plane and X-axis guarantee perpendicular to specify direction.
            @see setCommonDirection
        @par
            The specify direction is billboard own direction when billboard type is BBT_PERPENDICULAR_SELF,
            and it's shared common direction when billboard type is BBT_PERPENDICULAR_COMMON.
        @param vec The up-vector for all billboards.
        @note
            The up-vector are use as is, never normalised in internal, user are supposed to normalise it himself.

</member>
        <member name="M:Ogre.BillboardSet.getCommonDirection">
Gets the common direction for all billboards (BBT_ORIENTED_COMMON) 
</member>
        <member name="M:Ogre.BillboardSet.setCommonDirection(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Use this to specify the common direction given to billboards of type BBT_ORIENTED_COMMON or BBT_PERPENDICULAR_COMMON.
        @remarks
            Use BBT_ORIENTED_COMMON when you want oriented billboards but you know they are always going to 
            be oriented the same way (e.g. rain in calm weather). It is faster for the system to calculate
            the billboard vertices if they have a common direction.
        @par
            The common direction also use in BBT_PERPENDICULAR_COMMON, in this case the common direction
            treat as Z axis, and an additional common up-vector was use to determine billboard X and Y
            axis.
            @see setCommonUpVector
        @param vec The direction for all billboards.
        @note
            The direction are use as is, never normalised in internal, user are supposed to normalise it himself.

</member>
        <member name="M:Ogre.BillboardSet.getBillboardType">
Returns the billboard type in use. 
</member>
        <member name="M:Ogre.BillboardSet.setBillboardType(Ogre.BillboardType)">
Sets the type of billboard to render.
        @remarks
            The default sort of billboard (BBT_POINT), always has both x and y axes parallel to 
            the camera's local axes. This is fine for 'point' style billboards (e.g. flares,
            smoke, anything which is symmetrical about a central point) but does not look good for
            billboards which have an orientation (e.g. an elongated raindrop). In this case, the
            oriented billboards are more suitable (BBT_ORIENTED_COMMON or BBT_ORIENTED_SELF) since
            they retain an independant Y axis and only the X axis is generated, perpendicular to both
            the local Y and the camera Z.
        @par
            In some case you might want the billboard has fixed Z axis and doesn't need to face to
            camera (e.g. an aureola around the player and parallel to the ground). You can use
            BBT_PERPENDICULAR_SELF which the billboard plane perpendicular to the billboard own
            direction. Or BBT_PERPENDICULAR_COMMON which the billboard plane perpendicular to the
            common direction.
        @note
            BBT_PERPENDICULAR_SELF and BBT_PERPENDICULAR_COMMON can't guarantee counterclockwise, you might
            use double-side material (<b>cull_hardware node</b>) to ensure no billboard are culled.
        @param bbt The type of billboard to render

</member>
        <member name="M:Ogre.BillboardSet.setCullIndividually(System.Boolean)">
Sets whether culling tests billboards in this individually as well as in a group.
        @remarks
            Billboard sets are always culled as a whole group, based on a bounding box which 
            encloses all billboards in the set. For fairly localised sets, this is enough. However, you
            can optionally tell the set to also cull individual billboards in the set, i.e. to test
            each individual billboard before rendering. The default is not to do this.
        @par
            This is useful when you have a large, fairly distributed set of billboards, like maybe 
            trees on a landscape. You probably still want to group them into more than one
            set (maybe one set per section of landscape), which will be culled coarsely, but you also
            want to cull the billboards individually because they are spread out. Whilst you could have
            lots of single-tree sets which are culled separately, this would be inefficient to render
            because each tree would be issued as it's own rendering operation.
        @par
            By calling this method with a parameter of true, you can have large billboard sets which 
            are spaced out and so get the benefit of batch rendering and coarse culling, but also have
            fine-grained culling so unnecessary rendering is avoided.
        @param cullIndividual If true, each billboard is tested before being sent to the pipeline as well 
            as the whole set having to pass the coarse group bounding test.

</member>
        <member name="M:Ogre.BillboardSet.getCullIndividually">
Returns whether or not billboards in this are tested individually for culling. 
</member>
        <member name="M:Ogre.BillboardSet._notifyBillboardRotated">
Internal callback used by Billboards to notify their parent that they have been rotated..

</member>
        <member name="M:Ogre.BillboardSet._notifyBillboardResized">
Internal callback used by Billboards to notify their parent that they have been resized.

</member>
        <member name="M:Ogre.BillboardSet.getWorldTransforms(Ogre.Matrix4*)">
Overridden from MovableObject
            @see
                MovableObject

</member>
        <member name="M:Ogre.BillboardSet.getRenderOperation(Ogre.RenderOperation*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Overridden from MovableObject
            @see
                MovableObject

</member>
        <member name="M:Ogre.BillboardSet.getMaterial">
Overridden from MovableObject
            @see
                MovableObject

</member>
        <member name="M:Ogre.BillboardSet._updateRenderQueue(Ogre.RenderQueue*)">
Overridden from MovableObject
            @see
                MovableObject

</member>
        <member name="M:Ogre.BillboardSet.getBoundingRadius">
Overridden from MovableObject
            @see
                MovableObject

</member>
        <member name="M:Ogre.BillboardSet.getBoundingBox">
Overridden from MovableObject
            @see
                MovableObject

</member>
        <member name="M:Ogre.BillboardSet.setBounds(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Set the bounds of the BillboardSet.
		@remarks
			You may need to call this if you're injecting billboards manually, 
			and you're relying on the BillboardSet to determine culling.

</member>
        <member name="M:Ogre.BillboardSet.endBillboards">
Finish defining billboards. 
</member>
        <member name="M:Ogre.BillboardSet.injectBillboard(Ogre.Billboard!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Define a billboard. 
</member>
        <member name="M:Ogre.BillboardSet.beginBillboards(System.UInt32)">
Begin injection of billboard data; applicable when 
            constructing the BillboardSet for external data use.
		@param numBillboards If you know the number of billboards you will be 
			issuing, state it here to make the update more efficient.

</member>
        <member name="M:Ogre.BillboardSet._notifyCurrentCamera(Ogre.Camera*)">
Overridden from MovableObject
            @see
                MovableObject

</member>
        <member name="M:Ogre.BillboardSet.getMaterialName">
Sets the name of the material to be used for this billboard set.
            @returns The name of the material that is used for this set.

</member>
        <member name="M:Ogre.BillboardSet.setMaterialName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the name of the material to be used for this billboard set.
            @param
                name The new name of the material to use for this set.

</member>
        <member name="M:Ogre.BillboardSet.getDefaultHeight">
See setDefaultDimensions - this gets 1 component individually. 
</member>
        <member name="M:Ogre.BillboardSet.setDefaultHeight(System.Single)">
See setDefaultDimensions - this sets 1 component individually. 
</member>
        <member name="M:Ogre.BillboardSet.getDefaultWidth">
See setDefaultDimensions - this gets 1 component individually. 
</member>
        <member name="M:Ogre.BillboardSet.setDefaultWidth(System.Single)">
See setDefaultDimensions - this sets 1 component individually. 
</member>
        <member name="M:Ogre.BillboardSet.setDefaultDimensions(System.Single,System.Single)">
Sets the default dimensions of the billboards in this set.
            @remarks
                All billboards in a set are created with these default dimensions. The set will render most efficiently if
                all the billboards in the set are the default size. It is possible to alter the size of individual
                billboards at the expense of extra calculation. See the Billboard class for more info.
            @param width
                The new default width for the billboards in this set.
            @param height
                The new default height for the billboards in this set.

</member>
        <member name="M:Ogre.BillboardSet.getBillboardRotationType">
Sets billboard rotation type.
            @returns
                A member of the BillboardRotationType enum specifying the rotation type for all the billboards in this set.

</member>
        <member name="M:Ogre.BillboardSet.setBillboardRotationType(Ogre.BillboardRotationType)">
Sets billboard rotation type.
            @remarks
                This setting controls the billboard rotation type, you can deciding rotate the billboard's vertices
                around their facing direction or rotate the billboard's texture coordinates.
            @par
                The default settings is BBR_TEXCOORD.
            @param
                rotationType A member of the BillboardRotationType enum specifying the rotation type for all the billboards in this set.

</member>
        <member name="M:Ogre.BillboardSet.getBillboardOrigin">
Gets the point which acts as the origin point for all billboards in this set.
            @returns
                A member of the BillboardOrigin enum specifying the origin for all the billboards in this set.

</member>
        <member name="M:Ogre.BillboardSet.setBillboardOrigin(Ogre.BillboardOrigin)">
Sets the point which acts as the origin point for all billboards in this set.
            @remarks
                This setting controls the fine tuning of where a billboard appears in relation to it's
                position. It could be that a billboard's position represents it's center (e.g. for fireballs),
                it could mean the center of the bottom edge (e.g. a tree which is positioned on the ground),
                the top-left corner (e.g. a cursor).
            @par
                The default setting is BBO_CENTER.
            @param
                origin A member of the BillboardOrigin enum specifying the origin for all the billboards in this set.

</member>
        <member name="M:Ogre.BillboardSet.removeBillboard(Ogre.Billboard*)">
Removes a billboard from the set.
            @note
                This version is more efficient than removing by index.

</member>
        <member name="M:Ogre.BillboardSet.removeBillboard(System.UInt32)">
Removes the billboard at the supplied index.
            @note
                This method requires linear time since the billboard list is a linked list.

</member>
        <member name="M:Ogre.BillboardSet.getBillboard(System.UInt32)">
Returns a pointer to the billboard at the supplied index.
            @note
                This method requires linear time since the billboard list is a linked list.
            @param
                index The index of the billboard that is requested.
            @returns
                On success, a valid pointer to the requested billboard is
                returned.
            @par
                On failure, <b>NULL</b> is returned.

</member>
        <member name="M:Ogre.BillboardSet.clear">
Empties this set of all billboards.

</member>
        <member name="M:Ogre.BillboardSet.getPoolSize">
Returns the current size of the billboard pool.
            @returns
                The current size of the billboard pool.
            @see
                BillboardSet::setAutoextend

</member>
        <member name="M:Ogre.BillboardSet.setPoolSize(System.UInt32)">
Adjusts the size of the pool of billboards available in this set.
            @remarks
                See the BillboardSet::setAutoextend method for full details of the billboard pool. This method adjusts
                the preallocated size of the pool. If you try to reduce the size of the pool, the set has the option
                of ignoring you if too many billboards are already in use. Bear in mind that calling this method will
                incur significant construction / destruction calls so should be avoided in time-critical code. The same
                goes for auto-extension, try to avoid it by estimating the pool size correctly up-front.
            @param
                size The new size for the pool.

</member>
        <member name="M:Ogre.BillboardSet.getSortingEnabled">
Returns true if sorting of billboards is enabled based on their distance from the camera
		    @see
				BillboardSet::setSortingEnabled

</member>
        <member name="M:Ogre.BillboardSet.setSortingEnabled(System.Boolean)">
Enables sorting for this BillboardSet. (default: off)
			@param sortenable true to sort the billboards according to their distance to the camera

</member>
        <member name="M:Ogre.BillboardSet.getAutoextend">
Returns true if the billboard pool automatically extends.
            @see
                BillboardSet::setAutoextend

</member>
        <member name="M:Ogre.BillboardSet.setAutoextend(System.Boolean)">
Tells the set whether to allow automatic extension of the pool of billboards.
            @remarks
                A BillboardSet stores a pool of pre-constructed billboards which are used as needed when
                a new billboard is requested. This allows applications to create / remove billboards efficiently
                without incurring construction / destruction costs (a must for sets with lots of billboards like
                particle effects). This method allows you to configure the behaviour when a new billboard is requested
                but the billboard pool has been exhausted.
            @par
                The default behaviour is to allow the pool to extend (typically this allocates double the current
                pool of billboards when the pool is expended), equivalent to calling this method with
                autoExtend = true. If you set the parameter to false however, any attempt to create a new billboard
                when the pool has expired will simply fail silently, returning a null pointer.
            @param autoextend true to double the pool every time it runs out, false to fail silently.

</member>
        <member name="M:Ogre.BillboardSet.getNumBillboards">
Returns the number of active billboards which currently make up this set.

</member>
        <member name="M:Ogre.BillboardSet.createBillboard(System.Single,System.Single,System.Single,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a new billboard and adds it to this set.
            @remarks
                Behaviour once the billboard pool has been exhausted depends on the
                BillboardSet::setAutoextendPool option.
            @param
                x
            @param
                y
            @param
                z The position of the new billboard relative to the center of the set
            @param
                colour Optional base colour of the billboard.
            @returns
                On success, a pointer to a newly created Billboard is
                returned.
            @par
                On failure (i.e. no more space and can't autoextend),
                <b>NULL</b> is returned.
            @see
                BillboardSet::setAutoextend

</member>
        <member name="M:Ogre.BillboardSet.createBillboard(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a new billboard and adds it to this set.
            @remarks
                Behaviour once the billboard pool has been exhausted depends on the
                BillboardSet::setAutoextendPool option.
            @param
                position The position of the new billboard realtive to the certer of the set
            @param
                colour Optional base colour of the billboard.
            @returns
                On success, a pointer to a newly created Billboard is
                returned.
            @par
                On failiure (i.e. no more space and can't autoextend),
                <b>NULL</b> is returned.
            @see
                BillboardSet::setAutoextend

</member>
        <member name="M:Ogre.BillboardSet.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.Boolean)">
Usual constructor - this is called by the SceneManager.
            @param
                name The name to give the billboard set (must be unique)
            @param
                poolSize The initial size of the billboard pool. Estimate of the number of billboards
                which will be required, and pass it using this parameter. The set will
                preallocate this number to avoid memory fragmentation. The default behaviour
                once this pool has run out is to double it.
            @param
                externalDataSource If true, the source of data for drawing the 
                billboards will not be the internal billboard list, but external 
                data. When driving the billboard from external data, you must call
                _notifyCurrentCamera to reorient the billboards, setPoolSize to set
                the maximum billboards you want to use, beginBillboards to 
                start the update, and injectBillboard per billboard, 
                followed by endBillboards.
            @see
                BillboardSet::setAutoextend

</member>
        <member name="M:Ogre.BillboardSet._destroyBuffers">
Internal method destroys vertex and index buffers.

</member>
        <member name="M:Ogre.BillboardSet._createBuffers">
Internal method creates vertex and index buffers.

</member>
        <member name="F:Ogre.BillboardSet.mBillboardDataChanged">
True if the billboard data changed. Will cause vertex buffer update.
</member>
        <member name="F:Ogre.BillboardSet.mAutoUpdate">
Tell if vertex buffer should be update automatically.
</member>
        <member name="F:Ogre.BillboardSet.mExternalData">
Is external billboard data in use?
</member>
        <member name="F:Ogre.BillboardSet.mPoolSize">
The number of billboard in the pool.
</member>
        <member name="F:Ogre.BillboardSet.mBuffersCreated">
Flag indicating whether the HW buffers have been created.
</member>
        <member name="F:Ogre.BillboardSet.mPointRendering">
Use point rendering?
</member>
        <member name="F:Ogre.BillboardSet.SortByDistanceFunctor.sortPos">
Position to sort in
</member>
        <member name="T:Ogre.BillboardSet.SortByDistanceFunctor">
Sort by distance functor 
</member>
        <member name="F:Ogre.BillboardSet.SortByDirectionFunctor.sortDir">
Direction to sort in
</member>
        <member name="T:Ogre.BillboardSet.SortByDirectionFunctor">
Sort by direction functor 
</member>
        <member name="M:Ogre.BillboardSet.genVertOffsets(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3*)">
Internal method generates vertex offsets.
        @remarks
            Takes in parametric offsets as generated from getParametericOffsets, width and height values
            and billboard x and y axes as generated from genBillboardAxes. 
            Fills output array of 4 vectors with vector offsets
            from origin for left-top, right-top, left-bottom, right-bottom corners.

</member>
        <member name="M:Ogre.BillboardSet.genVertices(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,Ogre.Billboard!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for generating vertex data. 
        @param offsets Array of 4 Vector3 offsets
        @param bb Reference to billboard

</member>
        <member name="M:Ogre.BillboardSet.getParametricOffsets(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method, generates parametric offsets based on origin.

</member>
        <member name="M:Ogre.BillboardSet.genBillboardAxes(Ogre.Vector3*,Ogre.Vector3*,Ogre.Billboard!System.Runtime.CompilerServices.IsConst*)">
Internal method for generating billboard corners. 
        @remarks
            Optional parameter pBill is only present for type BBT_ORIENTED_SELF and BBT_PERPENDICULAR_SELF

</member>
        <member name="M:Ogre.BillboardSet.increasePool(System.UInt32)">
Internal method for increasing pool size
</member>
        <member name="M:Ogre.BillboardSet.billboardVisible(Ogre.Camera*,Ogre.Billboard!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for culling individual billboards
</member>
        <member name="F:Ogre.BillboardSet.mCommonUpVector">
Common up-vector for billboards of type BBT_PERPENDICULAR_SELF and BBT_PERPENDICULAR_COMMON
</member>
        <member name="F:Ogre.BillboardSet.mCommonDirection">
Common direction for billboards of type BBT_ORIENTED_COMMON and BBT_PERPENDICULAR_COMMON
</member>
        <member name="F:Ogre.BillboardSet.mBillboardType">
The type of billboard to render
</member>
        <member name="F:Ogre.BillboardSet.mCullIndividual">
Flag indicating whether each billboard should be culled separately (default: false)
</member>
        <member name="F:Ogre.BillboardSet.mIndexData">
The vertex index data for all billboards in this set (1 set only)
</member>
        <member name="F:Ogre.BillboardSet.mCurrentCamera">
Current camera
</member>
        <member name="F:Ogre.BillboardSet.mVOffset">
Boundary offsets based on origin and camera orientation
Vector3 vLeftOff, vRightOff, vTopOff, vBottomOff;
Final vertex offsets, used where sizes all default to save calcs
</member>
        <member name="F:Ogre.BillboardSet.mLockPtr">
Locked pointer to buffer
</member>
        <member name="F:Ogre.BillboardSet.mMainBuf">
Shortcut to main buffer (positions, colours, texture coords)
</member>
        <member name="F:Ogre.BillboardSet.mVertexData">
The vertex position data for all billboards in this set.
</member>
        <member name="F:Ogre.BillboardSet.mBillboardPool">
Pool of billboard instances for use and reuse in the active billboard list.
            @remarks
                This vector will be preallocated with the estimated size of the set,and will extend as required.

</member>
        <member name="F:Ogre.BillboardSet.mFreeBillboards">
Free billboard queue.
            @remarks
                This contains a list of the billboards free for use as new instances
                as required by the set. Billboard instances are preconstructed up to the estimated size in the
                mBillboardPool vector and are referenced on this deque at startup. As they get used this deque
                reduces, as they get released back to to the set they get added back to the deque.

</member>
        <member name="F:Ogre.BillboardSet.mSortingEnabled">
Flag indicating whether the billboards has to be sorted
</member>
        <member name="F:Ogre.BillboardSet.mAutoExtendPool">
Flag indicating whether to autoextend pool
</member>
        <member name="F:Ogre.BillboardSet.mAllDefaultSize">
True if no billboards in this set have been resized - greater efficiency.
</member>
        <member name="F:Ogre.BillboardSet.mpMaterial">
Pointer to the material to use
</member>
        <member name="F:Ogre.BillboardSet.mMaterialName">
Name of the material to use
</member>
        <member name="F:Ogre.BillboardSet.mDefaultHeight">
Default height of each billboard
</member>
        <member name="F:Ogre.BillboardSet.mDefaultWidth">
Default width of each billboard
</member>
        <member name="F:Ogre.BillboardSet.mRotationType">
Rotation type of each billboard
</member>
        <member name="F:Ogre.BillboardSet.mOriginType">
Origin of each billboard
</member>
        <member name="F:Ogre.BillboardSet.mBoundingRadius">
Bounding radius
</member>
        <member name="F:Ogre.BillboardSet.mAABB">
Bounds of all billboards in this set
</member>
        <member name="M:Ogre.BillboardSet.#ctor">
Private constructor (instances cannot be created directly).

</member>
        <member name="T:Ogre.BillboardSet">
A collection of billboards (faces which are always facing the given direction) with the same (default) dimensions, material
        and which are fairly close proximity to each other.
        @remarks
            Billboards are rectangles made up of 2 tris which are always facing the given direction. They are typically used
            for special effects like particles. This class collects together a set of billboards with the same (default) dimensions,
            material and relative locality in order to process them more efficiently. The entire set of billboards will be
            culled as a whole (by default, although this can be changed if you want a large set of billboards
            which are spread out and you want them culled individually), individual Billboards have locations which are relative to the set (which itself derives it's
            position from the SceneNode it is attached to since it is a MoveableObject), they will be rendered as a single rendering operation,
            and some calculations will be sped up by the fact that they use the same dimensions so some workings can be reused.
        @par
            A BillboardSet can be created using the SceneManager::createBillboardSet method. They can also be used internally
            by other classes to create effects.
		@note
			Billboard bounds are only automatically calculated when you create them.
			If you modify the position of a billboard you may need to call 
			_updateBounds if the billboard moves outside the original bounds. 
			Similarly, the bounds do no shrink when you remove a billboard, 
			if you want them to call _updateBounds, but note this requires a
			potentially expensive examination of every billboard in the set.

</member>
        <member name="T:Ogre.BillboardType">
The type of billboard to use. 
</member>
        <member name="F:BBT_PERPENDICULAR_SELF">
Billboards are perpendicular to their own direction vector (their own Z axis, the facing direction) and X, Y axis are determined by a shared up-vertor
</member>
        <member name="F:BBT_PERPENDICULAR_COMMON">
Billboards are perpendicular to a shared direction vector (used as Z axis, the facing direction) and X, Y axis are determined by a shared up-vertor
</member>
        <member name="F:BBT_ORIENTED_SELF">
Billboards are oriented around their own direction vector (their own Y axis) and only rotate around this to face the camera
</member>
        <member name="F:BBT_ORIENTED_COMMON">
Billboards are oriented around a shared direction vector (used as Y axis) and only rotate around this to face the camera
</member>
        <member name="F:BBT_POINT">
Standard point billboard (default), always faces the camera completely and is always upright
</member>
        <member name="T:Ogre.BillboardRotationType">
The rotation type of billboard. 
</member>
        <member name="F:BBR_TEXCOORD">
Rotate the billboard's texture coordinates
</member>
        <member name="F:BBR_VERTEX">
Rotate the billboard's vertices around their facing direction
</member>
        <member name="T:Ogre.BillboardOrigin">
\addtogroup Core
	*  @{

\addtogroup Effects
	*  @{

Enum covering what exactly a billboard's position means (center,
        top-left etc).
        @see
            BillboardSet::setBillboardOrigin

</member>
        <member name="T:Ogre.BillboardChainFactory">
Factory object for creating BillboardChain instances 
</member>
        <member name="F:Ogre.BillboardChain.SEGMENT_EMPTY">
Chain segment has no elements
</member>
        <member name="M:Ogre.BillboardChain.updateIndexBuffer">
Update the contents of the index buffer
</member>
        <member name="M:Ogre.BillboardChain.updateVertexBuffer(Ogre.Camera*)">
Update the contents of the vertex buffer
</member>
        <member name="M:Ogre.BillboardChain.setupVertexDeclaration">
Setup vertex declaration
</member>
        <member name="M:Ogre.BillboardChain.setupChainContainers">
Setup the STL collections
</member>
        <member name="F:Ogre.BillboardChain.ChainSegment.tail">
The 'tail' of the chain, relative to start
</member>
        <member name="F:Ogre.BillboardChain.ChainSegment.head">
The 'head' of the chain, relative to start
</member>
        <member name="F:Ogre.BillboardChain.ChainSegment.start">
The start of this chains subset of the buffer
</member>
        <member name="T:Ogre.BillboardChain.ChainSegment">
Simple struct defining a chain segment by referencing a subset of
			the preallocated buffer (which will be mMaxElementsPerChain * mChainCount
			long), by it's chain index, and a head and tail value which describe
			the current chain. The buffer subset wraps at mMaxElementsPerChain
			so that head and tail can move freely. head and tail are inclusive,
			when the chain is empty head and tail are filled with high-values.

</member>
        <member name="F:Ogre.BillboardChain.mChainElementList">
The list holding the chain elements
</member>
        <member name="F:Ogre.BillboardChain.mOtherTexCoordRange">
Other texture coord range
</member>
        <member name="F:Ogre.BillboardChain.mTexCoordDir">
Texture coord direction
</member>
        <member name="F:Ogre.BillboardChain.mMaterialName">
Material 
</member>
        <member name="F:Ogre.BillboardChain.mRadius">
Bounding radius
</member>
        <member name="F:Ogre.BillboardChain.mAABB">
AABB
</member>
        <member name="F:Ogre.BillboardChain.mIndexContentDirty">
Is the index buffer dirty?
</member>
        <member name="F:Ogre.BillboardChain.mBoundsDirty">
Do the bounds need redefining?
</member>
        <member name="F:Ogre.BillboardChain.mBuffersNeedRecreating">
Do the buffers need recreating?
</member>
        <member name="F:Ogre.BillboardChain.mVertexDeclDirty">
Is the vertex declaration dirty?
</member>
        <member name="F:Ogre.BillboardChain.mIndexData">
Index data (to allow multiple unconnected chains)
</member>
        <member name="F:Ogre.BillboardChain.mVertexData">
Vertex data
</member>
        <member name="F:Ogre.BillboardChain.mDynamic">
Dynamic use?
</member>
        <member name="F:Ogre.BillboardChain.mUseVertexColour">
Use vertex colour?
</member>
        <member name="F:Ogre.BillboardChain.mUseTexCoords">
Use texture coords?
</member>
        <member name="F:Ogre.BillboardChain.mChainCount">
Number of chains
</member>
        <member name="F:Ogre.BillboardChain.mMaxElementsPerChain">
Maximum length of each chain
</member>
        <member name="M:Ogre.BillboardChain.visitRenderables(Ogre.Renderable.Visitor*,System.Boolean)">
@copydoc MovableObject::visitRenderables
</member>
        <member name="M:Ogre.BillboardChain.setMaterialName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the material name to use for rendering
</member>
        <member name="M:Ogre.BillboardChain.getMaterialName">
Get the material name in use
</member>
        <member name="M:Ogre.BillboardChain.clearAllChains">
Remove all elements from all chains (but leave the chains themselves intact). 
</member>
        <member name="M:Ogre.BillboardChain.clearChain(System.UInt32)">
Remove all elements of a given chain (but leave the chain intact). 
</member>
        <member name="M:Ogre.BillboardChain.getNumChainElements(System.UInt32)">
Returns the number of chain elements. 
</member>
        <member name="M:Ogre.BillboardChain.getChainElement(System.UInt32,System.UInt32)">
Get the detail of a chain element.
		@param chainIndex The index of the chain
		@param elementIndex The element index within the chain, measured from
			the 'head' of the chain

</member>
        <member name="M:Ogre.BillboardChain.updateChainElement(System.UInt32,System.UInt32,Ogre.BillboardChain.Element!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update the details of an existing chain element.
		@param chainIndex The index of the chain
		@param elementIndex The element index within the chain, measured from 
			the 'head' of the chain
		@param billboardChainElement The details to set

</member>
        <member name="M:Ogre.BillboardChain.removeChainElement(System.UInt32)">
Remove an element from the 'tail' of a chain.
		@param chainIndex The index of the chain

</member>
        <member name="M:Ogre.BillboardChain.addChainElement(System.UInt32,Ogre.BillboardChain.Element!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add an element to the 'head' of a chain.
		@remarks
			If this causes the number of elements to exceed the maximum elements
			per chain, the last element in the chain (the 'tail') will be removed
			to allow the additional element to be added.
		@param chainIndex The index of the chain
		@param billboardChainElement The details to add

</member>
        <member name="M:Ogre.BillboardChain.getDynamic">
Gets whether or not the buffers created for this object are suitable
			for dynamic alteration.

</member>
        <member name="M:Ogre.BillboardChain.setDynamic(System.Boolean)">
Sets whether or not the buffers created for this object are suitable
			for dynamic alteration.

</member>
        <member name="M:Ogre.BillboardChain.getUseVertexColours">
Gets whether vertex colour information should be included in the
			final buffers generated.

</member>
        <member name="M:Ogre.BillboardChain.setUseVertexColours(System.Boolean)">
Sets whether vertex colour information should be included in the
			final buffers generated.
		@note You must use either texture coordinates or vertex colour since the
			vertices have no normals and without one of these there is no source of
			colour for the vertices.

</member>
        <member name="M:Ogre.BillboardChain.getOtherTextureCoordRange">
Get the range of the texture coordinates generated across the width of
			the chain elements.

</member>
        <member name="M:Ogre.BillboardChain.setOtherTextureCoordRange(System.Single,System.Single)">
Set the range of the texture coordinates generated across the width of
			the chain elements.
		@param start Start coordinate, default 0.0
		@param end End coordinate, default 1.0

</member>
        <member name="M:Ogre.BillboardChain.getTextureCoordDirection">
Gets the direction in which texture coords specified on each element
			are deemed to run.

</member>
        <member name="M:Ogre.BillboardChain.setTextureCoordDirection(Ogre.BillboardChain.TexCoordDirection)">
Sets the direction in which texture coords specified on each element
			are deemed to run along the length of the chain.
		@param dir The direction, default is TCD_U.

</member>
        <member name="F:TCD_V">
Tex coord in elements is treated as the 'v' texture coordinate
</member>
        <member name="F:TCD_U">
Tex coord in elements is treated as the 'u' texture coordinate
</member>
        <member name="T:Ogre.BillboardChain.TexCoordDirection">
The direction in which texture coordinates from elements of the
			chain are used.

</member>
        <member name="M:Ogre.BillboardChain.getUseTextureCoords">
Gets whether texture coordinate information should be included in the
			final buffers generated.

</member>
        <member name="M:Ogre.BillboardChain.setUseTextureCoords(System.Boolean)">
Sets whether texture coordinate information should be included in the
			final buffers generated.
		@note You must use either texture coordinates or vertex colour since the
			vertices have no normals and without one of these there is no source of
			colour for the vertices.

</member>
        <member name="M:Ogre.BillboardChain.getNumberOfChains">
Get the number of chain segments (this class can render multiple chains
		at once using the same material). 

</member>
        <member name="M:Ogre.BillboardChain.setNumberOfChains(System.UInt32)">
Set the number of chain segments (this class can render multiple chains
			at once using the same material). 

</member>
        <member name="M:Ogre.BillboardChain.getMaxChainElements">
Get the maximum number of chain elements per chain 

</member>
        <member name="M:Ogre.BillboardChain.setMaxChainElements(System.UInt32)">
Set the maximum number of chain elements per chain 

</member>
        <member name="M:Ogre.BillboardChain.Dispose">
destructor
</member>
        <member name="M:Ogre.BillboardChain.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,System.Boolean,System.Boolean)">
Constructor (don't use directly, use factory) 
		@param name The name to give this object
		@param maxElements The maximum number of elements per chain
		@param numberOfChains The number of separate chain segments contained in this object
		@param useTextureCoords If true, use texture coordinates from the chain elements
		@param useVertexColours If true, use vertex colours from the chain elements
		@param dynamic If true, buffers are created with the intention of being updated

</member>
        <member name="F:Ogre.BillboardChain.Element.texCoord">
U or V texture coord depending on options
</member>
        <member name="T:Ogre.BillboardChain.Element">
Contains the data of an element of the BillboardChain.

</member>
        <member name="T:Ogre.BillboardChain">
\addtogroup Core
	*  @{

\addtogroup Effects
	*  @{

Allows the rendering of a chain of connected billboards.
	@remarks
		A billboard chain operates much like a traditional billboard, i.e. its
		segments always face the camera; the difference being that instead of
		a set of disconnected quads, the elements in this class are connected
		together in a chain which must always stay in a continuous strip. This
		kind of effect is useful for creating effects such as trails, beams,
		lightning effects, etc.
	@par
		A single instance of this class can actually render multiple separate
		chain segments in a single render operation, provided they all use the
		same material. To clarify the terminology: a 'segment' is a separate 
		sub-part of the chain with its own start and end (called the 'head'
		and the 'tail'. An 'element' is a single position / colour / texcoord
		entry in a segment. You can add items to the head of a chain, and 
		remove them from the tail, very efficiently. Each segment has a max
		size, and if adding an element to the segment would exceed this size, 
		the tail element is automatically removed and re-used as the new item
		on the head.
	@par
		This class has no auto-updating features to do things like alter the
		colour of the elements or to automatically add / remove elements over
		time - you have to do all this yourself as a user of the class. 
		Subclasses can however be used to provide this kind of behaviour 
		automatically. @see RibbonTrail

</member>
        <member name="M:Ogre.MovableObjectFactory.getTypeFlags">
Gets the type flag for this factory.
		@remarks
			A type flag is like a query flag, except that it applies to all instances
			of a certain type of object.

</member>
        <member name="M:Ogre.MovableObjectFactory._notifyTypeFlags(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Notify this factory of the type mask to apply. 
		@remarks
			This should normally only be called by Root in response to
			a 'true' result from requestTypeMask. However, you can actually use
			it yourself if you're careful; for example to assign the same mask
			to a number of different types of object, should you always wish them
			to be treated the same in queries.

</member>
        <member name="M:Ogre.MovableObjectFactory.requestTypeFlags">
Does this factory require the allocation of a 'type flag', used to 
			selectively include / exclude this type from scene queries?
		@remarks
			The default implementation here is to return 'false', ie not to 
			request a unique type mask from Root. For objects that
			never need to be excluded in SceneQuery results, that's fine, since
			the default implementation of MovableObject::getTypeFlags is to return
			all ones, hence matching any query type mask. However, if you want the
			objects created by this factory to be filterable by queries using a 
			broad type, you have to give them a (preferably unique) type mask - 
			and given that you don't know what other MovableObject types are 
			registered, Root will allocate you one. 

</member>
        <member name="M:Ogre.MovableObjectFactory.destroyInstance(Ogre.MovableObject*)">
Destroy an instance of the object 
</member>
        <member name="M:Ogre.MovableObjectFactory.createInstance(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.SceneManager*,std.map&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.">
Create a new instance of the object.
		@param name The name of the new object
		@param manager The SceneManager instance that will be holding the
			instance once created.
		@param params Name/value pair list of additional parameters required to 
			construct the object (defined per subtype). Optional.

</member>
        <member name="M:Ogre.MovableObjectFactory.getType">
Get the type of the object to be created
</member>
        <member name="M:Ogre.MovableObjectFactory.createInstanceImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Ru">
Internal implementation of create method - must be overridden
</member>
        <member name="F:Ogre.MovableObjectFactory.mTypeFlag">
Type flag, allocated if requested
</member>
        <member name="T:Ogre.MovableObjectFactory">
Interface definition for a factory class which produces a certain
		kind of MovableObject, and can be registered with Root in order
		to allow all clients to produce new instances of this object, integrated
		with the standard Ogre processing.

</member>
        <member name="M:Ogre.MovableObject.isDebugDisplayEnabled">
Gets whether debug display of this object is enabled. 
</member>
        <member name="M:Ogre.MovableObject.setDebugDisplayEnabled(System.Boolean)">
Sets whether or not the debug display of this object is enabled.
		@remarks
			Some objects aren't visible themselves but it can be useful to display
			a debug representation of them. Or, objects may have an additional 
			debug display on top of their regular display. This option enables / 
			disables that debug display. Objects that are not visible never display
			debug geometry regardless of this setting.

</member>
        <member name="M:Ogre.MovableObject.visitRenderables(Ogre.Renderable.Visitor*,System.Boolean)">
Method to allow a caller to abstractly iterate over the Renderable
			instances that this MovableObject will add to the render queue when
			asked, if any. 
		@param visitor Pointer to a class implementing the Renderable::Visitor 
			interface which will be called back for each Renderable which will
			be queued. Bear in mind that the state of the Renderable instances
			may not be finalised depending on when you call this.
		@param debugRenderables If false, only regular renderables will be visited
			(those for normal display). If true, debug renderables will be
			included too.

</member>
        <member name="M:Ogre.MovableObject.getTypeFlags">
Get the 'type flags' for this MovableObject.
		@remarks
			A type flag identifies the type of the MovableObject as a bitpattern. 
			This is used for categorical inclusion / exclusion in SceneQuery
			objects. By default, this method returns all ones for objects not 
			created by a MovableObjectFactory (hence always including them); 
			otherwise it returns the value assigned to the MovableObjectFactory.
			Custom objects which don't use MovableObjectFactory will need to 
			override this if they want to be included in queries.

</member>
        <member name="M:Ogre.MovableObject.getPointExtrusionDistance(Ogre.Light!System.Runtime.CompilerServices.IsConst*)">
Get the distance to extrude for a point/spot light 
</member>
        <member name="M:Ogre.MovableObject.getReceivesShadows">
Returns whether the Material of any Renderable that this MovableObject will add to 
			the render queue will receive shadows. 

</member>
        <member name="M:Ogre.MovableObject.getCastShadows">
Returns whether shadow casting is enabled for this object. 
</member>
        <member name="M:Ogre.MovableObject.setCastShadows(System.Boolean)">
Sets whether or not this object will cast shadows.
        @remarks
        This setting simply allows you to turn on/off shadows for a given object.
        An object will not cast shadows unless the scene supports it in any case
        (see SceneManager::setShadowTechnique), and also the material which is
        in use must also have shadow casting enabled. By default all entities cast
        shadows. If, however, for some reason you wish to disable this for a single 
        object then you can do so using this method.
        @note This method normally refers to objects which block the light, but
        since Light is also a subclass of MovableObject, in that context it means
        whether the light causes shadows itself.

</member>
        <member name="M:Ogre.MovableObject.getDarkCapBounds(Ogre.Light!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Overridden member from ShadowCaster. 
</member>
        <member name="M:Ogre.MovableObject.getLightCapBounds">
Overridden member from ShadowCaster. 
</member>
        <member name="M:Ogre.MovableObject.getShadowVolumeRenderableIterator(Ogre.ShadowTechnique,Ogre.Light!System.Runtime.CompilerServices.IsConst*,Ogre.HardwareIndexBufferSharedPtr*,System.Boolean,System.Single,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Define a default implementation of method from ShadowCaster which implements no shadows
</member>
        <member name="M:Ogre.MovableObject.hasEdgeList">
Define a default implementation of method from ShadowCaster which implements no shadows
</member>
        <member name="M:Ogre.MovableObject.getEdgeList">
Define a default implementation of method from ShadowCaster which implements no shadows
</member>
        <member name="M:Ogre.MovableObject._getLightList">
Returns a pointer to the current list of lights for this object.
		@remarks
			You should not modify this list outside of MovableObject::Listener::objectQueryLights
			(say if you want to use it to implement this method, and use the pointer
			as a return value) and for reading it's only accurate as at the last frame.

</member>
        <member name="M:Ogre.MovableObject.setLightMask(System.UInt32)">
Set a bitwise mask which will filter the lights affecting this object
		@remarks
		This mask will be compared against the mask held against Light to determine
		if a light should affect a given object. 
		By default, this mask is fully set meaning all lights will affect this object

</member>
        <member name="M:Ogre.MovableObject.getLightMask">
Get a bitwise mask which will filter the lights affecting this object
		@remarks
		By default, this mask is fully set meaning all lights will affect this object

</member>
        <member name="M:Ogre.MovableObject.queryLights">
Gets a list of lights, ordered relative to how close they are to this movable object.
        @remarks
            By default, this method gives the listener a chance to populate light list first,
            if there is no listener or Listener::objectQueryLights returns NULL, it'll
            query the light list from parent entity if it is present, or returns
            SceneNode::findLights if it has parent scene node, otherwise it just returns
            an empty list.
        @par
            The object internally caches the light list, so it will recalculate
			it only when object is moved, or lights that affect the frustum have
			been changed (@see SceneManager::_getLightsDirtyCounter),
            but if listener exists, it will be called each time, so the listener 
			should implement their own cache mechanism to optimise performance.
        @par
            This method can be useful when implementing Renderable::getLights in case
            the renderable is a part of the movable.
        @returns The list of lights use to lighting this object.

</member>
        <member name="M:Ogre.MovableObject.getListener">
Gets the current listener for this object.

</member>
        <member name="M:Ogre.MovableObject.setListener(Ogre.MovableObject.Listener*)">
Sets a listener for this object.
        @remarks
            Note for size and performance reasons only one listener per object
            is allowed.

</member>
        <member name="M:Ogre.MovableObject.getDefaultVisibilityFlags">
Get the default visibility flags for all future MovableObject instances.

</member>
        <member name="M:Ogre.MovableObject.setDefaultVisibilityFlags(System.UInt32)">
Set the default visibility flags for all future MovableObject instances.

</member>
        <member name="M:Ogre.MovableObject.getVisibilityFlags">
Returns the visibility flags relevant for this object
</member>
        <member name="M:Ogre.MovableObject.removeVisibilityFlags(System.UInt32)">
As setVisibilityFlags, except the flags passed as parameters are removed from the
        existing flags on this object. 
</member>
        <member name="M:Ogre.MovableObject.addVisibilityFlags(System.UInt32)">
As setVisibilityFlags, except the flags passed as parameters are appended to the
        existing flags on this object. 
</member>
        <member name="M:Ogre.MovableObject.setVisibilityFlags(System.UInt32)">
Sets the visiblity flags for this object.
        @remarks
			As well as a simple true/false value for visibility (as seen in setVisible), 
			you can also set visiblity flags which when 'and'ed with the SceneManager's
			visibility mask can also make an object invisible.

</member>
        <member name="M:Ogre.MovableObject.getDefaultQueryFlags">
Get the default query flags for all future MovableObject instances.

</member>
        <member name="M:Ogre.MovableObject.setDefaultQueryFlags(System.UInt32)">
Set the default query flags for all future MovableObject instances.

</member>
        <member name="M:Ogre.MovableObject.getQueryFlags">
Returns the query flags relevant for this object
</member>
        <member name="M:Ogre.MovableObject.removeQueryFlags(System.UInt32!System.Runtime.CompilerServices.IsLong)">
As setQueryFlags, except the flags passed as parameters are removed from the
        existing flags on this object. 
</member>
        <member name="M:Ogre.MovableObject.addQueryFlags(System.UInt32)">
As setQueryFlags, except the flags passed as parameters are appended to the
        existing flags on this object. 
</member>
        <member name="M:Ogre.MovableObject.setQueryFlags(System.UInt32)">
Sets the query flags for this object.
        @remarks
            When performing a scene query, this object will be included or excluded according
            to flags on the object and flags on the query. This is a bitwise value, so only when
            a bit on these flags is set, will it be included in a query asking for that flag. The
            meaning of the bits is application-specific.

</member>
        <member name="M:Ogre.MovableObject._getParentNodeFullTransform">
return the full transformation of the parent sceneNode or the attachingPoint node
</member>
        <member name="M:Ogre.MovableObject.getRenderQueueGroup">
Gets the queue group for this entity, see setRenderQueueGroup for full details. 
</member>
        <member name="M:Ogre.MovableObject.setRenderQueueGroupAndPriority(System.Byte,System.UInt16)">
Sets the render queue group and group priority this entity will be rendered through.
		@remarks
			Render queues are grouped to allow you to more tightly control the ordering
			of rendered objects. Within a single render group there another type of grouping
			called priority which allows further control.  If you do not call this method, 
			all Entity objects default to the default queue and priority 
			(RenderQueue::getDefaultQueueGroup, RenderQueue::getDefaultRenderablePriority), 
			which is fine for most objects. You may want to alter this if you want this entity 
			to always appear in front of other objects, e.g. for a 3D menu system or such.
		@par
			See RenderQueue for more details.
		@param queueID Enumerated value of the queue group to use. See the
			enum RenderQueueGroupID for what kind of values can be used here.
		@param priority The priority within a group to use.

</member>
        <member name="M:Ogre.MovableObject.setRenderQueueGroup(System.Byte)">
Sets the render queue group this entity will be rendered through.
        @remarks
            Render queues are grouped to allow you to more tightly control the ordering
            of rendered objects. If you do not call this method, all Entity objects default
            to the default queue (RenderQueue::getDefaultQueueGroup), which is fine for most objects. You may want to alter this
            if you want this entity to always appear in front of other objects, e.g. for
            a 3D menu system or such.
        @par
            See RenderQueue for more details.
        @param queueID Enumerated value of the queue group to use. See the
			enum RenderQueueGroupID for what kind of values can be used here.

</member>
        <member name="M:Ogre.MovableObject.getUserObjectBindings">
Return an instance of user objects binding associated with this class.
		You can use it to associate one or more custom objects with this class instance.
		@see UserObjectBindings::setUserAny.		


Return an instance of user objects binding associated with this class.
		You can use it to associate one or more custom objects with this class instance.
		@see UserObjectBindings::setUserAny.		

</member>
        <member name="M:Ogre.MovableObject.getUserAny">
@deprecated use UserObjectBindings::getUserAny via getUserObjectBindings() instead.
			Retrieves the custom user value associated with this object.

</member>
        <member name="M:Ogre.MovableObject.setUserAny(Ogre.Any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@deprecated use UserObjectBindings::setUserAny via getUserObjectBindings() instead.
			Sets any kind of user value on this object.
		@remarks
			This method allows you to associate any user value you like with 
			this MovableObject. This can be a pointer back to one of your own
			classes for instance.		

</member>
        <member name="M:Ogre.MovableObject.getRenderingDistance">
Gets the distance at which batches are no longer rendered. 
</member>
        <member name="M:Ogre.MovableObject.setRenderingDistance(System.Single)">
Sets the distance at which the object is no longer rendered.
		@param dist Distance beyond which the object will not be rendered 
			(the default is 0, which means objects are always rendered).

</member>
        <member name="M:Ogre.MovableObject.isVisible">
Returns whether or not this object is supposed to be visible or not. 
		@remarks
			Takes into account both upper rendering distance and visible flag.

</member>
        <member name="M:Ogre.MovableObject.getVisible">
Gets this object whether to be visible or not, if it has a renderable component. 
        @remarks
            Returns the value set by MovableObject::setVisible only.

</member>
        <member name="M:Ogre.MovableObject.setVisible(System.Boolean)">
Tells this object whether to be visible or not, if it has a renderable component. 
		@note An alternative approach of making an object invisible is to detach it
			from it's SceneNode, or to remove the SceneNode entirely. 
			Detaching a node means that structurally the scene graph changes. 
			Once this change has taken place, the objects / nodes that have been 
			removed have less overhead to the visibility detection pass than simply
			making the object invisible, so if you do this and leave the objects 
			out of the tree for a long time, it's faster. However, the act of 
			detaching / reattaching nodes is in itself more expensive than 
			setting an object visibility flag, since in the latter case 
			structural changes are not made. Therefore, small or frequent visibility
			changes are best done using this method; large or more longer term
			changes are best done by detaching.

</member>
        <member name="M:Ogre.MovableObject._updateRenderQueue(Ogre.RenderQueue*)">
Internal method by which the movable object must add Renderable subclass instances to the rendering queue.
            @remarks
                The engine will call this method when this object is to be rendered. The object must then create one or more
                Renderable subclass instances which it places on the passed in Queue for rendering.

</member>
        <member name="M:Ogre.MovableObject.getWorldBoundingSphere(System.Boolean)">
Retrieves the worldspace bounding sphere for this object. 
</member>
        <member name="M:Ogre.MovableObject.getWorldBoundingBox(System.Boolean)">
Retrieves the axis-aligned bounding box for this object in world coordinates. 
</member>
        <member name="M:Ogre.MovableObject.getBoundingRadius">
Retrieves the radius of the origin-centered bounding sphere 
		 	 for this object.

</member>
        <member name="M:Ogre.MovableObject.getBoundingBox">
Retrieves the local axis-aligned bounding box for this object.
            @remarks
                This bounding box is in local coordinates.

</member>
        <member name="M:Ogre.MovableObject._notifyCurrentCamera(Ogre.Camera*)">
Internal method to notify the object of the camera to be used for the next rendering operation.
            @remarks
                Certain objects may want to do specific processing based on the camera position. This method notifies
                them in case they wish to do this.

</member>
        <member name="M:Ogre.MovableObject._notifyMoved">
Internal method called to notify the object that it has been moved.

</member>
        <member name="M:Ogre.MovableObject.isInScene">
Returns true if this object is attached to a SceneNode or TagPoint, 
			and this SceneNode / TagPoint is currently in an active part of the
			scene graph. 
</member>
        <member name="M:Ogre.MovableObject.detachFromParent">
Detaches an object from a parent SceneNode or TagPoint, if attached. 
</member>
        <member name="M:Ogre.MovableObject.isAttached">
Returns true if this object is attached to a SceneNode or TagPoint. 
</member>
        <member name="M:Ogre.MovableObject._notifyAttached(Ogre.Node*,System.Boolean)">
Internal method called to notify the object that it has been attached to a node.

</member>
        <member name="M:Ogre.MovableObject.isParentTagPoint">
Gets whether the parent node is a TagPoint (or a SceneNode)
</member>
        <member name="M:Ogre.MovableObject.getParentSceneNode">
Returns the scene node to which this object is attached.
        @remarks
            A MovableObject may be attached to either a SceneNode or to a TagPoint, 
            the latter case if it's attached to a bone on an animated entity. 
            This method will return the scene node of the parent entity 
            if the latter is true.

</member>
        <member name="M:Ogre.MovableObject.getParentNode">
Returns the node to which this object is attached.
        @remarks
            A MovableObject may be attached to either a SceneNode or to a TagPoint, 
            the latter case if it's attached to a bone on an animated entity. 
            Both are Node subclasses so this method will return either.

</member>
        <member name="M:Ogre.MovableObject.getMovableType">
Returns the type name of this object. 
</member>
        <member name="M:Ogre.MovableObject.getName">
Returns the name of this object. 
</member>
        <member name="M:Ogre.MovableObject._getManager">
Get the manager of this object, if any (internal use only) 
</member>
        <member name="M:Ogre.MovableObject._notifyManager(Ogre.SceneManager*)">
Notify the object of it's manager (internal use only) 
</member>
        <member name="M:Ogre.MovableObject._getCreator">
Get the creator of this object, if any (internal use only) 
</member>
        <member name="M:Ogre.MovableObject._notifyCreator(Ogre.MovableObjectFactory*)">
Notify the object of it's creator (internal use only) 
</member>
        <member name="M:Ogre.MovableObject.Dispose">
Virtual destructor - read Scott Meyers if you don't know why this is needed.

</member>
        <member name="M:Ogre.MovableObject.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Named constructor
</member>
        <member name="M:Ogre.MovableObject.#ctor">
Constructor
</member>
        <member name="F:Ogre.MovableObject.msDefaultVisibilityFlags">
Default visibility flags
</member>
        <member name="F:Ogre.MovableObject.msDefaultQueryFlags">
Default query flags
</member>
        <member name="F:Ogre.MovableObject.mLightMask">
the light mask defined for this movable. This will be taken into consideration when deciding which light should affect this movable
</member>
        <member name="F:Ogre.MovableObject.mLightListUpdated">
The last frame that this light list was updated in
</member>
        <member name="F:Ogre.MovableObject.mLightList">
List of lights for this object
</member>
        <member name="F:Ogre.MovableObject.mRenderingDisabled">
Does rendering this object disabled by listener?
</member>
        <member name="F:Ogre.MovableObject.mCastShadows">
Does this object cast shadows?
</member>
        <member name="F:Ogre.MovableObject.mWorldDarkCapBounds">
World space AABB of this object's dark cap
</member>
        <member name="F:Ogre.MovableObject.mWorldAABB">
Cached world AABB of this object
</member>
        <member name="F:Ogre.MovableObject.mVisibilityFlags">
Flags determining whether this object is visible (compared to SceneManager mask)
</member>
        <member name="F:Ogre.MovableObject.mQueryFlags">
Flags determining whether this object is included / excluded from scene queries
</member>
        <member name="F:Ogre.MovableObject.mRenderQueuePrioritySet">
Flags whether the RenderQueue's default should be used.
</member>
        <member name="F:Ogre.MovableObject.mRenderQueuePriority">
The render queue group to use when rendering this object
</member>
        <member name="F:Ogre.MovableObject.mRenderQueueIDSet">
Flags whether the RenderQueue's default should be used.
</member>
        <member name="F:Ogre.MovableObject.mRenderQueueID">
The render queue to use when rendering this object
</member>
        <member name="F:Ogre.MovableObject.mUserObjectBindings">
User objects binding.
</member>
        <member name="F:Ogre.MovableObject.mBeyondFarDistance">
Hidden because of distance?
</member>
        <member name="F:Ogre.MovableObject.mUpperDistance">
Upper distance to still render
</member>
        <member name="F:Ogre.MovableObject.mDebugDisplay">
Is debug display enabled?
</member>
        <member name="F:Ogre.MovableObject.mVisible">
Is this object visible?
</member>
        <member name="F:Ogre.MovableObject.mParentNode">
node to which this object is attached
</member>
        <member name="F:Ogre.MovableObject.mManager">
SceneManager holding this object (if applicable)
</member>
        <member name="F:Ogre.MovableObject.mCreator">
Creator of this object (if created by a factory)
</member>
        <member name="F:Ogre.MovableObject.mName">
Name of this object
</member>
        <member name="M:Ogre.MovableObject.Listener.objectQueryLights(Ogre.MovableObject!System.Runtime.CompilerServices.IsConst*)">
Called when the movable object needs to query a light list.
            @remarks
                If you want to customize light finding for this object, you should override 
				this method and hook into MovableObject via MovableObject::setListener.
				Be aware that the default method caches results within a frame to 
				prevent unnecessary recalculation, so if you override this you 
				should provide your own caching to maintain performance.
			@note
				If you use texture shadows, there is an additional restriction - 
				since the lights which should have shadow textures rendered for
				them are determined based on the entire frustum, and not per-object,
				it is important that the lights returned at the start of this 
				list (up to the number of shadow textures available) are the same 
				lights that were used to generate the shadow textures, 
				and they are in the same order (particularly for additive effects).
			@note
				This method will not be called for additive stencil shadows since the
				light list cannot be varied per object with this technique.
            @returns
                A pointer to a light list if you populated the light list yourself, or
                NULL to fall back on the default finding process.

</member>
        <member name="M:Ogre.MovableObject.Listener.objectRendering(Ogre.MovableObject!System.Runtime.CompilerServices.IsConst*,Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Called when the movable object of the camera to be used for rendering.
            @returns
                true if allows queue for rendering, false otherwise.

</member>
        <member name="M:Ogre.MovableObject.Listener.objectMoved(Ogre.MovableObject*)">
MovableObject has been moved 
</member>
        <member name="M:Ogre.MovableObject.Listener.objectDetached(Ogre.MovableObject*)">
MovableObject has been detached from a node 
</member>
        <member name="M:Ogre.MovableObject.Listener.objectAttached(Ogre.MovableObject*)">
MovableObject has been attached to a node 
</member>
        <member name="M:Ogre.MovableObject.Listener.objectDestroyed(Ogre.MovableObject*)">
MovableObject is being destroyed 
</member>
        <member name="T:Ogre.MovableObject.Listener">
Listener which gets called back on MovableObject events.

</member>
        <member name="T:Ogre.MovableObject">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Abstract class defining a movable object in a scene.
        @remarks
            Instances of this class are discrete, relatively small, movable objects
            which are attached to SceneNode objects to define their position.

</member>
        <member name="M:Ogre.ShadowCaster.extrudeBounds(Ogre.AxisAlignedBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Utility method for extruding a bounding box. 
        @param box Original bounding box, will be updated in-place
        @param lightPos 4D light position in object space, when w=0.0f this
        represents a directional light
        @param extrudeDist The distance to extrude

</member>
        <member name="M:Ogre.ShadowCaster.generateShadowVolume(Ogre.EdgeData*,Ogre.HardwareIndexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Light!System.Runtime.CompilerServices.IsConst*,std.vector&lt;Ogre.ShadowRenderable**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Generates the indexes required to render a shadow volume into the 
            index buffer which is passed in, and updates shadow renderables
            to use it.
        @param edgeData The edge information to use
        @param indexBuffer The buffer into which to write data into; current 
            contents are assumed to be discardable.
        @param light The light, mainly for type info as silhouette calculations
            should already have been done in updateEdgeListLightFacing
        @param shadowRenderables A list of shadow renderables which has 
            already been constructed but will need populating with details of
            the index ranges to be used.
        @param flags Additional controller flags, see ShadowRenderableFlags

</member>
        <member name="M:Ogre.ShadowCaster.updateEdgeListLightFacing(Ogre.EdgeData*,Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tells the caster to perform the tasks necessary to update the 
            edge data's light listing. Can be overridden if the subclass needs 
            to do additional things. 
        @param edgeData The edge information to update
        @param lightPos 4D vector representing the light, a directional light
            has w=0.0

</member>
        <member name="M:Ogre.ShadowCaster.getExtrusionDistance(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Light!System.Runtime.CompilerServices.IsConst*)">
Helper method for calculating extrusion distance
</member>
        <member name="M:Ogre.ShadowCaster.getPointExtrusionDistance(Ogre.Light!System.Runtime.CompilerServices.IsConst*)">
Get the distance to extrude for a point/spot light 
</member>
        <member name="M:Ogre.ShadowCaster.extrudeVertices(Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Utility method for extruding vertices based on a light. 
        @remarks
            Unfortunately, because D3D cannot handle homogeneous (4D) position
            coordinates in the fixed-function pipeline (GL can, but we have to
            be cross-API), when we extrude in software we cannot extrude to 
            infinity the way we do in the vertex program (by setting w to
            0.0f). Therefore we extrude by a fixed distance, which may cause 
            some problems with larger scenes. Luckily better hardware (ie
            vertex programs) can fix this.
        @param vertexBuffer The vertex buffer containing ONLY xyz position
        values, which must be originalVertexCount * 2 * 3 floats long.
        @param originalVertexCount The count of the original number of
        vertices, i.e. the number in the mesh, not counting the doubling
        which has already been done (by VertexData::prepareForShadowVolume)
        to provide the extruded area of the buffer.
        @param lightPos 4D light position in object space, when w=0.0f this
        represents a directional light
        @param extrudeDist The distance to extrude

</member>
        <member name="M:Ogre.ShadowCaster.getShadowVolumeRenderableIterator(Ogre.ShadowTechnique,Ogre.Light!System.Runtime.CompilerServices.IsConst*,Ogre.HardwareIndexBufferSharedPtr*,System.Boolean,System.Single,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Gets an iterator over the renderables required to render the shadow volume. 
        @remarks
            Shadowable geometry should ideally be designed such that there is only one
            ShadowRenderable required to render the the shadow; however this is not a necessary
            limitation and it can be exceeded if required.
        @param shadowTechnique The technique being used to generate the shadow
        @param light The light to generate the shadow from
        @param indexBuffer The index buffer to build the renderables into, 
            the current contents are assumed to be disposable.
        @param extrudeVertices If true, this means this class should extrude
            the vertices of the back of the volume in software. If false, it
            will not be done (a vertex program is assumed).
        @param extrusionDistance The distance to extrude the shadow volume
        @param flags Technique-specific flags, see ShadowRenderableFlags

</member>
        <member name="M:Ogre.ShadowCaster.getDarkCapBounds(Ogre.Light!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Gets the world space bounding box of the dark cap, as extruded using the light provided 
</member>
        <member name="M:Ogre.ShadowCaster.getLightCapBounds">
Gets the world space bounding box of the light cap 
</member>
        <member name="M:Ogre.ShadowCaster.getWorldBoundingBox(System.Boolean)">
Get the world bounding box of the caster. 
</member>
        <member name="M:Ogre.ShadowCaster.hasEdgeList">
Returns whether the object has a valid edge list. 
</member>
        <member name="M:Ogre.ShadowCaster.getEdgeList">
Returns details of the edges which might be used to determine a silhouette. 
</member>
        <member name="M:Ogre.ShadowCaster.getCastShadows">
Returns whether or not this object currently casts a shadow. 
</member>
        <member name="T:Ogre.ShadowCaster">
This class defines the interface that must be implemented by shadow casters.

</member>
        <member name="T:Ogre.ShadowRenderableFlags">
A set of flags that can be used to influence ShadowRenderable creation. 
</member>
        <member name="F:SRF_EXTRUDE_TO_INFINITY">
For shadow volume techniques only, indicates volume is extruded to infinity
</member>
        <member name="F:SRF_INCLUDE_DARK_CAP">
For shadow volume techniques only, generate a dark cap on the volume
</member>
        <member name="F:SRF_INCLUDE_LIGHT_CAP">
For shadow volume techniques only, generate a light cap on the volume
</member>
        <member name="M:Ogre.ShadowRenderable.isVisible">
Should this ShadowRenderable be treated as visible?
</member>
        <member name="M:Ogre.ShadowRenderable.getLightCapRenderable">
Get the light cap version of this renderable
</member>
        <member name="M:Ogre.ShadowRenderable.isLightCapSeparate">
Does this renderable require a separate light cap?
        @remarks
            If possible, the light cap (when required) should be contained in the
            usual geometry of the shadow renderable. However, if for some reason
            the normal depth function (less than) could cause artefacts, then a
            separate light cap with a depth function of 'always fail' can be used 
            instead. The primary example of this is when there are floating point
            inaccuracies caused by calculating the shadow geometry separately from
            the real geometry. 

</member>
        <member name="M:Ogre.ShadowRenderable.getLights">
Overridden from Renderable
</member>
        <member name="M:Ogre.ShadowRenderable.getSquaredViewDepth(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Overridden from Renderable
</member>
        <member name="M:Ogre.ShadowRenderable.getWorldTransforms(Ogre.Matrix4*)">
Overridden from Renderable
</member>
        <member name="M:Ogre.ShadowRenderable.getRenderOperationForUpdate">
Get the internal render operation for set up
</member>
        <member name="M:Ogre.ShadowRenderable.getRenderOperation(Ogre.RenderOperation*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Overridden from Renderable
</member>
        <member name="M:Ogre.ShadowRenderable.getMaterial">
Overridden from Renderable
</member>
        <member name="M:Ogre.ShadowRenderable.setMaterial(Ogre.MaterialPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the material to be used by the shadow, should be set by the caller 
          before adding to a render queue

</member>
        <member name="T:Ogre.ShadowRenderable">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Class which represents the renderable aspects of a set of shadow volume faces. 
    @remarks
        Note that for casters comprised of more than one set of vertex buffers (e.g. SubMeshes each
        using their own geometry), it will take more than one ShadowRenderable to render the 
        shadow volume. Therefore for shadow caster geometry, it is best to stick to one set of
        vertex buffers (not necessarily one buffer, but the positions for the entire geometry 
        should come from one buffer if possible)

</member>
        <member name="M:Ogre.Renderable.setRenderSystemData(Ogre.Renderable.RenderSystemData*)">
gets render system private data
		@remarks
		This should only be used by a render system

</member>
        <member name="M:Ogre.Renderable.getRenderSystemData">
Sets render system private data
		@remarks
		This should only be used by a render system

</member>
        <member name="M:Ogre.Renderable.Visitor.visit(Ogre.Renderable*,System.UInt16,System.Boolean,Ogre.Any*)">
Generic visitor method. 
			@param rend The Renderable instance being visited
			@param lodIndex The LOD index to which this Renderable belongs. Some
				objects support LOD and this will tell you whether the Renderable
				you're looking at is from the top LOD (0) or otherwise
			@param isDebug Whether this is a debug renderable or not.
			@param pAny Optional pointer to some additional data that the class
				calling the visitor may populate if it chooses to.

</member>
        <member name="M:Ogre.Renderable.Visitor.Dispose">
Virtual destructor needed as class has virtual methods. 
</member>
        <member name="T:Ogre.Renderable.Visitor">
Visitor object that can be used to iterate over a collection of Renderable
		instances abstractly.
		@remarks
		Different scene objects use Renderable differently; some will have a 
		single Renderable, others will have many. This visitor interface allows
		classes using Renderable to expose a clean way for external code to
		get access to the contained Renderable instance(s) that it will
		eventually add to the render queue.
		@par
		To actually have this method called, you have to call a method on the
		class containing the Renderable instances. One example is 
		MovableObject::visitRenderables.

</member>
        <member name="M:Ogre.Renderable.getUserObjectBindings">
Return an instance of user objects binding associated with this class.
		You can use it to associate one or more custom objects with this class instance.
		@see UserObjectBindings::setUserAny.


Return an instance of user objects binding associated with this class.
		You can use it to associate one or more custom objects with this class instance.
		@see UserObjectBindings::setUserAny.		

</member>
        <member name="M:Ogre.Renderable.getUserAny">
@deprecated use UserObjectBindings::getUserAny via getUserObjectBindings() instead.
			Retrieves the custom user value associated with this object.

</member>
        <member name="M:Ogre.Renderable.setUserAny(Ogre.Any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@deprecated use UserObjectBindings::setUserAny via getUserObjectBindings() instead.
			Sets any kind of user value on this object.
		@remarks
			This method allows you to associate any user value you like with 
			this Renderable. This can be a pointer back to one of your own
			classes for instance.

</member>
        <member name="M:Ogre.Renderable.getPolygonModeOverrideable">
Gets whether this renderable's chosen detail level can be
			overridden (downgraded) by the camera setting. 

</member>
        <member name="M:Ogre.Renderable.setPolygonModeOverrideable(System.Boolean)">
Sets whether this renderable's chosen detail level can be
			overridden (downgraded) by the camera setting. 
		@param override true means that a lower camera detail will override this
			renderables detail level, false means it won't.

</member>
        <member name="M:Ogre.Renderable._updateCustomGpuParameter(Ogre.GpuProgramParameters.AutoConstantEntry!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.GpuProgramParameters*)">
Update a custom GpuProgramParameters constant which is derived from 
            information only this Renderable knows.
        @remarks
            This method allows a Renderable to map in a custom GPU program parameter
            based on it's own data. This is represented by a GPU auto parameter
            of ACT_CUSTOM, and to allow there to be more than one of these per
            Renderable, the 'data' field on the auto parameter will identify
            which parameter is being updated. The implementation of this method
            must identify the parameter being updated, and call a 'setConstant' 
            method on the passed in GpuProgramParameters object, using the details
            provided in the incoming auto constant setting to identify the index
            at which to set the parameter.
        @par
            You do not need to override this method if you're using the standard
            sets of data associated with the Renderable as provided by setCustomParameter
            and getCustomParameter. By default, the implementation will map from the
            value indexed by the 'constantEntry.data' parameter to a value previously
            set by setCustomParameter. But custom Renderables are free to override
            this if they want, in any case.
        @param constantEntry The auto constant entry referring to the parameter
            being updated
        @param params The parameters object which this method should call to 
            set the updated parameters.

</member>
        <member name="M:Ogre.Renderable.getCustomParameter(System.UInt32)">
Gets the custom value associated with this Renderable at the given index.
        @param
            @see setCustomParaemter for full details.

</member>
        <member name="M:Ogre.Renderable.setCustomParameter(System.UInt32,Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets a custom parameter for this Renderable, which may be used to 
            drive calculations for this specific Renderable, like GPU program parameters.
        @remarks
            Calling this method simply associates a numeric index with a 4-dimensional
            value for this specific Renderable. This is most useful if the material
            which this Renderable uses a vertex or fragment program, and has an 
            ACT_CUSTOM parameter entry. This parameter entry can refer to the
            index you specify as part of this call, thereby mapping a custom
            parameter for this renderable to a program parameter.
        @param index The index with which to associate the value. Note that this
            does not have to start at 0, and can include gaps. It also has no direct
            correlation with a GPU program parameter index - the mapping between the
            two is performed by the ACT_CUSTOM entry, if that is used.
        @param value The value to associate.

</member>
        <member name="M:Ogre.Renderable.getCastsShadows">
Method which reports whether this renderable would normally cast a
            shadow. 
        @remarks
            Subclasses should override this if they could have been used to 
            generate a shadow.

</member>
        <member name="M:Ogre.Renderable.getLights">
Gets a list of lights, ordered relative to how close they are to this renderable.
        @remarks
            Directional lights, which have no position, will always be first on this list.

</member>
        <member name="M:Ogre.Renderable.getSquaredViewDepth(Ogre.Camera!System.Runtime.CompilerServices.IsConst*)">
Returns the camera-relative squared depth of this renderable.
		@remarks
			Used to sort transparent objects. Squared depth is used rather than
			actual depth to avoid having to perform a square root on the result.

</member>
        <member name="M:Ogre.Renderable.getUseIdentityView">
Returns whether or not to use an 'identity' view.
        @remarks
            Usually Renderable objects will use a view matrix as determined
            by the active camera. However, if they want they can cancel this out
            and use an identity matrix, which means all geometry is assumed
            to be relative to camera space already. Useful for overlay rendering. 
            Normal renderables need not change this.
        @see Renderable::setUseIdentityView

</member>
        <member name="M:Ogre.Renderable.setUseIdentityView(System.Boolean)">
Sets whether or not to use an 'identity' view.
        @remarks
            Usually Renderable objects will use a view matrix as determined
            by the active camera. However, if they want they can cancel this out
            and use an identity matrix, which means all geometry is assumed
            to be relative to camera space already. Useful for overlay rendering. 
            Normal renderables need not change this. The default is false.
        @see Renderable::getUseIdentityView

</member>
        <member name="M:Ogre.Renderable.getUseIdentityProjection">
Returns whether or not to use an 'identity' projection.
        @remarks
            Usually Renderable objects will use a projection matrix as determined
            by the active camera. However, if they want they can cancel this out
            and use an identity projection, which effectively projects in 2D using
            a {-1, 1} view space. Useful for overlay rendering. Normal renderables
            need not change this.
        @see Renderable::setUseIdentityProjection

</member>
        <member name="M:Ogre.Renderable.setUseIdentityProjection(System.Boolean)">
Sets whether or not to use an 'identity' projection.
        @remarks
            Usually Renderable objects will use a projection matrix as determined
            by the active camera. However, if they want they can cancel this out
            and use an identity projection, which effectively projects in 2D using
            a {-1, 1} view space. Useful for overlay rendering. Normal renderables
            need not change this. The default is false.
        @see Renderable::getUseIdentityProjection

</member>
        <member name="M:Ogre.Renderable.getNumWorldTransforms">
Returns the number of world transform matrices this renderable requires.
        @remarks
            When a renderable uses vertex blending, it uses multiple world matrices instead of a single
            one. Each vertex sent to the pipeline can reference one or more matrices in this list
            with given weights.
            If a renderable does not use vertex blending this method returns 1, which is the default for 
            simplicity.

</member>
        <member name="M:Ogre.Renderable.getWorldTransforms(Ogre.Matrix4*)">
Gets the world transform matrix / matrices for this renderable object.
            @remarks
                If the object has any derived transforms, these are expected to be up to date as long as
                all the SceneNode structures have been updated before this is called.
            @par
                This method will populate xform with 1 matrix if it does not use vertex blending. If it
                does use vertex blending it will fill the passed in pointer with an array of matrices,
                the length being the value returned from getNumWorldTransforms.
            @note
                Internal Ogre never supports non-affine matrix for world transform matrix/matrices,
                the behavior is undefined if returns non-affine matrix here. @see Matrix4::isAffine.

</member>
        <member name="M:Ogre.Renderable.postRender(Ogre.SceneManager*,Ogre.RenderSystem*)">
Called immediately after the Renderable has been rendered. 

</member>
        <member name="M:Ogre.Renderable.getRenderOperation(Ogre.RenderOperation*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the render operation required to send this object to the frame buffer.

</member>
        <member name="M:Ogre.Renderable.getTechnique">
Retrieves a pointer to the Material Technique this renderable object uses.
        @remarks
            This is to allow Renderables to use a chosen Technique if they wish, otherwise
            they will use the best Technique available for the Material they are using.

</member>
        <member name="M:Ogre.Renderable.getMaterial">
Retrieves a weak reference to the material this renderable object uses.
        @remarks
            Note that the Renderable also has the option to override the getTechnique method
            to specify a particular Technique to use instead of the best one available.

</member>
        <member name="M:Ogre.Renderable.Dispose">
Virtual destructor needed as class has virtual methods. 
</member>
        <member name="T:Ogre.Renderable.RenderSystemData">
An internal class that should be used only by a render system for internal use 
		@remarks
		This class was created so a render system can associate internal data to this class.
		The need for this class started when the DX10 render system needed to save state objects.

</member>
        <member name="T:Ogre.Renderable">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Abstract class defining the interface all renderable objects must implement.
        @remarks
            This interface abstracts renderable discrete objects which will be queued in the render pipeline,
            grouped by material. Classes implementing this interface must be based on a single material, a single
            world matrix (or a collection of world matrices which are blended by weights), and must be 
            renderable via a single render operation.
        @par
            Note that deciding whether to put these objects in the rendering pipeline is done from the more specific
            classes e.g. entities. Only once it is decided that the specific class is to be rendered is the abstract version
            created (could be more than one per visible object) and pushed onto the rendering queue.

</member>
        <member name="M:Ogre.UserObjectBindings.Attributes.Dispose">
Attribute storage dtor. 
</member>
        <member name="M:Ogre.UserObjectBindings.Attributes.#ctor">
Attribute storage ctor. 
</member>
        <member name="T:Ogre.UserObjectBindings.Attributes">
Internal class that uses as data storage container.

</member>
        <member name="M:Ogre.UserObjectBindings.getEmptyUserAny">
Returns empty user any object.

</member>
        <member name="M:Ogre.UserObjectBindings.clear">
Clear all user objects from this binding.	
</member>
        <member name="M:Ogre.UserObjectBindings.eraseUserAny(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Erase the custom user object associated with this class and key from this binding.
		@param key The key that the requested user object is associated with.		

</member>
        <member name="M:Ogre.UserObjectBindings.getUserAny(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves the custom user object associated with this class and key.
		@param key The key that the requested user object is associated with.
		@remarks
		In case no object associated with this key the returned Any object will be empty.

</member>
        <member name="M:Ogre.UserObjectBindings.setUserAny(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets any kind of user object on this class instance.
		@remarks
		This method allows you to associate multiple object with this class. 
		This can be a pointer back to one of your own classes for instance.
		Use a unique key to distinguish between each of these objects. 
		@param key The key that this data is associate with.
		@param anything The data to associate with the given key.

</member>
        <member name="M:Ogre.UserObjectBindings.getUserAny">
Retrieves the custom key less user object associated with this class.

</member>
        <member name="M:Ogre.UserObjectBindings.setUserAny(Ogre.Any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets any kind of user object on this class instance.
		@remarks
		This method allows you to associate any user object you like with 
		this class. This can be a pointer back to one of your own
		classes for instance.
		@note This method is key less meaning that each call for it will override
		previous object that were set. If you need to associate multiple objects
		with this class use the extended version that takes key.

</member>
        <member name="M:Ogre.UserObjectBindings.Dispose">
Class destructor. 
</member>
        <member name="M:Ogre.UserObjectBindings.#ctor">
Class constructor. 
</member>
        <member name="T:Ogre.UserObjectBindings">
\addtogroup Core
	*  @{

\addtogroup Scene
	*  @{

Class that provide convenient interface to establish a linkage between
	custom user application objects and Ogre core classes.
	Any instance of Ogre class that will derive from this class could be associated with custom 
	application object using this class interface.

</member>
        <member name="M:Ogre.GpuProgramPtr.op_Assign(Ogre.HighLevelGpuProgramPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Operator used to convert a HighLevelGpuProgramPtr to a GpuProgramPtr
</member>
        <member name="M:Ogre.GpuProgramPtr.op_Assign(Ogre.SharedPtr&lt;Ogre.Resource&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Operator used to convert a ResourcePtr to a GpuProgramPtr
</member>
        <member name="M:Ogre.GpuProgram.loadFromSource">
Virtual method which must be implemented by subclasses, load from mSource
</member>
        <member name="M:Ogre.GpuProgram.getConstantDefinitions">
Get the full list of named constants.
		@note
		Only available if this parameters object has named parameters, which means either
		a high-level program which loads them, or a low-level program which has them
		specified manually.

</member>
        <member name="M:Ogre.GpuProgram.getManualNamedConstantsFile">
Gets the name of a file from which to load named parameters mapping
			for a program which would not be able to derive named parameters itself.

</member>
        <member name="M:Ogre.GpuProgram.setManualNamedConstantsFile(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Specifies the name of a file from which to load named parameters mapping
			for a program which would not be able to derive named parameters itself.
		@remarks
			You may wish to use this if you have assembler programs that were compiled
			from a high-level source, and want the convenience of still being able
			to use the named parameters from the original high-level source. This
			method will make a low-level program search in the resource group of the
			program for the named file from which to load parameter names from. 
			The file must be in the format produced by GpuNamedConstants::save.

</member>
        <member name="M:Ogre.GpuProgram.getNamedConstants">
Get a read-only reference to the named constants registered for this program (manually or automatically)
</member>
        <member name="M:Ogre.GpuProgram.setManualNamedConstants(Ogre.GpuNamedConstants!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Allows you to manually provide a set of named parameter mappings
			to a program which would not be able to derive named parameters itself.
		@remarks
			You may wish to use this if you have assembler programs that were compiled
			from a high-level source, and want the convenience of still being able
			to use the named parameters from the original high-level source.
		@see setManualNamedConstantsFile

</member>
        <member name="M:Ogre.GpuProgram.resetCompileError">
Reset a compile error if it occurred, allowing the load to be retried

</member>
        <member name="M:Ogre.GpuProgram.hasCompileError">
Did this program encounter a compile error when loading?

</member>
        <member name="M:Ogre.GpuProgram.getLanguage">
Returns a string that specifies the language of the gpu programs as specified
        in a material script. ie: asm, cg, hlsl, glsl

</member>
        <member name="M:Ogre.GpuProgram.getPassTransformStates">
Returns whether a vertex program wants transform state to be passed
		through fixed pipeline low level API rendering calls
		@remarks
		Most vertex programs do not need fixed-function transform information, however GLSL
		shaders can refer to this state so enable this option

</member>
        <member name="M:Ogre.GpuProgram.getPassFogStates">
Returns whether a fragment program wants fog state to be passed
		through fixed pipeline low level API rendering calls (default true, subclasses can override)
		@remarks
		On DirectX, shader model 2 and earlier continues to have fixed-function fog
		applied to it, so fog state is still passed (you should disable fog on the
		pass if you want to perform fog in the shader). In OpenGL it is also
		common to be able to access the fixed-function fog state inside the shader. 

</member>
        <member name="M:Ogre.GpuProgram.getPassSurfaceAndLightStates">
Returns whether a vertex program wants light and material states to be passed
		through fixed pipeline low level API rendering calls (default false, subclasses can override)
		@remarks
			Most vertex programs do not need this material information, however GLSL
			shaders can refer to this material and lighting state so enable this option

</member>
        <member name="M:Ogre.GpuProgram.hasDefaultParameters">
Returns true if default parameters have been set up.  

</member>
        <member name="M:Ogre.GpuProgram.getDefaultParameters">
Get a reference to the default parameters which are to be used for all
			uses of this program.
		@remarks
			A program can be set up with a list of default parameters, which can save time when 
			using a program many times in a material with roughly the same settings. By 
			retrieving the default parameters and populating it with the most used options, 
			any new parameter objects created from this program afterwards will automatically include
			the default parameters; thus users of the program need only change the parameters
			which are unique to their own usage of the program.

</member>
        <member name="M:Ogre.GpuProgram.isAdjacencyInfoRequired">
Returns whether this geometry program requires adjacency information 
			from the input primitives.

</member>
        <member name="M:Ogre.GpuProgram.setAdjacencyInfoRequired(System.Boolean)">
Sets whether this geometry program requires adjacency information
			from the input primitives.

</member>
        <member name="M:Ogre.GpuProgram.isVertexTextureFetchRequired">
Returns whether this vertex program requires support for vertex 
			texture fetch from the hardware.

</member>
        <member name="M:Ogre.GpuProgram.setVertexTextureFetchRequired(System.Boolean)">
Sets whether this vertex program requires support for vertex 
			texture fetch from the hardware.

</member>
        <member name="M:Ogre.GpuProgram.getNumberOfPosesIncluded">
Returns the number of simultaneous poses the vertex program can 
			blend, for use in pose animation.

</member>
        <member name="M:Ogre.GpuProgram.isPoseAnimationIncluded">
Returns whether a vertex program includes the required instructions
            to perform pose animation. 
        @remarks
            If this returns true, OGRE will not blend the geometry according to 
            pose animation, it will expect the vertex program to do it.

</member>
        <member name="M:Ogre.GpuProgram.isMorphAnimationIncluded">
Returns whether a vertex program includes the required instructions
            to perform morph animation. 
        @remarks
            If this returns true, OGRE will not blend the geometry according to 
            morph animation, it will expect the vertex program to do it.

</member>
        <member name="M:Ogre.GpuProgram.setPoseAnimationIncluded(System.UInt16)">
Sets whether a vertex program includes the required instructions
        to perform pose animation. 
        @remarks
        If this is set to true, OGRE will not blend the geometry according to 
        pose animation, it will expect the vertex program to do it.
		@param poseCount The number of simultaneous poses the program can blend

</member>
        <member name="M:Ogre.GpuProgram.setMorphAnimationIncluded(System.Boolean)">
Sets whether a vertex program includes the required instructions
        to perform morph animation. 
        @remarks
        If this is set to true, OGRE will not blend the geometry according to 
        morph animation, it will expect the vertex program to do it.

</member>
        <member name="M:Ogre.GpuProgram.isSkeletalAnimationIncluded">
Returns whether a vertex program includes the required instructions
            to perform skeletal animation. 
        @remarks
            If this returns true, OGRE will not blend the geometry according to 
            skeletal animation, it will expect the vertex program to do it.

</member>
        <member name="M:Ogre.GpuProgram.setSkeletalAnimationIncluded(System.Boolean)">
Sets whether a vertex program includes the required instructions
        to perform skeletal animation. 
        @remarks
        If this is set to true, OGRE will not blend the geometry according to 
        skeletal animation, it will expect the vertex program to do it.

</member>
        <member name="M:Ogre.GpuProgram.createParameters">
Creates a new parameters object compatible with this program definition. 
        @remarks
            It is recommended that you use this method of creating parameters objects
            rather than going direct to GpuProgramManager, because this method will
            populate any implementation-specific extras (like named parameters) where
            they are appropriate.

</member>
        <member name="M:Ogre.GpuProgram.isSupported">
Returns whether this program can be supported on the current renderer and hardware. 
</member>
        <member name="M:Ogre.GpuProgram._getBindingDelegate">
Returns the GpuProgram which should be bound to the pipeline.
        @remarks
            This method is simply to allow some subclasses of GpuProgram to delegate
            the program which is bound to the pipeline to a delegate, if required. 
</member>
        <member name="M:Ogre.GpuProgram.getType">
Get the program type
</member>
        <member name="M:Ogre.GpuProgram.setType(Ogre.GpuProgramType)">
Set the program type (only valid before load)
</member>
        <member name="M:Ogre.GpuProgram.getSource">
Gets the assembler source for this program. 
</member>
        <member name="M:Ogre.GpuProgram.getSourceFile">
Gets the name of the file used as source for this program. 
</member>
        <member name="M:Ogre.GpuProgram.setSyntaxCode(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the syntax code for this program e.g. arbvp1, fp20, vs_1_1 etc 
</member>
        <member name="M:Ogre.GpuProgram.getSyntaxCode">
Gets the syntax code for this program e.g. arbvp1, fp20, vs_1_1 etc 
</member>
        <member name="M:Ogre.GpuProgram.setSource(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the source assembly for this program from an in-memory string.
        @remarks
            Setting this will have no effect until you (re)load the program.

</member>
        <member name="M:Ogre.GpuProgram.setSourceFile(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the filename of the source assembly for this program.
        @remarks
            Setting this will have no effect until you (re)load the program.

</member>
        <member name="M:Ogre.GpuProgram.createNamedParameterMappingStructures(System.Boolean)">
Create the internal params named mapping structures
</member>
        <member name="M:Ogre.GpuProgram.createLogicalParameterMappingStructures(System.Boolean)">
Create the internal params logical mapping structures
</member>
        <member name="M:Ogre.GpuProgram.loadImpl">
@copydoc Resource::loadImpl
</member>
        <member name="M:Ogre.GpuProgram.calculateSize">
@copydoc Resource::calculateSize
</member>
        <member name="M:Ogre.GpuProgram.isRequiredCapabilitiesSupported">
Internal method returns whether required capabilities for this program is supported.

</member>
        <member name="M:Ogre.GpuProgram.setupBaseParamDictionary">
Internal method for setting up the basic parameter definitions for a subclass. 
		@remarks
		Because StringInterface holds a dictionary of parameters per class, subclasses need to
		call this to ask the base class to add it's parameters to their dictionary as well.
		Can't do this in the constructor because that runs in a non-virtual context.
		@par
		The subclass must have called it's own createParamDictionary before calling this method.

</member>
        <member name="F:Ogre.GpuProgram.mManualNamedConstantsFile">
File from which to load named constants manually
</member>
        <member name="F:Ogre.GpuProgram.mConstantDefs">
Parameter name -&gt; ConstantDefinition map, shared instance used by all parameter objects.
		This is a shared pointer because if the program is recompiled and the parameters
		change, this definition will alter, but previous params may reference the old def.

</member>
        <member name="F:Ogre.GpuProgram.mIntLogicalToPhysical">
Record of logical to physical buffer maps. Mandatory for low-level
			programs or high-level programs which set their params the same way. 
			This is a shared pointer because if the program is recompiled and the parameters
			change, this definition will alter, but previous params may reference the old def.
</member>
        <member name="F:Ogre.GpuProgram.mFloatLogicalToPhysical">
Record of logical to physical buffer maps. Mandatory for low-level
			programs or high-level programs which set their params the same way. 
			This is a shared pointer because if the program is recompiled and the parameters
			change, this definition will alter, but previous params may reference the old def. 
</member>
        <member name="F:Ogre.GpuProgram.mCompileError">
Did we encounter a compilation error?
</member>
        <member name="F:Ogre.GpuProgram.mDefaultParams">
The default parameters for use with this object
</member>
        <member name="F:Ogre.GpuProgram.mNeedsAdjacencyInfo">
Does this (geometry) program require adjacency information?
</member>
        <member name="F:Ogre.GpuProgram.mVertexTextureFetch">
Does this (vertex) program require support for vertex texture fetch?
</member>
        <member name="F:Ogre.GpuProgram.mPoseAnimation">
Does this (vertex) program include pose animation (count of number of poses supported)
</member>
        <member name="F:Ogre.GpuProgram.mMorphAnimation">
Does this (vertex) program include morph animation?
</member>
        <member name="F:Ogre.GpuProgram.mSkeletalAnimation">
Does this (vertex) program include skeletal animation?
</member>
        <member name="F:Ogre.GpuProgram.mSyntaxCode">
Syntax code e.g. arbvp1, vs_2_0 etc
</member>
        <member name="F:Ogre.GpuProgram.mLoadFromFile">
Whether we need to load source from file or not
</member>
        <member name="F:Ogre.GpuProgram.mSource">
The assembler source of the program (may be blank until file loaded)
</member>
        <member name="F:Ogre.GpuProgram.mFilename">
The name of the file to load source from (may be blank)
</member>
        <member name="F:Ogre.GpuProgram.mType">
The type of the program
</member>
        <member name="T:Ogre.GpuProgram.CmdType">
Command object - see ParamCommand 
</member>
        <member name="T:Ogre.GpuProgram">
Defines a program which runs on the GPU such as a vertex or fragment program. 
	@remarks
		This class defines the low-level program in assembler code, the sort used to
		directly assemble into machine instructions for the GPU to execute. By nature,
		this means that the assembler source is rendersystem specific, which is why this
		is an abstract class - real instances are created through the RenderSystem. 
		If you wish to use higher level shading languages like HLSL and Cg, you need to 
		use the HighLevelGpuProgram class instead.

</member>
        <member name="T:Ogre.GpuProgramType">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

Enumerates the types of programs which can run on the GPU. 
</member>
        <member name="D:Ogre.GpuProgramParametersSharedPtr">
Shared pointer used to hold references to GpuProgramParameters instances
</member>
        <member name="M:Ogre.GpuProgramParameters._copySharedParams">
Update the parameters by copying the data from the shared
		parameters.
		@note This method  may not actually be called if the RenderSystem
		supports using shared parameters directly in their own shared buffer; in
		which case the values should not be copied out of the shared area
		into the individual parameter set, but bound separately.

</member>
        <member name="M:Ogre.GpuProgramParameters._getRenderSystemData">
Internal method that the RenderSystem might use to store optional data. 
</member>
        <member name="M:Ogre.GpuProgramParameters._setRenderSystemData(Ogre.Any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method that the RenderSystem might use to store optional data. 
</member>
        <member name="M:Ogre.GpuProgramParameters.getSharedParameters">
Get the list of shared parameter sets. 
</member>
        <member name="M:Ogre.GpuProgramParameters.removeAllSharedParameters">
Stop using all shared parameter sets. 
</member>
        <member name="M:Ogre.GpuProgramParameters.removeSharedParameters(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Stop using the named shared parameter set. 
</member>
        <member name="M:Ogre.GpuProgramParameters.isUsingSharedParameters(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether this parameter set is using the named shared parameter set. 
</member>
        <member name="M:Ogre.GpuProgramParameters.addSharedParameters(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Use a set of shared parameters in this parameters object.
		@remarks
			Allows you to use a set of shared parameters to automatically update 
			this parameter set.
		@param sharedParamsName The name of a shared parameter set as defined in
			GpuProgramManager

</member>
        <member name="M:Ogre.GpuProgramParameters.addSharedParameters(Ogre.SharedPtr&lt;Ogre.GpuSharedParameters&gt;)">
Use a set of shared parameters in this parameters object.
		@remarks
			Allows you to use a set of shared parameters to automatically update 
			this parameter set.

</member>
        <member name="M:Ogre.GpuProgramParameters.getPassIterationNumberIndex">
Get the physical buffer index of the pass iteration number constant 
</member>
        <member name="M:Ogre.GpuProgramParameters.hasPassIterationNumber">
Does this parameters object have a pass iteration number constant? 
</member>
        <member name="M:Ogre.GpuProgramParameters.incPassIterationNumber">
increments the multipass number entry by 1 if it exists

</member>
        <member name="M:Ogre.GpuProgramParameters.getNumAutoConstantDefinitions">
Returns the number of auto constant definitions

</member>
        <member name="M:Ogre.GpuProgramParameters.getAutoConstantDefinition(System.UInt32!System.Runtime.CompilerServices.IsConst)">
gets the auto constant definition using an index into the auto constant definition array.
		If the index is out of bounds then NULL is returned;
		@param idx The auto constant index

</member>
        <member name="M:Ogre.GpuProgramParameters.getAutoConstantDefinition(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
gets the auto constant definition associated with name if found else returns NULL
		@param name The name of the auto constant

</member>
        <member name="M:Ogre.GpuProgramParameters.copyMatchingNamedConstantsFrom(Ogre.GpuProgramParameters!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copies the values of all matching named constants (including auto constants) from 
		another GpuProgramParameters object. 
		@remarks
		This method iterates over the named constants in another parameters object
		and copies across the values where they match. This method is safe to
		use when the 2 parameters objects came from different programs, but only
		works for named parameters.

</member>
        <member name="M:Ogre.GpuProgramParameters.copyConstantsFrom(Ogre.GpuProgramParameters!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copies the values of all constants (including auto constants) from another
		GpuProgramParameters object.
		@note This copes the internal storage of the paarameters object and therefore
		can only be used for parameters objects created from the same GpuProgram.
		To merge parameters that match from different programs, use copyMatchingNamedConstantsFrom.

</member>
        <member name="M:Ogre.GpuProgramParameters.getTransposeMatrices">
Gets whether or not matrices are to be transposed when set
</member>
        <member name="M:Ogre.GpuProgramParameters.setTransposeMatrices(System.Boolean)">
Sets whether or not we need to transpose the matrices passed in from the rest of OGRE.
		@remarks
		D3D uses transposed matrices compared to GL and OGRE; this is not important when you
		use programs which are written to process row-major matrices, such as those generated
		by Cg, but if you use a program written to D3D's matrix layout you will need to enable
		this flag.

</member>
        <member name="M:Ogre.GpuProgramParameters._findNamedConstantDefinition(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Find a constant definition for a named parameter.
		@remarks
		This method returns null if the named parameter did not exist, unlike
		getConstantDefinition which is more strict; unless you set the 
		last parameter to true.
		@param name The name to look up
		@param throwExceptionIfMissing If set to true, failure to find an entry
		will throw an exception.

</member>
        <member name="M:Ogre.GpuProgramParameters.clearNamedAutoConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Unbind an auto constant so that the constant is manually controlled again. 
</member>
        <member name="M:Ogre.GpuProgramParameters.setNamedConstantFromTime(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Sets a named parameter up to track a derivation of the current time.
		@note
		This named option will only work if you are using a parameters object created
		from a high-level program (HighLevelGpuProgram).
		@param name The name of the parameter
		@param factor The amount by which to scale the time value

</member>
        <member name="M:Ogre.GpuProgramParameters.setNamedAutoConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.GpuProgramParameters.AutoConstantType,System.UInt16,System.UInt16)">
Sets up a constant which will automatically be updated by the system.
		@remarks
		Vertex and fragment programs often need parameters which are to do with the
		current render state, or particular values which may very well change over time,
		and often between objects which are being rendered. This feature allows you 
		to set up a certain number of predefined parameter mappings that are kept up to 
		date for you.
		@note
		This named option will only work if you are using a parameters object created
		from a high-level program (HighLevelGpuProgram).
		@param name The name of the parameter
		@param acType The type of automatic constant to set
		@param extraInfo1 The first extra info required by this auto constant type
		@param extraInfo2 The first extra info required by this auto constant type

</member>
        <member name="M:Ogre.GpuProgramParameters.setNamedAutoConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.GpuProgramParameters.AutoConstantType,System.UInt32)">
Sets up a constant which will automatically be updated by the system.
		@remarks
		Vertex and fragment programs often need parameters which are to do with the
		current render state, or particular values which may very well change over time,
		and often between objects which are being rendered. This feature allows you 
		to set up a certain number of predefined parameter mappings that are kept up to 
		date for you.
		@note
		This named option will only work if you are using a parameters object created
		from a high-level program (HighLevelGpuProgram).
		@param name The name of the parameter
		@param acType The type of automatic constant to set
		@param extraInfo If the constant type needs more information (like a light index) put it here.

</member>
        <member name="M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32)">
Sets a multiple value constant floating-point parameter to the program.
		@par
		Some systems only allow constants to be set on certain boundaries, 
		e.g. in sets of 4 values for example. The 'multiple' parameter allows
		you to control that although you should only change it if you know
		your chosen language supports that (at the time of writing, only
		GLSL allows constants which are not a multiple of 4).
		@note
		This named option will only work if you are using a parameters object created
		from a high-level program (HighLevelGpuProgram).
		@param name The name of the parameter
		@param val Pointer to the values to write
		@param count The number of 'multiples' of floats to write
		@param multiple The number of raw entries in each element to write, 
		the default is 4 so count = 1 would write 4 floats.

</member>
        <member name="M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets a ColourValue parameter to the program.
		@param name The name of the parameter
		@param colour The value to set

</member>
        <member name="M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32)">
Sets a multiple value constant floating-point parameter to the program.
		@par
		Some systems only allow constants to be set on certain boundaries, 
		e.g. in sets of 4 values for example. The 'multiple' parameter allows
		you to control that although you should only change it if you know
		your chosen language supports that (at the time of writing, only
		GLSL allows constants which are not a multiple of 4).
		@note
		This named option will only work if you are using a parameters object created
		from a high-level program (HighLevelGpuProgram).
		@param name The name of the parameter
		@param val Pointer to the values to write
		@param count The number of 'multiples' of floats to write
		@param multiple The number of raw entries in each element to write, 
		the default is 4 so count = 1 would write 4 floats.

</member>
        <member name="M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32)">
Sets a multiple value constant floating-point parameter to the program.
		@par
		Some systems only allow constants to be set on certain boundaries, 
		e.g. in sets of 4 values for example. The 'multiple' parameter allows
		you to control that although you should only change it if you know
		your chosen language supports that (at the time of writing, only
		GLSL allows constants which are not a multiple of 4).
		@note
		This named option will only work if you are using a parameters object created
		from a high-level program (HighLevelGpuProgram).
		@param name The name of the parameter
		@param val Pointer to the values to write
		@param count The number of 'multiples' of floats to write
		@param multiple The number of raw entries in each element to write, 
		the default is 4 so count = 1 would write 4 floats.

</member>
        <member name="M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Sets a list of Matrix4 parameters to the program.
		@param name The name of the parameter; this must be the first index of an array,
		for examples 'matrices[0]'
		NB since a Matrix4 is 16 floats long, so each entry will take up 4 indexes.
		@param m Pointer to an array of matrices to set
		@param numEntries Number of Matrix4 entries

</member>
        <member name="M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets a Matrix4 parameter to the program.
		@param name The name of the parameter
		@param m The value to set

</member>
        <member name="M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets a Vector4 parameter to the program.
		@param name The name of the parameter
		@param vec The value to set

</member>
        <member name="M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Sets a single value constant integer parameter to the program.
		@remarks
		Different types of GPU programs support different types of constant parameters.
		For example, it's relatively common to find that vertex programs only support
		floating point constants, and that fragment programs only support integer (fixed point)
		parameters. This can vary depending on the program version supported by the
		graphics card being used. You should consult the documentation for the type of
		low level program you are using, or alternatively use the methods
		provided on RenderSystemCapabilities to determine the options.
		@par
		Another possible limitation is that some systems only allow constants to be set
		on certain boundaries, e.g. in sets of 4 values for example. Again, see
		RenderSystemCapabilities for full details.
		@note
		This named option will only work if you are using a parameters object created
		from a high-level program (HighLevelGpuProgram).
		@param name The name of the parameter
		@param val The value to set

</member>
        <member name="M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Sets a single value constant floating-point parameter to the program.
		@remarks
		Different types of GPU programs support different types of constant parameters.
		For example, it's relatively common to find that vertex programs only support
		floating point constants, and that fragment programs only support integer (fixed point)
		parameters. This can vary depending on the program version supported by the
		graphics card being used. You should consult the documentation for the type of
		low level program you are using, or alternatively use the methods
		provided on RenderSystemCapabilities to determine the options.
		@par
		Another possible limitation is that some systems only allow constants to be set
		on certain boundaries, e.g. in sets of 4 values for example. Again, see
		RenderSystemCapabilities for full details.
		@note
		This named option will only work if you are using a parameters object created
		from a high-level program (HighLevelGpuProgram).
		@param name The name of the parameter
		@param val The value to set

</member>
        <member name="M:Ogre.GpuProgramParameters.setIgnoreMissingParams(System.Boolean)">
Tells the program whether to ignore missing parameters or not.

</member>
        <member name="M:Ogre.GpuProgramParameters._updateAutoParams(Ogre.AutoParamDataSource!System.Runtime.CompilerServices.IsConst*,System.UInt16)">
Update automatic parameters.
		@param source The source of the parameters
		@param variabilityMask A mask of GpuParamVariability which identifies which autos will need updating

</member>
        <member name="M:Ogre.GpuProgramParameters._findRawAutoConstantEntryInt(System.UInt32)">
Finds an auto constant that's affecting a given physical position in 
		the integer buffer

</member>
        <member name="M:Ogre.GpuProgramParameters._findRawAutoConstantEntryFloat(System.UInt32)">
Finds an auto constant that's affecting a given physical position in 
		the floating-point buffer

</member>
        <member name="M:Ogre.GpuProgramParameters.findAutoConstantEntry(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Finds an auto constant that's affecting a given named parameter index.
		@note Only applicable to high-level programs.

</member>
        <member name="M:Ogre.GpuProgramParameters.findIntAutoConstantEntry(System.UInt32)">
Finds an auto constant that's affecting a given logical parameter 
		index for integer values.
		@note Only applicable for low-level programs.

</member>
        <member name="M:Ogre.GpuProgramParameters.findFloatAutoConstantEntry(System.UInt32)">
Finds an auto constant that's affecting a given logical parameter 
		index for floating-point values.
		@note Only applicable for low-level programs.

</member>
        <member name="M:Ogre.GpuProgramParameters.hasAutoConstants">
Returns true if this instance has any automatic constants. 
</member>
        <member name="M:Ogre.GpuProgramParameters.getAutoConstantEntry(System.UInt32!System.Runtime.CompilerServices.IsConst)">
Gets a specific Auto Constant entry if index is in valid range
		otherwise returns a NULL
		@param index which entry is to be retrieved

</member>
        <member name="M:Ogre.GpuProgramParameters.getAutoConstantCount">
Gets the number of int constants that have been set
</member>
        <member name="M:Ogre.GpuProgramParameters.getAutoConstantIterator">
Gets an iterator over the automatic constant bindings currently in place. 
</member>
        <member name="M:Ogre.GpuProgramParameters.clearAutoConstants">
Clears all the existing automatic constants. 
</member>
        <member name="M:Ogre.GpuProgramParameters.setConstantFromTime(System.UInt32,System.Single)">
Sets a named parameter up to track a derivation of the current time.
		@param index The index of the parameter
		@param factor The amount by which to scale the time value

</member>
        <member name="M:Ogre.GpuProgramParameters.clearAutoConstant(System.UInt32)">
Unbind an auto constant so that the constant is manually controlled again. 
</member>
        <member name="M:Ogre.GpuProgramParameters._setRawAutoConstantReal(System.UInt32,Ogre.GpuProgramParameters.AutoConstantType,System.Single,System.UInt16,System.UInt32)">
As setAutoConstantReal, but sets up the auto constant directly against a
		physical buffer index.

</member>
        <member name="M:Ogre.GpuProgramParameters._setRawAutoConstant(System.UInt32,Ogre.GpuProgramParameters.AutoConstantType,System.UInt32,System.UInt16,System.UInt32)">
As setAutoConstant, but sets up the auto constant directly against a
		physical buffer index.

</member>
        <member name="M:Ogre.GpuProgramParameters.setAutoConstant(System.UInt32,Ogre.GpuProgramParameters.AutoConstantType,System.UInt16,System.UInt16)">
Sets up a constant which will automatically be updated by the system.
		@remarks
		Vertex and fragment programs often need parameters which are to do with the
		current render state, or particular values which may very well change over time,
		and often between objects which are being rendered. This feature allows you 
		to set up a certain number of predefined parameter mappings that are kept up to 
		date for you.
		@param index The location in the constant list to place this updated constant every time
		it is changed. Note that because of the nature of the types, we know how big the 
		parameter details will be so you don't need to set that like you do for manual constants.
		@param acType The type of automatic constant to set
		@param extraInfo1 The first extra parameter required by the auto constant type
		@param extraInfo2 The first extra parameter required by the auto constant type

</member>
        <member name="M:Ogre.GpuProgramParameters.setAutoConstant(System.UInt32,Ogre.GpuProgramParameters.AutoConstantType,System.UInt32)">
Sets up a constant which will automatically be updated by the system.
		@remarks
		Vertex and fragment programs often need parameters which are to do with the
		current render state, or particular values which may very well change over time,
		and often between objects which are being rendered. This feature allows you 
		to set up a certain number of predefined parameter mappings that are kept up to 
		date for you.
		@param index The location in the constant list to place this updated constant every time
		it is changed. Note that because of the nature of the types, we know how big the 
		parameter details will be so you don't need to set that like you do for manual constants.
		@param acType The type of automatic constant to set
		@param extraInfo If the constant type needs more information (like a light index) put it here.

</member>
        <member name="M:Ogre.GpuProgramParameters.getAutoConstantList">
Get a reference to the list of auto constant bindings
</member>
        <member name="M:Ogre.GpuProgramParameters.getIntPointer(System.UInt32)">
Get a pointer to the 'nth' item in the int buffer

Get a pointer to the 'nth' item in the int buffer
</member>
        <member name="M:Ogre.GpuProgramParameters.getIntConstantList">
Get a reference to the list of int constants
</member>
        <member name="M:Ogre.GpuProgramParameters.getFloatPointer(System.UInt32)">
Get a pointer to the 'nth' item in the float buffer

Get a pointer to the 'nth' item in the float buffer
</member>
        <member name="M:Ogre.GpuProgramParameters.getFloatConstantList">
Get a reference to the list of float constants
</member>
        <member name="M:Ogre.GpuProgramParameters.getIntLogicalBufferStruct">
Get the current list of mappings from low-level logical param indexes
		to physical buffer locations in the integer buffer.
		@note
		Only applicable to low-level programs.

</member>
        <member name="M:Ogre.GpuProgramParameters.getFloatLogicalBufferStruct">
Get the current list of mappings from low-level logical param indexes
		to physical buffer locations in the float buffer.
		@note
		Only applicable to low-level programs.

</member>
        <member name="M:Ogre.GpuProgramParameters.getConstantDefinitions">
Get the full list of GpuConstantDefinition instances.
		@note
		Only available if this parameters object has named parameters.

</member>
        <member name="M:Ogre.GpuProgramParameters.getConstantDefinition(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get a specific GpuConstantDefinition for a named parameter.
		@note
		Only available if this parameters object has named parameters.

</member>
        <member name="M:Ogre.GpuProgramParameters.getConstantDefinitionIterator">
Gets an iterator over the named GpuConstantDefinition instances as defined
		by the program for which these parameters exist.
		@note
		Only available if this parameters object has named parameters.

</member>
        <member name="M:Ogre.GpuProgramParameters._writeRawConstant(System.UInt32,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Write a ColourValue parameter to the program.
		@note You can use these methods if you have already derived the physical
		constant buffer location, for a slight speed improvement over using
		the named / logical index versions.
		@param physicalIndex The physical buffer index at which to place the parameter 
		@param colour The value to set
		@param count The number of floats to write; if for example
		the uniform constant 'slot' is smaller than a Vector4

</member>
        <member name="M:Ogre.GpuProgramParameters._writeRawConstant(System.UInt32,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Write a list of Matrix4 parameters to the program.
		@note You can use these methods if you have already derived the physical
		constant buffer location, for a slight speed improvement over using
		the named / logical index versions.
		@param physicalIndex The physical buffer index at which to place the parameter 
		@param numEntries Number of Matrix4 entries

</member>
        <member name="M:Ogre.GpuProgramParameters._writeRawConstant(System.UInt32,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Write a Matrix4 parameter to the program.
		@note You can use these methods if you have already derived the physical
		constant buffer location, for a slight speed improvement over using
		the named / logical index versions.
		@param physicalIndex The physical buffer index at which to place the parameter 
		@param m The value to set
		@param elementCount actual element count used with shader

</member>
        <member name="M:Ogre.GpuProgramParameters._writeRawConstant(System.UInt32,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Write a 3-element floating-point parameter to the program via Vector3.
		@note You can use these methods if you have already derived the physical
		constant buffer location, for a slight speed improvement over using
		the named / logical index versions.
		@param physicalIndex The physical buffer index at which to place the parameter 
		@param vec The value to set

</member>
        <member name="M:Ogre.GpuProgramParameters._writeRawConstant(System.UInt32,System.Int32)">
Write a single integer parameter to the program.
		@note You can use these methods if you have already derived the physical
		constant buffer location, for a slight speed improvement over using
		the named / logical index versions.
		@param physicalIndex The physical buffer index at which to place the parameter 
		@param val The value to set

</member>
        <member name="M:Ogre.GpuProgramParameters._writeRawConstant(System.UInt32,System.Single)">
Write a single floating-point parameter to the program.
		@note You can use these methods if you have already derived the physical
		constant buffer location, for a slight speed improvement over using
		the named / logical index versions.
		@param physicalIndex The physical buffer index at which to place the parameter 
		@param val The value to set

</member>
        <member name="M:Ogre.GpuProgramParameters._writeRawConstant(System.UInt32,Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Write a 4-element floating-point parameter to the program directly to 
		the underlying constants buffer.
		@note You can use these methods if you have already derived the physical
		constant buffer location, for a slight speed improvement over using
		the named / logical index versions.
		@param physicalIndex The physical buffer index at which to place the parameter 
		@param vec The value to set
		@param count The number of floats to write; if for example
		the uniform constant 'slot' is smaller than a Vector4

</member>
        <member name="M:Ogre.GpuProgramParameters._readRawConstants(System.UInt32,System.UInt32,System.Int32*)">
Read a series of integer values from the underlying integer 
		constant buffer at the given physical index.
		@param physicalIndex The buffer position to start reading
		@param count The number of ints to read
		@param dest Pointer to a buffer to receive the values

</member>
        <member name="M:Ogre.GpuProgramParameters._readRawConstants(System.UInt32,System.UInt32,System.Single*)">
Read a series of floating point values from the underlying float 
		constant buffer at the given physical index.
		@param physicalIndex The buffer position to start reading
		@param count The number of floats to read
		@param dest Pointer to a buffer to receive the values

</member>
        <member name="M:Ogre.GpuProgramParameters._writeRawConstants(System.UInt32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Write a series of integer values into the underlying integer
		constant buffer at the given physical index.
		@param physicalIndex The buffer position to start writing
		@param val Pointer to a list of values to write
		@param count The number of ints to write

</member>
        <member name="M:Ogre.GpuProgramParameters._writeRawConstants(System.UInt32,System.Double!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Write a series of floating point values into the underlying float 
		constant buffer at the given physical index.
		@param physicalIndex The buffer position to start writing
		@param val Pointer to a list of values to write
		@param count The number of floats to write

</member>
        <member name="M:Ogre.GpuProgramParameters._writeRawConstants(System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Write a series of floating point values into the underlying float 
		constant buffer at the given physical index.
		@param physicalIndex The buffer position to start writing
		@param val Pointer to a list of values to write
		@param count The number of floats to write

</member>
        <member name="M:Ogre.GpuProgramParameters.setConstant(System.UInt32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Sets a multiple value constant integer parameter to the program.
		@remarks
		Different types of GPU programs support different types of constant parameters.
		For example, it's relatively common to find that vertex programs only support
		floating point constants, and that fragment programs only support integer (fixed point)
		parameters. This can vary depending on the program version supported by the
		graphics card being used. You should consult the documentation for the type of
		low level program you are using, or alternatively use the methods
		provided on RenderSystemCapabilities to determine the options.
		@param index The logical constant index at which to place the parameter (each constant is
		a 4D integer)
		@param val Pointer to the values to write, must contain 4*count ints
		@param count The number of groups of 4 ints to write

</member>
        <member name="M:Ogre.GpuProgramParameters.setConstant(System.UInt32,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets a ColourValue parameter to the program.
		@param index The logical constant index at which to place the parameter (each constant is
		a 4D float)
		@param colour The value to set

</member>
        <member name="M:Ogre.GpuProgramParameters.setConstant(System.UInt32,System.Double!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Sets a multiple value constant floating-point parameter to the program.
		@param index The logical constant index at which to start placing parameters (each constant is
		a 4D float)
		@param val Pointer to the values to write, must contain 4*count floats
		@param count The number of groups of 4 floats to write

</member>
        <member name="M:Ogre.GpuProgramParameters.setConstant(System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Sets a multiple value constant floating-point parameter to the program.
		@param index The logical constant index at which to start placing parameters (each constant is
		a 4D float)
		@param val Pointer to the values to write, must contain 4*count floats
		@param count The number of groups of 4 floats to write

</member>
        <member name="M:Ogre.GpuProgramParameters.setConstant(System.UInt32,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Sets a list of Matrix4 parameters to the program.
		@param index The logical constant index at which to start placing the parameter (each constant is
		a 4D float).
		NB since a Matrix4 is 16 floats long, so each entry will take up 4 indexes.
		@param m Pointer to an array of matrices to set
		@param numEntries Number of Matrix4 entries

</member>
        <member name="M:Ogre.GpuProgramParameters.setConstant(System.UInt32,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets a Matrix4 parameter to the program.
		@param index The logical constant index at which to place the parameter (each constant is
		a 4D float).
		NB since a Matrix4 is 16 floats long, this parameter will take up 4 indexes.
		@param m The value to set

</member>
        <member name="M:Ogre.GpuProgramParameters.setConstant(System.UInt32,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets a 4-element floating-point parameter to the program via Vector3.
		@param index The logical constant index at which to place the parameter (each constant is
		a 4D float).
		Note that since you're passing a Vector3, the last element of the 4-element
		value will be set to 1 (a homogeneous vector)
		@param vec The value to set

</member>
        <member name="M:Ogre.GpuProgramParameters.setConstant(System.UInt32,System.Single)">
Sets a single floating-point parameter to the program.
		@note This is actually equivalent to calling 
		setConstant(index Vector4(val, 0, 0, 0)) since all constants are 4D.
		@param index The logical constant index at which to place the parameter (each constant is
		a 4D float)
		@param val The value to set

</member>
        <member name="M:Ogre.GpuProgramParameters.setConstant(System.UInt32,Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets a 4-element floating-point parameter to the program.
		@param index The logical constant index at which to place the parameter 
		(each constant is a 4D float)
		@param vec The value to set

</member>
        <member name="M:Ogre.GpuProgramParameters.hasLogicalIndexedParameters">
Does this parameter set include logically indexed parameters?
		@note Not mutually exclusive with hasNamedParameters since some high-level
		programs still use logical indexes to set the parameters on the 
		rendersystem.

</member>
        <member name="M:Ogre.GpuProgramParameters.hasNamedParameters">
Does this parameter set include named parameters?
</member>
        <member name="M:Ogre.GpuProgramParameters._setLogicalIndexes(Ogre.SharedPtr&lt;Ogre.GpuLogicalBufferStruct&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.SharedPtr&lt;Ogre.GpuLogicalBufferStruct&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for providing a link to a logical index-&gt;physical index map for parameters. 
</member>
        <member name="M:Ogre.GpuProgramParameters._setNamedConstants(Ogre.SharedPtr&lt;Ogre.GpuNamedConstants&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for providing a link to a name-&gt;definition map for parameters. 
</member>
        <member name="M:Ogre.GpuProgramParameters.op_Assign(Ogre.GpuProgramParameters!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Operator = overload
</member>
        <member name="M:Ogre.GpuProgramParameters.#ctor(Ogre.GpuProgramParameters!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:Ogre.GpuProgramParameters.deriveVariability(Ogre.GpuProgramParameters.AutoConstantType)">
Return the variability for an auto constant
</member>
        <member name="M:Ogre.GpuProgramParameters._getIntConstantLogicalIndexUse(System.UInt32,System.UInt32,System.UInt16)">
Gets the physical buffer index associated with a logical int constant index. 

</member>
        <member name="M:Ogre.GpuProgramParameters._getFloatConstantLogicalIndexUse(System.UInt32,System.UInt32,System.UInt16)">
Gets the low-level structure for a logical index. 

</member>
        <member name="F:Ogre.GpuProgramParameters.mActivePassIterationIndex">
physical index for active pass iteration parameter real constant entry;
</member>
        <member name="F:Ogre.GpuProgramParameters.mIgnoreMissingParams">
flag to indicate if names not found will be ignored
</member>
        <member name="F:Ogre.GpuProgramParameters.mTransposeMatrices">
Do we need to transpose matrices?
</member>
        <member name="F:Ogre.GpuProgramParameters.mCombinedVariability">
The combined variability masks of all parameters
</member>
        <member name="F:Ogre.GpuProgramParameters.mAutoConstants">
List of automatically updated parameters
</member>
        <member name="F:Ogre.GpuProgramParameters.mNamedConstants">
Mapping from parameter names to def - high-level programs are expected to populate this
</member>
        <member name="F:Ogre.GpuProgramParameters.mIntLogicalToPhysical">
Logical index to physical index map - for low-level programs
		or high-level programs which pass params this way. 
</member>
        <member name="F:Ogre.GpuProgramParameters.mFloatLogicalToPhysical">
Logical index to physical index map - for low-level programs
		or high-level programs which pass params this way. 
</member>
        <member name="F:Ogre.GpuProgramParameters.mIntConstants">
Packed list of integer constants (physical indexing)
</member>
        <member name="F:Ogre.GpuProgramParameters.mFloatConstants">
Packed list of floating-point constants (physical indexing)
</member>
        <member name="F:Ogre.GpuProgramParameters.AutoConstantEntry.variability">
The variability of this parameter (see GpuParamVariability)
</member>
        <member name="F:Ogre.GpuProgramParameters.AutoConstantEntry.elementCount">
The number of elements per individual entry in this constant
			Used in case people used packed elements smaller than 4 (e.g. GLSL)
			and bind an auto which is 4-element packed to it 
</member>
        <member name="F:Ogre.GpuProgramParameters.AutoConstantEntry.physicalIndex">
The target (physical) constant index
</member>
        <member name="F:Ogre.GpuProgramParameters.AutoConstantEntry.paramType">
The type of parameter
</member>
        <member name="T:Ogre.GpuProgramParameters.AutoConstantEntry">
Structure recording the use of an automatic parameter. 
</member>
        <member name="F:Ogre.GpuProgramParameters.AutoConstantDefinition.dataType">
The type of any extra data
</member>
        <member name="F:Ogre.GpuProgramParameters.AutoConstantDefinition.elementType">
The type of the constant in the program
</member>
        <member name="T:Ogre.GpuProgramParameters.AutoConstantDefinition">
Structure defining an auto constant that's available for use in 
		a parameters object.

</member>
        <member name="T:Ogre.GpuProgramParameters.ElementType">
Defines the base element type of the auto constant

</member>
        <member name="F:ACDT_REAL">
the auto constant requires data of type real
</member>
        <member name="F:ACDT_INT">
the auto constant requires data of type int
</member>
        <member name="F:ACDT_NONE">
no data is required
</member>
        <member name="T:Ogre.GpuProgramParameters.ACDataType">
Defines the type of the extra data item used by the auto constant.


</member>
        <member name="F:ACT_LIGHT_CUSTOM">
Binds custom per-light constants to the shaders. 
</member>
        <member name="F:ACT_LOD_CAMERA_POSITION_OBJECT_SPACE">
Provides the position of the LOD camera in object space, allowing you 
			to perform separate LOD calculations in shaders independent of the rendering
			camera. If there is no separate LOD camera then this is the real camera
			position. See Camera::setLodCamera.

</member>
        <member name="F:ACT_LOD_CAMERA_POSITION">
Provides the position of the LOD camera in world space, allowing you 
			to perform separate LOD calculations in shaders independent of the rendering
			camera. If there is no separate LOD camera then this is the real camera
			position. See Camera::setLodCamera.

</member>
        <member name="F:ACT_TEXTURE_MATRIX">
Provides the current transform matrix of the texture unit (index determined by setAutoConstant
			call), as seen by the fixed-function pipeline. 

</member>
        <member name="F:ACT_PACKED_TEXTURE_SIZE">
Provides packed texture size of the texture unit (index determined by setAutoConstant
			call). Packed as float4(width, height, 1 / width, 1 / height)

</member>
        <member name="F:ACT_INVERSE_TEXTURE_SIZE">
Provides inverse texture size of the texture unit (index determined by setAutoConstant
			call). Packed as float4(1 / width, 1 / height, 1 / depth, 1)

</member>
        <member name="F:ACT_TEXTURE_SIZE">
Provides texture size of the texture unit (index determined by setAutoConstant
			call). Packed as float4(width, height, depth, 1)

</member>
        <member name="F:ACT_SHADOW_COLOUR">
Provides the fixed shadow colour as configured via SceneManager::setShadowColour;
			useful for integrated modulative shadows.

</member>
        <member name="F:ACT_SHADOW_SCENE_DEPTH_RANGE">
Provides information about the depth range of the scene as viewed
			from a given shadow camera. Requires an index parameter which maps
			to a light index relative to the current light list.
			Passed as float4(minDepth, maxDepth, depthRange, 1 / depthRange)

</member>
        <member name="F:ACT_SCENE_DEPTH_RANGE">
Provides information about the depth range of the scene as viewed
			from the current camera. 
			Passed as float4(minDepth, maxDepth, depthRange, 1 / depthRange)

</member>
        <member name="F:ACT_TEXEL_OFFSETS">
Provides the texel offsets required by this rendersystem to map
			texels to pixels. Packed as 
			float4(absoluteHorizontalOffset, absoluteVerticalOffset, 
			horizontalOffset / viewportWidth, verticalOffset / viewportHeight)

</member>
        <member name="F:ACT_ANIMATION_PARAMETRIC">
Provides a parametric animation value [0..1], only available
			where the renderable specifically implements it.

</member>
        <member name="F:ACT_PASS_ITERATION_NUMBER">
provides the current iteration number of the pass. The iteration
			number is the number of times the current render operation has
			been drawn for the active pass.

</member>
        <member name="F:ACT_PASS_NUMBER">
provides the pass index number within the technique
			of the active materil.

</member>
        <member name="F:ACT_FAR_CLIP_DISTANCE">
This variable provides the far clip distance as a floating point value.
			Equivalent to RenderMonkey's "FarClipPlane".

</member>
        <member name="F:ACT_NEAR_CLIP_DISTANCE">
This variable provides the near clip distance as a floating point value.
			Equivalent to RenderMonkey's "NearClipPlane".

</member>
        <member name="F:ACT_FOV">
This variable provides the field of view as a floating point value.
			Equivalent to RenderMonkey's "FOV".

</member>
        <member name="F:ACT_VIEW_UP_VECTOR">
This variable provides the view up vector (world space).
			Equivalent to RenderMonkey's "ViewUpVector".

</member>
        <member name="F:ACT_VIEW_SIDE_VECTOR">
This variable provides the view side vector (world space).
			Equivalent to RenderMonkey's "ViewSideVector".

</member>
        <member name="F:ACT_VIEW_DIRECTION">
view parameters
This variable provides the view direction vector (world space).
			Equivalent to RenderMonkey's "ViewDirection".

</member>
        <member name="F:ACT_VIEWPORT_SIZE">
Packed of "ViewportWidth", "ViewportHeight", "ViewportWidthInverse",
			"ViewportHeightInverse".

</member>
        <member name="F:ACT_INVERSE_VIEWPORT_HEIGHT">
This variable represents 1.0/ViewportHeight.
			Equivalent to RenderMonkey's "ViewportHeightInverse".

</member>
        <member name="F:ACT_INVERSE_VIEWPORT_WIDTH">
This variable represents 1.0/ViewportWidth. 
			Equivalent to RenderMonkey's "ViewportWidthInverse".

</member>
        <member name="F:ACT_VIEWPORT_HEIGHT">
Current viewport height (in pixels) as floating point value.
			Equivalent to RenderMonkey's "ViewportHeight".

</member>
        <member name="F:ACT_VIEWPORT_WIDTH">
viewport-related values
Current viewport width (in pixels) as floating point value.
			Equivalent to RenderMonkey's "ViewportWidth".

</member>
        <member name="F:ACT_FPS">
provides the calculated frames per second, returned as a floating point value.
</member>
        <member name="F:ACT_FRAME_TIME">
provides the scaled frame time, returned as a floating point value.
</member>
        <member name="F:ACT_TIME_0_2PI_PACKED">
Vector of "Time0_2PI", "SinTime0_2PI", "CosTime0_2PI",
			"TanTime0_2PI". Equivalent to RenderMonkey's "Time0_2PI_Packed".

</member>
        <member name="F:ACT_TANTIME_0_2PI">
Tangent of "Time0_2PI". Equivalent to RenderMonkey's "TanTime0_2PI".
</member>
        <member name="F:ACT_SINTIME_0_2PI">
Sine of "Time0_2PI". Equivalent to RenderMonkey's "SinTime0_2PI".
</member>
        <member name="F:ACT_COSTIME_0_2PI">
Cosine of "Time0_2PI". Equivalent to RenderMonkey's "CosTime0_2PI".
</member>
        <member name="F:ACT_TIME_0_2PI">
Single float value, which represents scaled time value [0..2*Pi],
			which repeats itself based on given as parameter "cycle time".
			Equivalent to RenderMonkey's "Time0_2PI".

</member>
        <member name="F:ACT_TIME_0_1_PACKED">
Vector of "Time0_1", "SinTime0_1", "CosTime0_1",
			"TanTime0_1". Equivalent to RenderMonkey's "Time0_1_Packed".

</member>
        <member name="F:ACT_TANTIME_0_1">
Tangent of "Time0_1". Equivalent to RenderMonkey's "TanTime0_1".
</member>
        <member name="F:ACT_SINTIME_0_1">
Sine of "Time0_1". Equivalent to RenderMonkey's "SinTime0_1".
</member>
        <member name="F:ACT_COSTIME_0_1">
Cosine of "Time0_1". Equivalent to RenderMonkey's "CosTime0_1".
</member>
        <member name="F:ACT_TIME_0_1">
Single float value, which represents scaled time value [0..1],
			which repeats itself based on given as parameter "cycle time".
			Equivalent to RenderMonkey's "Time0_1".

</member>
        <member name="F:ACT_TIME_0_X_PACKED">
Vector of "Time0_X", "SinTime0_X", "CosTime0_X", 
			"TanTime0_X". Equivalent to RenderMonkey's "Time0_X_Packed".

</member>
        <member name="F:ACT_TANTIME_0_X">
Tangent of "Time0_X". Equivalent to RenderMonkey's "TanTime0_X".
</member>
        <member name="F:ACT_SINTIME_0_X">
Sine of "Time0_X". Equivalent to RenderMonkey's "SinTime0_X".
</member>
        <member name="F:ACT_COSTIME_0_X">
Cosine of "Time0_X". Equivalent to RenderMonkey's "CosTime0_X".
</member>
        <member name="F:ACT_TIME_0_X">
Single float value, which repeats itself based on given as
			parameter "cycle time". Equivalent to RenderMonkey's "Time0_X".

</member>
        <member name="F:ACT_TIME">
provides current elapsed time

</member>
        <member name="F:ACT_CUSTOM">
A custom parameter which will come from the renderable, using 'data' as the identifier
</member>
        <member name="F:ACT_SPOTLIGHT_WORLDVIEWPROJ_MATRIX">
The view/projection matrix of a given spotlight projection frustum, 
			combined with the current world matrix

</member>
        <member name="F:ACT_SPOTLIGHT_VIEWPROJ_MATRIX">
The view/projection matrix of a given spotlight
</member>
        <member name="F:ACT_TEXTURE_WORLDVIEWPROJ_MATRIX_ARRAY">
Array of world/view/projection matrices of the first n texture projection frustums
</member>
        <member name="F:ACT_TEXTURE_WORLDVIEWPROJ_MATRIX">
The view/projection matrix of the assigned texture projection frustum, 
			combined with the current world matrix

</member>
        <member name="F:ACT_TEXTURE_VIEWPROJ_MATRIX_ARRAY">
Array of view/projection matrices of the first n texture projection frustums
</member>
        <member name="F:ACT_TEXTURE_VIEWPROJ_MATRIX">
The view/projection matrix of the assigned texture projection frustum
</member>
        <member name="F:ACT_CAMERA_POSITION_OBJECT_SPACE">
The current camera's position in object space 
</member>
        <member name="F:ACT_CAMERA_POSITION">
The current camera's position in world space
</member>
        <member name="F:ACT_SHADOW_EXTRUSION_DISTANCE">
The distance a shadow volume should be extruded when using
			finite extrusion programs.

</member>
        <member name="F:ACT_LIGHT_CASTS_SHADOWS">
Returns (int) 1 if the  given light casts shadows, 0 otherwise (index set in extra param)
</member>
        <member name="F:ACT_LIGHT_NUMBER">
The absolute light number of a local light index. Each pass may have
			a number of lights passed to it, and each of these lights will have
			an index in the overall light list, which will differ from the local
			light index due to factors like setStartLight and setIteratePerLight.
			This binding provides the global light index for a local index.

</member>
        <member name="F:ACT_DERIVED_LIGHT_SPECULAR_COLOUR_ARRAY">
Array of derived light specular colours (count set by extra param)
</member>
        <member name="F:ACT_DERIVED_LIGHT_DIFFUSE_COLOUR_ARRAY">
Array of derived light diffuse colours (count set by extra param)
</member>
        <member name="F:ACT_DERIVED_LIGHT_SPECULAR_COLOUR">
The derived light specular colour (index determined by setAutoConstant call),
			with 'r', 'g' and 'b' components filled with product of surface specular colour
			and light specular colour, respectively, and 'a' component filled with surface
			specular alpha component.

</member>
        <member name="F:ACT_DERIVED_LIGHT_DIFFUSE_COLOUR">
The derived light diffuse colour (index determined by setAutoConstant call),
			with 'r', 'g' and 'b' components filled with product of surface diffuse colour,
			light power scale and light diffuse colour, respectively, and 'a' component filled with surface
			diffuse alpha component.

</member>
        <member name="F:ACT_DERIVED_SCENE_COLOUR">
The derived scene colour, with 'r', 'g' and 'b' components filled with sum
			of derived ambient light colour and surface emissive colour, respectively,
			and 'a' component filled with surface diffuse alpha component.

</member>
        <member name="F:ACT_DERIVED_AMBIENT_LIGHT_COLOUR">
The derived ambient light colour, with 'r', 'g', 'b' components filled with
			product of surface ambient colour and ambient light colour, respectively,
			and 'a' component filled with surface ambient alpha component.

</member>
        <member name="F:ACT_SPOTLIGHT_PARAMS_ARRAY">
Spotlight parameters array of Vector4(innerFactor, outerFactor, falloff, isSpot)
			innerFactor and outerFactor are cos(angle/2)
			The isSpot parameter is 0.0f for non-spotlights, 1.0f for spotlights.
			Also for non-spotlights the inner and outer factors are 1 and nearly 1 respectively.
			(count set by extra param)

</member>
        <member name="F:ACT_LIGHT_POWER_SCALE_ARRAY">
Array of light power levels, a single scalar as set in Light::setPowerScale 
			(count set by extra param)

</member>
        <member name="F:ACT_LIGHT_DISTANCE_OBJECT_SPACE_ARRAY">
Array of distances of the lights from the center of the object
			a useful approximation as an alternative to per-vertex distance
			calculations. (count set by extra param)

</member>
        <member name="F:ACT_LIGHT_DIRECTION_VIEW_SPACE_ARRAY">
Array of light directions in view space (count set by extra param)
</member>
        <member name="F:ACT_LIGHT_DIRECTION_OBJECT_SPACE_ARRAY">
Array of light directions in object space (count set by extra param)
</member>
        <member name="F:ACT_LIGHT_DIRECTION_ARRAY">
Array of light directions in world space (count set by extra param)
</member>
        <member name="F:ACT_LIGHT_POSITION_VIEW_SPACE_ARRAY">
Array of light positions in view space (count set by extra param)
</member>
        <member name="F:ACT_LIGHT_POSITION_OBJECT_SPACE_ARRAY">
Array of light positions in object space (count set by extra param)
</member>
        <member name="F:ACT_LIGHT_POSITION_ARRAY">
Array of light positions in world space (count set by extra param)
</member>
        <member name="F:ACT_LIGHT_ATTENUATION_ARRAY">
Array of light attenuation parameters, Vector4(range, constant, linear, quadric) (count set by extra param)
</member>
        <member name="F:ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED_ARRAY">
Array of light specular colours scaled by light power (count set by extra param)
</member>
        <member name="F:ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED_ARRAY">
Array of light diffuse colours scaled by light power (count set by extra param)
</member>
        <member name="F:ACT_LIGHT_SPECULAR_COLOUR_ARRAY">
Array of light specular colours (count set by extra param)
</member>
        <member name="F:ACT_LIGHT_DIFFUSE_COLOUR_ARRAY">
Array of light diffuse colours (count set by extra param)
</member>
        <member name="F:ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED">
Light specular colour pre-scaled by Light::setPowerScale (index determined by setAutoConstant call)
</member>
        <member name="F:ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED">
Light diffuse colour pre-scaled by Light::setPowerScale (index determined by setAutoConstant call)
</member>
        <member name="F:ACT_LIGHT_POWER_SCALE">
Light power level, a single scalar as set in Light::setPowerScale  (index determined by setAutoConstant call) 
</member>
        <member name="F:ACT_LIGHT_DISTANCE_OBJECT_SPACE">
The distance of the light from the center of the object
			a useful approximation as an alternative to per-vertex distance
			calculations.

</member>
        <member name="F:ACT_LIGHT_DIRECTION_VIEW_SPACE">
A light direction in view space (index determined by setAutoConstant call)
</member>
        <member name="F:ACT_LIGHT_DIRECTION_OBJECT_SPACE">
A light direction in object space (index determined by setAutoConstant call)
</member>
        <member name="F:ACT_LIGHT_DIRECTION">
A light direction in world space (index determined by setAutoConstant call)
</member>
        <member name="F:ACT_LIGHT_POSITION_VIEW_SPACE">
A light position in view space (index determined by setAutoConstant call)
</member>
        <member name="F:ACT_LIGHT_POSITION_OBJECT_SPACE">
A light position in object space (index determined by setAutoConstant call)
</member>
        <member name="F:ACT_LIGHT_POSITION">
A light position in world space (index determined by setAutoConstant call)
</member>
        <member name="F:ACT_SPOTLIGHT_PARAMS">
Spotlight parameters, Vector4(innerFactor, outerFactor, falloff, isSpot)
			innerFactor and outerFactor are cos(angle/2)
			The isSpot parameter is 0.0f for non-spotlights, 1.0f for spotlights.
			Also for non-spotlights the inner and outer factors are 1 and nearly 1 respectively

</member>
        <member name="F:ACT_LIGHT_ATTENUATION">
Light attenuation parameters, Vector4(range, constant, linear, quadric)
</member>
        <member name="F:ACT_LIGHT_SPECULAR_COLOUR">
Light specular colour (index determined by setAutoConstant call)
</member>
        <member name="F:ACT_LIGHT_DIFFUSE_COLOUR">
Light diffuse colour (index determined by setAutoConstant call)
</member>
        <member name="F:ACT_AMBIENT_LIGHT_COLOUR">
The ambient light colour set in the scene
</member>
        <member name="F:ACT_LIGHT_COUNT">
The number of active light sources (better than gl_MaxLights)
</member>
        <member name="F:ACT_SURFACE_SHININESS">
Surface shininess, as set in Pass::setShininess
</member>
        <member name="F:ACT_SURFACE_EMISSIVE_COLOUR">
Surface emissive colour, as set in Pass::setSelfIllumination
</member>
        <member name="F:ACT_SURFACE_SPECULAR_COLOUR">
Surface specular colour, as set in Pass::setSpecular
</member>
        <member name="F:ACT_SURFACE_DIFFUSE_COLOUR">
Surface diffuse colour, as set in Pass::setDiffuse
</member>
        <member name="F:ACT_SURFACE_AMBIENT_COLOUR">
Surface ambient colour, as set in Pass::setAmbient
</member>
        <member name="F:ACT_FOG_PARAMS">
Fog params: density, linear start, linear end, 1/(end-start)
</member>
        <member name="F:ACT_FOG_COLOUR">
Fog colour
</member>
        <member name="F:ACT_VERTEX_WINDING">
-1 if the winding has been inverted (e.g. for reflections), +1 otherwise.

</member>
        <member name="F:ACT_RENDER_TARGET_FLIPPING">
render target related values
-1 if requires texture flipping, +1 otherwise. It's useful when you bypassed
			projection matrix transform, still able use this value to adjust transformed y position.

</member>
        <member name="F:ACT_INVERSE_TRANSPOSE_WORLDVIEWPROJ_MATRIX">
Provides inverse transpose of concatenated world, view and projection
			matrices. Equivalent to RenderMonkey's "WorldViewProjectionInverseTranspose".

</member>
        <member name="F:ACT_TRANSPOSE_WORLDVIEWPROJ_MATRIX">
Provides transpose of concatenated world, view and projection matrices.
			Equivalent to RenderMonkey's "WorldViewProjectionTranspose".

</member>
        <member name="F:ACT_INVERSE_WORLDVIEWPROJ_MATRIX">
Provides inverse of concatenated world, view and projection matrices.
			Equivalent to RenderMonkey's "WorldViewProjectionInverse".

</member>
        <member name="F:ACT_TRANSPOSE_WORLDVIEW_MATRIX">
Provides transpose of concatenated world and view matrices.
			Equivalent to RenderMonkey's "WorldViewTranspose".

</member>
        <member name="F:ACT_INVERSE_TRANSPOSE_VIEWPROJ_MATRIX">
Provides inverse transpose of concatenated view and projection matrices.
			Equivalent to RenderMonkey's "ViewProjectionInverseTranspose".

</member>
        <member name="F:ACT_TRANSPOSE_VIEWPROJ_MATRIX">
Provides transpose of concatenated view and projection matrices.
			Equivalent to RenderMonkey's "ViewProjectionTranspose".

</member>
        <member name="F:ACT_INVERSE_VIEWPROJ_MATRIX">
Provides inverse of concatenated view and projection matrices.
			Equivalent to RenderMonkey's "ViewProjectionInverse".

</member>
        <member name="F:ACT_INVERSE_TRANSPOSE_PROJECTION_MATRIX">
Provides inverse transpose of projection matrix.
			Equivalent to RenderMonkey's "ProjectionInverseTranspose".

</member>
        <member name="F:ACT_TRANSPOSE_PROJECTION_MATRIX">
Provides transpose of projection matrix.
			Equivalent to RenderMonkey's "ProjectionTranspose".

</member>
        <member name="F:ACT_INVERSE_PROJECTION_MATRIX">
Provides inverse of projection matrix.
			Equivalent to RenderMonkey's "ProjectionInverse".

</member>
        <member name="F:ACT_PROJECTION_MATRIX">
The current projection matrix
</member>
        <member name="F:ACT_INVERSE_TRANSPOSE_VIEW_MATRIX">
Provides inverse transpose of view matrix.
			Equivalent to RenderMonkey's "ViewInverseTranspose".

</member>
        <member name="F:ACT_TRANSPOSE_VIEW_MATRIX">
Provides transpose of view matrix.
			Equivalent to RenderMonkey's "ViewTranspose".

</member>
        <member name="F:ACT_INVERSE_VIEW_MATRIX">
The current view matrix, inverted
</member>
        <member name="F:ACT_VIEW_MATRIX">
The current view matrix
</member>
        <member name="F:ACT_WORLD_MATRIX_ARRAY">
The current array of world matrices, used for blending
</member>
        <member name="F:ACT_WORLD_MATRIX_ARRAY_3x4">
The current array of world matrices, as a 3x4 matrix, used for blending
</member>
        <member name="F:ACT_TRANSPOSE_WORLD_MATRIX">
Provides transpose of world matrix.
			Equivalent to RenderMonkey's "WorldTranspose".

</member>
        <member name="F:ACT_INVERSE_WORLD_MATRIX">
The current world matrix, inverted
</member>
        <member name="F:ACT_WORLD_MATRIX">
The current world matrix
</member>
        <member name="T:Ogre.GpuProgramParameters.AutoConstantType">
Defines the types of automatically updated values that may be bound to GpuProgram
		parameters, or used to modify parameters on a per-object basis.

</member>
        <member name="T:Ogre.GpuProgramParameters">
Collects together the program parameters used for a GpuProgram.
	@remarks
	Gpu program state includes constant parameters used by the program, and
	bindings to render system state which is propagated into the constants 
	by the engine automatically if requested.
	@par
	GpuProgramParameters objects should be created through the GpuProgram and
	may be shared between multiple Pass instances. For this reason they
	are managed using a shared pointer, which will ensure they are automatically
	deleted when no Pass is using them anymore. 
	@par
	High-level programs use named parameters (uniforms), low-level programs 
	use indexed constants. This class supports both, but you can tell whether 
	named constants are supported by calling hasNamedParameters(). There are
	references in the documentation below to 'logical' and 'physical' indexes;
	logical indexes are the indexes used by low-level programs and represent 
	indexes into an array of float4's, some of which may be settable, some of
	which may be predefined constants in the program. We only store those
	constants which have actually been set, therefore our buffer could have 
	gaps if we used the logical indexes in our own buffers. So instead we map
	these logical indexes to physical indexes in our buffer. When using 
	high-level programs, logical indexes don't necessarily exist, although they
	might if the high-level program has a direct, exposed mapping from parameter
	names to logical indexes. In addition, high-level languages may or may not pack
	arrays of elements that are smaller than float4 (e.g. float2/vec2) contiguously.
	This kind of information is held in the ConstantDefinition structure which 
	is only populated for high-level programs. You don't have to worry about
	any of this unless you intend to read parameters back from this structure
	rather than just setting them.

</member>
        <member name="M:Ogre.GpuSharedParametersUsage._getRenderSystemData">
Internal method that the RenderSystem might use to store optional data. 
</member>
        <member name="M:Ogre.GpuSharedParametersUsage._setRenderSystemData(Ogre.Any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method that the RenderSystem might use to store optional data. 
</member>
        <member name="M:Ogre.GpuSharedParametersUsage.getName">
Get the name of the shared parameter set
</member>
        <member name="M:Ogre.GpuSharedParametersUsage._copySharedParamsToTargetParams">
Update the target parameters by copying the data from the shared
			parameters.
		@note This method  may not actually be called if the RenderSystem
			supports using shared parameters directly in their own shared buffer; in
			which case the values should not be copied out of the shared area
			into the individual parameter set, but bound separately.

</member>
        <member name="M:Ogre.GpuSharedParametersUsage.#ctor(Ogre.SharedPtr&lt;Ogre.GpuSharedParameters&gt;,Ogre.GpuProgramParameters*)">
Construct usage
</member>
        <member name="F:Ogre.GpuSharedParametersUsage.mCopyDataVersion">
Version of shared params we based the copydata on
</member>
        <member name="T:Ogre.GpuSharedParametersUsage">
This class records the usage of a set of shared parameters in a concrete
		set of GpuProgramParameters.

</member>
        <member name="D:Ogre.GpuSharedParametersPtr">
Shared pointer used to hold references to GpuProgramParameters instances
</member>
        <member name="M:Ogre.GpuSharedParameters._getRenderSystemData">
Internal method that the RenderSystem might use to store optional data. 
</member>
        <member name="M:Ogre.GpuSharedParameters._setRenderSystemData(Ogre.Any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method that the RenderSystem might use to store optional data. 
</member>
        <member name="M:Ogre.GpuSharedParameters.getIntPointer(System.UInt32)">
Get a pointer to the 'nth' item in the int buffer

Get a pointer to the 'nth' item in the int buffer
</member>
        <member name="M:Ogre.GpuSharedParameters.getFloatPointer(System.UInt32)">
Get a pointer to the 'nth' item in the float buffer

Get a pointer to the 'nth' item in the float buffer
</member>
        <member name="M:Ogre.GpuSharedParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
@copydoc GpuProgramParameters::setNamedConstant 
</member>
        <member name="M:Ogre.GpuSharedParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc GpuProgramParameters::setNamedConstant 
</member>
        <member name="M:Ogre.GpuSharedParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
@copydoc GpuProgramParameters::setNamedConstant 
</member>
        <member name="M:Ogre.GpuSharedParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
@copydoc GpuProgramParameters::setNamedConstant 
</member>
        <member name="M:Ogre.GpuSharedParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
@copydoc GpuProgramParameters::setNamedConstant 
</member>
        <member name="M:Ogre.GpuSharedParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc GpuProgramParameters::setNamedConstant 
</member>
        <member name="M:Ogre.GpuSharedParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc GpuProgramParameters::setNamedConstant 
</member>
        <member name="M:Ogre.GpuSharedParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc GpuProgramParameters::setNamedConstant 
</member>
        <member name="M:Ogre.GpuSharedParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@copydoc GpuProgramParameters::setNamedConstant 
</member>
        <member name="M:Ogre.GpuSharedParameters.setNamedConstant(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
@copydoc GpuProgramParameters::setNamedConstant 
</member>
        <member name="M:Ogre.GpuSharedParameters.getConstantDefinitions">
Get the full list of GpuConstantDefinition instances.

</member>
        <member name="M:Ogre.GpuSharedParameters.getConstantDefinition(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get a specific GpuConstantDefinition for a named parameter.

</member>
        <member name="M:Ogre.GpuSharedParameters.getConstantDefinitionIterator">
Gets an iterator over the named GpuConstantDefinition instances as defined
			by the user. 

</member>
        <member name="M:Ogre.GpuSharedParameters.getFrameLastUpdated">
Get the frame in which this shared parameter set was last updated
</member>
        <member name="M:Ogre.GpuSharedParameters._markDirty">
Mark the shared set as being dirty (values modified).
		@remarks
		You do not need to call this yourself, set is marked as dirty whenever
		setNamedConstant or (non const) getFloatPointer et al are called.

</member>
        <member name="M:Ogre.GpuSharedParameters.getVersion">
Get the version number of this shared parameter set, can be used to identify when 
			changes have occurred. 

</member>
        <member name="M:Ogre.GpuSharedParameters.removeAllConstantDefinitions">
Remove a constant definition from this shared set of parameters.

</member>
        <member name="M:Ogre.GpuSharedParameters.removeConstantDefinition(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Remove a constant definition from this shared set of parameters.

</member>
        <member name="M:Ogre.GpuSharedParameters.addConstantDefinition(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.GpuConstantType,System.UInt32)">
Add a new constant definition to this shared set of parameters.
		@remarks
			Unlike GpuProgramParameters, where the parameter list is defined by the
			program being compiled, this shared parameter set is defined by the
			user. Only parameters which have been predefined here may be later
			updated.

</member>
        <member name="M:Ogre.GpuSharedParameters.getName">
Get the name of this shared parameter set
</member>
        <member name="F:Ogre.GpuSharedParameters.mVersion">
Version number of the definitions in this buffer
</member>
        <member name="F:Ogre.GpuSharedParameters.mFrameLastUpdated">
Not used when copying data, but might be useful to RS using shared buffers
</member>
        <member name="T:Ogre.GpuSharedParameters">
A group of manually updated parameters that are shared between many parameter sets.
	@remarks
		Sometimes you want to set some common parameters across many otherwise 
		different parameter sets, and keep them all in sync together. This class
		allows you to define a set of parameters that you can share across many
		parameter sets and have the parameters that match automatically be pulled
		from the shared set, rather than you having to set them on all the parameter
		sets individually.
	@par
		Parameters in a shared set are matched up with instances in a GpuProgramParameters
		structure by matching names. It is up to you to define the named parameters
		that a shared set contains, and ensuring the definition matches.
	@note
		Shared parameter sets can be named, and looked up using the GpuProgramManager.

</member>
        <member name="D:Ogre.IntConstantList">
Definition of container that holds the current float constants.
	@note Not necessarily in direct index order to constant indexes, logical
	to physical index map is derived from GpuProgram

</member>
        <member name="D:Ogre.FloatConstantList">
Definition of container that holds the current float constants.
	@note Not necessarily in direct index order to constant indexes, logical
	to physical index map is derived from GpuProgram

</member>
        <member name="F:Ogre.GpuLogicalBufferStruct.bufferSize">
Shortcut to know the buffer size needs
</member>
        <member name="F:Ogre.GpuLogicalBufferStruct.map">
Map from logical index to physical buffer location
</member>
        <member name="F:Ogre.GpuLogicalIndexUse.variability">
How the contents of this slot vary
</member>
        <member name="F:Ogre.GpuLogicalIndexUse.currentSize">
Current physical size allocation
</member>
        <member name="F:Ogre.GpuLogicalIndexUse.physicalIndex">
Physical buffer index
</member>
        <member name="T:Ogre.GpuLogicalIndexUse">
Structure recording the use of a physical buffer by a logical parameter
	index. Only used for low-level programs.

</member>
        <member name="T:Ogre.GpuNamedConstantsSerializer">
Simple class for loading / saving GpuNamedConstants
</member>
        <member name="F:Ogre.GpuNamedConstants.msGenerateAllConstantDefinitionArrayEntries">
Indicates whether all array entries will be generated and added to the definitions map
		@remarks
		Normally, the number of array entries added to the definitions map is capped at 16
		to save memory. Setting this value to <code>true</code> allows all of the entries
		to be generated and added to the map.

</member>
        <member name="M:Ogre.GpuNamedConstants.load(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Loads constant definitions from a stream, compatible with GpuProgram::setManualNamedConstantsFile. 
		@see GpuProgram::setManualNamedConstantsFile

</member>
        <member name="M:Ogre.GpuNamedConstants.save(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Saves constant definitions to a file, compatible with GpuProgram::setManualNamedConstantsFile. 
		@see GpuProgram::setManualNamedConstantsFile

</member>
        <member name="M:Ogre.GpuNamedConstants.setGenerateAllConstantDefinitionArrayEntries(System.Boolean)">
Sets whether all array entries will be generated and added to the definitions map.
		@remarks
		Usually, array entries can only be individually indexed if they're up to 16 entries long,
		to save memory - arrays larger than that can be set but only via the bulk setting
		methods. This option allows you to choose to individually index every array entry. 

</member>
        <member name="M:Ogre.GpuNamedConstants.getGenerateAllConstantDefinitionArrayEntries">
Indicates whether all array entries will be generated and added to the definitions map
</member>
        <member name="M:Ogre.GpuNamedConstants.generateConstantDefinitionArrayEntries(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.GpuConstantDefinition!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Generate additional constant entries for arrays based on a base definition.
		@remarks
		Array uniforms will be added just with their base name with no array
		suffix. This method will add named entries for array suffixes too
		so individual array entries can be addressed. Note that we only 
		individually index array elements if the array size is up to 16
		entries in size. Anything larger than that only gets a [0] entry
		as well as the main entry, to save cluttering up the name map. After
		all, you can address the larger arrays in a bulk fashion much more
		easily anyway. 

</member>
        <member name="F:Ogre.GpuNamedConstants.map">
Map of parameter names to GpuConstantDefinition
</member>
        <member name="F:Ogre.GpuNamedConstants.intBufferSize">
Total size of the int buffer required
</member>
        <member name="F:Ogre.GpuNamedConstants.floatBufferSize">
Total size of the float buffer required
</member>
        <member name="T:Ogre.GpuNamedConstants">
Struct collecting together the information for named constants.
</member>
        <member name="M:Ogre.GpuConstantDefinition.getElementSize(Ogre.GpuConstantType,System.Boolean)">
Get the element size of a given type, including whether to pad the 
			elements into multiples of 4 (e.g. SM1 and D3D does, GLSL doesn't)

</member>
        <member name="F:Ogre.GpuConstantDefinition.variability">
How this parameter varies (bitwise combination of GpuProgramVariability)
</member>
        <member name="F:Ogre.GpuConstantDefinition.arraySize">
Length of array
</member>
        <member name="F:Ogre.GpuConstantDefinition.elementSize">
Number of raw buffer slots per element 
		(some programs pack each array element to float4, some do not) 
</member>
        <member name="F:Ogre.GpuConstantDefinition.logicalIndex">
Logical index - used to communicate this constant to the rendersystem
</member>
        <member name="F:Ogre.GpuConstantDefinition.physicalIndex">
Physical start index in buffer (either float or int buffer)
</member>
        <member name="F:Ogre.GpuConstantDefinition.constType">
Data type
</member>
        <member name="T:Ogre.GpuConstantDefinition">
Information about predefined program constants. 
	@note Only available for high-level programs but is referenced generically
	by GpuProgramParameters.

</member>
        <member name="T:Ogre.GpuParamVariability">
The variability of a GPU parameter, as derived from auto-params targetting it.
	These values must be powers of two since they are used in masks.

</member>
        <member name="F:GPV_ALL">
Full mask (16-bit)
</member>
        <member name="F:GPV_PASS_ITERATION_NUMBER">
Varies with pass iteration number
</member>
        <member name="F:GPV_LIGHTS">
Varies with light setup
</member>
        <member name="F:GPV_PER_OBJECT">
Varies per object (based on an auto param usually), but not per light setup
</member>
        <member name="F:GPV_GLOBAL">
No variation except by manual setting - the default
</member>
        <member name="T:Ogre.GpuConstantType">
\addtogroup Core
	*  @{

\addtogroup Materials
	*  @{

Enumeration of the types of constant we may encounter in programs. 
	@note Low-level programs, by definition, will always use either
	float4 or int4 constant types since that is the fundamental underlying
	type in assembler.

</member>
        <member name="M:Ogre.Serializer.determineEndianness(Ogre.Serializer.Endian)">
Determine the endianness to write with based on option
</member>
        <member name="M:Ogre.Serializer.determineEndianness(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Determine the endianness of the incoming stream compared to native
</member>
        <member name="F:ENDIAN_LITTLE">
Use little endian (0x1000 is serialised as 0x00 0x10)
</member>
        <member name="F:ENDIAN_BIG">
Use big endian (0x1000 is serialised as 0x10 0x00)
</member>
        <member name="F:ENDIAN_NATIVE">
Use the platform native endian
</member>
        <member name="T:Ogre.Serializer.Endian">
The endianness of written files
</member>
        <member name="T:Ogre.Serializer">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

Generic class for serialising data to / from binary stream-based files.
    @remarks
        This class provides a number of useful methods for exporting / importing data
        from stream-oriented binary files (e.g. .mesh and .skeleton).

</member>
        <member name="M:Ogre.MaterialPtr.op_Assign(Ogre.SharedPtr&lt;Ogre.Resource&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Operator used to convert a ResourcePtr to a MaterialPtr
</member>
        <member name="M:Ogre.Material.getCompilationRequired">
Gets the compilation status of the material.
        @return True if the material needs recompilation.

</member>
        <member name="M:Ogre.Material.applyTextureAliases(std.map&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.less&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServ">
Applies texture names to Texture Unit State with matching texture name aliases.
            All techniques, passes, and Texture Unit States within the material are checked.
            If matching texture aliases are found then true is returned.

        @param
            aliasList is a map container of texture alias, texture name pairs
        @param
            apply set true to apply the texture aliases else just test to see if texture alias matches are found.
        @return
            True if matching texture aliases were found in the material.

</member>
        <member name="M:Ogre.Material.touch">
@copydoc Resource::touch

</member>
        <member name="M:Ogre.Material.setLodStrategy(Ogre.LodStrategy*)">
Set the lod strategy used by this material. 
</member>
        <member name="M:Ogre.Material.getLodStrategy">
Get lod strategy used by this material. 
</member>
        <member name="M:Ogre.Material.getLodIndex(System.Single)">
Gets the LOD index to use at the given value. 
		@note The value passed in is the 'transformed' value. If you are dealing with
		an original source value (e.g. distance), use LodStrategy::transformUserValue
		to turn this into a lookup value.

</member>
        <member name="M:Ogre.Material.getLodValueIterator">
Gets an iterator over the list of values at which each LOD comes into effect. 
        @remarks
            Note that the iterator returned from this method is not totally analogous to 
            the one passed in by calling setLodLevels - the list includes a zero
            entry at the start (since the highest LOD starts at value 0). Also, the
			values returned are after being transformed by LodStrategy::transformUserValue.

</member>
        <member name="M:Ogre.Material.setLodLevels(std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the distance at which level-of-detail (LOD) levels come into effect.
        @remarks
            You should only use this if you have assigned LOD indexes to the Technique
            instances attached to this Material. If you have done so, you should call this
            method to determine the distance at which the lowe levels of detail kick in.
            The decision about what distance is actually used is a combination of this
            and the LOD bias applied to both the current Camera and the current Entity.
        @param lodValues A vector of Reals which indicate the lod value at which to 
            switch to lower details. They are listed in LOD index order, starting at index
            1 (ie the first level down from the highest level 0, which automatically applies
            from a value of 0). These are 'user values', before being potentially 
			transformed by the strategy, so for the distance strategy this is an
			unsquared distance for example.

</member>
        <member name="M:Ogre.Material._notifyNeedsRecompile">
Tells the material that it needs recompilation. 
</member>
        <member name="M:Ogre.Material.setSeparateSceneBlending(Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst,Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst,Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst,Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst)">
Allows very fine control of blending every Pass with the existing contents of the scene, using individual factors for color and alpha channels
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setSeparateSceneBlending

</member>
        <member name="M:Ogre.Material.setSceneBlending(Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst,Ogre.SceneBlendFactor!System.Runtime.CompilerServices.IsConst)">
Allows very fine control of blending every Pass with the existing contents of the scene.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setSceneBlending

</member>
        <member name="M:Ogre.Material.setSeparateSceneBlending(Ogre.SceneBlendType!System.Runtime.CompilerServices.IsConst,Ogre.SceneBlendType!System.Runtime.CompilerServices.IsConst)">
Sets the kind of blending every pass has with the existing contents of the scene, using individual factors for color and alpha channels
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setSeparateSceneBlending

</member>
        <member name="M:Ogre.Material.setSceneBlending(Ogre.SceneBlendType!System.Runtime.CompilerServices.IsConst)">
Sets the kind of blending every pass has with the existing contents of the scene.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setSceneBlending

</member>
        <member name="M:Ogre.Material.setTextureAnisotropy(System.Int32)">
Sets the anisotropy level to be used for all textures.
        @note
            This property has been moved to the TextureUnitState class, which is accessible via the 
            Technique and Pass. For simplicity, this method allows you to set these properties for 
            every current TeextureUnitState, If you need more precision, retrieve the Technique, 
            Pass and TextureUnitState instances and set the property there.
        @see TextureUnitState::setTextureAnisotropy

</member>
        <member name="M:Ogre.Material.setTextureFiltering(Ogre.TextureFilterOptions)">
Set texture filtering for every texture unit in every Technique and Pass
        @note
            This property has been moved to the TextureUnitState class, which is accessible via the 
            Technique and Pass. For simplicity, this method allows you to set these properties for 
            every current TeextureUnitState, If you need more precision, retrieve the Technique, 
            Pass and TextureUnitState instances and set the property there.
        @see TextureUnitState::setTextureFiltering

</member>
        <member name="M:Ogre.Material.setDepthBias(System.Single,System.Single)">
Sets the depth bias to be used for each Pass.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setDepthBias

</member>
        <member name="M:Ogre.Material.setFog(System.Boolean,Ogre.FogMode,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single)">
Sets the fogging mode applied to each pass.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setFog

</member>
        <member name="M:Ogre.Material.setShadingMode(Ogre.ShadeOptions)">
Sets the type of light shading required
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setShadingMode

</member>
        <member name="M:Ogre.Material.setLightingEnabled(System.Boolean)">
Sets whether or not dynamic lighting is enabled for every Pass.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setLightingEnabled

</member>
        <member name="M:Ogre.Material.setManualCullingMode(Ogre.ManualCullingMode)">
Sets the manual culling mode, performed by CPU rather than hardware.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setManualCullingMode

</member>
        <member name="M:Ogre.Material.setCullingMode(Ogre.CullingMode)">
Sets the culling mode for each pass  based on the 'vertex winding'.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setCullingMode

</member>
        <member name="M:Ogre.Material.setColourWriteEnabled(System.Boolean)">
Sets whether or not colour buffer writing is enabled for each Pass.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setColourWriteEnabled

</member>
        <member name="M:Ogre.Material.setDepthFunction(Ogre.CompareFunction)">
Sets the function used to compare depth values when depth checking is on.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setDepthFunction

</member>
        <member name="M:Ogre.Material.setDepthWriteEnabled(System.Boolean)">
Sets whether or not each Pass renders with depth-buffer writing on or not.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setDepthWriteEnabled

</member>
        <member name="M:Ogre.Material.setDepthCheckEnabled(System.Boolean)">
Sets whether or not each Pass renders with depth-buffer checking on or not.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setDepthCheckEnabled

</member>
        <member name="M:Ogre.Material.setSelfIllumination(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the amount of self-illumination of every Pass in every Technique.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setSelfIllumination

</member>
        <member name="M:Ogre.Material.setSelfIllumination(System.Single,System.Single,System.Single)">
Sets the amount of self-illumination of every Pass in every Technique.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setSelfIllumination

</member>
        <member name="M:Ogre.Material.setShininess(System.Single)">
Sets the shininess properties of every Pass in every Technique.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setShininess

</member>
        <member name="M:Ogre.Material.setSpecular(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the specular colour reflectance properties of every Pass in every Technique.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setSpecular

</member>
        <member name="M:Ogre.Material.setSpecular(System.Single,System.Single,System.Single,System.Single)">
Sets the specular colour reflectance properties of every Pass in every Technique.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setSpecular

</member>
        <member name="M:Ogre.Material.setDiffuse(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the diffuse colour reflectance properties of every Pass in every Technique.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setDiffuse

</member>
        <member name="M:Ogre.Material.setDiffuse(System.Single,System.Single,System.Single,System.Single)">
Sets the diffuse colour reflectance properties of every Pass in every Technique.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setDiffuse

</member>
        <member name="M:Ogre.Material.setAmbient(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the ambient colour reflectance properties for every Pass in every Technique.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setAmbient

</member>
        <member name="M:Ogre.Material.setAmbient(System.Single,System.Single,System.Single)">
Sets the ambient colour reflectance properties for every Pass in every Technique.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setAmbient

</member>
        <member name="M:Ogre.Material.setPointSize(System.Single)">
Sets the point size properties for every Pass in every Technique.
        @note
            This property has been moved to the Pass class, which is accessible via the 
            Technique. For simplicity, this method allows you to set these properties for 
            every current Technique, and for every current Pass within those Techniques. If 
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
        @see Pass::setPointSize

</member>
        <member name="M:Ogre.Material.compile(System.Boolean)">
'Compiles' this Material.
        @remarks
            Compiling a material involves determining which Techniques are supported on the
            card on which OGRE is currently running, and for fixed-function Passes within those
            Techniques, splitting the passes down where they contain more TextureUnitState 
            instances than the current card has texture units.
        @par
            This process is automatically done when the Material is loaded, but may be
            repeated if you make some procedural changes.
        @param
            autoManageTextureUnits If true, when a fixed function pass has too many TextureUnitState
                entries than the card has texture units, the Pass in question will be split into
                more than one Pass in order to emulate the Pass. If you set this to false and
                this situation arises, an Exception will be thrown.

</member>
        <member name="M:Ogre.Material.copyDetailsTo(Ogre.MaterialPtr*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copies the details of this material into another, preserving the target's handle and name
        (unlike operator=) but copying everything else.
        @param mat Weak reference to material which will receive this material's settings.

</member>
        <member name="M:Ogre.Material.clone(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a new copy of this material with the same settings but a new name.
		@param newName The name for the cloned material
		@param changeGroup If true, the resource group of the clone is changed
		@param newGroup Only required if changeGroup is true; the new group to assign

</member>
        <member name="M:Ogre.Material.getBestTechnique(System.UInt16,Ogre.Renderable!System.Runtime.CompilerServices.IsConst*)">
Gets the best supported technique. 
        @remarks
            This method returns the lowest-index supported Technique in this material
            (since lower-indexed Techniques are considered to be better than higher-indexed
            ones).
        @par
            The best supported technique is only available after this material has been compiled,
            which typically happens on loading the material. Therefore, if this method returns
            NULL, try calling Material::load.
		@param lodIndex The material lod index to use
		@param rend Optional parameter specifying the Renderable that is requesting
			this technique. Only used if no valid technique for the active material 
			scheme is found, at which point it is passed to 
			MaterialManager::Listener::handleSchemeNotFound as information.

</member>
        <member name="M:Ogre.Material.getNumLodLevels(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the number of levels-of-detail this material has in the 
			given scheme, based on Technique::setLodIndex. 
        @remarks
            Note that this will not be up to date until the material has been compiled.

</member>
        <member name="M:Ogre.Material.getNumLodLevels(System.UInt16)">
Gets the number of levels-of-detail this material has in the 
			given scheme, based on Technique::setLodIndex. 
        @remarks
            Note that this will not be up to date until the material has been compiled.

</member>
        <member name="M:Ogre.Material.getUnsupportedTechniquesExplanation">
Gets a string explaining why any techniques are not supported. 
</member>
        <member name="M:Ogre.Material.getNumSupportedTechniques">
Retrieves the number of supported techniques. 
</member>
        <member name="M:Ogre.Material.getSupportedTechnique(System.UInt16)">
Gets the indexed supported technique. 
</member>
        <member name="M:Ogre.Material.getSupportedTechniqueIterator">
Gets an iterator over all the Techniques which are supported by the current card. 
        @remarks
            The supported technique list is only available after this material has been compiled,
            which typically happens on loading the material. Therefore, if this method returns
            an empty list, try calling Material::load.

</member>
        <member name="M:Ogre.Material.getTechniqueIterator">
Get an iterator over the Techniques in this Material. 
</member>
        <member name="M:Ogre.Material.removeAllTechniques">
Removes all the techniques in this Material. 
</member>
        <member name="M:Ogre.Material.removeTechnique(System.UInt16)">
Removes the technique at the given index. 
</member>
        <member name="M:Ogre.Material.getNumTechniques">
Retrieves the number of techniques. 
</member>
        <member name="M:Ogre.Material.getTechnique(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
searches for the named technique.
            Return 0 if technique with name is not found

</member>
        <member name="M:Ogre.Material.getTechnique(System.UInt16)">
Gets the indexed technique. 
</member>
        <member name="M:Ogre.Material.createTechnique">
Creates a new Technique for this Material.
        @remarks
            A Technique is a single way of rendering geometry in order to achieve the effect
            you are intending in a material. There are many reason why you would want more than
            one - the main one being to handle variable graphics card abilities; you might have
            one technique which is impressive but only runs on 4th-generation graphics cards, 
            for example. In this case you will want to create at least one fallback Technique.
            OGRE will work out which Techniques a card can support and pick the best one.
        @par
            If multiple Techniques are available, the order in which they are created is 
            important - the engine will consider lower-indexed Techniques to be preferable
            to higher-indexed Techniques, ie when asked for the 'best' technique it will
            return the first one in the technique list which is supported by the hardware.

</member>
        <member name="M:Ogre.Material.getTransparencyCastsShadows">
Returns whether or not objects using this material be classified as opaque to the shadow caster system. 
</member>
        <member name="M:Ogre.Material.setTransparencyCastsShadows(System.Boolean)">
Sets whether objects using this material be classified as opaque to	the shadow caster system.
		@remarks
		This method allows a material to cast a shadow, even if it is transparent.
		By default, transparent materials neither cast nor receive shadows. Shadows
		will not be cast on any objects unless the scene is set up to support shadows 
		(@see SceneManager::setShadowTechnique), and not all techniques cast
		shadows on all objects.

</member>
        <member name="M:Ogre.Material.getReceiveShadows">
Returns whether or not objects using this material will receive shadows. 
</member>
        <member name="M:Ogre.Material.setReceiveShadows(System.Boolean)">
Sets whether objects using this material will receive shadows.
        @remarks
            This method allows a material to opt out of receiving shadows, if
            it would otherwise do so. Shadows will not be cast on any objects
            unless the scene is set up to support shadows 
            (@see SceneManager::setShadowTechnique), and not all techniques cast
            shadows on all objects. In any case, if you have a need to prevent
            shadows being received by material, this is the method you call to
            do it.
        @note 
            Transparent materials never receive shadows despite this setting. 
            The default is to receive shadows.

</member>
        <member name="M:Ogre.Material.isTransparent">
Determines if the material has any transparency with the rest of the scene (derived from 
            whether any Techniques say they involve transparency).

</member>
        <member name="M:Ogre.Material.op_Assign(Ogre.Material!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator to allow easy copying between materials.

</member>
        <member name="M:Ogre.Material.#ctor(Ogre.ResourceManager*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.M">
Constructor - use resource manager's create method rather than this.

</member>
        <member name="M:Ogre.Material.calculateSize">
@copydoc Resource::calculateSize
</member>
        <member name="M:Ogre.Material.unloadImpl">
Unloads the material, frees resources etc.
		@see
		Resource

</member>
        <member name="M:Ogre.Material.loadImpl">
Overridden from Resource.

</member>
        <member name="M:Ogre.Material.unprepareImpl">
Overridden from Resource.

</member>
        <member name="M:Ogre.Material.prepareImpl">
Overridden from Resource.

</member>
        <member name="M:Ogre.Material.clearBestTechniqueList">
Clear the best technique list.

</member>
        <member name="M:Ogre.Material.insertSupportedTechnique(Ogre.Technique*)">
Insert a supported technique into the local collections. 
</member>
        <member name="F:Ogre.Material.mUnsupportedReasons">
Text description of why any techniques are not supported
</member>
        <member name="F:Ogre.Material.mCompilationRequired">
Does this material require compilation?
</member>
        <member name="F:Ogre.Material.mBestTechniquesBySchemeList">
Map of scheme -&gt; list of LOD techniques. 
			Current scheme is set on MaterialManager,
			and can be set per Viewport for auto activation.

</member>
        <member name="F:Ogre.Material.mSupportedTechniques">
Supported techniques of any sort
</member>
        <member name="F:Ogre.Material.mTechniques">
All techniques, supported and unsupported
</member>
        <member name="M:Ogre.Material.applyDefaults">
Internal method which sets the material up from the default settings.

</member>
        <member name="D:Ogre.Material.LodValueList">
distance list used to specify LOD
</member>
        <member name="T:Ogre.Material">
\addtogroup Core
	*  @{

\addtogroup Materials
	*  @{

Class encapsulates rendering properties of an object.
    @remarks
    Ogre's material class encapsulates ALL aspects of the visual appearance,
    of an object. It also includes other flags which 
    might not be traditionally thought of as material properties such as 
    culling modes and depth buffer settings, but these affect the 
    appearance of the rendered object and are convenient to attach to the 
    material since it keeps all the settings in one place. This is 
    different to Direct3D which treats a material as just the colour 
    components (diffuse, specular) and not texture maps etc. An Ogre 
    Material can be thought of as equivalent to a 'Shader'.
    @par
    A Material can be rendered in multiple different ways depending on the
    hardware available. You may configure a Material to use high-complexity
    fragment shaders, but these won't work on every card; therefore a Technique
    is an approach to creating the visual effect you are looking for. You are advised
    to create fallback techniques with lower hardware requirements if you decide to
    use advanced features. In addition, you also might want lower-detail techniques
    for distant geometry.
    @par
    Each technique can be made up of multiple passes. A fixed-function pass
    may combine multiple texture layers using multitexrtuing, but Ogre can 
    break that into multiple passes automatically if the active card cannot
    handle that many simultaneous textures. Programmable passes, however, cannot
    be split down automatically, so if the active graphics card cannot handle the
    technique which contains these passes, OGRE will try to find another technique
    which the card can do. If, at the end of the day, the card cannot handle any of the
    techniques which are listed for the material, the engine will render the 
    geometry plain white, which should alert you to the problem.
    @par
    Ogre comes configured with a number of default settings for a newly 
    created material. These can be changed if you wish by retrieving the 
    default material settings through 
    SceneManager::getDefaultMaterialSettings. Any changes you make to the 
    Material returned from this method will apply to any materials created 
    from this point onward.

</member>
        <member name="T:Ogre.SceneBlendOperation">
Blending operations controls how objects are blended into the scene. The default operation
		is add (+) but by changing this you can change how drawn objects are blended into the
		existing scene.

</member>
        <member name="T:Ogre.SceneBlendFactor">
Blending factors for manually blending objects with the scene. If there isn't a predefined
        SceneBlendType that you like, then you can specify the blending factors directly to affect the
        combination of object and the existing scene. See Material::setSceneBlending for more details.

</member>
        <member name="T:Ogre.SceneBlendType">
Types of blending that you can specify between an object and the existing contents of the scene.
        @remarks
            As opposed to the LayerBlendType, which classifies blends between texture layers, these blending
            types blend between the output of the texture units and the pixels already in the viewport,
            allowing for object transparency, glows, etc.
        @par
            These types are provided to give quick and easy access to common effects. You can also use
            the more manual method of supplying source and destination blending factors.
            See Material::setSceneBlending for more details.
        @see
            Material::setSceneBlending

</member>
        <member name="F:SBT_REPLACE">
The default blend mode where source replaces destination
</member>
        <member name="F:SBT_MODULATE">
Multiply the 2 colours together
</member>
        <member name="F:SBT_ADD">
Add the texture values to the existing scene content
</member>
        <member name="F:SBT_TRANSPARENT_COLOUR">
Make the object transparent based on the colour values in the texture (brighter = more opaque)
</member>
        <member name="F:SBT_TRANSPARENT_ALPHA">
Make the object transparent based on the final alpha values in the texture
</member>
        <member name="F:Ogre.LayerBlendModeEx.factor">
Manual blending factor
</member>
        <member name="F:Ogre.LayerBlendModeEx.alphaArg2">
Manual alpha value for manual source2
</member>
        <member name="F:Ogre.LayerBlendModeEx.alphaArg1">
Manual alpha value for manual source1
</member>
        <member name="F:Ogre.LayerBlendModeEx.colourArg2">
Manual colour value for manual source2
</member>
        <member name="F:Ogre.LayerBlendModeEx.colourArg1">
Manual colour value for manual source1
</member>
        <member name="F:Ogre.LayerBlendModeEx.source2">
The second source of colour/alpha
</member>
        <member name="F:Ogre.LayerBlendModeEx.source1">
The first source of colour/alpha
</member>
        <member name="F:Ogre.LayerBlendModeEx.operation">
The operation to be applied
</member>
        <member name="F:Ogre.LayerBlendModeEx.blendType">
The type of blending (colour or alpha)
</member>
        <member name="T:Ogre.LayerBlendModeEx">
Class which manages blending of both colour and alpha components.
        @remarks
            This class is a utility class used by both TextureUnitState and
            RenderSystem to wrap up the details of a blending operation. This blending
            operation could be used for blending colour or alpha in a texture layer.
            This class is really only for use by OGRE, since apps can deal with
            blending modes through the TextureUnitState class methods
            setColourOperation and setAlphaOperation.
        @par
            It's worth noting that these operations are for blending <i>between texture
            layers</i> and not between rendered objects and the existing scene. If
            you wish to make an object blend with others in the scene, e.g. to make
            transparent objects etc, use the Material::setSceneBlending method.

</member>
        <member name="T:Ogre.LayerBlendSource">
List of valid sources of values for blending operations used
        in TextureUnitState::setColourOperation and TextureUnitState::setAlphaOperation,
        and internally in the LayerBlendModeEx class.

</member>
        <member name="F:LBS_MANUAL">
a colour supplied manually as a separate argument
</member>
        <member name="F:LBS_SPECULAR">
the interpolated specular colour from the vertices
</member>
        <member name="F:LBS_DIFFUSE">
the interpolated diffuse colour from the vertices
</member>
        <member name="F:LBS_TEXTURE">
the colour derived from the texture assigned to this layer
</member>
        <member name="F:LBS_CURRENT">
the colour as built up from previous stages
</member>
        <member name="T:Ogre.LayerBlendOperationEx">
Expert list of valid texture blending operations, for use with TextureUnitState::setColourOperationEx
        and TextureUnitState::setAlphaOperation, and internally in the LayerBlendModeEx class. It's worth
        noting that these operations are for blending <i>between texture layers</i> and not between rendered objects
        and the existing scene. Because all of these modes are only supported in multitexture hardware it may be
        required to set up a fallback operation where this hardware is not available.

</member>
        <member name="F:LBX_BLEND_DIFFUSE_COLOUR">
use interpolated color values from vertices to scale source1, then add source2 scaled by (1-color)
</member>
        <member name="F:LBX_DOTPRODUCT">
dot product of color1 and color2 
</member>
        <member name="F:LBX_BLEND_MANUAL">
as LBX_BLEND_DIFFUSE_ALPHA but use a constant manual blend value (0.0-1.0)
</member>
        <member name="F:LBX_BLEND_CURRENT_ALPHA">
as LBX_BLEND_DIFFUSE_ALPHA, but use current alpha from previous stages
</member>
        <member name="F:LBX_BLEND_TEXTURE_ALPHA">
as LBX_BLEND_DIFFUSE_ALPHA, but use alpha from texture
</member>
        <member name="F:LBX_BLEND_DIFFUSE_ALPHA">
use interpolated alpha value from vertices to scale source1, then add source2 scaled by (1-alpha)
</member>
        <member name="F:LBX_SUBTRACT">
subtract source2 from source1
</member>
        <member name="F:LBX_ADD_SMOOTH">
as LBX_ADD, but subtract product from the sum
</member>
        <member name="F:LBX_ADD_SIGNED">
as LBX_ADD, but subtract 0.5 from the result
</member>
        <member name="F:LBX_ADD">
add source1 and source2 together
</member>
        <member name="F:LBX_MODULATE_X4">
as LBX_MODULATE but brighten more afterwards (x4)
</member>
        <member name="F:LBX_MODULATE_X2">
as LBX_MODULATE but brighten afterwards (x2)
</member>
        <member name="F:LBX_MODULATE">
multiply source1 and source2 together
</member>
        <member name="F:LBX_SOURCE2">
use source2 without modification
</member>
        <member name="F:LBX_SOURCE1">
use source1 without modification
</member>
        <member name="T:Ogre.LayerBlendOperation">
List of valid texture blending operations, for use with TextureUnitState::setColourOperation.
        @remarks
            This list is a more limited list than LayerBlendOperationEx because it only
            includes operations that are supportable in both multipass and multitexture
            rendering and thus provides automatic fallback if multitexture hardware
            is lacking or insufficient.

</member>
        <member name="F:LBO_ALPHA_BLEND">
Blend based on texture alpha
</member>
        <member name="F:LBO_MODULATE">
Multiply colour components together.
</member>
        <member name="F:LBO_ADD">
Add colour components together.
</member>
        <member name="F:LBO_REPLACE">
Replace all colour with texture with no adjustment
</member>
        <member name="T:Ogre.LayerBlendType">
\addtogroup Core
	*  @{

\addtogroup Materials
	*  @{

Type of texture blend mode.

</member>
        <member name="F:Ogre.RenderOperation.srcRenderable">
Debug pointer back to renderable which created this
</member>
        <member name="F:Ogre.RenderOperation.indexData">
Index data - only valid if useIndexes is true
</member>
        <member name="F:Ogre.RenderOperation.useIndexes">
Specifies whether to use indexes to determine the vertices to use as input. If false, the vertices are
		 simply read in sequence to define the primitives. If true, indexes are used instead to identify vertices
		 anywhere in the buffer, and allowing vertices to be used more than once.
	   	 If true, then the indexBuffer, indexStart and numIndexes properties must be valid. 
</member>
        <member name="F:Ogre.RenderOperation.operationType">
The type of operation to perform
</member>
        <member name="F:Ogre.RenderOperation.vertexData">
Vertex source data
</member>
        <member name="F:OT_TRIANGLE_FAN">
A fan of triangles, 3 vertices for the first triangle, and 1 per triangle after that
</member>
        <member name="F:OT_TRIANGLE_STRIP">
A strip of triangles, 3 vertices for the first triangle, and 1 per triangle after that 
</member>
        <member name="F:OT_TRIANGLE_LIST">
A list of triangles, 3 vertices per triangle
</member>
        <member name="F:OT_LINE_STRIP">
A strip of connected lines, 1 vertex per line plus 1 start vertex
</member>
        <member name="F:OT_LINE_LIST">
A list of lines, 2 vertices per line
</member>
        <member name="F:OT_POINT_LIST">
A list of points, 1 vertex per point
</member>
        <member name="T:Ogre.RenderOperation.OperationType">
The rendering operation type to perform
</member>
        <member name="T:Ogre.RenderOperation">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

'New' rendering operation using vertex buffers. 
</member>
        <member name="T:Ogre.VertexCacheProfiler">
Vertex cache profiler.
	@remarks
		Utility class for evaluating the effectiveness of the use of the vertex
		cache by a given index buffer.

</member>
        <member name="M:Ogre.IndexData.optimiseVertexCacheTriList">
Re-order the indexes in this index data structure to be more
			vertex cache friendly; that is to re-use the same vertices as close
			together as possible. 
		@remarks
			Can only be used for index data which consists of triangle lists.
			It would in fact be pointless to use it on triangle strips or fans
			in any case.

</member>
        <member name="M:Ogre.IndexData.clone(System.Boolean,Ogre.HardwareBufferManagerBase*)">
Clones this index data, potentially including replicating the index buffer.
		@param copyData Whether to create new buffers too or just reference the existing ones
		@param mgr If supplied, the buffer manager through which copies should be made
		@remarks The caller is expected to delete the returned pointer when finished

</member>
        <member name="F:Ogre.IndexData.indexCount">
The number of indexes to use from the buffer
</member>
        <member name="F:Ogre.IndexData.indexStart">
index in the buffer to start from for this operation
</member>
        <member name="F:Ogre.IndexData.indexBuffer">
pointer to the HardwareIndexBuffer to use, must be specified if useIndexes = true
</member>
        <member name="M:Ogre.IndexData.op_Assign(Ogre.IndexData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Protected operator=, to prevent misuse
</member>
        <member name="M:Ogre.IndexData.#ctor(Ogre.IndexData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Protected copy constructor, to prevent misuse
</member>
        <member name="T:Ogre.IndexData">
Summary class collecting together index data source information. 
</member>
        <member name="M:Ogre.VertexData.allocateHardwareAnimationElements(System.UInt16)">
Allocate elements to serve a holder of morph / pose target data 
			for hardware morphing / pose blending.
		@remarks
			This method will allocate the given number of 3D texture coordinate 
			sets for use as a morph target or target pose offset (3D position).
			These elements will be saved in hwAnimationDataList.
			It will also assume that the source of these new elements will be new
			buffers which are not bound at this time, so will start the sources to 
			1 higher than the current highest binding source. The caller is
			expected to bind these new buffers when appropriate. For morph animation
			the original position buffer will be the 'from' keyframe data, whilst
			for pose animation it will be the original vertex data.

</member>
        <member name="M:Ogre.VertexData.convertPackedColour(Ogre.VertexElementType,Ogre.VertexElementType)">
Convert all packed colour values (VET_COLOUR_*) in buffers used to
			another type.
		@param srcType The source colour type to assume if the ambiguous VET_COLOUR
			is encountered.
		@param destType The destination colour type, must be VET_COLOUR_ABGR or
			VET_COLOUR_ARGB.

</member>
        <member name="M:Ogre.VertexData.removeUnusedBuffers">
Remove all vertex buffers that never used by the vertex declaration.
        @remarks
            This is useful if you've removed elements from the vertex declaration
            and want to unreference buffers that never used any more. This method
            is mainly useful when reorganising vertex data manually.
        @note
            This also remove any gaps in the vertex buffer bindings.

</member>
        <member name="M:Ogre.VertexData.closeGapsInBindings">
Remove any gaps in the vertex buffer bindings.
        @remarks
            This is useful if you've removed elements and buffers from this vertex
            data and want to remove any gaps in the vertex buffer bindings. This
            method is mainly useful when reorganising vertex data manually.
        @note
            This will cause binding index of the elements in the vertex declaration
            to be altered to new binding index.

</member>
        <member name="M:Ogre.VertexData.reorganiseBuffers(Ogre.VertexDeclaration*,Ogre.HardwareBufferManagerBase*)">
Reorganises the data in the vertex buffers according to the 
			new vertex declaration passed in. Note that new vertex buffers
			are created and written to, so if the buffers being referenced 
			by this vertex data object are also used by others, then the 
			original buffers will not be damaged by this operation.
			Once this operation has completed, the new declaration 
			passed in will overwrite the current one.
            This version of the method derives the buffer usages from the existing
            buffers, by using the 'most flexible' usage from the equivalent sources.
		@param newDeclaration The vertex declaration which will be used
			for the reorganised buffer state. Note that the new delcaration
			must not include any elements which do not already exist in the 
			current declaration; you can drop elements by 
			excluding them from the declaration if you wish, however.
		@param mgr Optional pointer to the manager to use to create new declarations
			and buffers etc. If not supplied, the HardwareBufferManager singleton will be used

</member>
        <member name="M:Ogre.VertexData.reorganiseBuffers(Ogre.VertexDeclaration*,std.vector&lt;Ogre.HardwareBuffer.Usage&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.HardwareBufferManagerBase*)">
Reorganises the data in the vertex buffers according to the 
			new vertex declaration passed in. Note that new vertex buffers
			are created and written to, so if the buffers being referenced 
			by this vertex data object are also used by others, then the 
			original buffers will not be damaged by this operation.
			Once this operation has completed, the new declaration 
			passed in will overwrite the current one.
		@param newDeclaration The vertex declaration which will be used
			for the reorganised buffer state. Note that the new declaration
			must not include any elements which do not already exist in the 
			current declaration; you can drop elements by 
			excluding them from the declaration if you wish, however.
		@param bufferUsages Vector of usage flags which indicate the usage options
			for each new vertex buffer created. The indexes of the entries must correspond
			to the buffer binding values referenced in the declaration.
		@param mgr Optional pointer to the manager to use to create new declarations
			and buffers etc. If not supplied, the HardwareBufferManager singleton will be used

</member>
        <member name="F:Ogre.VertexData.hardwareShadowVolWBuffer">
Additional shadow volume vertex buffer storage. 
        @remarks
            This additional buffer is only used where we have prepared this VertexData for
            use in shadow volume construction, and where the current render system supports
            vertex programs. This buffer contains the 'w' vertex position component which will
            be used by that program to differentiate between extruded and non-extruded vertices.
            This 'w' component cannot be included in the original position buffer because
            DirectX does not allow 4-component positions in the fixed-function pipeline, and the original
            position buffer must still be usable for fixed-function rendering.
        @par    
            Note that we don't store any vertex declaration or vertex buffer binding here because this
            can be reused in the shadow algorithm.

</member>
        <member name="M:Ogre.VertexData.prepareForShadowVolume">
Modifies the vertex data to be suitable for use for rendering shadow geometry.
        @remarks
            Preparing vertex data to generate a shadow volume involves firstly ensuring that the 
            vertex buffer containing the positions is a standalone vertex buffer,
            with no other components in it. This method will therefore break apart any existing
            vertex buffers if position is sharing a vertex buffer. 
            Secondly, it will double the size of this vertex buffer so that there are 2 copies of 
            the position data for the mesh. The first half is used for the original, and the second 
            half is used for the 'extruded' version. The vertex count used to render will remain 
            the same though, so as not to add any overhead to regular rendering of the object.
            Both copies of the position are required in one buffer because shadow volumes stretch 
            from the original mesh to the extruded version. 
        @par
            It's important to appreciate that this method can fundamentally change the structure of your
            vertex buffers, although in reality they will be new buffers. As it happens, if other 
            objects are using the original buffers then they will be unaffected because the reference
            counting will keep them intact. However, if you have made any assumptions about the 
            structure of the vertex data in the buffers of this object, you may have to rethink them.

</member>
        <member name="M:Ogre.VertexData.clone(System.Boolean,Ogre.HardwareBufferManagerBase*)">
Clones this vertex data, potentially including replicating any vertex buffers.
		@param copyData Whether to create new vertex buffers too or just reference the existing ones
		@param mgr If supplied, the buffer manager through which copies should be made
		@remarks The caller is expected to delete the returned pointer when ready

</member>
        <member name="F:Ogre.VertexData.hwAnimDataItemsUsed">
Number of hardware animation data items used
</member>
        <member name="F:Ogre.VertexData.hwAnimationDataList">
VertexElements used for hardware morph / pose animation
</member>
        <member name="T:Ogre.VertexData.HardwareAnimationData">
Struct used to hold hardware morph / pose vertex data information
</member>
        <member name="F:Ogre.VertexData.vertexCount">
The number of vertices used in this operation
</member>
        <member name="F:Ogre.VertexData.vertexStart">
The base vertex index to start from
</member>
        <member name="F:Ogre.VertexData.mDeleteDclBinding">
Whether this class should delete the declaration and binding
</member>
        <member name="F:Ogre.VertexData.vertexBufferBinding">
The vertex buffer bindings to be used. 
		@remarks Note that this is created for you on construction.

</member>
        <member name="F:Ogre.VertexData.vertexDeclaration">
Declaration of the vertex to be used in this operation. 
		@remarks Note that this is created for you on construction.

</member>
        <member name="M:Ogre.VertexData.#ctor(Ogre.VertexDeclaration*,Ogre.VertexBufferBinding*)">
Constructor.
		@note 
		This constructor receives the VertexDeclaration and VertexBufferBinding
		from the caller, and as such does not arrange for their deletion afterwards, 
		the caller remains responsible for that.
		@param dcl The VertexDeclaration to use
		@param bind The VertexBufferBinding to use

</member>
        <member name="M:Ogre.VertexData.#ctor(Ogre.HardwareBufferManagerBase*)">
Constructor.
		@note 
			This constructor creates the VertexDeclaration and VertexBufferBinding
			automatically, and arranges for their deletion afterwards.
		@param mgr Optional HardwareBufferManager from which to create resources

</member>
        <member name="M:Ogre.VertexData.op_Assign(Ogre.VertexData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Protected operator=, to prevent misuse
</member>
        <member name="M:Ogre.VertexData.#ctor(Ogre.VertexData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Protected copy constructor, to prevent misuse
</member>
        <member name="T:Ogre.VertexData">
Summary class collecting together vertex source information. 
</member>
        <member name="D:Ogre.BufferUsageList">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

Define a list of usage flags
</member>
        <member name="T:Ogre.HardwareIndexBufferSharedPtr">
Shared pointer implementation used to share index buffers. 
</member>
        <member name="M:Ogre.HardwareIndexBuffer.getIndexSize">
Get the size in bytes of each index
</member>
        <member name="M:Ogre.HardwareIndexBuffer.getNumIndexes">
Get the number of indexes in this buffer
</member>
        <member name="M:Ogre.HardwareIndexBuffer.getType">
Get the type of indexes used in this buffer
</member>
        <member name="M:Ogre.HardwareIndexBuffer.getManager">
Return the manager of this buffer, if any
</member>
        <member name="M:Ogre.HardwareIndexBuffer.#ctor(Ogre.HardwareBufferManagerBase*,Ogre.HardwareIndexBuffer.IndexType,System.UInt32,Ogre.HardwareBuffer.Usage,System.Boolean,System.Boolean)">
Should be called by HardwareBufferManager
</member>
        <member name="T:Ogre.HardwareIndexBuffer">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

Specialisation of HardwareBuffer for vertex index buffers, still abstract. 
</member>
        <member name="M:Ogre.Sphere.intersects(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether or not this sphere intersects a point. 
</member>
        <member name="M:Ogre.Sphere.intersects(Ogre.Plane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether or not this sphere intersects a plane. 
</member>
        <member name="M:Ogre.Sphere.intersects(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether or not this sphere intersects a box. 
</member>
        <member name="M:Ogre.Sphere.intersects(Ogre.Sphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether or not this sphere intersects another sphere. 
</member>
        <member name="M:Ogre.Sphere.setCenter(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the center point of the sphere. 
</member>
        <member name="M:Ogre.Sphere.getCenter">
Returns the center point of the sphere. 
</member>
        <member name="M:Ogre.Sphere.setRadius(System.Single)">
Sets the radius of the sphere. 
</member>
        <member name="M:Ogre.Sphere.getRadius">
Returns the radius of the sphere. 
</member>
        <member name="M:Ogre.Sphere.#ctor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Constructor allowing arbitrary spheres. 
            @param center The center point of the sphere.
            @param radius The radius of the sphere.

</member>
        <member name="M:Ogre.Sphere.#ctor">
Standard constructor - creates a unit sphere around the origin.
</member>
        <member name="T:Ogre.Sphere">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

A sphere primitive, mostly used for bounds checking. 
    @remarks
        A sphere in math texts is normally represented by the function
        x^2 + y^2 + z^2 = r^2 (for sphere's centered on the origin). Ogre stores spheres
        simply as a center point and a radius.

</member>
        <member name="M:Ogre.RenderQueue.processVisibleObject(Ogre.MovableObject*,Ogre.Camera*,System.Boolean,Ogre.VisibleObjectsBoundsInfo*)">
Utility method to perform the standard actions associated with 
			getting a visible object to add itself to the queue. This is 
			a replacement for SceneManager implementations of the associated
			tasks related to calling MovableObject::_updateRenderQueue.

</member>
        <member name="M:Ogre.RenderQueue.merge(Ogre.RenderQueue!System.Runtime.CompilerServices.IsConst*)">
Merge render queue.

</member>
        <member name="M:Ogre.RenderQueue.setRenderableListener(Ogre.RenderQueue.RenderableListener*)">
Set a renderable listener on the queue.
		@remarks
			There can only be a single renderable listener on the queue, since
			that listener has complete control over the techniques in use.

</member>
        <member name="M:Ogre.RenderQueue.getShadowCastersCannotBeReceivers">
Gets whether or not objects which cast shadows should be treated as
		never receiving shadows. 

</member>
        <member name="M:Ogre.RenderQueue.setShadowCastersCannotBeReceivers(System.Boolean)">
Sets whether or not objects which cast shadows should be treated as
		never receiving shadows. 

</member>
        <member name="M:Ogre.RenderQueue.getSplitNoShadowPasses">
Gets whether or not the queue will split passes which have shadow receive
        turned off (in their parent material), which is needed when certain shadow
        techniques are used.

</member>
        <member name="M:Ogre.RenderQueue.setSplitNoShadowPasses(System.Boolean)">
Sets whether or not the queue will split passes which have shadow receive
        turned off (in their parent material), which is needed when certain shadow
        techniques are used.

</member>
        <member name="M:Ogre.RenderQueue.getSplitPassesByLightingType">
Gets whether or not the queue will split passes by their lighting type,
            ie ambient, per-light and decal. 

</member>
        <member name="M:Ogre.RenderQueue.setSplitPassesByLightingType(System.Boolean)">
Sets whether or not the queue will split passes by their lighting type,
            ie ambient, per-light and decal. 

</member>
        <member name="M:Ogre.RenderQueue._getQueueGroupIterator">
Internal method, returns an iterator for the queue groups. 
</member>
        <member name="M:Ogre.RenderQueue.setDefaultQueueGroup(System.Byte)">
Sets the current default queue group, which will be used for all renderable which do not
            specify which group they wish to be on. See the enum RenderQueueGroupID for what kind of
			values can be used here.

</member>
        <member name="M:Ogre.RenderQueue.getDefaultRenderablePriority">
Gets the current default renderable priority, which will be used for all renderables which do not
            specify which priority they wish to use.

</member>
        <member name="M:Ogre.RenderQueue.setDefaultRenderablePriority(System.UInt16)">
Sets the current default renderable priority, 
            which will be used for all renderables which do not
            specify which priority they wish to use.

</member>
        <member name="M:Ogre.RenderQueue.getDefaultQueueGroup">
Gets the current default queue group, which will be used for all renderable which do not
            specify which group they wish to be on.

</member>
        <member name="M:Ogre.RenderQueue.addRenderable(Ogre.Renderable*)">
Add a renderable object to the queue.
        @remarks
            This methods adds a Renderable to the queue, which will be rendered later by 
            the SceneManager. This is the simplified version of the call which does not 
            require a queue or priority to be specified. The queue group is taken from the
            current default (see setDefaultQueueGroup).  The queue priority is take from the
            current default (see setDefaultRenderablePriority).
        @note
            Called by implementation of MovableObject::_updateRenderQueue.
        @param
            pRend Pointer to the Renderable to be added to the queue

</member>
        <member name="M:Ogre.RenderQueue.addRenderable(Ogre.Renderable*,System.Byte)">
Add a renderable object to the queue.
        @remarks
            This methods adds a Renderable to the queue, which will be rendered later by 
            the SceneManager. This is the simplified version of the call which does not 
            require a priority to be specified. The queue priority is take from the
            current default (see setDefaultRenderablePriority).
        @note
            Called by implementation of MovableObject::_updateRenderQueue.
        @param
            pRend Pointer to the Renderable to be added to the queue
		@param
            groupID The group the renderable is to be added to. This
            can be used to schedule renderable objects in separate groups such that the SceneManager
            respects the divisions between the groupings and does not reorder them outside these
            boundaries. This can be handy for overlays where no matter what you want the overlay to 
            be rendered last.

</member>
        <member name="M:Ogre.RenderQueue.addRenderable(Ogre.Renderable*,System.Byte,System.UInt16)">
Add a renderable object to the queue.
        @remarks
            This methods adds a Renderable to the queue, which will be rendered later by 
            the SceneManager. This is the advanced version of the call which allows the renderable
            to be added to any queue.
        @note
            Called by implementation of MovableObject::_updateRenderQueue.
        @param
            pRend Pointer to the Renderable to be added to the queue
        @param
            groupID The group the renderable is to be added to. This
            can be used to schedule renderable objects in separate groups such that the SceneManager
            respects the divisions between the groupings and does not reorder them outside these
            boundaries. This can be handy for overlays where no matter what you want the overlay to 
            be rendered last.
        @param
            priority Controls the priority of the renderable within the queue group. If this number
            is raised, the renderable will be rendered later in the group compared to it's peers.
            Don't use this unless you really need to, manually ordering renderables prevents OGRE
            from sorting them for best efficiency. However this could be useful for ordering 2D
            elements manually for example.

</member>
        <member name="M:Ogre.RenderQueue.getQueueGroup(System.Byte)">
Get a render queue group.
		@remarks
			OGRE registers new queue groups as they are requested, 
			therefore this method will always return a valid group.

</member>
        <member name="M:Ogre.RenderQueue.clear(System.Boolean)">
Empty the queue - should only be called by SceneManagers.
		@param destroyPassMaps Set to true to destroy all pass maps so that
			the queue is completely clean (useful when switching scene managers)

</member>
        <member name="F:Ogre.RenderQueue.mDefaultRenderablePriority">
The default priority
</member>
        <member name="F:Ogre.RenderQueue.mDefaultQueueGroup">
The current default queue group
</member>
        <member name="M:Ogre.RenderQueue.RenderableListener.renderableQueued(Ogre.Renderable*,System.Byte,System.UInt16,Ogre.Technique**,Ogre.RenderQueue*)">
Method called when a Renderable is added to the queue.
			@remarks
				You can use this event hook to alter the Technique used to
				render a Renderable as the item is added to the queue. This is
				a low-level way to override the material settings for a given
				Renderable on the fly.
			@param rend The Renderable being added to the queue
			@param groupID The render queue group this Renderable is being added to
			@param priority The priority the Renderable has been given
			@param ppTech A pointer to the pointer to the Technique that is 
				intended to be used; you can alter this to an alternate Technique
				if you so wish (the Technique doesn't have to be from the same
				Material either).
			@param pQueue Pointer to the render queue that this object is being
				added to. You can for example call this back to duplicate the 
				object with a different technique
			@returns true to allow the Renderable to be added to the queue, 
				false if you want to prevent it being added

</member>
        <member name="T:Ogre.RenderQueue.RenderableListener">
Class to listen in on items being added to the render queue. 
		@remarks
			Use RenderQueue::setRenderableListener to get callbacks when an item
			is added to the render queue.

</member>
        <member name="D:Ogre.RenderQueue.QueueGroupIterator">
Iterator over queue groups
</member>
        <member name="T:Ogre.RenderQueue">
Class to manage the scene object rendering queue.
        @remarks
            Objects are grouped by material to minimise rendering state changes. The map from
            material to renderable object is wrapped in a class for ease of use.
        @par
            This class now includes the concept of 'queue groups' which allows the application
            adding the renderable to specifically schedule it so that it is included in 
            a discrete group. Good for separating renderables into the main scene,
            backgrounds and overlays, and also could be used in the future for more
            complex multipass routines like stenciling.

</member>
        <member name="T:Ogre.RenderQueueGroupID">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

Enumeration of queue groups, by which the application may group queued renderables
        so that they are rendered together with events in between
	@remarks
		When passed into methods these are actually passed as a uint8 to allow you
		to use values in between if you want to.

</member>
        <member name="F:RENDER_QUEUE_MAX">
Final possible render queue, don't exceed this
</member>
        <member name="F:RENDER_QUEUE_OVERLAY">
Use this queue for objects which must be rendered last e.g. overlays
</member>
        <member name="F:RENDER_QUEUE_SKIES_LATE">
Penultimate queue(before overlays), used for skyboxes if rendered last
</member>
        <member name="F:RENDER_QUEUE_MAIN">
The default render queue
</member>
        <member name="F:RENDER_QUEUE_SKIES_EARLY">
First queue (after backgrounds), used for skyboxes if rendered first
</member>
        <member name="F:RENDER_QUEUE_BACKGROUND">
Use this queue for objects which must be rendered first e.g. backgrounds
</member>
        <member name="M:Ogre.AxisAlignedBox.op_Inequality(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tests 2 boxes for inequality.

</member>
        <member name="M:Ogre.AxisAlignedBox.op_Equality(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tests 2 boxes for equality.

</member>
        <member name="M:Ogre.AxisAlignedBox.contains(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tests whether another box contained by this box.

</member>
        <member name="M:Ogre.AxisAlignedBox.contains(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tests whether the given point contained by this box.

</member>
        <member name="M:Ogre.AxisAlignedBox.getHalfSize">
Gets the half-size of the box
</member>
        <member name="M:Ogre.AxisAlignedBox.getSize">
Gets the size of the box
</member>
        <member name="M:Ogre.AxisAlignedBox.getCenter">
Gets the centre of the box
</member>
        <member name="M:Ogre.AxisAlignedBox.intersects(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tests whether the vector point is within this box. 
</member>
        <member name="M:Ogre.AxisAlignedBox.intersects(Ogre.Plane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tests whether this box intersects a plane. 
</member>
        <member name="M:Ogre.AxisAlignedBox.intersects(Ogre.Sphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tests whether this box intersects a sphere. 
</member>
        <member name="M:Ogre.AxisAlignedBox.scale(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Scales the AABB by the vector given. 
</member>
        <member name="M:Ogre.AxisAlignedBox.volume">
Calculate the volume of this box
</member>
        <member name="M:Ogre.AxisAlignedBox.intersection(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculate the area of intersection of this box and another
</member>
        <member name="M:Ogre.AxisAlignedBox.intersects(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether or not this box intersects another. 
</member>
        <member name="M:Ogre.AxisAlignedBox.isInfinite">
Returns true if the box is infinite.

</member>
        <member name="M:Ogre.AxisAlignedBox.setInfinite">
Sets the box to 'infinite'

</member>
        <member name="M:Ogre.AxisAlignedBox.isFinite">
Returns true if the box is finite.

</member>
        <member name="M:Ogre.AxisAlignedBox.isNull">
Returns true if the box is null i.e. empty.

</member>
        <member name="M:Ogre.AxisAlignedBox.setNull">
Sets the box to a 'null' value i.e. not a box.

</member>
        <member name="M:Ogre.AxisAlignedBox.transformAffine(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Transforms the box according to the affine matrix supplied.
		@remarks
		By calling this method you get the axis-aligned box which
		surrounds the transformed version of this box. Therefore each
		corner of the box is transformed by the matrix, then the
		extents are mapped back onto the axes to produce another
		AABB. Useful when you have a local AABB for an object which
		is then transformed.
		@note
		The matrix must be an affine matrix. @see Matrix4::isAffine.

</member>
        <member name="M:Ogre.AxisAlignedBox.transform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Transforms the box according to the matrix supplied.
		@remarks
		By calling this method you get the axis-aligned box which
		surrounds the transformed version of this box. Therefore each
		corner of the box is transformed by the matrix, then the
		extents are mapped back onto the axes to produce another
		AABB. Useful when you have a local AABB for an object which
		is then transformed.

</member>
        <member name="M:Ogre.AxisAlignedBox.merge(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Extends the box to encompass the specified point (if needed).

</member>
        <member name="M:Ogre.AxisAlignedBox.merge(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Merges the passed in box into the current box. The result is the
		box which encompasses both.

</member>
        <member name="M:Ogre.AxisAlignedBox.getCorner(Ogre.AxisAlignedBox.CornerEnum)">
gets the position of one of the corners

</member>
        <member name="M:Ogre.AxisAlignedBox.getAllCorners">
Returns a pointer to an array of 8 corner points, useful for
		collision vs. non-aligned objects.
		@remarks
		If the order of these corners is important, they are as
		follows: The 4 points of the minimum Z face (note that
		because Ogre uses right-handed coordinates, the minimum Z is
		at the 'back' of the box) starting with the minimum point of
		all, then anticlockwise around this face (if you are looking
		onto the face from outside the box). Then the 4 points of the
		maximum Z face, starting with maximum point of all, then
		anticlockwise around this face (looking onto the face from
		outside the box). Like this:
		<pre>
		1-----2
		/|    /|
		/ |   / |
		5-----4  |
		|  0--|--3
		| /   | /
		|/    |/
		6-----7
		</pre>
		@remarks as this implementation uses a static member, make sure to use your own copy !

</member>
        <member name="M:Ogre.AxisAlignedBox.setExtents(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets both minimum and maximum extents at once.

</member>
        <member name="M:Ogre.AxisAlignedBox.setMaximumX(System.Single)">
Changes one of the components of the maximum corner of the box
		used to resize only one dimension of the box

</member>
        <member name="M:Ogre.AxisAlignedBox.setMaximum(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the maximum corner of the box.

</member>
        <member name="M:Ogre.AxisAlignedBox.setMinimumX(System.Single)">
Changes one of the components of the minimum corner of the box
		used to resize only one dimension of the box

</member>
        <member name="M:Ogre.AxisAlignedBox.setMinimum(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the minimum corner of the box.

</member>
        <member name="M:Ogre.AxisAlignedBox.getMaximum">
Gets the maximum corner of the box.


Gets a modifiable version of the maximum
		corner of the box.

</member>
        <member name="M:Ogre.AxisAlignedBox.getMinimum">
Gets the minimum corner of the box.


Gets a modifiable version of the minimum
		corner of the box.

</member>
        <member name="T:Ogre.AxisAlignedBox">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

A 3D box aligned with the x/y/z axes.
	@remarks
	This class represents a simple box which is aligned with the
	axes. Internally it only stores 2 points as the extremeties of
	the box, one which is the minima of all 3 axes, and the other
	which is the maxima of all 3 axes. This class is typically used
	for an axis-aligned bounding box (AABB) for collision and
	visibility determination.

</member>
        <member name="M:Ogre.ArchiveManager.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.ArchiveManager.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.ArchiveManager.addArchiveFactory(Ogre.ArchiveFactory*)">
Adds a new ArchiveFactory to the list of available factories.
            @remarks
                Plugin developers who add new archive codecs need to call
                this after defining their ArchiveFactory subclass and
                Archive subclasses for their archive type.

</member>
        <member name="M:Ogre.ArchiveManager.getArchiveIterator">
Get an iterator over the Archives in this Manager. 
</member>
        <member name="M:Ogre.ArchiveManager.unload(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Unloads an archive by name.
		@remarks
			You must ensure that this archive is not being used before removing it.

</member>
        <member name="M:Ogre.ArchiveManager.unload(Ogre.Archive*)">
Unloads an archive.
		@remarks
			You must ensure that this archive is not being used before removing it.

</member>
        <member name="M:Ogre.ArchiveManager.load(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Opens an archive for file reading.
            @remarks
                The archives are created using class factories within
                extension libraries.
            @param filename
                The filename that will be opened
            @param refLibrary
                The library that contains the data-handling code
            @returns
                If the function succeeds, a valid pointer to an Archive
                object is returned.
            @par
                If the function fails, an exception is thrown.

</member>
        <member name="M:Ogre.ArchiveManager.Dispose">
Default destructor.

</member>
        <member name="M:Ogre.ArchiveManager.#ctor">
Default constructor - should never get called by a client app.

</member>
        <member name="D:Ogre.ArchiveManager.ArchiveMap">
Currently loaded archives
</member>
        <member name="F:Ogre.ArchiveManager.mArchFactories">
Factories available to create archives, indexed by archive type (String identifier e.g. 'Zip')
</member>
        <member name="T:Ogre.ArchiveManager">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

This class manages the available ArchiveFactory plugins. 

</member>
        <member name="M:Ogre.ResourceManager.getResourceIterator">
Returns an iterator over all resources in this manager. 
        @note
            Use of this iterator is NOT thread safe!

</member>
        <member name="F:Ogre.ResourceManager.mResourceType">
String identifying the resource type this manager handles
</member>
        <member name="F:Ogre.ResourceManager.mLoadOrder">
Loading order relative to other managers, higher is later
</member>
        <member name="F:Ogre.ResourceManager.mScriptPatterns">
Patterns to use to look for scripts if supported (e.g. *.overlay)
</member>
        <member name="M:Ogre.ResourceManager.checkUsage">
Checks memory usage and pages out if required.

</member>
        <member name="M:Ogre.ResourceManager.removeImpl(Ogre.SharedPtr&lt;Ogre.Resource&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Remove a resource from this manager; remove it from the lists. 
</member>
        <member name="M:Ogre.ResourceManager.addImpl(Ogre.SharedPtr&lt;Ogre.Resource&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add a newly created resource to the manager (note weak reference) 
</member>
        <member name="M:Ogre.ResourceManager.createImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.ManualResou">
Create a new resource instance compatible with this manager (no custom 
			parameters are populated at this point). 
		@remarks
			Subclasses must override this method and create a subclass of Resource.
		@param name The unique name of the resource
		@param group The name of the resource group to attach this new resource to
		@param isManual Is this resource manually loaded? If so, you should really
			populate the loader parameter in order that the load process
			can call the loader back when loading is required. 
		@param loader Pointer to a ManualLoader implementation which will be called
			when the Resource wishes to load (should be supplied if you set
			isManual to true). You can in fact leave this parameter null 
			if you wish, but the Resource will never be able to reload if 
			anything ever causes it to unload. Therefore provision of a proper
			ManualLoader instance is strongly recommended.
        @param createParams If any parameters are required to create an instance,
            they should be supplied here as name / value pairs. These do not need 
            to be set on the instance (handled elsewhere), just used if required
            to differentiate which concrete class is created.


</member>
        <member name="M:Ogre.ResourceManager.getNextHandle">
Allocates the next handle. 
</member>
        <member name="M:Ogre.ResourceManager.destroyAllResourcePools">
destroy all pools
</member>
        <member name="M:Ogre.ResourceManager.destroyResourcePool(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroy a resource pool
</member>
        <member name="M:Ogre.ResourceManager.destroyResourcePool(Ogre.ResourceManager.ResourcePool*)">
Destroy a resource pool
</member>
        <member name="M:Ogre.ResourceManager.getResourcePool(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a resource pool, or reuse one that already exists
</member>
        <member name="M:Ogre.ResourceManager.ResourcePool.getName">
Get the name of the pool
</member>
        <member name="T:Ogre.ResourceManager.ResourcePool">
Definition of a pool of resources, which users can use to reuse similar
			resources many times without destroying and recreating them.
		@remarks
			This is a simple utility class which allows the reuse of resources
			between code which has a changing need for them. For example, 

</member>
        <member name="M:Ogre.ResourceManager.getVerbose">
Gets whether this manager and its resources habitually produce log output 
</member>
        <member name="M:Ogre.ResourceManager.setVerbose(System.Boolean)">
Sets whether this manager and its resources habitually produce log output 
</member>
        <member name="M:Ogre.ResourceManager.getResourceType">
Gets a string identifying the type of resource this manager handles. 
</member>
        <member name="M:Ogre.ResourceManager.getLoadingOrder">
Gets the relative loading order of resources of this type.
		@remarks
			There are dependencies between some kinds of resource in terms of loading
			order, and this value enumerates that. Higher values load later during
			bulk loading tasks.

</member>
        <member name="M:Ogre.ResourceManager.parseScript(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Parse the definition of a set of resources from a script file.
		@remarks
			Some resource managers can read script files in order to define
			resources ahead of time. These resources are added to the available
			list inside the manager, but none are loaded initially. This allows
			you to load the items that are used on demand, or to load them all 
			as a group if you wish (through ResourceGroupManager).
		@param stream Weak reference to a data stream which is the source of the script
		@param groupName The name of the resource group that resources which are
			parsed are to become a member of. If this group is loaded or unloaded, 
			then the resources discovered in this script will be loaded / unloaded
			with it.

</member>
        <member name="M:Ogre.ResourceManager.getScriptPatterns">
Gets the file patterns which should be used to find scripts for this
			ResourceManager.
		@remarks
			Some resource managers can read script files in order to define
			resources ahead of time. These resources are added to the available
			list inside the manager, but none are loaded initially. This allows
			you to load the items that are used on demand, or to load them all 
			as a group if you wish (through ResourceGroupManager).
		@par
			This method lets you determine the file pattern which will be used
			to identify scripts intended for this manager.
		@returns
			A list of file patterns, in the order they should be searched in.
		@see isScriptingSupported, parseScript

</member>
        <member name="M:Ogre.ResourceManager.load(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.ManualResourceLoader*,std.map&lt;s">
Generic load method, used to create a Resource specific to this 
			ResourceManager without using one of the specialised 'load' methods
			(containing per-Resource-type parameters).
		@param name The name of the Resource
		@param group The resource group to which this resource will belong
		@param isManual Is the resource to be manually loaded? If so, you should
			provide a value for the loader parameter
		@param loader The manual loader which is to perform the required actions
			when this resource is loaded; only applicable when you specify true
			for the previous parameter
        @param loadParams Optional pointer to a list of name/value pairs 
            containing loading parameters for this type of resource.
		@param backgroundThread Optional boolean which lets the load routine know if it
			is being run on the background resource loading thread

</member>
        <member name="M:Ogre.ResourceManager.prepare(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.ManualResourceLoader*,std.ma">
Generic prepare method, used to create a Resource specific to this 
			ResourceManager without using one of the specialised 'prepare' methods
			(containing per-Resource-type parameters).
		@param name The name of the Resource
		@param group The resource group to which this resource will belong
		@param isManual Is the resource to be manually loaded? If so, you should
			provide a value for the loader parameter
		@param loader The manual loader which is to perform the required actions
			when this resource is loaded; only applicable when you specify true
			for the previous parameter
        @param loadParams Optional pointer to a list of name/value pairs 
            containing loading parameters for this type of resource.
		@param backgroundThread Optional boolean which lets the load routine know if it
			is being run on the background resource loading thread

</member>
        <member name="M:Ogre.ResourceManager._notifyResourceUnloaded(Ogre.Resource*)">
Notify this manager that a resource which it manages has been 
			unloaded.

</member>
        <member name="M:Ogre.ResourceManager._notifyResourceLoaded(Ogre.Resource*)">
Notify this manager that a resource which it manages has been 
			loaded. 

</member>
        <member name="M:Ogre.ResourceManager._notifyResourceTouched(Ogre.Resource*)">
Notify this manager that a resource which it manages has been 
			'touched', i.e. used. 

</member>
        <member name="M:Ogre.ResourceManager.resourceExists(System.UInt64)">
Returns whether a resource with the given handle exists in this manager
</member>
        <member name="M:Ogre.ResourceManager.resourceExists(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether the named resource exists in this manager
</member>
        <member name="M:Ogre.ResourceManager.getByHandle(System.UInt64)">
Retrieves a pointer to a resource by handle, or null if the resource does not exist.

</member>
        <member name="M:Ogre.ResourceManager.getByName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves a pointer to a resource by name, or null if the resource does not exist.

</member>
        <member name="M:Ogre.ResourceManager.removeUnreferencedResources(System.Boolean)">
Remove all resources which are not referenced by any other object.
		@remarks
			This method behaves like removeAll, except that it only removes resources
            which are not in use, ie not referenced by other objects. This allows you
            to free up some memory selectively whilst still keeping the group around
            (and the resources present, just not using much memory).
        @par
            Some referenced resource may exists 'weak' pointer to their sub-components
            (e.g. Entity held pointer to SubMesh), in this case, remove or reload that
            resource will cause dangerous pointer access. Use this function instead of
            removeAll allows you avoid fail in those situations.
		@param reloadableOnly If true (the default), only removes resources
			which can be subsequently automatically reloaded.

</member>
        <member name="M:Ogre.ResourceManager.removeAll">
Removes all resources.
		@note
			The word 'Destroy' is not used here, since
			if any other pointers are referring to these resources, they will persist
			until they have been finished with; however to all intents and purposes
			the resources no longer exist and will get destroyed imminently.
        @note
            If you do have shared pointers to resources hanging around after the 
            ResourceManager is destroyed, you may get problems on destruction of
            these resources if they were relying on the manager (especially if
            it is a plugin). If you find you get problems on shutdown in the
            destruction of resources, try making sure you release all your
            shared pointers before you shutdown OGRE.

</member>
        <member name="M:Ogre.ResourceManager.remove(System.UInt64)">
Remove a single resource by handle.
		@remarks
			Removes a single resource, meaning it will be removed from the list
			of valid resources in this manager, also causing it to be unloaded. 
		@note
			The word 'Destroy' is not used here, since
			if any other pointers are referring to this resource, it will persist
			until they have finished with it; however to all intents and purposes
			it no longer exists and will likely get destroyed imminently.
        @note
            If you do have shared pointers to resources hanging around after the 
            ResourceManager is destroyed, you may get problems on destruction of
            these resources if they were relying on the manager (especially if
            it is a plugin). If you find you get problems on shutdown in the
            destruction of resources, try making sure you release all your
            shared pointers before you shutdown OGRE.

</member>
        <member name="M:Ogre.ResourceManager.remove(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Remove a single resource by name.
		@remarks
			Removes a single resource, meaning it will be removed from the list
			of valid resources in this manager, also causing it to be unloaded. 
		@note
			The word 'Destroy' is not used here, since
			if any other pointers are referring to this resource, it will persist
			until they have finished with it; however to all intents and purposes
			it no longer exists and will likely get destroyed imminently.
        @note
            If you do have shared pointers to resources hanging around after the 
            ResourceManager is destroyed, you may get problems on destruction of
            these resources if they were relying on the manager (especially if
            it is a plugin). If you find you get problems on shutdown in the
            destruction of resources, try making sure you release all your
            shared pointers before you shutdown OGRE.

</member>
        <member name="M:Ogre.ResourceManager.remove(Ogre.SharedPtr&lt;Ogre.Resource&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Remove a single resource.
		@remarks
			Removes a single resource, meaning it will be removed from the list
			of valid resources in this manager, also causing it to be unloaded. 
		@note
			The word 'Destroy' is not used here, since
			if any other pointers are referring to this resource, it will persist
			until they have finished with it; however to all intents and purposes
			it no longer exists and will likely get destroyed imminently.
        @note
            If you do have shared pointers to resources hanging around after the 
            ResourceManager is destroyed, you may get problems on destruction of
            these resources if they were relying on the manager (especially if
            it is a plugin). If you find you get problems on shutdown in the
            destruction of resources, try making sure you release all your
            shared pointers before you shutdown OGRE.

</member>
        <member name="M:Ogre.ResourceManager.reloadUnreferencedResources(System.Boolean)">
Caused all currently loaded but not referenced by any other object
            resources to be reloaded.
		@remarks
			This method behaves like reloadAll, except that it only reloads resources
            which are not in use, i.e. not referenced by other objects.
        @par
            Some referenced resource may exists 'weak' pointer to their sub-components
            (e.g. Entity held pointer to SubMesh), in this case, unload or reload that
            resource will cause dangerous pointer access. Use this function instead of
            reloadAll allows you avoid fail in those situations.
		@param reloadableOnly If true (the default), only reloads resources
			which can be subsequently automatically reloaded.

</member>
        <member name="M:Ogre.ResourceManager.unloadUnreferencedResources(System.Boolean)">
Unload all resources which are not referenced by any other object.
		@remarks
			This method behaves like unloadAll, except that it only unloads resources
            which are not in use, ie not referenced by other objects. This allows you
            to free up some memory selectively whilst still keeping the group around
            (and the resources present, just not using much memory).
        @par
            Some referenced resource may exists 'weak' pointer to their sub-components
            (e.g. Entity held pointer to SubMesh), in this case, unload or reload that
            resource will cause dangerous pointer access. Use this function instead of
            unloadAll allows you avoid fail in those situations.
		@param reloadableOnly If true (the default), only unloads resources
			which can be subsequently automatically reloaded.

</member>
        <member name="M:Ogre.ResourceManager.reloadAll(System.Boolean)">
Caused all currently loaded resources to be reloaded.
		@remarks
			All resources currently being held in this manager which are also
			marked as currently loaded will be unloaded, then loaded again.
		@param reloadableOnly If true (the default), only reload the resource that
            is reloadable. Because some resources isn't reloadable, they will be
			unloaded but can't loaded again. Thus, you might not want to them
			unloaded. Or, you might unload all of them, and then populate them
			manually later.
			@see Resource::isReloadable for resource is reloadable.

</member>
        <member name="M:Ogre.ResourceManager.unloadAll(System.Boolean)">
Unloads all resources.
		@remarks
			Unloaded resources are not removed, they simply free up their memory
			as much as they can and wait to be reloaded.
			@see ResourceGroupManager for unloading of resource groups.
		@param reloadableOnly If true (the default), only unload the resource that
            is reloadable. Because some resources isn't reloadable, they will be
			unloaded but can't load them later. Thus, you might not want to them
			unloaded. Or, you might unload all of them, and then populate them
			manually later.
			@see Resource::isReloadable for resource is reloadable.

</member>
        <member name="M:Ogre.ResourceManager.unload(System.UInt64)">
Unloads a single resource by handle.
		@remarks
			Unloaded resources are not removed, they simply free up their memory
			as much as they can and wait to be reloaded.
			@see ResourceGroupManager for unloading of resource groups.

</member>
        <member name="M:Ogre.ResourceManager.unload(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Unloads a single resource by name.
		@remarks
			Unloaded resources are not removed, they simply free up their memory
			as much as they can and wait to be reloaded.
			@see ResourceGroupManager for unloading of resource groups.

</member>
        <member name="M:Ogre.ResourceManager.getMemoryUsage">
Gets the current memory usage, in bytes. 
</member>
        <member name="M:Ogre.ResourceManager.getMemoryBudget">
Get the limit on the amount of memory this resource handler may use.

</member>
        <member name="M:Ogre.ResourceManager.setMemoryBudget(System.UInt32)">
Set a limit on the amount of memory this resource handler may use.
            @remarks
                If, when asked to load a new resource, the manager believes it will exceed this memory
                budget, it will temporarily unload a resource to make room for the new one. This unloading
                is not permanent and the Resource is not destroyed; it simply needs to be reloaded when
                next used.

</member>
        <member name="M:Ogre.ResourceManager.createOrRetrieve(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.ManualResourceLoade">
Create a new resource, or retrieve an existing one with the same
			name if it already exists.
		@remarks
			This method performs the same task as calling getByName() followed
			by create() if that returns null. The advantage is that it does it
			in one call so there are no race conditions if using multiple
			threads that could cause getByName() to return null, but create() to
			fail because another thread created a resource in between.
		@see ResourceManager::create
		@see ResourceManager::getByName
		@returns A pair, the first element being the pointer, and the second being 
			an indicator specifying whether the resource was newly created.

</member>
        <member name="M:Ogre.ResourceManager.create(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.ManualResourceLoader*,std.map">
Creates a new blank resource, but does not immediately load it.
        @remarks
            Resource managers handle disparate types of resources, so if you want
			to get at the detailed interface of this resource, you'll have to 
			cast the result to the subclass you know you're creating. 
		@param name The unique name of the resource
		@param group The name of the resource group to attach this new resource to
		@param isManual Is this resource manually loaded? If so, you should really
			populate the loader parameter in order that the load process
			can call the loader back when loading is required. 
		@param loader Pointer to a ManualLoader implementation which will be called
			when the Resource wishes to load (should be supplied if you set
			isManual to true). You can in fact leave this parameter null 
			if you wish, but the Resource will never be able to reload if 
			anything ever causes it to unload. Therefore provision of a proper
			ManualLoader instance is strongly recommended.
        @param createParams If any parameters are required to create an instance,
            they should be supplied here as name / value pairs

</member>
        <member name="T:Ogre.ResourceManager">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

Defines a generic resource handler.
    @remarks
        A resource manager is responsible for managing a pool of
        resources of a particular type. It must index them, look
        them up, load and destroy them. It may also need to stay within
        a defined memory budget, and temporarily unload some resources
        if it needs to to stay within this budget.
    @par
        Resource managers use a priority system to determine what can
        be unloaded, and a Least Recently Used (LRU) policy within
        resources of the same priority.
	@par
		Resources can be loaded using the generalised load interface,
		and they can be unloaded and removed. In addition, each 
		subclass of ResourceManager will likely define custom 'load' methods
		which take explicit parameters depending on the kind of resource
		being created.
	@note
		Resources can be loaded and unloaded through the Resource class, 
		but they can only be removed (and thus eventually destroyed) using
		their parent ResourceManager.
    @note
        If OGRE_THREAD_SUPPORT is 1, this class is thread-safe.

</member>
        <member name="M:Ogre.ScriptLoader.getLoadingOrder">
Gets the relative loading order of scripts of this type.
		@remarks
			There are dependencies between some kinds of scripts, and to enforce
			this all implementors of this interface must define a loading order. 
		@returns A value representing the relative loading order of these scripts
			compared to other script users, where higher values load later.

</member>
        <member name="M:Ogre.ScriptLoader.parseScript(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Parse a script file.
		@param stream Weak reference to a data stream which is the source of the script
		@param groupName The name of a resource group which should be used if any resources
			are created during the parse of this script.

</member>
        <member name="M:Ogre.ScriptLoader.getScriptPatterns">
Gets the file patterns which should be used to find scripts for this
			class.
		@remarks
			This method is called when a resource group is loaded if you use 
			ResourceGroupManager::_registerScriptLoader.
		@returns
			A list of file patterns, in the order they should be searched in.

</member>
        <member name="T:Ogre.ScriptLoader">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

Abstract class defining the interface used by classes which wish 
		to perform script loading to define instances of whatever they manage.
	@remarks
		Typically classes of this type wish to either parse individual script files
		on demand, or be called with a group of files matching a certain pattern
		at the appropriate time. Normally this will coincide with resource loading,
		although the script use does not necessarily have to be a ResourceManager
		(which subclasses from this class), it may be simply a script loader which 
		manages non-resources but needs to be synchronised at the same loading points.
	@par
		Subclasses should add themselves to the ResourceGroupManager as a script loader
		if they wish to be called at the point a resource group is loaded, at which 
		point the parseScript method will be called with each file which matches a 
		the pattern returned from getScriptPatterns.

</member>
        <member name="M:Ogre.ResourceGroupManager.getSingletonPtr">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.ResourceGroupManager.getSingleton">
Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.

</member>
        <member name="M:Ogre.ResourceGroupManager.getLoadingListener">
Returns the current loading listener
</member>
        <member name="M:Ogre.ResourceGroupManager.setLoadingListener(Ogre.ResourceLoadingListener*)">
Sets a new loading listener
</member>
        <member name="M:Ogre.ResourceGroupManager.getResourceLocationList(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get the list of resource locations for the specified group name.
		@param groupName The name of the group
		@returns The list of resource locations associated with the given group.

</member>
        <member name="M:Ogre.ResourceGroupManager.getResourceDeclarationList(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get the list of resource declarations for the specified group name. 
		@note This method intentionally returns a copy rather than a reference in
			order to avoid any contention issues in multithreaded applications.
		@param groupName The name of the group
		@returns A copy of list of currently defined resources.

</member>
        <member name="M:Ogre.ResourceGroupManager.getResourceGroups">
Get a list of the currently defined resource groups. 
		@note This method intentionally returns a copy rather than a reference in
			order to avoid any contention issues in multithreaded applications.
		@returns A copy of list of currently defined groups.

</member>
        <member name="M:Ogre.ResourceGroupManager._notifyWorldGeometryStageEnded">
Notify this manager that one stage of world geometry loading has been 
            completed.
        @remarks
            Custom SceneManagers which load custom world geometry should call this 
            method the number of times equal to the value they return from 
            SceneManager::estimateWorldGeometry while loading their geometry.

</member>
        <member name="M:Ogre.ResourceGroupManager._notifyWorldGeometryStageStarted(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Notify this manager that one stage of world geometry loading has been 
            started.
        @remarks
            Custom SceneManagers which load custom world geometry should call this 
            method the number of times equal to the value they return from 
            SceneManager::estimateWorldGeometry while loading their geometry.

</member>
        <member name="M:Ogre.ResourceGroupManager._notifyAllResourcesRemoved(Ogre.ResourceManager*)">
Internal method called by ResourceManager when all resources 
			for that manager are removed.
		@param manager Pointer to the manager for which all resources are being removed

</member>
        <member name="M:Ogre.ResourceGroupManager._notifyResourceGroupChanged(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Resource*)">
Internal method to notify the group manager that a resource has
			changed group (only applicable for autodetect group) 
</member>
        <member name="M:Ogre.ResourceGroupManager._notifyResourceRemoved(Ogre.SharedPtr&lt;Ogre.Resource&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method called by ResourceManager when a resource is removed.
		@param res Weak reference to resource

</member>
        <member name="M:Ogre.ResourceGroupManager._notifyResourceCreated(Ogre.SharedPtr&lt;Ogre.Resource&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method called by ResourceManager when a resource is created.
		@param res Weak reference to resource

</member>
        <member name="M:Ogre.ResourceGroupManager._getResourceManager(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for getting a registered ResourceManager.
		@param resourceType String identifying the resource type.

</member>
        <member name="M:Ogre.ResourceGroupManager._findScriptLoader(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method used to directly query for registered script loaders.
		@param pattern The specific script pattern (e.g. *.material) the script loader handles

</member>
        <member name="M:Ogre.ResourceGroupManager._unregisterScriptLoader(Ogre.ScriptLoader*)">
Internal method for unregistering a ScriptLoader.
        @param su Pointer to the ScriptLoader instance.

</member>
        <member name="M:Ogre.ResourceGroupManager._registerScriptLoader(Ogre.ScriptLoader*)">
Internal method for registering a ScriptLoader.
		@remarks ScriptLoaders parse scripts when resource groups are initialised.
        @param su Pointer to the ScriptLoader instance.

</member>
        <member name="M:Ogre.ResourceGroupManager.getResourceManagerIterator">
Get an iterator over the registered resource managers.

</member>
        <member name="M:Ogre.ResourceGroupManager._unregisterResourceManager(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for unregistering a ResourceManager.
		@remarks
			ResourceManagers that wish to parse scripts must also call 
			_unregisterScriptLoader.
        @param resourceType String identifying the resource type.

</member>
        <member name="M:Ogre.ResourceGroupManager._registerResourceManager(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ResourceManager*)">
Internal method for registering a ResourceManager (which should be
            a singleton). Creators of plugins can register new ResourceManagers
            this way if they wish.
		@remarks
			ResourceManagers that wish to parse scripts must also call 
			_registerScriptLoader.
        @param resourceType String identifying the resource type, must be unique.
        @param rm Pointer to the ResourceManager instance.

</member>
        <member name="M:Ogre.ResourceGroupManager.shutdownAll">
Shutdown all ResourceManagers, performed as part of clean-up. 
</member>
        <member name="M:Ogre.ResourceGroupManager.isResourceGroupInGlobalPool(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Checks the status of a resource group.
		@remarks
			Looks at the state of a resource group.
			If loadResourceGroup has been called for the resource
			group return true, otherwise return false.
		@param name The name to of the resource group to access.

</member>
        <member name="M:Ogre.ResourceGroupManager.unlinkWorldGeometryFromResourceGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Clear any link to world geometry from a resource group.
        @remarks
            Basically undoes a previous call to linkWorldGeometryToResourceGroup.

</member>
        <member name="M:Ogre.ResourceGroupManager.linkWorldGeometryToResourceGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.SceneManager*">
Associates some world geometry with a resource group, causing it to 
            be loaded / unloaded with the resource group.
        @remarks
            You would use this method to essentially defer a call to 
            SceneManager::setWorldGeometry to the time when the resource group
            is loaded. The advantage of this is that compatible scene managers 
            will include the estimate of the number of loading stages for that
            world geometry when the resource group begins loading, allowing you
            to include that in a loading progress report. 
        @param group The name of the resource group
        @param worldGeometry The parameter which should be passed to setWorldGeometry
        @param sceneManager The SceneManager which should be called

</member>
        <member name="M:Ogre.ResourceGroupManager.getWorldResourceGroupName">
Gets the resource group that 'world' resources will use.
</member>
        <member name="M:Ogre.ResourceGroupManager.setWorldResourceGroupName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the resource group that 'world' resources will use.
        @remarks
            This is the group which should be used by SceneManagers implementing
            world geometry when looking for their resources. Defaults to the 
            DEFAULT_RESOURCE_GROUP_NAME but this can be altered.

</member>
        <member name="M:Ogre.ResourceGroupManager.removeResourceGroupListener(Ogre.ResourceGroupListener*)">
Removes a ResourceGroupListener 
</member>
        <member name="M:Ogre.ResourceGroupManager.addResourceGroupListener(Ogre.ResourceGroupListener*)">
Adds a ResourceGroupListener which will be called back during 
            resource loading events. 

</member>
        <member name="M:Ogre.ResourceGroupManager.deleteMatchingResources(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SBy">
Delete all matching resource files.
		@param filePattern The pattern (see StringUtil::match) of the files to delete. 
		@param groupName The name of the group in which to search
		@param locationPattern If the resource group contains multiple locations, 
			then usually all matching files in any location will be deleted. If you 
			want to be more specific, you can include a location pattern here and 
			only locations which match that pattern (as determined by StringUtil::match)
			will be considered candidates for deletion.

</member>
        <member name="M:Ogre.ResourceGroupManager.deleteResource(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System">
Delete a single resource file.
		@param filename The name of the file to delete. 
		@param groupName The name of the group in which to search
		@param locationPattern If the resource group contains multiple locations, 
			then usually first matching file found in any location will be deleted. If you 
			want to be more specific, you can include a location pattern here and 
			only locations which match that pattern (as determined by StringUtil::match)
			will be considered candidates for deletion.

</member>
        <member name="M:Ogre.ResourceGroupManager.createResource(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,std.basic_string&lt;Syst">
Create a new resource file in a given group.
		@remarks
			This method creates a new file in a resource group and passes you back a 
			writeable stream. 
		@param filename The name of the file to create
		@param groupName The name of the group in which to create the file
		@param overwrite If true, an existing file will be overwritten, if false
			an error will occur if the file already exists
		@param locationPattern If the resource group contains multiple locations, 
			then usually the file will be created in the first writable location. If you 
			want to be more specific, you can include a location pattern here and 
			only locations which match that pattern (as determined by StringUtil::match)
			will be considered candidates for creation.

</member>
        <member name="M:Ogre.ResourceGroupManager.resourceModifiedTime(Ogre.ResourceGroupManager.ResourceGroup*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieve the modification time of a given file 
</member>
        <member name="M:Ogre.ResourceGroupManager.findResourceLocation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Find all resource location names matching a given pattern in a
            resource group.
        @param groupName The name of the group
        @param pattern The pattern to search for; wildcards (*) are allowed
        @returns A list of resource locations matching the criteria

</member>
        <member name="M:Ogre.ResourceGroupManager.listResourceLocations(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
List all resource locations in a resource group.
        @param groupName The name of the group
        @returns A list of resource locations matching the criteria

</member>
        <member name="M:Ogre.ResourceGroupManager.resourceModifiedTime(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieve the modification time of a given file 
</member>
        <member name="M:Ogre.ResourceGroupManager.findResourceFileInfo(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Find all files or directories matching a given pattern in a group
            and get some detailed information about them.
        @param group The name of the resource group
        @param pattern The pattern to search for; wildcards (*) are allowed
        @param dirs Set to true if you want the directories to be listed
            instead of files
        @returns A list of file information structures for all files matching 
        the criteria.

</member>
        <member name="M:Ogre.ResourceGroupManager.findGroupContainingResource(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Find the group in which a resource exists.
		@param filename Fully qualified name of the file the resource should be
			found as
		@returns Name of the resource group the resource was found in. An
			exception is thrown if the group could not be determined.

</member>
        <member name="M:Ogre.ResourceGroupManager.resourceExistsInAnyGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Find out if the named file exists in any group. 
        @param filename Fully qualified name of the file to test for

</member>
        <member name="M:Ogre.ResourceGroupManager.resourceExists(Ogre.ResourceGroupManager.ResourceGroup*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Find out if the named file exists in a group. 
        @param group Pointer to the resource group
        @param filename Fully qualified name of the file to test for

</member>
        <member name="M:Ogre.ResourceGroupManager.resourceExists(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Find out if the named file exists in a group. 
        @param group The name of the resource group
        @param filename Fully qualified name of the file to test for

</member>
        <member name="M:Ogre.ResourceGroupManager.findResourceNames(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Find all file or directory names matching a given pattern in a
            resource group.
        @note
        This method only returns filenames, you can also retrieve other
        information using findFileInfo.
        @param groupName The name of the group
        @param pattern The pattern to search for; wildcards (*) are allowed
        @param dirs Set to true if you want the directories to be listed
            instead of files
        @returns A list of filenames matching the criteria, all are fully qualified

</member>
        <member name="M:Ogre.ResourceGroupManager.listResourceFileInfo(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
List all files in a resource group with accompanying information.
        @param groupName The name of the group
        @param dirs If true, directory names will be returned instead of file names
        @returns A list of structures detailing quite a lot of information about
        all the files in the archive.

</member>
        <member name="M:Ogre.ResourceGroupManager.listResourceNames(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
List all file or directory names in a resource group.
        @note
        This method only returns filenames, you can also retrieve other
        information using listFileInfo.
        @param groupName The name of the group
        @param dirs If true, directory names will be returned instead of file names
        @returns A list of filenames matching the criteria, all are fully qualified

</member>
        <member name="M:Ogre.ResourceGroupManager.openResources(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Open all resources matching a given pattern (which can contain
			the character '*' as a wildcard), and return a collection of 
			DataStream objects on them.
		@param pattern The pattern to look for. If resource locations have been
			added recursively, subdirectories will be searched too so this
			does not need to be fully qualified.
		@param groupName The resource group; this determines which locations
			are searched.
		@returns Shared pointer to a data stream list , will be
			destroyed automatically when no longer referenced

</member>
        <member name="M:Ogre.ResourceGroupManager.openResource(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.Resource*)">
Open a single resource by name and return a DataStream
		 	pointing at the source of the data.
		@param resourceName The name of the resource to locate.
			Even if resource locations are added recursively, you
			must provide a fully qualified name to this method. You 
			can find out the matching fully qualified names by using the
			find() method if you need to.
		@param groupName The name of the resource group; this determines which 
			locations are searched. 
		@param searchGroupsIfNotFound If true, if the resource is not found in 
			the group specified, other groups will be searched. If you're
			loading a real Resource using this option, you <strong>must</strong>
			also provide the resourceBeingLoaded parameter to enable the 
			group membership to be changed
		@param resourceBeingLoaded Optional pointer to the resource being 
			loaded, which you should supply if you want
		@returns Shared pointer to data stream containing the data, will be
			destroyed automatically when no longer referenced

</member>
        <member name="M:Ogre.ResourceGroupManager.undeclareResource(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Undeclare a resource.
		@remarks
			Note that this will not cause it to be unloaded
            if it is already loaded, nor will it destroy a resource which has 
			already been created if initialiseResourceGroup has been called already.
			Only unloadResourceGroup / clearResourceGroup / destroyResourceGroup 
			will do that. 
        @param name The name of the resource. 
		@param groupName The name of the group this resource was declared in. 

</member>
        <member name="M:Ogre.ResourceGroupManager.declareResource(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!Syste">
Declares a resource to be a part of a resource group, allowing you 
            to load and unload it as part of the group.
        @remarks
            By declaring resources before you attempt to use them, you can 
            more easily control the loading and unloading of those resources
            by their group. Declaring them also allows them to be enumerated, 
            which means events can be raised to indicate the loading progress
            (@see ResourceGroupListener). Note that another way of declaring
			resources is to use a script specific to the resource type, if
			available (e.g. .material).
		@par
			Declared resources are not created as Resource instances (and thus
			are not available through their ResourceManager) until initialiseResourceGroup
			is called, at which point all declared resources will become created 
			(but unloaded) Resource instances, along with any resources declared
			in scripts in resource locations associated with the group.
        @param name The resource name. 
        @param resourceType The type of the resource. Ogre comes preconfigured with 
            a number of resource types: 
            <ul><li>Font</li><li>GpuProgram</li><li>HighLevelGpuProgram</li><li>Material</li><li>Mesh</li><li>Skeleton</li><li>Texture</li></ul>
            .. but more can be added by plugin ResourceManager classes.
        @param groupName The name of the group to which it will belong.
		@param loadParameters A list of name / value pairs which supply custom
			parameters to the resource which will be required before it can 
			be loaded. These are specific to the resource type.


Declares a resource to be a part of a resource group, allowing you
            to load and unload it as part of the group.
        @remarks
            By declaring resources before you attempt to use them, you can
            more easily control the loading and unloading of those resources
            by their group. Declaring them also allows them to be enumerated,
            which means events can be raised to indicate the loading progress
            (@see ResourceGroupListener). Note that another way of declaring
            resources is to use a script specific to the resource type, if
            available (e.g. .material).
        @par
            Declared resources are not created as Resource instances (and thus
            are not available through their ResourceManager) until initialiseResourceGroup
            is called, at which point all declared resources will become created
            (but unloaded) Resource instances, along with any resources declared
            in scripts in resource locations associated with the group.
        @param name The resource name.
        @param resourceType The type of the resource. Ogre comes preconfigured with
            a number of resource types:
            <ul><li>Font</li><li>GpuProgram</li><li>HighLevelGpuProgram</li><li>Material</li><li>Mesh</li><li>Skeleton</li><li>Texture</li></ul>
            .. but more can be added by plugin ResourceManager classes.
        @param groupName The name of the group to which it will belong.
        @param loader Pointer to a ManualResourceLoader implementation which will
            be called when the Resource wishes to load. If supplied, the resource
            is manually loaded, otherwise it'll loading from file automatic.
            @note We don't support declare manually loaded resource without loader
                here, since it's meaningless.
        @param loadParameters A list of name / value pairs which supply custom
            parameters to the resource which will be required before it can
            be loaded. These are specific to the resource type.

</member>
        <member name="M:Ogre.ResourceGroupManager.resourceLocationExists(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Verify if a resource location exists for the given group. 
</member>
        <member name="M:Ogre.ResourceGroupManager.removeResourceLocation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Removes a resource location from the search path. 
</member>
        <member name="M:Ogre.ResourceGroupManager.addResourceLocation(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!S">
Method to add a resource location to for a given resource group. 
        @remarks
            Resource locations are places which are searched to load resource files.
            When you choose to load a file, or to search for valid files to load, 
            the resource locations are used.
        @param name The name of the resource location; probably a directory, zip file, URL etc.
        @param locType The codename for the resource type, which must correspond to the 
            Archive factory which is providing the implementation.
        @param resGroup The name of the resource group for which this location is
            to apply. ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME is the 
			default group which always exists, and can
            be used for resources which are unlikely to be unloaded until application
            shutdown. Otherwise it must be the name of a group; if it
            has not already been created with createResourceGroup then it is created
            automatically.
        @param recursive Whether subdirectories will be searched for files when using 
			a pattern match (such as *.material), and whether subdirectories will be
			indexed. This can slow down initial loading of the archive and searches.
			When opening a resource you still need to use the fully qualified name, 
			this allows duplicate names in alternate paths.

</member>
        <member name="M:Ogre.ResourceGroupManager.isResourceGroupLoaded(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Checks the status of a resource group.
		@remarks
			Looks at the state of a resource group.
			If loadResourceGroup has been called for the resource
			group return true, otherwise return false.
		@param name The name to of the resource group to access.

</member>
        <member name="M:Ogre.ResourceGroupManager.isResourceGroupInitialised(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Checks the status of a resource group.
		@remarks
			Looks at the state of a resource group.
			If initialiseResourceGroup has been called for the resource
			group return true, otherwise return false.
		@param name The name to of the resource group to access.

</member>
        <member name="M:Ogre.ResourceGroupManager.destroyResourceGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroys a resource group, clearing it first, destroying the resources
            which are part of it, and then removing it from
            the list of resource groups. 
        @param name The name of the resource group to destroy.

</member>
        <member name="M:Ogre.ResourceGroupManager.clearResourceGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Clears a resource group. 
		@remarks
			This method unloads all resources in the group, but in addition it
			removes all those resources from their ResourceManagers, and then 
			clears all the members from the list. That means after calling this
			method, there are no resources declared as part of the named group
			any more. Resource locations still persist though.
        @param name The name to of the resource group to clear.

</member>
        <member name="M:Ogre.ResourceGroupManager.unloadUnreferencedResourcesInGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Unload all resources which are not referenced by any other object.
		@remarks
			This method behaves like unloadResourceGroup, except that it only
			unloads resources in the group which are not in use, ie not referenced
			by other objects. This allows you to free up some memory selectively
			whilst still keeping the group around (and the resources present,
			just not using much memory).
		@param name The name of the group to check for unreferenced resources
		@param reloadableOnly If true (the default), only unloads resources
			which can be subsequently automatically reloaded

</member>
        <member name="M:Ogre.ResourceGroupManager.unloadResourceGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Unloads a resource group.
        @remarks
            This method unloads all the resources that have been declared as
            being part of the named resource group. Note that these resources
            will still exist in their respective ResourceManager classes, but
            will be in an unloaded state. If you want to remove them entirely,
            you should use clearResourceGroup or destroyResourceGroup.
        @param name The name to of the resource group to unload.
        @param reloadableOnly If set to true, only unload the resource that is
            reloadable. Because some resources isn't reloadable, they will be
            unloaded but can't load them later. Thus, you might not want to them
            unloaded. Or, you might unload all of them, and then populate them
            manually later.
            @see Resource::isReloadable for resource is reloadable.

</member>
        <member name="M:Ogre.ResourceGroupManager.loadResourceGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
Loads a resource group.
        @remarks
			Loads any created resources which are part of the named group.
			Note that resources must have already been created by calling
			ResourceManager::create, or declared using declareResource() or
			in a script (such as .material and .overlay). The latter requires
			that initialiseResourceGroup has been called. 
		
			When this method is called, this class will callback any ResourceGroupListeners
			which have been registered to update them on progress. 
        @param name The name of the resource group to load.
		@param loadMainResources If true, loads normal resources associated 
			with the group (you might want to set this to false if you wanted
			to just load world geometry in bulk)
		@param loadWorldGeom If true, loads any linked world geometry
			@see ResourceGroupManager::linkWorldGeometryToResourceGroup

</member>
        <member name="M:Ogre.ResourceGroupManager.prepareResourceGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
Prepares a resource group.
        @remarks
			Prepares any created resources which are part of the named group.
			Note that resources must have already been created by calling
			ResourceManager::create, or declared using declareResource() or
			in a script (such as .material and .overlay). The latter requires
			that initialiseResourceGroup has been called. 
		
			When this method is called, this class will callback any ResourceGroupListeners
			which have been registered to update them on progress. 
        @param name The name of the resource group to prepare.
		@param prepareMainResources If true, prepares normal resources associated 
			with the group (you might want to set this to false if you wanted
			to just prepare world geometry in bulk)
		@param prepareWorldGeom If true, prepares any linked world geometry
			@see ResourceGroupManager::linkWorldGeometryToResourceGroup

</member>
        <member name="M:Ogre.ResourceGroupManager.initialiseAllResourceGroups">
Initialise all resource groups which are yet to be initialised.
		@see ResourceGroupManager::intialiseResourceGroup

</member>
        <member name="M:Ogre.ResourceGroupManager.initialiseResourceGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Initialises a resource group.
		@remarks
			After creating a resource group, adding some resource locations, and
			perhaps pre-declaring some resources using declareResource(), but 
			before you need to use the resources in the group, you 
			should call this method to initialise the group. By calling this,
			you are triggering the following processes:
			<ol><li>Scripts for all resource types which support scripting are
				parsed from the resource locations, and resources within them are
				created (but not loaded yet).</li><li>Creates all the resources which have just pre-declared using
			declareResource (again, these are not loaded yet)</li></ol>
			So what this essentially does is create a bunch of unloaded Resource entries
			in the respective ResourceManagers based on scripts, and resources
			you've pre-declared. That means that code looking for these resources
			will find them, but they won't be taking up much memory yet, until
			they are either used, or they are loaded in bulk using loadResourceGroup.
			Loading the resource group in bulk is entirely optional, but has the 
			advantage of coming with progress reporting as resources are loaded.
		@par
			Failure to call this method means that loadResourceGroup will do 
			nothing, and any resources you define in scripts will not be found.
			Similarly, once you have called this method you won't be able to
			pick up any new scripts or pre-declared resources, unless you
			call clearResourceGroup, set up declared resources, and call this
			method again.
		@note 
			When you call Root::initialise, all resource groups that have already been
			created are automatically initialised too. Therefore you do not need to 
			call this method for groups you define and set up before you call 
			Root::initialise. However, since one of the most useful features of 
			resource groups is to set them up after the main system initialisation
			has occurred (e.g. a group per game level), you must remember to call this
			method for the groups you create after this.

		@param name The name of the resource group to initialise

</member>
        <member name="M:Ogre.ResourceGroupManager.createResourceGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean!System.Runtime.CompilerServices.IsConst)">
Create a resource group.
        @remarks
            A resource group allows you to define a set of resources that can 
            be loaded / unloaded as a unit. For example, it might be all the 
            resources used for the level of a game. There is always one predefined
            resource group called ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, 
			which is typically used to hold all resources which do not need to 
			be unloaded until shutdown. There is another predefined resource
            group called ResourceGroupManager::INTERNAL_RESOURCE_GROUP_NAME too,
            which should be used by OGRE internal only, the resources created
            in this group aren't supposed to modify, unload or remove by user.
            You can create additional ones so that you can control the life of
            your resources in whichever way you wish.
			There is one other predefined value, 
			ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME; using this 
			causes the group name to be derived at load time by searching for 
			the resource in the resource locations of each group in turn.
        @par
            Once you have defined a resource group, resources which will be loaded
			as part of it are defined in one of 3 ways:
			<ol><li>Manually through declareResource(); this is useful for scripted
				declarations since it is entirely generalised, and does not 
				create Resource instances right away</li><li>Through the use of scripts; some ResourceManager subtypes have
				script formats (e.g. .material, .overlay) which can be used
				to declare resources</li><li>By calling ResourceManager::create to create a resource manually.
			This resource will go on the list for it's group and will be loaded
			and unloaded with that group</li></ol>
			You must remember to call initialiseResourceGroup if you intend to use
			the first 2 types.
        @param name The name to give the resource group.
		@param inGlobalPool if true the resource will be loaded even a different
			group was requested in the load method as a parameter.

</member>
        <member name="F:Ogre.ResourceGroupManager.mCurrentGroup">
Stored current group - optimisation for when bulk loading a group
</member>
        <member name="M:Ogre.ResourceGroupManager.fireResourceGroupPrepareEnded(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal event firing method
</member>
        <member name="M:Ogre.ResourceGroupManager.fireResourcePrepareEnded">
Internal event firing method
</member>
        <member name="M:Ogre.ResourceGroupManager.fireResourcePrepareStarted(Ogre.SharedPtr&lt;Ogre.Resource&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal event firing method
</member>
        <member name="M:Ogre.ResourceGroupManager.fireResourceGroupPrepareStarted(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Internal event firing method
</member>
        <member name="M:Ogre.ResourceGroupManager.fireResourceGroupLoadEnded(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal event firing method
</member>
        <member name="M:Ogre.ResourceGroupManager.fireResourceLoadEnded">
Internal event firing method
</member>
        <member name="M:Ogre.ResourceGroupManager.fireResourceLoadStarted(Ogre.SharedPtr&lt;Ogre.Resource&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal event firing method
</member>
        <member name="M:Ogre.ResourceGroupManager.fireResourceGroupLoadStarted(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Internal event firing method
</member>
        <member name="M:Ogre.ResourceGroupManager.fireResourceGroupScriptingEnded(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal event firing method
</member>
        <member name="M:Ogre.ResourceGroupManager.fireScriptEnded(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Internal event firing method
</member>
        <member name="M:Ogre.ResourceGroupManager.fireScriptStarted(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal event firing method
</member>
        <member name="M:Ogre.ResourceGroupManager.fireResourceGroupScriptingStarted(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Internal event firing method
</member>
        <member name="M:Ogre.ResourceGroupManager.findGroupContainingResourceImpl(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal find method for auto groups
</member>
        <member name="M:Ogre.ResourceGroupManager.deleteGroup(Ogre.ResourceGroupManager.ResourceGroup*)">
Delete a group for shutdown - don't notify ResourceManagers. 
</member>
        <member name="M:Ogre.ResourceGroupManager.dropGroupContents(Ogre.ResourceGroupManager.ResourceGroup*)">
Drops contents of a group, leave group there, notify ResourceManagers. 
</member>
        <member name="M:Ogre.ResourceGroupManager.getResourceGroup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get resource group 
</member>
        <member name="M:Ogre.ResourceGroupManager.addCreatedResource(Ogre.SharedPtr&lt;Ogre.Resource&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ResourceGroupManager.ResourceGroup*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds a created resource to a group. 
</member>
        <member name="M:Ogre.ResourceGroupManager.createDeclaredResources(Ogre.ResourceGroupManager.ResourceGroup*)">
Create all the pre-declared resources.
		@remarks
			Called as part of initialiseResourceGroup

</member>
        <member name="M:Ogre.ResourceGroupManager.parseResourceGroupScripts(Ogre.ResourceGroupManager.ResourceGroup*)">
Parses all the available scripts found in the resource locations
		for the given group, for all ResourceManagers.
		@remarks
			Called as part of initialiseResourceGroup

</member>
        <member name="F:Ogre.ResourceGroupManager.mWorldGroupName">
Group name for world resources
</member>
        <member name="D:Ogre.ResourceGroupManager.ResourceGroupMap">
Map from resource group names to groups
</member>
        <member name="F:Ogre.ResourceGroupManager.ResourceGroup.worldGeometrySceneManager">
Scene manager to use with linked world geometry
</member>
        <member name="F:Ogre.ResourceGroupManager.ResourceGroup.worldGeometry">
Linked world geometry, as passed to setWorldGeometry
</member>
        <member name="D:Ogre.ResourceGroupManager.ResourceGroup.LoadResourceOrderMap">
Created resources which are ready to be loaded / unloaded
</member>
        <member name="F:Ogre.ResourceGroupManager.ResourceGroup.resourceDeclarations">
Pre-declared resources, ready to be created
</member>
        <member name="F:Ogre.ResourceGroupManager.ResourceGroup.resourceIndexCaseInsensitive">
Index of resource names to locations, built for speedy access (case insensitive archives)
</member>
        <member name="F:Ogre.ResourceGroupManager.ResourceGroup.resourceIndexCaseSensitive">
Index of resource names to locations, built for speedy access (case sensitive archives)
</member>
        <member name="F:Ogre.ResourceGroupManager.ResourceGroup.locationList">
List of possible locations to search
</member>
        <member name="F:Ogre.ResourceGroupManager.ResourceGroup.groupStatus">
Group status
</member>
        <member name="F:Ogre.ResourceGroupManager.ResourceGroup.name">
General mutex for dealing with group content
Status-specific mutex, separate from content-changing mutex
Group name
</member>
        <member name="T:Ogre.ResourceGroupManager.ResourceGroup">
Resource group entry
</member>
        <member name="D:Ogre.ResourceGroupManager.LoadUnloadResourceList">
List of resources which can be loaded / unloaded
</member>
        <member name="D:Ogre.ResourceGroupManager.ResourceLocationIndex">
Resource index entry, resourcename-&gt;location 
</member>
        <member name="D:Ogre.ResourceGroupManager.ScriptLoaderOrderMap">
Map of loading order (Real) to ScriptLoader, used to order script parsing
</member>
        <member name="F:Ogre.ResourceGroupManager.mResourceManagerMap">
Map of resource types (strings) to ResourceManagers, used to notify them to load / unload group contents
</member>
        <member name="D:Ogre.ResourceGroupManager.LocationList">
List of possible file locations
</member>
        <member name="F:Ogre.ResourceGroupManager.ResourceLocation.recursive">
Whether this location was added recursively
</member>
        <member name="F:Ogre.ResourceGroupManager.ResourceLocation.archive">
Pointer to the archive which is the destination
</member>
        <member name="T:Ogre.ResourceGroupManager.ResourceLocation">
Resource location entry
</member>
        <member name="D:Ogre.ResourceGroupManager.ResourceDeclarationList">
List of resource declarations
</member>
        <member name="T:Ogre.ResourceGroupManager.ResourceDeclaration">
Nested struct defining a resource declaration
</member>
        <member name="F:Ogre.ResourceGroupManager.RESOURCE_SYSTEM_NUM_REFERENCE_COUNTS">
The number of reference counts held per resource by the resource system
</member>
        <member name="F:Ogre.ResourceGroupManager.AUTODETECT_RESOURCE_GROUP_NAME">
Special resource group name which causes resource group to be automatically determined based on searching for the resource in all groups.
</member>
        <member name="F:Ogre.ResourceGroupManager.INTERNAL_RESOURCE_GROUP_NAME">
Internal resource group name (should be used by OGRE internal only)
</member>
        <member name="F:Ogre.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME">
Default resource group name
</member>
        <member name="T:Ogre.ResourceGroupManager">
This singleton class manages the list of resource groups, and notifying
        the various resource managers of their obligations to load / unload
        resources in a group. It also provides facilities to monitor resource
        loading per group (to do progress bars etc), provided the resources 
        that are required are pre-registered.
    @par
        Defining new resource groups,  and declaring the resources you intend to
        use in advance is optional, however it is a very useful feature. In addition, 
		if a ResourceManager supports the definition of resources through scripts, 
		then this is the class which drives the locating of the scripts and telling
		the ResourceManager to parse them. 
	@par
		There are several states that a resource can be in (the concept, not the
		object instance in this case):
		<ol><li><b>Undefined</b>. Nobody knows about this resource yet. It might be
		in the filesystem, but Ogre is oblivious to it at the moment - there 
		is no Resource instance. This might be because it's never been declared
		(either in a script, or using ResourceGroupManager::declareResource), or
		it may have previously been a valid Resource instance but has been 
		removed, either individually through ResourceManager::remove or as a group
		through ResourceGroupManager::clearResourceGroup.</li><li><b>Declared</b>. Ogre has some forewarning of this resource, either
		through calling ResourceGroupManager::declareResource, or by declaring
		the resource in a script file which is on one of the resource locations
		which has been defined for a group. There is still no instance of Resource,
		but Ogre will know to create this resource when 
		ResourceGroupManager::initialiseResourceGroup is called (which is automatic
		if you declare the resource group before Root::initialise).</li><li><b>Unloaded</b>. There is now a Resource instance for this resource, 
		although it is not loaded. This means that code which looks for this
		named resource will find it, but the Resource is not using a lot of memory
		because it is in an unloaded state. A Resource can get into this state
		by having just been created by ResourceGroupManager::initialiseResourceGroup 
		(either from a script, or from a call to declareResource), by 
		being created directly from code (ResourceManager::create), or it may 
		have previously been loaded and has been unloaded, either individually
		through Resource::unload, or as a group through ResourceGroupManager::unloadResourceGroup.</li><li><b>Loaded</b>The Resource instance is fully loaded. This may have
		happened implicitly because something used it, or it may have been 
		loaded as part of a group.</li></ol>
		@see ResourceGroupManager::declareResource
		@see ResourceGroupManager::initialiseResourceGroup
		@see ResourceGroupManager::loadResourceGroup
		@see ResourceGroupManager::unloadResourceGroup
		@see ResourceGroupManager::clearResourceGroup

</member>
        <member name="M:Ogre.ResourceLoadingListener.resourceCollision(Ogre.Resource*,Ogre.ResourceManager*)">
This event is called when a resource collides with another existing one in a resource manager

</member>
        <member name="M:Ogre.ResourceLoadingListener.resourceStreamOpened(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Resource*,Ogre.SharedP">
This event is called when a resource stream has been opened, but not processed yet. 
		@remarks
			You may alter the stream if you wish or alter the incoming pointer to point at
			another stream if you wish.

</member>
        <member name="M:Ogre.ResourceLoadingListener.resourceLoading(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Resource*)">
This event is called when a resource beings loading. 
</member>
        <member name="T:Ogre.ResourceLoadingListener">
	 @remarks	This class allows users to override resource loading behavior.
				By overriding this class' methods, you can change how resources
				are loaded and the behavior for resource name collisions.

</member>
        <member name="M:Ogre.ResourceGroupListener.resourceGroupLoadEnded(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This event is fired when a resource group finished loading. 
</member>
        <member name="M:Ogre.ResourceGroupListener.worldGeometryStageEnded">
This event is fired when a stage of loading linked world geometry 
            has been completed. The number of stages required will have been 
            included in the resourceCount passed in resourceGroupLoadStarted.
        @param description Text description of what was just loaded

</member>
        <member name="M:Ogre.ResourceGroupListener.worldGeometryStageStarted(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This event is fired when a stage of loading linked world geometry 
            is about to start. The number of stages required will have been 
            included in the resourceCount passed in resourceGroupLoadStarted.
        @param description Text description of what was just loaded

</member>
        <member name="M:Ogre.ResourceGroupListener.resourceLoadEnded">
This event is fired when the resource has been loaded. 

</member>
        <member name="M:Ogre.ResourceGroupListener.resourceLoadStarted(Ogre.SharedPtr&lt;Ogre.Resource&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This event is fired when a declared resource is about to be loaded. 
		@param resource Weak reference to the resource loaded.

</member>
        <member name="M:Ogre.ResourceGroupListener.resourceGroupLoadStarted(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
This event is fired  when a resource group begins loading.
		@param groupName The name of the group being loaded
		@param resourceCount The number of resources which will be loaded, including
            a number of stages required to load any linked world geometry

</member>
        <member name="M:Ogre.ResourceGroupListener.resourceGroupPrepareEnded(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This event is fired when a resource group finished preparing. 
</member>
        <member name="M:Ogre.ResourceGroupListener.worldGeometryPrepareStageEnded">
This event is fired when a stage of preparing linked world geometry 
            has been completed. The number of stages required will have been 
            included in the resourceCount passed in resourceGroupLoadStarted.
        @param description Text description of what was just prepared

</member>
        <member name="M:Ogre.ResourceGroupListener.worldGeometryPrepareStageStarted(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This event is fired when a stage of preparing linked world geometry 
            is about to start. The number of stages required will have been 
            included in the resourceCount passed in resourceGroupLoadStarted.
        @param description Text description of what was just prepared

</member>
        <member name="M:Ogre.ResourceGroupListener.resourcePrepareEnded">
This event is fired when the resource has been prepared. 

</member>
        <member name="M:Ogre.ResourceGroupListener.resourcePrepareStarted(Ogre.SharedPtr&lt;Ogre.Resource&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This event is fired when a declared resource is about to be prepared. 
		@param resource Weak reference to the resource prepared.

</member>
        <member name="M:Ogre.ResourceGroupListener.resourceGroupPrepareStarted(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
This event is fired  when a resource group begins preparing.
		@param groupName The name of the group being prepared
		@param resourceCount The number of resources which will be prepared, including
            a number of stages required to prepare any linked world geometry

</member>
        <member name="M:Ogre.ResourceGroupListener.resourceGroupScriptingEnded(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This event is fired when a resource group finished parsing scripts. 
</member>
        <member name="M:Ogre.ResourceGroupListener.scriptParseEnded(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
This event is fired when the script has been fully parsed.

</member>
        <member name="M:Ogre.ResourceGroupListener.scriptParseStarted(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This event is fired when a script is about to be parsed.
			@param scriptName Name of the to be parsed
			@param skipThisScript A boolean passed by reference which is by default set to 
			false. If the event sets this to true, the script will be skipped and not
			parsed. Note that in this case the scriptParseEnded event will not be raised
			for this script.

</member>
        <member name="M:Ogre.ResourceGroupListener.resourceGroupScriptingStarted(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
This event is fired when a resource group begins parsing scripts.
		@note
			Remember that if you are loading resources through ResourceBackgroundQueue,
			these callbacks will occur in the background thread, so you should
			not perform any thread-unsafe actions in this callback if that's the
			case (check the group name / script name).
		@param groupName The name of the group 
		@param scriptCount The number of scripts which will be parsed

</member>
        <member name="T:Ogre.ResourceGroupListener">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

This abstract class defines an interface which is called back during
        resource group loading to indicate the progress of the load. 
	@remarks
		Resource group loading is in 2 phases - creating resources from 
		declarations (which includes parsing scripts), and loading
		resources. Note that you don't necessarily have to have both; it
		is quite possible to just parse all the scripts for a group (see
		ResourceGroupManager::initialiseResourceGroup, but not to 
		load the resource group. 
		The sequence of events is (* signifies a repeating item):
		<ul><li>resourceGroupScriptingStarted</li><li>scriptParseStarted (*)</li><li>scriptParseEnded (*)</li><li>resourceGroupScriptingEnded</li><li>resourceGroupLoadStarted</li><li>resourceLoadStarted (*)</li><li>resourceLoadEnded (*)</li><li>worldGeometryStageStarted (*)</li><li>worldGeometryStageEnded (*)</li><li>resourceGroupLoadEnded</li><li>resourceGroupPrepareStarted</li><li>resourcePrepareStarted (*)</li><li>resourcePrepareEnded (*)</li><li>resourceGroupPrepareEnded</li></ul>
    @note
        If OGRE_THREAD_SUPPORT is 1, this class is thread-safe.


</member>
        <member name="M:Ogre.ManualResourceLoader.loadResource(Ogre.Resource*)">
Called when a resource wishes to prepare.
		@param resource The resource which wishes to prepare

</member>
        <member name="M:Ogre.ManualResourceLoader.prepareResource(Ogre.Resource*)">
Called when a resource wishes to load.  Note that this could get
         * called in a background thread even in just a semithreaded ogre
         * (OGRE_THREAD_SUPPORT==2).  Thus, you must not access the rendersystem from
         * this callback.  Do that stuff in loadResource.
		@param resource The resource which wishes to load

</member>
        <member name="T:Ogre.ManualResourceLoader">
Interface describing a manual resource loader.
	@remarks
		Resources are usually loaded from files; however in some cases you
		want to be able to set the data up manually instead. This provides
		some problems, such as how to reload a Resource if it becomes
		unloaded for some reason, either because of memory constraints, or
		because a device fails and some or all of the data is lost.
	@par
		This interface should be implemented by all classes which wish to
		provide manual data to a resource. They provide a pointer to themselves
		when defining the resource (via the appropriate ResourceManager), 
		and will be called when the Resource tries to load. 
		They should implement the loadResource method such that the Resource 
		is in the end set up exactly as if it had loaded from a file, 
		although the implementations will likely differ	between subclasses 
		of Resource, which is why no generic algorithm can be stated here. 
	@note
		The loader must remain valid for the entire life of the resource,
		so that if need be it can be called upon to re-load the resource
		at any time.

</member>
        <member name="M:Ogre.Resource._fireUnloadingComplete">
Firing of unloading complete event
		@remarks
		You should call this from the thread that runs the main frame loop 
		to avoid having to make the receivers of this event thread-safe.
		If you use Ogre's built in frame loop you don't need to call this
		yourself.

</member>
        <member name="M:Ogre.Resource._firePreparingComplete(System.Boolean)">
Firing of preparing complete event
		@remarks
			You should call this from the thread that runs the main frame loop 
			to avoid having to make the receivers of this event thread-safe.
			If you use Ogre's built in frame loop you don't need to call this
			yourself.
			@param wasBackgroundLoaded Whether this was a background loaded event

</member>
        <member name="M:Ogre.Resource._fireLoadingComplete(System.Boolean)">
Firing of loading complete event
		@remarks
			You should call this from the thread that runs the main frame loop 
			to avoid having to make the receivers of this event thread-safe.
			If you use Ogre's built in frame loop you don't need to call this
			yourself.
			@param wasBackgroundLoaded Whether this was a background loaded event

</member>
        <member name="M:Ogre.Resource._dirtyState">
Manually mark the state of this resource as having been changed.
		@remarks
			You only need to call this from outside if you explicitly want derived
			objects to think this object has changed. @see getStateCount.

</member>
        <member name="M:Ogre.Resource.getStateCount">
Returns the number of times this resource has changed state, which 
			generally means the number of times it has been loaded. Objects that 
			build derived data based on the resource can check this value against 
			a copy they kept last time they built this derived data, in order to
			know whether it needs rebuilding. This is a nice way of monitoring
			changes without having a tightly-bound callback.

</member>
        <member name="M:Ogre.Resource._notifyOrigin(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Notify this resource of it's origin
</member>
        <member name="M:Ogre.Resource.getOrigin">
Get the origin of this resource, e.g. a script file name.
		@remarks
			This property will only contain something if the creator of
			this resource chose to populate it. Script loaders are advised
			to populate it.

</member>
        <member name="M:Ogre.Resource.getCreator">
Gets the manager which created this resource
</member>
        <member name="M:Ogre.Resource.changeGroupOwnership(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Change the resource group ownership of a Resource.
		@remarks
			This method is generally reserved for internal use, although
			if you really know what you're doing you can use it to move
			this resource from one group to another.
		@param newGroup Name of the new group

</member>
        <member name="M:Ogre.Resource.getGroup">
Gets the group which this resource is a member of
</member>
        <member name="M:Ogre.Resource.removeListener(Ogre.Resource.Listener*)">
Remove a listener on this resource.
			@see Resource::Listener

</member>
        <member name="M:Ogre.Resource.addListener(Ogre.Resource.Listener*)">
Register a listener on this resource.
			@see Resource::Listener

</member>
        <member name="M:Ogre.Resource.escalateLoading">
Escalates the loading of a background loaded resource. 
		@remarks
			If a resource is set to load in the background, but something needs
			it before it's been loaded, there could be a problem. If the user
			of this resource really can't wait, they can escalate the loading
			which basically pulls the loading into the current thread immediately.
			If the resource is already being loaded but just hasn't quite finished
			then this method will simply wait until the background load is complete.

</member>
        <member name="M:Ogre.Resource.setBackgroundLoaded(System.Boolean)">
Tells the resource whether it is background loaded or not.
		@remarks
			@see Resource::isBackgroundLoaded . Note that calling this only
			defers the normal on-demand loading behaviour of a resource, it
			does not actually set up a thread to make sure the resource gets
			loaded in the background. You should use ResourceBackgroundLoadingQueue
			to manage the actual loading (which will call this method itself).

</member>
        <member name="M:Ogre.Resource.isBackgroundLoaded">
Returns whether this Resource has been earmarked for background loading.
		@remarks
			This option only makes sense when you have built Ogre with 
			thread support (OGRE_THREAD_SUPPORT). If a resource has been marked
			for background loading, then it won't load on demand like normal
			when load() is called. Instead, it will ignore request to load()
			except if the caller indicates it is the background loader. Any
			other users of this resource should check isLoaded(), and if that
			returns false, don't use the resource and come back later.

</member>
        <member name="M:Ogre.Resource.getLoadingState">
Returns the current loading state.

</member>
        <member name="M:Ogre.Resource.isLoading">
Returns whether the resource is currently in the process of
			background loading.

</member>
        <member name="M:Ogre.Resource.isLoaded">
Returns true if the Resource has been loaded, false otherwise.

</member>
        <member name="M:Ogre.Resource.isPrepared">
Returns true if the Resource has been prepared, false otherwise.

</member>
        <member name="M:Ogre.Resource.getName">
Gets resource name.

</member>
        <member name="M:Ogre.Resource.touch">
'Touches' the resource to indicate it has been used.

</member>
        <member name="M:Ogre.Resource.getSize">
Retrieves info about the size of the resource.

</member>
        <member name="M:Ogre.Resource.unload">
Unloads the resource; this is not permanent, the resource can be
			reloaded later if required.

</member>
        <member name="M:Ogre.Resource.isManuallyLoaded">
Is this resource manually loaded?

</member>
        <member name="M:Ogre.Resource.isReloadable">
Returns true if the Resource is reloadable, false otherwise.

</member>
        <member name="M:Ogre.Resource.reload">
Reloads the resource, if it is already loaded.
		@remarks
			Calls unload() and then load() again, if the resource is already
			loaded. If it is not loaded already, then nothing happens.

</member>
        <member name="M:Ogre.Resource.load(System.Boolean)">
Loads the resource, if it is not already.
		@remarks
			If the resource is loaded from a file, loading is automatic. If not,
			if for example this resource gained it's data from procedural calls
			rather than loading from a file, then this resource will not reload 
			on it's own.
		@param backgroundThread Indicates whether the caller of this method is
			the background resource loading thread. 
			

</member>
        <member name="M:Ogre.Resource.prepare(System.Boolean)">
Prepares the resource for load, if it is not already.  One can call prepare()
            before load(), but this is not required as load() will call prepare() 
            itself, if needed.  When OGRE_THREAD_SUPPORT==1 both load() and prepare() 
            are thread-safe.  When OGRE_THREAD_SUPPORT==2 however, only prepare() 
            is thread-safe.  The reason for this function is to allow a background 
            thread to do some of the loading work, without requiring the whole render
            system to be thread-safe.  The background thread would call
            prepare() while the main render loop would later call load().  So long as
            prepare() remains thread-safe, subclasses can arbitrarily split the work of
            loading a resource between load() and prepare().  It is best to try and
            do as much work in prepare(), however, since this will leave less work for
            the main render thread to do and thus increase FPS.
			@param backgroundThread Whether this is occurring in a background thread

</member>
        <member name="M:Ogre.Resource.Dispose">
Virtual destructor. Shouldn't need to be overloaded, as the resource
            deallocation code should reside in unload()
            @see
                Resource::unload()

</member>
        <member name="M:Ogre.Resource.#ctor(Ogre.ResourceManager*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,Ogre.M">
Standard constructor.
		@param creator Pointer to the ResourceManager that is creating this resource
		@param name The unique name of the resource
		@param group The name of the resource group to which this resource belongs
		@param isManual Is this resource manually loaded? If so, you should really
			populate the loader parameter in order that the load process
			can call the loader back when loading is required. 
		@param loader Pointer to a ManualResourceLoader implementation which will be called
			when the Resource wishes to load (should be supplied if you set
			isManual to true). You can in fact leave this parameter null 
			if you wish, but the Resource will never be able to reload if 
			anything ever causes it to unload. Therefore provision of a proper
			ManualResourceLoader instance is strongly recommended.

</member>
        <member name="M:Ogre.Resource.calculateSize">
Calculate the size of a resource; this will only be called after 'load' 
</member>
        <member name="M:Ogre.Resource.unloadImpl">
Internal implementation of the 'unload' action; called regardless of
			whether this resource is being loaded from a ManualResourceLoader. 

</member>
        <member name="M:Ogre.Resource.loadImpl">
Internal implementation of the meat of the 'load' action, only called if this 
			resource is not being loaded from a ManualResourceLoader. 

</member>
        <member name="M:Ogre.Resource.unprepareImpl">
Internal function for undoing the 'prepare' action.  Called when
            the load is completed, and when resources are unloaded when they
            are prepared but not yet loaded.

</member>
        <member name="M:Ogre.Resource.prepareImpl">
Internal implementation of the meat of the 'prepare' action. 

</member>
        <member name="M:Ogre.Resource.postUnloadImpl">
Internal hook to perform actions after the unload process, but
		before the resource has been marked as fully unloaded.
		@note Mutex will have already been acquired by the unloading thread.

</member>
        <member name="M:Ogre.Resource.preUnloadImpl">
Internal hook to perform actions before the unload process.
		@note Mutex will have already been acquired by the unloading thread.

</member>
        <member name="M:Ogre.Resource.postLoadImpl">
Internal hook to perform actions after the load process, but
			before the resource has been marked as fully loaded.
		@note Mutex will have already been acquired by the loading thread.
			Also, this call will occur even when using a ManualResourceLoader 
			(when loadImpl is not actually called)

</member>
        <member name="M:Ogre.Resource.preLoadImpl">
Internal hook to perform actions before the load process, but
			after the resource has been marked as 'loading'.
		@note Mutex will have already been acquired by the loading thread.
			Also, this call will occur even when using a ManualResourceLoader 
			(when loadImpl is not actually called)

</member>
        <member name="M:Ogre.Resource.#ctor">
Protected unnamed constructor to prevent default construction. 

</member>
        <member name="F:Ogre.Resource.mStateCount">
State count, the number of times this resource has changed state
</member>
        <member name="F:Ogre.Resource.mLoader">
Optional manual loader; if provided, data is loaded from here instead of a file
</member>
        <member name="F:Ogre.Resource.mOrigin">
Origin of this resource (e.g. script name) - optional
</member>
        <member name="F:Ogre.Resource.mIsManual">
Is this file manually loaded?
</member>
        <member name="F:Ogre.Resource.mSize">
The size of the resource in bytes
</member>
        <member name="F:Ogre.Resource.mIsBackgroundLoaded">
Is this resource going to be background loaded? Only applicable for multithreaded
</member>
        <member name="F:Ogre.Resource.mLoadingState">
Is the resource currently loaded?
</member>
        <member name="F:Ogre.Resource.mHandle">
Numeric handle for more efficient look up than name
</member>
        <member name="F:Ogre.Resource.mGroup">
The name of the resource group
</member>
        <member name="F:Ogre.Resource.mName">
Unique name of the resource
</member>
        <member name="F:Ogre.Resource.mCreator">
Creator
</member>
        <member name="F:LOADSTATE_PREPARING">
Preparing is in progress
</member>
        <member name="F:LOADSTATE_PREPARED">
Fully prepared
</member>
        <member name="F:LOADSTATE_UNLOADING">
Currently unloading
</member>
        <member name="F:LOADSTATE_LOADED">
Fully loaded
</member>
        <member name="F:LOADSTATE_LOADING">
Loading is in progress
</member>
        <member name="F:LOADSTATE_UNLOADED">
Not loaded
</member>
        <member name="T:Ogre.Resource.LoadingState">
Enum identifying the loading state of the resource
</member>
        <member name="M:Ogre.Resource.Listener.unloadingComplete(Ogre.Resource*)">
Called whenever the resource has been unloaded. 
</member>
        <member name="M:Ogre.Resource.Listener.preparingComplete(Ogre.Resource*)">
called whenever the resource finishes preparing (paging into memory).
			@remarks
				If a Resource has been marked as background loaded (@see Resource::setBackgroundLoaded)
				the call does not itself occur in the thread which is doing the preparing;
				when preparing is complete a response indicator is placed with the
				ResourceGroupManager, which will then be sent back to the 
				listener as part of the application's primary frame loop thread.

</member>
        <member name="M:Ogre.Resource.Listener.loadingComplete(Ogre.Resource*)">
Called whenever the resource finishes loading. 
			@remarks
				If a Resource has been marked as background loaded (@see Resource::setBackgroundLoaded), 
				the call does not itself occur in the thread which is doing the loading;
				when loading is complete a response indicator is placed with the
				ResourceGroupManager, which will then be sent back to the 
				listener as part of the application's primary frame loop thread.

</member>
        <member name="M:Ogre.Resource.Listener.backgroundPreparingComplete(Ogre.Resource*)">
Callback to indicate that background preparing has completed.
			@deprecated
				Use preparingComplete instead.

</member>
        <member name="M:Ogre.Resource.Listener.backgroundLoadingComplete(Ogre.Resource*)">
Callback to indicate that background loading has completed.
			@deprecated
				Use loadingComplete instead.

</member>
        <member name="T:Ogre.Resource">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

Abstract class representing a loadable resource (e.g. textures, sounds etc)
        @remarks
            Resources are data objects that must be loaded and managed throughout
			an application. A resource might be a mesh, a texture, or any other
			piece of data - the key thing is that they must be identified by 
			a name which is unique, must be loaded only once,
			must be managed efficiently in terms of retrieval, and they may
			also be unloadable to free memory up when they have not been used for
			a while and the memory budget is under stress.
		@par
			All Resource instances must be a member of a resource group; see
			ResourceGroupManager for full details.
        @par
            Subclasses must implement:
			<ol><li>A constructor, overriding the same parameters as the constructor
			    defined by this class. Subclasses are not allowed to define
				constructors with other parameters; other settings must be
				settable through accessor methods before loading.</li><li>The loadImpl() and unloadImpl() methods - mSize must be set 
				after loadImpl()</li><li>StringInterface ParamCommand and ParamDictionary setups
			    in order to allow setting of core parameters (prior to load)
				through a generic interface.</li></ol></member>
        <member name="M:Ogre.StringInterface.cleanupDictionary">
Cleans up the static 'msDictionary' required to reset Ogre,
        otherwise the containers are left with invalid pointers, which will lead to a crash
        as soon as one of the ResourceManager implementers (e.g. MaterialManager) initializes.
</member>
        <member name="M:Ogre.StringInterface.copyParametersTo(Ogre.StringInterface*)">
Method for copying this object's parameters to another object.
        @remarks
            This method takes the values of all the object's parameters and tries to set the
            same values on the destination object. This provides a completely type independent
            way to copy parameters to other objects. Note that because of the String manipulation 
            involved, this should not be regarded as an efficient process and should be saved for
            times outside of the rendering loop.
        @par
            Any unrecognised parameters will be ignored as with setParameter method.
        @param dest Pointer to object to have it's parameters set the same as this object.


</member>
        <member name="M:Ogre.StringInterface.getParameter(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Generic parameter retrieval method.
        @remarks
            Call this method with the name of a parameter to retrieve a string-format value of
            the parameter in question. If in doubt, check the parameter definition in the
            list returned from getParameters for the type of this parameter. If you
            like you can use StringConverter to convert this string back into a native type.
        @param
            name The name of the parameter to get
        @returns
            String value of parameter, blank if not found

</member>
        <member name="M:Ogre.StringInterface.setParameterList(std.map&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.less&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.Compiler">
Generic multiple parameter setting method.
        @remarks
            Call this method with a list of name / value pairs
            to set. The implementor will convert the string to a native type internally.
            If in doubt, check the parameter definition in the list returned from 
            StringInterface::getParameters.
        @param
            paramList Name/value pair list

</member>
        <member name="M:Ogre.StringInterface.setParameter(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Generic parameter setting method.
        @remarks
            Call this method with the name of a parameter and a string version of the value
            to set. The implementor will convert the string to a native type internally.
            If in doubt, check the parameter definition in the list returned from 
            StringInterface::getParameters.
        @param
            name The name of the parameter to set
        @param
            value String value. Must be in the right format for the type specified in the parameter definition.
            See the StringConverter class for more information.
        @returns
            true if set was successful, false otherwise (NB no exceptions thrown - tolerant method)

</member>
        <member name="M:Ogre.StringInterface.getParameters">
Retrieves a list of parameters valid for this object. 
        @returns
            A reference to a static list of ParameterDef objects.


</member>
        <member name="M:Ogre.StringInterface.getParamDictionary">
Retrieves the parameter dictionary for this class. 
        @remarks
            Only valid to call this after createParamDictionary.
        @returns
            Pointer to ParamDictionary shared by all instances of this class
            which you can add parameters to, retrieve parameters etc.

</member>
        <member name="M:Ogre.StringInterface.Dispose">
Virtual destructor, see Effective C++ 
</member>
        <member name="M:Ogre.StringInterface.createParamDictionary(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for creating a parameter dictionary for the class, if it does not already exist.
        @remarks
            This method will check to see if a parameter dictionary exist for this class yet,
            and if not will create one. NB you must supply the name of the class (RTTI is not 
            used or performance).
        @param
            className the name of the class using the dictionary
        @returns
            true if a new dictionary was created, false if it was already there

</member>
        <member name="F:Ogre.StringInterface.mParamDictName">
Class name for this instance to be used as a lookup (must be initialised by subclasses)
</member>
        <member name="F:Ogre.StringInterface.msDictionary">
Dictionary of parameters
</member>
        <member name="T:Ogre.StringInterface">
Class defining the common interface which classes can use to 
        present a reflection-style, self-defining parameter set to callers.
    @remarks
        This class also holds a static map of class name to parameter dictionaries
        for each subclass to use. See ParamDictionary for details. 
    @remarks
        In order to use this class, each subclass must call createParamDictionary in their constructors
        which will create a parameter dictionary for the class if it does not exist yet.

</member>
        <member name="M:Ogre.ParamDictionary.getParameters">
Retrieves a list of parameters valid for this object. 
        @returns
            A reference to a static list of ParameterDef objects.


</member>
        <member name="M:Ogre.ParamDictionary.addParameter(Ogre.ParameterDef!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ParamCommand*)">
Method for adding a parameter definition for this class. 
        @param paramDef A ParameterDef object defining the parameter
        @param paramCmd Pointer to a ParamCommand subclass to handle the getting / setting of this parameter.
            NB this class will not destroy this on shutdown, please ensure you do


</member>
        <member name="M:Ogre.ParamDictionary.getParamCommand(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieves the parameter command object for a named parameter. 
</member>
        <member name="F:Ogre.ParamDictionary.mParamCommands">
Command objects to get/set
</member>
        <member name="F:Ogre.ParamDictionary.mParamDefs">
Definitions of parameters
</member>
        <member name="T:Ogre.ParamDictionary">
Class to hold a dictionary of parameters for a single class. 
</member>
        <member name="T:Ogre.ParamCommand">
Abstract class which is command object which gets/sets parameters.
</member>
        <member name="T:Ogre.ParameterDef">
Definition of a parameter supported by a StringInterface class, for introspection
</member>
        <member name="T:Ogre.ParameterType">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

List of parameter types available
</member>
        <member name="M:Ogre.NameGenerator.getNext">
Get the internal counter
</member>
        <member name="M:Ogre.NameGenerator.setNext(System.UInt64)">
Manually set the internal counter (use caution)
</member>
        <member name="M:Ogre.NameGenerator.reset">
Reset the internal counter
</member>
        <member name="M:Ogre.NameGenerator.generate">
Generate a new name
</member>
        <member name="T:Ogre.NameGenerator">
Utility class to generate a sequentially numbered series of names
</member>
        <member name="D:Ogre.RenderWindowList">
Render window container.
</member>
        <member name="D:Ogre.RenderWindowDescriptionList">
Render window creation parameters container.
</member>
        <member name="T:Ogre.RenderWindowDescription">
Render window creation parameters.
</member>
        <member name="T:Ogre.ClipResult">
Generic result of clipping
</member>
        <member name="F:CLIPPED_ALL">
Everything was clipped away
</member>
        <member name="F:CLIPPED_SOME">
Partially clipped
</member>
        <member name="F:CLIPPED_NONE">
Nothing was clipped
</member>
        <member name="M:Ogre.findCommandLineOpts(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**,std.map&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,System.Boolean,std.less&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSi">
Locate command-line options of the unary form '-blah' and of the
        binary form '-blah foo', passing back the index of the next non-option.
    @param numargs, argv The standard parameters passed to the main method
    @param unaryOptList Map of unary options (i.e. those that do not require a parameter).
        Should be pre-populated with, for example '-e' in the key and false in the 
        value. Options which are found will be set to true on return.
    @param binOptList Map of binary options (i.e. those that require a parameter
        e.g. '-e afile.txt').
        Should be pre-populated with, for example '-e' and the default setting. 
        Options which are found will have the value updated.

</member>
        <member name="M:Ogre.Box.getDepth">
Get the depth of this box
</member>
        <member name="M:Ogre.Box.getHeight">
Get the height of this box
</member>
        <member name="M:Ogre.Box.getWidth">
Get the width of this box
</member>
        <member name="M:Ogre.Box.contains(Ogre.Box!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return true if the other box is a part of this one
</member>
        <member name="M:Ogre.Box.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
Define a box from left, top, front, right, bottom and back
            	coordinates.
            	@param	l	x value of left edge
            	@param	t	y value of top edge
            	@param  ff  z value of front edge
            	@param	r	x value of right edge
            	@param	b	y value of bottom edge
            	@param  bb  z value of back edge
            	@note Note that the left, top, and front edges are included 
 		           	but the right, bottom and back ones are not.

</member>
        <member name="M:Ogre.Box.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
Define a box from left, top, right and bottom coordinates
            	This box will have depth one (front=0 and back=1).
            	@param	l	x value of left edge
            	@param	t	y value of top edge
            	@param	r	x value of right edge
            	@param	b	y value of bottom edge
            	@note Note that the left, top, and front edges are included 
 		           	but the right, bottom and back ones are not.

</member>
        <member name="M:Ogre.Box.#ctor">
Parameterless constructor for setting the members manually
</member>
        <member name="T:Ogre.Box">
Structure used to define a box in a 3-D integer space.
         	Note that the left, top, and front edges are included but the right, 
         	bottom and back ones are not.

</member>
        <member name="D:Ogre.Rect">
Structure used to define a rectangle in a 2-D integer space.

</member>
        <member name="D:Ogre.RealRect">
Structure used to define a rectangle in a 2-D floating point space, 
			subject to double / single floating point settings.

</member>
        <member name="D:Ogre.FloatRect">
Structure used to define a rectangle in a 2-D floating point space.

</member>
        <member name="D:Ogre.AliasTextureNamePairList">
Alias / Texture name pair (first = alias, second = texture name)
</member>
        <member name="D:Ogre.NameValuePairList">
Name / value parameter pair (first = name, second = value)
</member>
        <member name="T:Ogre.FrameBufferType">
Defines the frame buffer types. 
</member>
        <member name="T:Ogre.SortMode">
Sort mode for billboard-set and particle-system 
</member>
        <member name="F:SM_DISTANCE">
Sort by distance from the camera 
</member>
        <member name="F:SM_DIRECTION">
Sort by direction of the camera 
</member>
        <member name="D:Ogre.TrackVertexColourType">
An enumeration describing which material properties should track the vertex colours 
</member>
        <member name="T:Ogre.ShadowTechnique">
An enumeration of broad shadow techniques 
</member>
        <member name="F:SHADOWTYPE_TEXTURE_MODULATIVE_INTEGRATED">
Texture-based shadow technique which involves a render-to-texture
			of the shadow caster and a projection of that texture on to the shadow
			receivers, with the usage of those shadow textures completely controlled
			by the materials of the receivers.
			This technique is easily the most flexible of all techniques because 
			the material author is in complete control over how the shadows are
			combined with regular rendering. It can perform shadows as accurately
			as SHADOWTYPE_TEXTURE_ADDITIVE but more efficiently because it requires
			less passes. However it also requires more expertise to use, and 
			in almost all cases, shader capable hardware to really use to the full.
			@note The 'modulative' part of this mode means that the colour of
			the rendered shadow texture is by default the 'shadow colour'. It does
			not mean it modulates on your receivers automatically though, how you
			use that result is up to you.

</member>
        <member name="F:SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED">
Texture-based shadow technique which involves a render-to-texture
		of the shadow caster and a projection of that texture on to the shadow
		receivers, with the usage of those shadow textures completely controlled
		by the materials of the receivers.
		This technique is easily the most flexible of all techniques because 
		the material author is in complete control over how the shadows are
		combined with regular rendering. It can perform shadows as accurately
		as SHADOWTYPE_TEXTURE_ADDITIVE but more efficiently because it requires
		less passes. However it also requires more expertise to use, and 
		in almost all cases, shader capable hardware to really use to the full.
		@note The 'additive' part of this mode means that the colour of
		the rendered shadow texture is by default plain black. It does
		not mean it does the adding on your receivers automatically though, how you
		use that result is up to you.

</member>
        <member name="F:SHADOWTYPE_TEXTURE_ADDITIVE">
Texture-based shadow technique which involves a render-to-texture
            of the shadow caster and a projection of that texture onto the 
            shadow receivers, built up per light as additive passes. 
			This technique can be very fillrate intensive because it requires numLights + 2 
			passes of the entire scene. However, it is a more accurate model than the 
			modulative approach and this is especially apparent when using coloured lights 
			or bump mapping.

</member>
        <member name="F:SHADOWTYPE_TEXTURE_MODULATIVE">
Texture-based shadow technique which involves a monochrome render-to-texture
            of the shadow caster and a projection of that texture onto the 
            shadow receivers as a modulative pass. 

</member>
        <member name="F:SHADOWTYPE_STENCIL_ADDITIVE">
Stencil shadow technique which renders each light as a separate
            additive pass to the scene. This technique can be very fillrate
            intensive because it requires at least 2 passes of the entire
            scene, more if there are multiple lights. However, it is a more
            accurate model than the modulative stencil approach and this is
            especially apparent when using coloured lights or bump mapping.

</member>
        <member name="F:SHADOWTYPE_STENCIL_MODULATIVE">
Stencil shadow technique which renders all shadow volumes as
            a modulation after all the non-transparent areas have been 
            rendered. This technique is considerably less fillrate intensive 
            than the additive stencil shadow approach when there are multiple
            lights, but is not an accurate model. 

</member>
        <member name="F:SHADOWDETAILTYPE_TEXTURE">
Mask for texture shadows (not for direct use, use  SHADOWTYPE_ enum instead)

</member>
        <member name="F:SHADOWDETAILTYPE_STENCIL">
Mask for stencil shadows (not for direct use, use  SHADOWTYPE_ enum instead)

</member>
        <member name="F:SHADOWDETAILTYPE_INTEGRATED">
Mask for integrated shadows (not for direct use, use SHADOWTYPE_ enum instead)

</member>
        <member name="F:SHADOWDETAILTYPE_MODULATIVE">
Mask for modulative shadows (not for direct use, use  SHADOWTYPE_ enum instead)

</member>
        <member name="F:SHADOWDETAILTYPE_ADDITIVE">
Mask for additive shadows (not for direct use, use  SHADOWTYPE_ enum instead)

</member>
        <member name="F:SHADOWTYPE_NONE">
No shadows 
</member>
        <member name="T:Ogre.PolygonMode">
The polygon mode to use when rasterising. 
</member>
        <member name="F:PM_SOLID">
Solid polygons are rendered.
</member>
        <member name="F:PM_WIREFRAME">
Wireframe models are rendered.
</member>
        <member name="F:PM_POINTS">
Only points are rendered.
</member>
        <member name="T:Ogre.WaveformType">
Enumerates the wave types usable with the Ogre engine. 
</member>
        <member name="F:WFT_PWM">
Pulse Width Modulation. Works like WFT_SQUARE, except the high to low transition is controlled by duty cycle. 
With a duty cycle of 50% (0.5) will give the same output as WFT_SQUARE.
</member>
        <member name="F:WFT_INVERSE_SAWTOOTH">
Gradual steady decrease from max to min over the period, with an instant return to max at the end.
</member>
        <member name="F:WFT_SAWTOOTH">
Gradual steady increase from min to max over the period with an instant return to min at the end.
</member>
        <member name="F:WFT_SQUARE">
Half of the time is spent at the min, half at the max with instant transition between.
</member>
        <member name="F:WFT_TRIANGLE">
An angular wave with a constant increase / decrease speed with pointed peaks.
</member>
        <member name="F:WFT_SINE">
Standard sine wave which smoothly changes from low to high and back again.
</member>
        <member name="T:Ogre.ManualCullingMode">
Manual culling modes based on vertex normals.
        This setting applies to how the software culls triangles before sending them to the 
		hardware API. This culling mode is used by scene managers which choose to implement it -
		normally those which deal with large amounts of fixed world geometry which is often 
		planar (software culling movable variable geometry is expensive). 
</member>
        <member name="F:MANUAL_CULL_FRONT">
Cull triangles whose normal is pointing towards the camera.
</member>
        <member name="F:MANUAL_CULL_BACK">
Cull triangles whose normal is pointing away from the camera (default).
</member>
        <member name="F:MANUAL_CULL_NONE">
No culling so everything is sent to the hardware.
</member>
        <member name="T:Ogre.CullingMode">
Hardware culling modes based on vertex winding.
        This setting applies to how the hardware API culls triangles it is sent. 
</member>
        <member name="F:CULL_ANTICLOCKWISE">
Hardware culls triangles whose vertices are listed anticlockwise in the view.
</member>
        <member name="F:CULL_CLOCKWISE">
Hardware culls triangles whose vertices are listed clockwise in the view (default).
</member>
        <member name="F:CULL_NONE">
Hardware never culls triangles and renders everything it receives.
</member>
        <member name="T:Ogre.FogMode">
Fog modes. 
</member>
        <member name="F:FOG_LINEAR">
Fog density increases linearly between the start and end distances
</member>
        <member name="F:FOG_EXP2">
Fog density increases at the square of FOG_EXP, i.e. even quicker (fog = 1/e^(distance * density)^2)
</member>
        <member name="F:FOG_EXP">
Fog density increases  exponentially from the camera (fog = 1/e^(distance * density))
</member>
        <member name="F:FOG_NONE">
No fog. Duh.
</member>
        <member name="T:Ogre.ShadeOptions">
Light shading modes. 
</member>
        <member name="T:Ogre.FilterOptions">
Filtering options for textures / mipmaps. 
</member>
        <member name="F:FO_ANISOTROPIC">
Similar to FO_LINEAR, but compensates for the angle of the texture plane
</member>
        <member name="F:FO_LINEAR">
Average of a 2x2 pixel area, denotes bilinear for MIN and MAG, trilinear for MIP
</member>
        <member name="F:FO_POINT">
Use the closest pixel
</member>
        <member name="F:FO_NONE">
No filtering, used for FILT_MIP to turn off mipmapping
</member>
        <member name="F:FT_MIP">
The filter used when determining the mipmap
</member>
        <member name="F:FT_MAG">
The filter used when magnifying a texture
</member>
        <member name="F:FT_MIN">
The filter used when shrinking a texture
</member>
        <member name="T:Ogre.TextureFilterOptions">
High-level filtering options providing shortcuts to settings the
        minification, magnification and mip filters. 
</member>
        <member name="F:TFO_ANISOTROPIC">
Equal to: min=FO_ANISOTROPIC, max=FO_ANISOTROPIC, mip=FO_LINEAR
</member>
        <member name="F:TFO_TRILINEAR">
Equal to: min=FO_LINEAR, mag=FO_LINEAR, mip=FO_LINEAR
</member>
        <member name="F:TFO_BILINEAR">
Equal to: min=FO_LINEAR, mag=FO_LINEAR, mip=FO_POINT
</member>
        <member name="F:TFO_NONE">
Equal to: min=FO_POINT, mag=FO_POINT, mip=FO_NONE
</member>
        <member name="T:Ogre.CompareFunction">
Comparison functions used for the depth/stencil buffer operations and 
		others. 
</member>
        <member name="M:Ogre.FastHash(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32)">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

Fast general hashing algorithm
</member>
        <member name="M:Ogre.Archive.getType">
Return the type code of this Archive
</member>
        <member name="M:Ogre.Archive.findFileInfo(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
Find all files or directories matching a given pattern in this
            archive and get some detailed information about them.
        @param pattern The pattern to search for; wildcards (*) are allowed
        @param recursive Whether all paths of the archive are searched (if the 
        archive has a concept of that)
        @param dirs Set to true if you want the directories to be listed
            instead of files
        @returns A list of file information structures for all files matching 
            the criteria.

</member>
        <member name="M:Ogre.Archive.getModifiedTime(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieve the modification time of a given file 
</member>
        <member name="M:Ogre.Archive.exists(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Find out if the named file exists (note: fully qualified filename required) 
</member>
        <member name="M:Ogre.Archive.find(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
Find all file or directory names matching a given pattern
            in this archive.
        @note
            This method only returns filenames, you can also retrieve other
            information using findFileInfo.
        @param pattern The pattern to search for; wildcards (*) are allowed
        @param recursive Whether all paths of the archive are searched (if the 
            archive has a concept of that)
        @param dirs Set to true if you want the directories to be listed
            instead of files
        @returns A list of filenames matching the criteria, all are fully qualified

</member>
        <member name="M:Ogre.Archive.listFileInfo(System.Boolean,System.Boolean)">
List all files in the archive with accompanying information.
        @param recursive Whether all paths of the archive are searched (if the 
            archive has a concept of that)
        @param dirs Set to true if you want the directories to be listed
            instead of files
        @returns A list of structures detailing quite a lot of information about
            all the files in the archive.

</member>
        <member name="M:Ogre.Archive.list(System.Boolean,System.Boolean)">
List all file names in the archive.
        @note
            This method only returns filenames, you can also retrieve other
            information using listFileInfo.
        @param recursive Whether all paths of the archive are searched (if the 
            archive has a concept of that)
        @param dirs Set to true if you want the directories to be listed
            instead of files
        @returns A list of filenames matching the criteria, all are fully qualified

</member>
        <member name="M:Ogre.Archive.remove(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Delete a named file.
		@remarks Not possible on read-only archives
		@param filename The fully qualified name of the file

</member>
        <member name="M:Ogre.Archive.create(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a new file (or overwrite one already there). 
		@note If the archive is read-only then this method will fail.
		@param filename The fully qualified name of the file
		@returns A shared pointer to a DataStream which can be used to 
		read / write the file. 

</member>
        <member name="M:Ogre.Archive.open(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Open a stream on a given file. 
        @note
            There is no equivalent 'close' method; the returned stream
            controls the lifecycle of this file operation.
        @param filename The fully qualified name of the file
		@param readOnly Whether to open the file in read-only mode or not (note, 
			if the archive is read-only then this cannot be set to false)
        @returns A shared pointer to a DataStream which can be used to 
            read / write the file. If the file is not present, returns a null
			shared pointer.

</member>
        <member name="M:Ogre.Archive.isReadOnly">
Reports whether this Archive is read-only, or whether the contents
			can be updated. 

</member>
        <member name="M:Ogre.Archive.unload">
Unloads the archive.
        @warning
            Do not call this function directly, it is meant to be used
            only by the ArchiveManager class.

</member>
        <member name="M:Ogre.Archive.load">
Loads the archive.
        @remarks
            This initializes all the internal data of the class.
        @warning
            Do not call this function directly, it is meant to be used
            only by the ArchiveManager class.

</member>
        <member name="M:Ogre.Archive.isCaseSensitive">
Returns whether this archive is case sensitive in the way it matches files
</member>
        <member name="M:Ogre.Archive.getName">
Get the name of this archive
</member>
        <member name="M:Ogre.Archive.Dispose">
Default destructor.

</member>
        <member name="M:Ogre.Archive.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor - don't call direct, used by ArchiveFactory.

</member>
        <member name="F:Ogre.Archive.mReadOnly">
Read-only flag
</member>
        <member name="F:Ogre.Archive.mType">
Archive type code
</member>
        <member name="F:Ogre.Archive.mName">
Archive name
</member>
        <member name="T:Ogre.Archive">
Archive-handling class.
    @remarks
        An archive is a generic term for a container of files. This may be a
        filesystem folder, it may be a compressed archive, it may even be 
        a remote location shared on the web. This class is designed to be 
        subclassed to provide access to a range of file locations. 
    @par
        Instances of this class are never constructed or even handled by end-user
        applications. They are constructed by custom ArchiveFactory classes, 
        which plugins can register new instances of using ArchiveManager. 
        End-user applications will typically use ResourceManager or 
        ResourceGroupManager to manage resources at a higher level, rather than 
        reading files directly through this class. Doing it this way allows you
        to benefit from OGRE's automatic searching of multiple file locations 
        for the resources you are looking for.

</member>
        <member name="F:Ogre.FileInfo.uncompressedSize">
Uncompressed size
</member>
        <member name="F:Ogre.FileInfo.compressedSize">
Compressed size
</member>
        <member name="F:Ogre.FileInfo.basename">
Base filename
</member>
        <member name="F:Ogre.FileInfo.path">
Path name; separated by '/' and ending with '/'
</member>
        <member name="F:Ogre.FileInfo.filename">
The file's fully qualified name
</member>
        <member name="F:Ogre.FileInfo.archive">
The archive in which the file has been found (for info when performing
multi-Archive searches, note you should still open through ResourceGroupManager)
</member>
        <member name="T:Ogre.FileInfo">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

Information about a file/directory within the archive will be
    returned using a FileInfo struct.
    @see
    Archive

</member>
        <member name="M:Ogre.FileHandleDataStream.close">
@copydoc DataStream::close

</member>
        <member name="M:Ogre.FileHandleDataStream.eof">
@copydoc DataStream::eof

</member>
        <member name="M:Ogre.FileHandleDataStream.tell">
@copydoc DataStream::tell

</member>
        <member name="M:Ogre.FileHandleDataStream.seek(System.UInt32)">
@copydoc DataStream::seek

</member>
        <member name="M:Ogre.FileHandleDataStream.skip(System.Int32!System.Runtime.CompilerServices.IsLong)">
@copydoc DataStream::skip

</member>
        <member name="M:Ogre.FileHandleDataStream.write(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
@copydoc DataStream::write

</member>
        <member name="M:Ogre.FileHandleDataStream.read(System.Void*,System.UInt32)">
@copydoc DataStream::read

</member>
        <member name="M:Ogre.FileHandleDataStream.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,_iobuf*,System.UInt16)">
Create named stream from a C file handle
</member>
        <member name="M:Ogre.FileHandleDataStream.#ctor(_iobuf*,System.UInt16)">
Create stream from a C file handle
</member>
        <member name="T:Ogre.FileHandleDataStream">
Common subclass of DataStream for handling data from C-style file 
		handles.
    @remarks
        Use of this class is generally discouraged; if you want to wrap file
        access in a DataStream, you should definitely be using the C++ friendly
        FileStreamDataStream. However, since there are quite a few applications
        and libraries still wedded to the old FILE handle access, this stream
        wrapper provides some backwards compatibility.

</member>
        <member name="M:Ogre.FileStreamDataStream.close">
@copydoc DataStream::close

</member>
        <member name="M:Ogre.FileStreamDataStream.eof">
@copydoc DataStream::eof

</member>
        <member name="M:Ogre.FileStreamDataStream.tell">
@copydoc DataStream::tell

</member>
        <member name="M:Ogre.FileStreamDataStream.seek(System.UInt32)">
@copydoc DataStream::seek

</member>
        <member name="M:Ogre.FileStreamDataStream.skip(System.Int32!System.Runtime.CompilerServices.IsLong)">
@copydoc DataStream::skip

</member>
        <member name="M:Ogre.FileStreamDataStream.readLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc DataStream::readLine

</member>
        <member name="M:Ogre.FileStreamDataStream.write(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
@copydoc DataStream::write

</member>
        <member name="M:Ogre.FileStreamDataStream.read(System.Void*,System.UInt32)">
@copydoc DataStream::read

</member>
        <member name="M:Ogre.FileStreamDataStream.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_fstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*,System.UInt32,System.Boolean)">
Construct named read-write stream from an STL stream, and tell it the size
		@remarks
		This variant tells the class the size of the stream too, which 
		means this class does not need to seek to the end of the stream 
		to determine the size up-front. This can be beneficial if you have
		metadata about the contents of the stream already.
		@param name The name to give this stream
		@param s Pointer to source stream
		@param size Size of the stream contents in bytes
		@param freeOnClose Whether to delete the underlying stream on 
		destruction of this class. If you specify 'true' for this you
		must ensure that the stream was allocated using OGRE_NEW_T with 
		MEMCATEGRORY_GENERAL.

</member>
        <member name="M:Ogre.FileStreamDataStream.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_ifstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*,System.UInt32,System.Boolean)">
Construct named read-only stream from an STL stream, and tell it the size
        @remarks
            This variant tells the class the size of the stream too, which 
            means this class does not need to seek to the end of the stream 
            to determine the size up-front. This can be beneficial if you have
            metadata about the contents of the stream already.
        @param name The name to give this stream
        @param s Pointer to source stream
        @param size Size of the stream contents in bytes
        @param freeOnClose Whether to delete the underlying stream on 
            destruction of this class. If you specify 'true' for this you
			must ensure that the stream was allocated using OGRE_NEW_T with 
			MEMCATEGRORY_GENERAL.

</member>
        <member name="M:Ogre.FileStreamDataStream.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_fstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*,System.Boolean)">
Construct named read-write stream from an STL stream
		@param name The name to give this stream
		@param s Pointer to source stream
		@param freeOnClose Whether to delete the underlying stream on 
		destruction of this class

</member>
        <member name="M:Ogre.FileStreamDataStream.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_ifstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*,System.Boolean)">
Construct named read-only stream from an STL stream
        @param name The name to give this stream
        @param s Pointer to source stream
        @param freeOnClose Whether to delete the underlying stream on 
            destruction of this class

</member>
        <member name="M:Ogre.FileStreamDataStream.#ctor(std.basic_fstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*,System.Boolean)">
Construct a read-write stream from an STL stream
		@param s Pointer to source stream
		@param freeOnClose Whether to delete the underlying stream on 
		destruction of this class

</member>
        <member name="M:Ogre.FileStreamDataStream.#ctor(std.basic_ifstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*,System.Boolean)">
Construct a read-only stream from an STL stream
        @param s Pointer to source stream
        @param freeOnClose Whether to delete the underlying stream on 
            destruction of this class

</member>
        <member name="F:Ogre.FileStreamDataStream.mpFStream">
Reference to source file stream (read-write)
</member>
        <member name="F:Ogre.FileStreamDataStream.mpFStreamRO">
Reference to source file stream (read-only)
</member>
        <member name="F:Ogre.FileStreamDataStream.mpInStream">
Reference to source stream (read)
</member>
        <member name="T:Ogre.FileStreamDataStream">
Common subclass of DataStream for handling data from 
		std::basic_istream.

</member>
        <member name="D:Ogre.MemoryDataStreamPtr">
Shared pointer to allow memory data streams to be passed around without
    worrying about deallocation

</member>
        <member name="M:Ogre.MemoryDataStream.setFreeOnClose(System.Boolean)">
Sets whether or not to free the encapsulated memory on close. 
</member>
        <member name="M:Ogre.MemoryDataStream.close">
@copydoc DataStream::close

</member>
        <member name="M:Ogre.MemoryDataStream.eof">
@copydoc DataStream::eof

</member>
        <member name="M:Ogre.MemoryDataStream.tell">
@copydoc DataStream::tell

</member>
        <member name="M:Ogre.MemoryDataStream.seek(System.UInt32)">
@copydoc DataStream::seek

</member>
        <member name="M:Ogre.MemoryDataStream.skip(System.Int32!System.Runtime.CompilerServices.IsLong)">
@copydoc DataStream::skip

</member>
        <member name="M:Ogre.MemoryDataStream.skipLine(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc DataStream::skipLine

</member>
        <member name="M:Ogre.MemoryDataStream.readLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@copydoc DataStream::readLine

</member>
        <member name="M:Ogre.MemoryDataStream.write(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
@copydoc DataStream::write

</member>
        <member name="M:Ogre.MemoryDataStream.read(System.Void*,System.UInt32)">
@copydoc DataStream::read

</member>
        <member name="M:Ogre.MemoryDataStream.getCurrentPtr">
Get a pointer to the current position in the memory block this stream holds. 
</member>
        <member name="M:Ogre.MemoryDataStream.getPtr">
Get a pointer to the start of the memory block this stream holds. 
</member>
        <member name="M:Ogre.MemoryDataStream.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.Boolean,System.Boolean)">
Create a named stream with a brand new empty memory chunk.
		@param name The name to give the stream
		@param size The size of the memory chunk to create in bytes
		@param freeOnClose If true, the memory associated will be destroyed
			when the stream is destroyed.
		@param readOnly Whether to make the stream on this memory read-only once created

</member>
        <member name="M:Ogre.MemoryDataStream.#ctor(System.UInt32,System.Boolean,System.Boolean)">
Create a stream with a brand new empty memory chunk.
		@param size The size of the memory chunk to create in bytes
		@param freeOnClose If true, the memory associated will be destroyed
			when the stream is destroyed.
		@param readOnly Whether to make the stream on this memory read-only once created

</member>
        <member name="M:Ogre.MemoryDataStream.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.SharedPtr&lt;Ogre.DataStream&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
Create a named stream which pre-buffers the contents of 
        another stream.
        @remarks
        This constructor can be used to intentionally read in the entire
        contents of another stream, copying them to the internal buffer
        and thus making them available in memory as a single unit.
        @param name The name to give the stream
        @param sourceStream Another DataStream which will provide the source
        of data
        @param freeOnClose If true, the memory associated will be destroyed
        when the stream is destroyed.
		@param readOnly Whether to make the stream on this memory read-only once created

</member>
        <member name="M:Ogre.MemoryDataStream.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.DataStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
Create a named stream which pre-buffers the contents of 
			another stream.
		@remarks
			This constructor can be used to intentionally read in the entire
			contents of another stream, copying them to the internal buffer
			and thus making them available in memory as a single unit.
		@param name The name to give the stream
		@param sourceStream Another DataStream which will provide the source
			of data
		@param freeOnClose If true, the memory associated will be destroyed
			when the stream is destroyed.
		@param readOnly Whether to make the stream on this memory read-only once created

</member>
        <member name="M:Ogre.MemoryDataStream.#ctor(Ogre.SharedPtr&lt;Ogre.DataStream&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
Create a stream which pre-buffers the contents of another stream.
		@remarks
			This constructor can be used to intentionally read in the entire
			contents of another stream, copying them to the internal buffer
			and thus making them available in memory as a single unit.
		@param sourceStream Weak reference to another DataStream which will provide the source
			of data
		@param freeOnClose If true, the memory associated will be destroyed
			when the stream is destroyed.
		@param readOnly Whether to make the stream on this memory read-only once created

</member>
        <member name="M:Ogre.MemoryDataStream.#ctor(Ogre.DataStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
Create a stream which pre-buffers the contents of another stream.
		@remarks
			This constructor can be used to intentionally read in the entire
			contents of another stream, copying them to the internal buffer
			and thus making them available in memory as a single unit.
		@param sourceStream Another DataStream which will provide the source
			of data
		@param freeOnClose If true, the memory associated will be destroyed
			when the stream is destroyed.
		@param readOnly Whether to make the stream on this memory read-only once created

</member>
        <member name="M:Ogre.MemoryDataStream.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void*,System.UInt32,System.Boolean,System.Boolean)">
Wrap an existing memory chunk in a named stream.
		@param name The name to give the stream
		@param pMem Pointer to the existing memory
		@param size The size of the memory chunk in bytes
		@param freeOnClose If true, the memory associated will be destroyed
			when the stream is destroyed. Note: it's important that if you set
			this option to true, that you allocated the memory using OGRE_ALLOC_T
			with a category of MEMCATEGORY_GENERAL ensure the freeing of memory 
			matches up.
		@param readOnly Whether to make the stream on this memory read-only once created

</member>
        <member name="M:Ogre.MemoryDataStream.#ctor(System.Void*,System.UInt32,System.Boolean,System.Boolean)">
Wrap an existing memory chunk in a stream.
		@param pMem Pointer to the existing memory
		@param size The size of the memory chunk in bytes
		@param freeOnClose If true, the memory associated will be destroyed
			when the stream is destroyed. Note: it's important that if you set
			this option to true, that you allocated the memory using OGRE_ALLOC_T
			with a category of MEMCATEGORY_GENERAL ensure the freeing of memory 
			matches up.
		@param readOnly Whether to make the stream on this memory read-only once created

</member>
        <member name="F:Ogre.MemoryDataStream.mFreeOnClose">
Do we delete the memory on close
</member>
        <member name="F:Ogre.MemoryDataStream.mEnd">
Pointer to the end of the memory
</member>
        <member name="F:Ogre.MemoryDataStream.mPos">
Pointer to the current position in the memory
</member>
        <member name="F:Ogre.MemoryDataStream.mData">
Pointer to the start of the data area
</member>
        <member name="T:Ogre.MemoryDataStream">
Common subclass of DataStream for handling data from chunks of memory.

</member>
        <member name="D:Ogre.DataStreamListPtr">
Shared pointer to list of DataStream items
</member>
        <member name="D:Ogre.DataStreamList">
List of DataStream items
</member>
        <member name="D:Ogre.DataStreamPtr">
Shared pointer to allow data streams to be passed around without
		worrying about deallocation

</member>
        <member name="M:Ogre.DataStream.close">
Close the stream; this makes further operations invalid. 
</member>
        <member name="M:Ogre.DataStream.size">
Returns the total size of the data to be read from the stream, 
			or 0 if this is indeterminate for this stream. 

</member>
        <member name="M:Ogre.DataStream.eof">
Returns true if the stream has reached the end.

</member>
        <member name="M:Ogre.DataStream.tell">
Returns the current byte offset from beginning 
</member>
        <member name="M:Ogre.DataStream.seek(System.UInt32)">
Repositions the read point to a specified byte.

</member>
        <member name="M:Ogre.DataStream.skip(System.Int32!System.Runtime.CompilerServices.IsLong)">
Skip a defined number of bytes. This can also be a negative value, in which case
		the file pointer rewinds a defined number of bytes. 
</member>
        <member name="M:Ogre.DataStream.skipLine(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Skip a single line from the stream.
        @note
            If you used this function, you <b>must</b> open the stream in <b>binary mode</b>,
            otherwise, it'll produce unexpected results.
		@param delim The delimiter(s) to stop at
		@returns The number of bytes skipped

</member>
        <member name="M:Ogre.DataStream.getAsString">
Returns a String containing the entire stream. 
	    @remarks
		    This is a convenience method for text streams only, allowing you to 
		    retrieve a String object containing all the data in the stream.

</member>
        <member name="M:Ogre.DataStream.getLine(System.Boolean)">
Returns a String containing the next line of data, optionally 
		    trimmed for whitespace. 
	    @remarks
		    This is a convenience method for text streams only, allowing you to 
		    retrieve a String object containing the next line of data. The data
		    is read up to the next newline character and the result trimmed if
		    required.
        @note
            If you used this function, you <b>must</b> open the stream in <b>binary mode</b>,
            otherwise, it'll produce unexpected results.
	    @param 
		    trimAfter If true, the line is trimmed for whitespace (as in 
		    String.trim(true,true))

</member>
        <member name="M:Ogre.DataStream.readLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get a single line from the stream.
		@remarks
			The delimiter character is not included in the data
			returned, and it is skipped over so the next read will occur
			after it. The buffer contents will include a
			terminating character.
        @note
            If you used this function, you <b>must</b> open the stream in <b>binary mode</b>,
            otherwise, it'll produce unexpected results.
		@param buf Reference to a buffer pointer
		@param maxCount The maximum length of data to be read, excluding the terminating character
		@param delim The delimiter to stop at
		@returns The number of bytes read, excluding the terminating character

</member>
        <member name="M:Ogre.DataStream.write(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Write the requisite number of bytes from the stream (only applicable to 
			streams that are not read-only)
		@param buf Pointer to a buffer containing the bytes to write
		@param count Number of bytes to write
		@returns The number of bytes written

</member>
        <member name="M:Ogre.DataStream.read(System.Void*,System.UInt32)">
Read the requisite number of bytes from the stream, 
			stopping at the end of the file.
		@param buf Reference to a buffer pointer
		@param count Number of bytes to read
		@returns The number of bytes read

</member>
        <member name="M:Ogre.DataStream.isWriteable">
Reports whether this stream is writeable. 
</member>
        <member name="M:Ogre.DataStream.isReadable">
Reports whether this stream is readable. 
</member>
        <member name="M:Ogre.DataStream.getAccessMode">
Gets the access mode of the stream
</member>
        <member name="M:Ogre.DataStream.getName">
Returns the name of the stream, if it has one.
</member>
        <member name="M:Ogre.DataStream.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16)">
Constructor for creating named streams
</member>
        <member name="M:Ogre.DataStream.#ctor(System.UInt16)">
Constructor for creating unnamed streams
</member>
        <member name="F:Ogre.DataStream.mAccess">
What type of access is allowed (AccessMode)
</member>
        <member name="F:Ogre.DataStream.mSize">
Size of the data in the stream (may be 0 if size cannot be determined)
</member>
        <member name="F:Ogre.DataStream.mName">
The name (e.g. resource name) that can be used to identify the source fot his data (optional)
</member>
        <member name="T:Ogre.DataStream">
\addtogroup Core
	*  @{

\addtogroup Resources
	*  @{

General purpose class used for encapsulating the reading and writing of data.
	@remarks
		This class performs basically the same tasks as std::basic_istream, 
		except that it does not have any formatting capabilities, and is
		designed to be subclassed to receive data from multiple sources,
		including libraries which have no compatibility with the STL's
		stream interfaces. As such, this is an abstraction of a set of 
		wrapper classes which pretend to be standard stream classes but 
		can actually be implemented quite differently. 
	@par
		Generally, if a plugin or application provides an ArchiveFactory, 
		it should also provide a DataStream subclass which will be used
		to stream data out of that Archive implementation, unless it can 
		use one of the common implementations included.
	@note
		Ogre makes no guarantees about thread safety, for performance reasons.
		If you wish to access stream data asynchronously then you should
		organise your own mutexes to avoid race conditions. 

</member>
        <member name="M:Ogre.Animation.buildKeyFrameTimeList">
Internal method to build global keyframe time list
</member>
        <member name="F:Ogre.Animation.mKeyFrameTimesDirty">
Dirty flag indicate that keyframe time list need to rebuild
</member>
        <member name="D:Ogre.Animation.KeyFrameTimeList">
Global keyframe time list used to search global keyframe index.
</member>
        <member name="F:Ogre.Animation.mVertexTrackList">
Vertex tracks, indexed by handle
</member>
        <member name="F:Ogre.Animation.mNumericTrackList">
Numeric tracks, indexed by handle
</member>
        <member name="F:Ogre.Animation.mNodeTrackList">
Node tracks, indexed by handle
</member>
        <member name="M:Ogre.Animation._getTimeIndex(System.Single)">
Internal method used to convert time position to time index object.
        @note
            The time index returns by this function are associated with state of
            the animation object, if the animation object altered (e.g. create/remove
            keyframe or track), all related time index will invalidated.
        @param timePos The time position.
        @returns The time index object which contains wrapped time position (in
            relation to the whole animation sequence) and lower bound index of
            global keyframe time list.

</member>
        <member name="M:Ogre.Animation._keyFrameListChanged">
Internal method used to tell the animation that keyframe list has been
            changed, which may cause it to rebuild some internal data 
</member>
        <member name="M:Ogre.Animation.clone(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Clone this animation.
		@note
			The pointer returned from this method is the only one recorded, 
			thus it is up to the caller to arrange for the deletion of this
			object.

</member>
        <member name="M:Ogre.Animation._destroyNodeTracks(std.set&lt;System.UInt16,std.less&lt;System.UInt16&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for destroy given node tracks.

</member>
        <member name="M:Ogre.Animation._collectIdentityNodeTracks(std.set&lt;System.UInt16,std.less&lt;System.UInt16&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for collecting identity node tracks.
        @remarks
            This method remove non-identity node tracks form the track handle list.
        @param
            tracks A list of track handle of non-identity node tracks, where this
            method will remove non-identity node track handles.

</member>
        <member name="D:Ogre.Animation.TrackHandleList">
A list of track handles
</member>
        <member name="M:Ogre.Animation.optimise(System.Boolean)">
Optimise an animation by removing unnecessary tracks and keyframes.
		@remarks
			When you export an animation, it is possible that certain tracks
			have been keyframed but actually don't include anything useful - the
			keyframes include no transformation. These tracks can be completely
			eliminated from the animation and thus speed up the animation. 
			In addition, if several keyframes in a row have the same value, 
			then they are just adding overhead and can be removed.
        @note
            Since track-less and identity track has difference behavior for
            accumulate animation blending if corresponding track presenting at
            other animation that is non-identity, and in normally this method
            didn't known about the situation of other animation, it can't deciding
            whether or not discards identity tracks. So there have a parameter
            allow you choose what you want, in case you aren't sure how to do that,
            you should use Skeleton::optimiseAllAnimations instead.
        @param
            discardIdentityNodeTracks If true, discard identity node tracks.

</member>
        <member name="M:Ogre.Animation.getVertexTrackIterator">
Get non-updateable iterator over node tracks
</member>
        <member name="M:Ogre.Animation._getVertexTrackList">
Fast access to NON-UPDATEABLE Vertex track list
</member>
        <member name="M:Ogre.Animation.getNumericTrackIterator">
Get non-updateable iterator over node tracks
</member>
        <member name="M:Ogre.Animation._getNumericTrackList">
Fast access to NON-UPDATEABLE numeric track list
</member>
        <member name="M:Ogre.Animation.getNodeTrackIterator">
Get non-updateable iterator over node tracks
</member>
        <member name="M:Ogre.Animation._getNodeTrackList">
Fast access to NON-UPDATEABLE node track list
</member>
        <member name="M:Ogre.Animation.getDefaultRotationInterpolationMode">
Gets the default rotation interpolation mode for all animations. 
</member>
        <member name="M:Ogre.Animation.setDefaultRotationInterpolationMode(Ogre.Animation.RotationInterpolationMode)">
Sets the default rotation interpolation mode. 
        @remarks
            Every animation created after this option is set will have the new interpolation
            mode specified. You can also change the mode per animation by calling the 
            setInterpolationMode method on the instance in question.

</member>
        <member name="M:Ogre.Animation.getDefaultInterpolationMode">
Gets the default interpolation mode for all animations. 
</member>
        <member name="M:Ogre.Animation.setDefaultInterpolationMode(Ogre.Animation.InterpolationMode)">
Sets the default animation interpolation mode. 
        @remarks
            Every animation created after this option is set will have the new interpolation
            mode specified. You can also change the mode per animation by calling the 
            setInterpolationMode method on the instance in question.

</member>
        <member name="M:Ogre.Animation.getRotationInterpolationMode">
Gets the current rotation interpolation mode of this animation. 
        @remarks
            See setRotationInterpolationMode for more info.

</member>
        <member name="M:Ogre.Animation.setRotationInterpolationMode(Ogre.Animation.RotationInterpolationMode)">
Tells the animation how to interpolate rotations.
        @remarks
            By default, animations interpolate linearly between rotations. This
            is fast but not necessarily completely accurate. If you want more 
            accurate interpolation, use spherical interpolation, but be aware 
            that it will incur a higher cost.
        @par
            You can also change the default rotation behaviour by calling 
            Animation::setDefaultRotationInterpolationMode.

</member>
        <member name="M:Ogre.Animation.getInterpolationMode">
Gets the current interpolation mode of this animation. 
        @remarks
            See setInterpolationMode for more info.

</member>
        <member name="M:Ogre.Animation.setInterpolationMode(Ogre.Animation.InterpolationMode)">
Tells the animation how to interpolate between keyframes.
        @remarks
            By default, animations normally interpolate linearly between keyframes. This is
            fast, but when animations include quick changes in direction it can look a little
            unnatural because directions change instantly at keyframes. An alternative is to
            tell the animation to interpolate along a spline, which is more expensive in terms
            of calculation time, but looks smoother because major changes in direction are 
            distributed around the keyframes rather than just at the keyframe.
        @par
            You can also change the default animation behaviour by calling 
            Animation::setDefaultInterpolationMode.

</member>
        <member name="M:Ogre.Animation.applyToVertexData(Ogre.VertexData*,System.Single,System.Single)">
Applies all vertex tracks given a specific time point and weight to the specified vertex data.
        @remarks
            It does not apply to the actual attached vertex data but rather uses all tracks for a given vertex data.
        @param timePos The time position in the animation to apply.
        @param weight The influence to give to this track, 1.0 for full influence, less to blend with
          other animations.

</member>
        <member name="M:Ogre.Animation.applyToAnimable(Ogre.SharedPtr&lt;Ogre.AnimableValue&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single)">
Applies all numeric tracks given a specific time point and weight to the specified animable value.
        @remarks
            It does not applies to actual attached animable values but rather uses all tracks for a single animable value.
        @param timePos The time position in the animation to apply.
        @param weight The influence to give to this track, 1.0 for full influence, less to blend with
          other animations.
	    @param scale The scale to apply to translations and scalings, useful for 
			adapting an animation to a different size target.

</member>
        <member name="M:Ogre.Animation.apply(Ogre.Entity*,System.Single,System.Single,System.Boolean,System.Boolean)">
Applies all vertex tracks given a specific time point and weight to a given entity.
		@remarks
		@param entity The Entity to which this animation should be applied
		@param timePos The time position in the animation to apply.
		@param weight The weight at which the animation should be applied 
			(only affects pose animation)
		@param software Whether to populate the software morph vertex data
		@param hardware Whether to populate the hardware morph vertex data

</member>
        <member name="M:Ogre.Animation.apply(Ogre.Skeleton*,System.Single,System.Single,std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*,System.Single)">
Applies all node tracks given a specific time point and weight to a given skeleton.
        @remarks
        Where you have associated animation tracks with Node objects, you can easily apply
        an animation to those nodes by calling this method.
        @param timePos The time position in the animation to apply.
        @param weight The influence to give to this track, 1.0 for full influence, less to blend with
        other animations.
        @param blendMask The influence array defining additional per bone weights. These will
        be modulated with the weight factor.
        @param scale The scale to apply to translations and scalings, useful for 
        adapting an animation to a different size target.

</member>
        <member name="M:Ogre.Animation.apply(Ogre.Skeleton*,System.Single,System.Single,System.Single)">
Applies all node tracks given a specific time point and weight to a given skeleton.
        @remarks
        Where you have associated animation tracks with Node objects, you can easily apply
        an animation to those nodes by calling this method.
        @param timePos The time position in the animation to apply.
        @param weight The influence to give to this track, 1.0 for full influence, less to blend with
        other animations.
	    @param scale The scale to apply to translations and scalings, useful for 
			adapting an animation to a different size target.

</member>
        <member name="M:Ogre.Animation.applyToNode(Ogre.Node*,System.Single,System.Single,System.Single)">
Applies all node tracks given a specific time point and weight to the specified node.
        @remarks
            It does not consider the actual node tracks are attached to.
			As such, it resembles the apply method for a given skeleton (see below).
        @param timePos The time position in the animation to apply.
        @param weight The influence to give to this track, 1.0 for full influence, less to blend with
          other animations.
	    @param scale The scale to apply to translations and scalings, useful for 
			adapting an animation to a different size target.

</member>
        <member name="M:Ogre.Animation.apply(System.Single,System.Single,System.Single)">
Applies an animation given a specific time point and weight.
        @remarks
            Where you have associated animation tracks with objects, you can easily apply
            an animation to those objects by calling this method.
        @param timePos The time position in the animation to apply.
        @param weight The influence to give to this track, 1.0 for full influence, less to blend with
          other animations.
	    @param scale The scale to apply to translations and scalings, useful for 
			adapting an animation to a different size target.

</member>
        <member name="M:Ogre.Animation.destroyAllVertexTracks">
Removes and destroys all tracks making up this animation. 
</member>
        <member name="M:Ogre.Animation.destroyAllNumericTracks">
Removes and destroys all tracks making up this animation. 
</member>
        <member name="M:Ogre.Animation.destroyAllNodeTracks">
Removes and destroys all tracks making up this animation. 
</member>
        <member name="M:Ogre.Animation.destroyAllTracks">
Removes and destroys all tracks making up this animation. 
</member>
        <member name="M:Ogre.Animation.destroyVertexTrack(System.UInt16)">
Destroys the Vertex track with the given handle. 
</member>
        <member name="M:Ogre.Animation.destroyNumericTrack(System.UInt16)">
Destroys the numeric track with the given handle. 
</member>
        <member name="M:Ogre.Animation.destroyNodeTrack(System.UInt16)">
Destroys the node track with the given handle. 
</member>
        <member name="M:Ogre.Animation.hasVertexTrack(System.UInt16)">
Does a track exist with the given handle? 
</member>
        <member name="M:Ogre.Animation.getVertexTrack(System.UInt16)">
Gets a Vertex track by it's handle. 
</member>
        <member name="M:Ogre.Animation.getNumVertexTracks">
Gets the number of VertexAnimationTrack objects contained in this animation. 
</member>
        <member name="M:Ogre.Animation.hasNumericTrack(System.UInt16)">
Does a track exist with the given handle? 
</member>
        <member name="M:Ogre.Animation.getNumericTrack(System.UInt16)">
Gets a numeric track by it's handle. 
</member>
        <member name="M:Ogre.Animation.getNumNumericTracks">
Gets the number of NumericAnimationTrack objects contained in this animation. 
</member>
        <member name="M:Ogre.Animation.hasNodeTrack(System.UInt16)">
Does a track exist with the given handle? 
</member>
        <member name="M:Ogre.Animation.getNodeTrack(System.UInt16)">
Gets a node track by it's handle. 
</member>
        <member name="M:Ogre.Animation.getNumNodeTracks">
Gets the number of NodeAnimationTrack objects contained in this animation. 
</member>
        <member name="M:Ogre.Animation.createVertexTrack(System.UInt16,Ogre.VertexData*,Ogre.VertexAnimationType)">
Creates a VertexAnimationTrack and associates it with VertexData. 
		@param handle Handle to give the track, used for accessing the track later. 
		@param data VertexData object link
		@param animType The animation type 
		Must be unique within this Animation.

</member>
        <member name="M:Ogre.Animation.createNumericTrack(System.UInt16,Ogre.SharedPtr&lt;Ogre.AnimableValue&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a NumericAnimationTrack and associates it with an animable. 
		@param handle Handle to give the track, used for accessing the track later. 
		@param anim Animable object link
		Must be unique within this Animation.

</member>
        <member name="M:Ogre.Animation.createNodeTrack(System.UInt16,Ogre.Node*)">
Creates a new AnimationTrack automatically associated with a Node. 
        @remarks
            This method creates a standard AnimationTrack, but also associates it with a
            target Node which will receive all keyframe effects.
        @param handle Numeric handle to give the track, used for accessing the track later. 
            Must be unique within this Animation.
        @param node A pointer to the Node object which will be affected by this track

</member>
        <member name="M:Ogre.Animation.createVertexTrack(System.UInt16,Ogre.VertexAnimationType)">
Creates a VertexAnimationTrack for animating vertex position data.
		@param handle Handle to give the track, used for accessing the track later. 
		Must be unique within this Animation, and is used to identify the target. For example
		when applied to a Mesh, the handle must reference the index of the geometry being 
		modified; 0 for the shared geometry, and 1+ for SubMesh geometry with the same index-1.
		@param animType Either morph or pose animation, 

</member>
        <member name="M:Ogre.Animation.createNumericTrack(System.UInt16)">
Creates a NumericAnimationTrack for animating any numeric value.
		@param handle Handle to give the track, used for accessing the track later. 
		Must be unique within this Animation.

</member>
        <member name="M:Ogre.Animation.createNodeTrack(System.UInt16)">
Creates a NodeAnimationTrack for animating a Node.
        @param handle Handle to give the track, used for accessing the track later. 
            Must be unique within this Animation.

</member>
        <member name="M:Ogre.Animation.setLength(System.Single)">
Sets the length of the animation. 
		@note Changing the length of an animation may invalidate existing AnimationState
		instances which will need to be recreated. 

</member>
        <member name="M:Ogre.Animation.getLength">
Gets the total length of the animation. 
</member>
        <member name="M:Ogre.Animation.getName">
Gets the name of this animation. 
</member>
        <member name="M:Ogre.Animation.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
You should not use this constructor directly, use the parent object such as Skeleton instead.
        @param name The name of the animation, should be unique within it's parent (e.g. Skeleton)
        @param length The length of the animation in seconds.

</member>
        <member name="F:RIM_SPHERICAL">
Values are interpolated spherically. This is more accurate but
                has a higher cost.

</member>
        <member name="F:RIM_LINEAR">
Values are interpolated linearly. This is faster but does not 
                necessarily give a completely accurate result.

</member>
        <member name="T:Ogre.Animation.RotationInterpolationMode">
The types of rotational interpolation available. 
</member>
        <member name="F:IM_SPLINE">
Values are interpolated along a spline, resulting in smoother changes in direction. 
</member>
        <member name="F:IM_LINEAR">
Values are interpolated along straight lines. 
</member>
        <member name="T:Ogre.Animation.InterpolationMode">
The types of animation interpolation available. 
</member>
        <member name="T:Ogre.Animation">
\addtogroup Core
	*  @{

\addtogroup Animation
	*  @{

An animation sequence. 
    @remarks
        This class defines the interface for a sequence of animation, whether that
        be animation of a mesh, a path along a spline, or possibly more than one
        type of animation in one. An animation is made up of many 'tracks', which are
        the more specific types of animation.
    @par
        You should not create these animations directly. They will be created via a parent
        object which owns the animation, e.g. Skeleton.

</member>
        <member name="M:Ogre.AnimationStateControllerValue.setValue(System.Single)">
ControllerValue implementation. 
</member>
        <member name="M:Ogre.AnimationStateControllerValue.getValue">
ControllerValue implementation. 
</member>
        <member name="M:Ogre.AnimationStateControllerValue.Dispose">
Destructor (parent already virtual)
</member>
        <member name="M:Ogre.AnimationStateControllerValue.#ctor(Ogre.AnimationState*)">
Constructor, pass in the target animation state. 
</member>
        <member name="T:Ogre.AnimationStateControllerValue">
ControllerValue wrapper class for AnimationState.
	@remarks
		In Azathoth and earlier, AnimationState was a ControllerValue but this
		actually causes memory problems since Controllers delete their values
		automatically when there are no further references to them, but AnimationState
		is deleted explicitly elsewhere so this causes double-free problems.
		This wrapper acts as a bridge and it is this which is destroyed automatically.

</member>
        <member name="M:Ogre.AnimationStateSet.getEnabledAnimationStateIterator">
Get an iterator over all the enabled animation states in this set
		@note
			The iterator returned from this method is not threadsafe,
			you will need to manually lock the public mutex on this
			class to ensure thread safety if you need it.

</member>
        <member name="M:Ogre.AnimationStateSet.hasEnabledAnimationState">
Tests if exists enabled animation state in this set
</member>
        <member name="M:Ogre.AnimationStateSet._notifyAnimationStateEnabled(Ogre.AnimationState*,System.Boolean)">
Internal method respond to enable/disable an animation state
</member>
        <member name="M:Ogre.AnimationStateSet.getDirtyFrameNumber">
Get the latest animation state been altered frame number
</member>
        <member name="M:Ogre.AnimationStateSet._notifyDirty">
Set the dirty flag and dirty frame number on this state set
</member>
        <member name="M:Ogre.AnimationStateSet.copyMatchingState(Ogre.AnimationStateSet*)">
Copy the state of any matching animation states from this to another
</member>
        <member name="M:Ogre.AnimationStateSet.getAnimationStateIterator">
Get an iterator over all the animation states in this set.
		@note
			The iterator returned from this method is not threadsafe,
			you will need to manually lock the public mutex on this
			class to ensure thread safety if you need it.


Get an iterator over all the animation states in this set.
		@note
			The iterator returned from this method is not threadsafe,
			you will need to manually lock the public mutex on this
			class to ensure thread safety if you need it.

</member>
        <member name="M:Ogre.AnimationStateSet.removeAllAnimationStates">
Remove all animation states
</member>
        <member name="M:Ogre.AnimationStateSet.removeAnimationState(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Remove animation state with the given name
</member>
        <member name="M:Ogre.AnimationStateSet.hasAnimationState(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tests if state for the named animation is present
</member>
        <member name="M:Ogre.AnimationStateSet.getAnimationState(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get an animation state by the name of the animation
</member>
        <member name="M:Ogre.AnimationStateSet.createAnimationState(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single,System.Boolean)">
Create a new AnimationState instance. 
		@param animName The name of the animation
		@param timePos Starting time position
		@param length Length of the animation to play
		@param weight Weight to apply the animation with 
		@param enabled Whether the animation is enabled

</member>
        <member name="M:Ogre.AnimationStateSet.#ctor(Ogre.AnimationStateSet!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create an animation set by copying the contents of another
</member>
        <member name="M:Ogre.AnimationStateSet.#ctor">
Mutex, public for external locking if needed
Create a blank animation state set
</member>
        <member name="T:Ogre.AnimationStateSet">
Class encapsulating a set of AnimationState objects.

</member>
        <member name="F:Ogre.AnimationState.mBlendMask">
the blend mask (containing per bone weights)
</member>
        <member name="M:Ogre.AnimationState.getBlendMaskEntry(System.UInt32)">
get the weight for the bone identified by the given handle
</member>
        <member name="M:Ogre.AnimationState.setBlendMaskEntry(System.UInt32,System.Single)">
set the weight for the bone identified by the given handle
</member>
        <member name="M:Ogre.AnimationState.hasBlendMask">
return whether there is currently a valid blend mask set
</member>
        <member name="M:Ogre.AnimationState.getBlendMask">
get the current blend mask (const version, may be 0) 
</member>
        <member name="M:Ogre.AnimationState._setBlendMask(std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*)">
@brief set the blend mask
       *
       * @par The size of the array should match the number of entries the
       *      blend mask was created with.
       *
       * @par Stick to the setBlendMaskEntry method if you don't know exactly what you're doing.

</member>
        <member name="M:Ogre.AnimationState._setBlendMaskData(System.Single!System.Runtime.CompilerServices.IsConst*)">
@brief set the blend mask data (might be dangerous)
       *
       * @par The size of the array should match the number of entries the
       *      blend mask was created with.
       *
       * @par Stick to the setBlendMaskEntry method if you don't know exactly what you're doing.

</member>
        <member name="M:Ogre.AnimationState.destroyBlendMask">
destroy the currently set blend mask
</member>
        <member name="M:Ogre.AnimationState.createBlendMask(System.UInt32,System.Single)">
@brief create a new blend mask with the given number of entries
       *
       * In addition to assigning a single weight value to a skeletal animation,
       * it may be desirable to assign animation weights per bone using a 'blend mask'.
       *
       * @param blendMaskSizeHint 
       *   The number of bones of the skeleton owning this AnimationState.
	   * @param initialWeight
	   *   The value all the blend mask entries will be initialised with (negative to skip initialisation)

</member>
        <member name="M:Ogre.AnimationState.getParent">
Get the parent animation state set
</member>
        <member name="M:Ogre.AnimationState.copyStateFrom(Ogre.AnimationState!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copies the states from another animation state, preserving the animation name
        (unlike operator=) but copying everything else.
        @param animState Reference to animation state which will use as source.

</member>
        <member name="M:Ogre.AnimationState.getLoop">
Gets whether or not this animation loops            
</member>
        <member name="M:Ogre.AnimationState.setLoop(System.Boolean)">
Sets whether or not an animation loops at the start and end of
            the animation if the time continues to be altered.

</member>
        <member name="M:Ogre.AnimationState.op_Equality(Ogre.AnimationState!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Equality operator
</member>
        <member name="M:Ogre.AnimationState.setEnabled(System.Boolean)">
Sets whether this animation is enabled
</member>
        <member name="M:Ogre.AnimationState.getEnabled">
Returns true if this animation is currently enabled
</member>
        <member name="M:Ogre.AnimationState.hasEnded">
Returns true if the animation has reached the end and is not looping
</member>
        <member name="M:Ogre.AnimationState.addTime(System.Single)">
Modifies the time position, adjusting for animation length
        @remarks
            This method loops at the edges if animation looping is enabled.

</member>
        <member name="M:Ogre.AnimationState.setWeight(System.Single)">
Sets the weight (influence) of this animation
</member>
        <member name="M:Ogre.AnimationState.getWeight">
Gets the weight (influence) of this animation
</member>
        <member name="M:Ogre.AnimationState.setLength(System.Single)">
Sets the total length of this animation (may be shorter than whole animation)
</member>
        <member name="M:Ogre.AnimationState.getLength">
Gets the total length of this animation (may be shorter than whole animation)
</member>
        <member name="M:Ogre.AnimationState.setTimePosition(System.Single)">
Sets the time position for this animation
</member>
        <member name="M:Ogre.AnimationState.getTimePosition">
Gets the time position for this animation
</member>
        <member name="M:Ogre.AnimationState.getAnimationName">
Gets the name of the animation to which this state applies
</member>
        <member name="M:Ogre.AnimationState.Dispose">
Destructor - is here because class has virtual functions and some compilers 
			would whine if it won't exist.

</member>
        <member name="M:Ogre.AnimationState.#ctor(Ogre.AnimationStateSet*,Ogre.AnimationState!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructor to copy from an existing state with new parent
</member>
        <member name="M:Ogre.AnimationState.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AnimationStateSet*,System.Single,System.Single,System.Single,System.Boolean)">
Normal constructor with all params supplied
</member>
        <member name="D:Ogre.AnimationState.BoneBlendMask">
typedef for an array of float values used as a bone blend mask
</member>
        <member name="T:Ogre.AnimationState">
\addtogroup Core
	*  @{

\addtogroup Animation
	*  @{

Represents the state of an animation and the weight of it's influence. 
    @remarks
        Other classes can hold instances of this class to store the state of any animations
        they are using.

</member>
        <member name="M:Ogre.VertexAnimationTrack.applyPoseToVertexData(Ogre.Pose!System.Runtime.CompilerServices.IsConst*,Ogre.VertexData*,System.Single)">
Utility method for applying pose animation
</member>
        <member name="M:Ogre.VertexAnimationTrack.createKeyFrameImpl(System.Single)">
@copydoc AnimationTrack::createKeyFrameImpl
</member>
        <member name="F:Ogre.VertexAnimationTrack.mTargetMode">
Mode to apply
</member>
        <member name="F:Ogre.VertexAnimationTrack.mTargetVertexData">
Target to animate
</member>
        <member name="F:Ogre.VertexAnimationTrack.mAnimationType">
Animation type
</member>
        <member name="M:Ogre.VertexAnimationTrack._clone(Ogre.Animation*)">
Clone this track (internal use only) 
</member>
        <member name="M:Ogre.VertexAnimationTrack.optimise">
Optimise the current track by removing any duplicate keyframes. 
</member>
        <member name="M:Ogre.VertexAnimationTrack.hasNonZeroKeyFrames">
Method to determine if this track has any KeyFrames which are
		doing anything useful - can be used to determine if this track
		can be optimised out.

</member>
        <member name="M:Ogre.VertexAnimationTrack.getTargetMode">
Get the target mode
</member>
        <member name="M:Ogre.VertexAnimationTrack.setTargetMode(Ogre.VertexAnimationTrack.TargetMode)">
Set the target mode
</member>
        <member name="M:Ogre.VertexAnimationTrack.getAssociatedVertexData">
Gets the associated VertexData which this track will update. 
</member>
        <member name="M:Ogre.VertexAnimationTrack.setAssociatedVertexData(Ogre.VertexData*)">
Sets the associated VertexData which this track will update. 
</member>
        <member name="M:Ogre.VertexAnimationTrack.getVertexPoseKeyFrame(System.UInt16)">
Returns the pose KeyFrame at the specified index. 
</member>
        <member name="M:Ogre.VertexAnimationTrack.getVertexMorphKeyFrame(System.UInt16)">
Returns the morph KeyFrame at the specified index. 
</member>
        <member name="M:Ogre.VertexAnimationTrack.applyToVertexData(Ogre.VertexData*,Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,std.vector&lt;Ogre.Pose**&gt;!System.Runtime.CompilerServices.IsConst*)">
As the 'apply' method but applies to specified VertexData instead of 
			associated data. 
</member>
        <member name="M:Ogre.VertexAnimationTrack.apply(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single)">
@copydoc AnimationTrack::apply
</member>
        <member name="M:Ogre.VertexAnimationTrack.getInterpolatedKeyFrame(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame*)">
This method in fact does nothing, since interpolation is not performed
			inside the keyframes for this type of track. 

</member>
        <member name="M:Ogre.VertexAnimationTrack.createVertexPoseKeyFrame(System.Single)">
Creates the single pose KeyFrame and adds it to this animation.

</member>
        <member name="M:Ogre.VertexAnimationTrack.createVertexMorphKeyFrame(System.Single)">
Creates a new morph KeyFrame and adds it to this animation at the given time index.
		@remarks
		It is better to create KeyFrames in time order. Creating them out of order can result 
		in expensive reordering processing. Note that a KeyFrame at time index 0.0 is always created
		for you, so you don't need to create this one, just access it using getKeyFrame(0);
		@param timePos The time from which this KeyFrame will apply.

</member>
        <member name="M:Ogre.VertexAnimationTrack.getAnimationType">
Get the type of vertex animation we're performing. 
</member>
        <member name="M:Ogre.VertexAnimationTrack.#ctor(Ogre.Animation*,System.UInt16,Ogre.VertexAnimationType,Ogre.VertexData*,Ogre.VertexAnimationTrack.TargetMode)">
Constructor, associates with target VertexData and temp buffer (for software)
</member>
        <member name="M:Ogre.VertexAnimationTrack.#ctor(Ogre.Animation*,System.UInt16,Ogre.VertexAnimationType)">
Constructor
</member>
        <member name="F:TM_HARDWARE">
Bind keyframe 1 to position, and keyframe 2 to a texture coordinate
				for interpolation in hardware 
</member>
        <member name="F:TM_SOFTWARE">
Interpolate vertex positions in software
</member>
        <member name="T:Ogre.VertexAnimationTrack.TargetMode">
The target animation mode 
</member>
        <member name="T:Ogre.VertexAnimationTrack">
Specialised AnimationTrack for dealing with changing vertex position information.
	@see VertexAnimationType

</member>
        <member name="T:Ogre.VertexAnimationType">
Type of vertex animation.
		Vertex animation comes in 2 types, morph and pose. The reason
		for the 2 types is that we have 2 different potential goals - to encapsulate
		a complete, flowing morph animation with multiple keyframes (a typical animation,
		but implemented by having snapshots of the vertex data at each keyframe), 
		or to represent a single pose change, for example a facial expression. 
		Whilst both could in fact be implemented using the same system, we choose
		to separate them since the requirements and limitations of each are quite
		different.
	@par
		Morph animation is a simple approach where we have a whole series of 
		snapshots of vertex data which must be interpolated, e.g. a running 
		animation implemented as morph targets. Because this is based on simple
		snapshots, it's quite fast to use when animating an entire mesh because 
		it's a simple linear change between keyframes. However, this simplistic 
		approach does not support blending between multiple morph animations. 
		If you need animation blending, you are advised to use skeletal animation
		for full-mesh animation, and pose animation for animation of subsets of 
		meshes or where skeletal animation doesn't fit - for example facial animation.
		For animating in a vertex shader, morph animation is quite simple and 
		just requires the 2 vertex buffers (one the original position buffer) 
		of absolute position data, and an interpolation factor. Each track in 
		a morph animation refrences a unique set of vertex data.
	@par
		Pose animation is more complex. Like morph animation each track references
		a single unique set of vertex data, but unlike morph animation, each 
		keyframe references 1 or more 'poses', each with an influence level. 
		A pose is a series of offsets to the base vertex data, and may be sparse - ie it
		may not reference every vertex. Because they're offsets, they can be 
		blended - both within a track and between animations. This set of features
		is very well suited to facial animation.
	@par
		For example, let's say you modelled a face (one set of vertex data), and 
		defined a set of poses which represented the various phonetic positions 
		of the face. You could then define an animation called 'SayHello', containing
		a single track which referenced the face vertex data, and which included 
		a series of keyframes, each of which referenced one or more of the facial 
		positions at different influence levels - the combination of which over
		time made the face form the shapes required to say the word 'hello'. Since
		the poses are only stored once, but can be referenced may times in 
		many animations, this is a very powerful way to build up a speech system.
	@par
		The downside of pose animation is that it can be more difficult to set up.
		Also, since it uses more buffers (one for the base data, and one for each
		active pose), if you're animating in hardware using vertex shaders you need
		to keep an eye on how many poses you're blending at once. You define a
		maximum supported number in your vertex program definition, see the 
		includes_pose_animation material script entry. 
	@par
		So, by partitioning the vertex animation approaches into 2, we keep the
		simple morph technique easy to use, whilst still allowing all 
		the powerful techniques to be used. Note that morph animation cannot
		be blended with other types of vertex animation (pose animation or other
		morph animation); pose animation can be blended with other pose animation
		though, and both types can be combined with skeletal animation. Also note
		that all morph animation can be expressed as pose animation, but not vice
		versa.

</member>
        <member name="F:VAT_POSE">
Pose animation is made up of a single delta pose keyframe
</member>
        <member name="F:VAT_MORPH">
Morph animation is made up of many interpolated snapshot keyframes
</member>
        <member name="F:VAT_NONE">
No animation
</member>
        <member name="F:Ogre.NodeAnimationTrack.mUseShortestRotationPath">
Defines if rotation is done using shortest path
</member>
        <member name="M:Ogre.NodeAnimationTrack.createKeyFrameImpl(System.Single)">
Specialised keyframe creation
</member>
        <member name="M:Ogre.NodeAnimationTrack._clone(Ogre.Animation*)">
Clone this track (internal use only) 
</member>
        <member name="M:Ogre.NodeAnimationTrack.optimise">
Optimise the current track by removing any duplicate keyframes. 
</member>
        <member name="M:Ogre.NodeAnimationTrack.hasNonZeroKeyFrames">
Method to determine if this track has any KeyFrames which are
			doing anything useful - can be used to determine if this track
			can be optimised out.

</member>
        <member name="M:Ogre.NodeAnimationTrack.getNodeKeyFrame(System.UInt16)">
Returns the KeyFrame at the specified index. 
</member>
        <member name="M:Ogre.NodeAnimationTrack._keyFrameDataChanged">
@copydoc AnimationTrack::_keyFrameDataChanged
</member>
        <member name="M:Ogre.NodeAnimationTrack.apply(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single)">
@copydoc AnimationTrack::apply
</member>
        <member name="M:Ogre.NodeAnimationTrack.getInterpolatedKeyFrame(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame*)">
@copydoc AnimationTrack::getInterpolatedKeyFrame
</member>
        <member name="M:Ogre.NodeAnimationTrack.getUseShortestRotationPath">
Gets the method of rotation calculation 
</member>
        <member name="M:Ogre.NodeAnimationTrack.setUseShortestRotationPath(System.Boolean)">
Sets the method of rotation calculation 
</member>
        <member name="M:Ogre.NodeAnimationTrack.applyToNode(Ogre.Node*,Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single)">
As the 'apply' method but applies to a specified Node instead of associated node. 
</member>
        <member name="M:Ogre.NodeAnimationTrack.setAssociatedNode(Ogre.Node*)">
Sets the associated Node object which will be automatically affected by calls to 'apply'. 
</member>
        <member name="M:Ogre.NodeAnimationTrack.getAssociatedNode">
Returns a pointer to the associated Node object (if any). 
</member>
        <member name="M:Ogre.NodeAnimationTrack.createNodeKeyFrame(System.Single)">
Creates a new KeyFrame and adds it to this animation at the given time index.
        @remarks
            It is better to create KeyFrames in time order. Creating them out of order can result 
            in expensive reordering processing. Note that a KeyFrame at time index 0.0 is always created
            for you, so you don't need to create this one, just access it using getKeyFrame(0);
        @param timePos The time from which this KeyFrame will apply.

</member>
        <member name="M:Ogre.NodeAnimationTrack.Dispose">
Destructor
</member>
        <member name="M:Ogre.NodeAnimationTrack.#ctor(Ogre.Animation*,System.UInt16,Ogre.Node*)">
Constructor, associates with a Node
</member>
        <member name="M:Ogre.NodeAnimationTrack.#ctor(Ogre.Animation*,System.UInt16)">
Constructor
</member>
        <member name="T:Ogre.NodeAnimationTrack">
Specialised AnimationTrack for dealing with node transforms.

</member>
        <member name="M:Ogre.NumericAnimationTrack.createKeyFrameImpl(System.Single)">
@copydoc AnimationTrack::createKeyFrameImpl
</member>
        <member name="F:Ogre.NumericAnimationTrack.mTargetAnim">
Target to animate
</member>
        <member name="M:Ogre.NumericAnimationTrack._clone(Ogre.Animation*)">
Clone this track (internal use only) 
</member>
        <member name="M:Ogre.NumericAnimationTrack.getNumericKeyFrame(System.UInt16)">
Returns the KeyFrame at the specified index. 
</member>
        <member name="M:Ogre.NumericAnimationTrack.setAssociatedAnimable(Ogre.SharedPtr&lt;Ogre.AnimableValue&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the associated animable object which will be automatically 
			affected by calls to 'apply'. 
</member>
        <member name="M:Ogre.NumericAnimationTrack.getAssociatedAnimable">
Returns a pointer to the associated animable object (if any). 
</member>
        <member name="M:Ogre.NumericAnimationTrack.applyToAnimable(Ogre.SharedPtr&lt;Ogre.AnimableValue&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single)">
Applies an animation track to a given animable value.
		@param anim The AnimableValue to which to apply the animation
        @param timeIndex The time position in the animation to apply.
        @param weight The influence to give to this track, 1.0 for full influence, less to blend with
          other animations.
	    @param scale The scale to apply to translations and scalings, useful for 
			adapting an animation to a different size target.

</member>
        <member name="M:Ogre.NumericAnimationTrack.apply(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single)">
@copydoc AnimationTrack::apply
</member>
        <member name="M:Ogre.NumericAnimationTrack.getInterpolatedKeyFrame(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame*)">
@copydoc AnimationTrack::getInterpolatedKeyFrame
</member>
        <member name="M:Ogre.NumericAnimationTrack.createNumericKeyFrame(System.Single)">
Creates a new KeyFrame and adds it to this animation at the given time index.
        @remarks
            It is better to create KeyFrames in time order. Creating them out of order can result 
            in expensive reordering processing. Note that a KeyFrame at time index 0.0 is always created
            for you, so you don't need to create this one, just access it using getKeyFrame(0);
        @param timePos The time from which this KeyFrame will apply.

</member>
        <member name="M:Ogre.NumericAnimationTrack.#ctor(Ogre.Animation*,System.UInt16,Ogre.SharedPtr&lt;Ogre.AnimableValue&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor, associates with an AnimableValue
</member>
        <member name="M:Ogre.NumericAnimationTrack.#ctor(Ogre.Animation*,System.UInt16)">
Constructor
</member>
        <member name="T:Ogre.NumericAnimationTrack">
Specialised AnimationTrack for dealing with generic animable values.

</member>
        <member name="M:Ogre.AnimationTrack.populateClone(Ogre.AnimationTrack*)">
Internal method for clone implementation
</member>
        <member name="M:Ogre.AnimationTrack.createKeyFrameImpl(System.Single)">
Create a keyframe implementation - must be overridden
</member>
        <member name="D:Ogre.AnimationTrack.KeyFrameIndexMap">
Map used to translate global keyframe time lower bound index to local lower bound index
</member>
        <member name="M:Ogre.AnimationTrack.getParent">
Returns the parent Animation object for this track. 
</member>
        <member name="M:Ogre.AnimationTrack.setListener(Ogre.AnimationTrack.Listener*)">
Set a listener for this track. 
</member>
        <member name="M:Ogre.AnimationTrack._buildKeyFrameIndexMap(std.vector&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method to build keyframe time index map to translate global lower
            bound index to local lower bound index. 
</member>
        <member name="M:Ogre.AnimationTrack._collectKeyFrameTimes(std.vector&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method to collect keyframe times, in unique, ordered format. 
</member>
        <member name="M:Ogre.AnimationTrack.optimise">
Optimise the current track by removing any duplicate keyframes. 
</member>
        <member name="M:Ogre.AnimationTrack.hasNonZeroKeyFrames">
Method to determine if this track has any KeyFrames which are
		doing anything useful - can be used to determine if this track
		can be optimised out.

</member>
        <member name="M:Ogre.AnimationTrack._keyFrameDataChanged">
Internal method used to tell the track that keyframe data has been 
            changed, which may cause it to rebuild some internal data. 
</member>
        <member name="M:Ogre.AnimationTrack.apply(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single)">
Applies an animation track to the designated target.
        @param timeIndex The time position in the animation to apply.
        @param weight The influence to give to this track, 1.0 for full influence, less to blend with
          other animations.
	    @param scale The scale to apply to translations and scalings, useful for 
			adapting an animation to a different size target.

</member>
        <member name="M:Ogre.AnimationTrack.getInterpolatedKeyFrame(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame*)">
Gets a KeyFrame object which contains the interpolated transforms at the time index specified.
        @remarks
            The KeyFrame objects held by this class are transformation snapshots at 
            discrete points in time. Normally however, you want to interpolate between these
            keyframes to produce smooth movement, and this method allows you to do this easily.
            In animation terminology this is called 'tweening'. 
        @param timeIndex The time (in relation to the whole animation sequence)
        @param kf Keyframe object to store results

</member>
        <member name="M:Ogre.AnimationTrack.removeAllKeyFrames">
Removes all the KeyFrames from this track. 
</member>
        <member name="M:Ogre.AnimationTrack.removeKeyFrame(System.UInt16)">
Removes a KeyFrame by it's index. 
</member>
        <member name="M:Ogre.AnimationTrack.createKeyFrame(System.Single)">
Creates a new KeyFrame and adds it to this animation at the given time index.
        @remarks
            It is better to create KeyFrames in time order. Creating them out of order can result 
            in expensive reordering processing. Note that a KeyFrame at time index 0.0 is always created
            for you, so you don't need to create this one, just access it using getKeyFrame(0);
        @param timePos The time from which this KeyFrame will apply.

</member>
        <member name="M:Ogre.AnimationTrack.getKeyFrame(System.UInt16)">
Returns the KeyFrame at the specified index. 
</member>
        <member name="M:Ogre.AnimationTrack.getNumKeyFrames">
Returns the number of keyframes in this animation. 
</member>
        <member name="M:Ogre.AnimationTrack.getHandle">
Get the handle associated with this track. 
</member>
        <member name="M:Ogre.AnimationTrack.#ctor(Ogre.Animation*,System.UInt16)">
Constructor
</member>
        <member name="M:Ogre.AnimationTrack.Listener.getInterpolatedKeyFrame(Ogre.AnimationTrack!System.Runtime.CompilerServices.IsConst*,Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame*)">
Get an interpolated keyframe for this track at the given time.
			@returns true if the KeyFrame was populated, false if not.

</member>
        <member name="T:Ogre.AnimationTrack.Listener">
Listener allowing you to override certain behaviour of a track, 
			for example to drive animation procedurally.

</member>
        <member name="T:Ogre.AnimationTrack">
A 'track' in an animation sequence, i.e. a sequence of keyframes which affect a
        certain type of animable object.
    @remarks
        This class is intended as a base for more complete classes which will actually
        animate specific types of object, e.g. a bone in a skeleton to affect
        skeletal animation. An animation will likely include multiple tracks each of which
        can be made up of many KeyFrame instances. Note that the use of tracks allows each animable
        object to have it's own number of keyframes, i.e. you do not have to have the
        maximum number of keyframes for all animable objects just to cope with the most
        animated one.
    @remarks
        Since the most common animable object is a Node, there are options in this class for associating
        the track with a Node which will receive keyframe updates automatically when the 'apply' method
        is called.
	@remarks
		By default rotation is done using shortest-path algorithm.
		It is possible to change this behaviour using
		setUseShortestRotationPath() method.

</member>
        <member name="M:Ogre.TimeIndex.#ctor(System.Single,System.UInt32)">
Construct time index object by the given time position and
            global keyframe index.
        @note In normally, you don't need to use this constructor directly, use
            Animation::_getTimeIndex instead.

</member>
        <member name="M:Ogre.TimeIndex.#ctor(System.Single)">
Construct time index object by the given time position.

</member>
        <member name="F:Ogre.TimeIndex.INVALID_KEY_INDEX">
Indicate it's an invalid global keyframe index.

</member>
        <member name="F:Ogre.TimeIndex.mKeyIndex">
The global keyframe index (in relation to the whole animation sequence)
            that used to convert to local keyframe index, or INVALID_KEY_INDEX which
            means global keyframe index unavailable, and then slight slow method will
            used to search local keyframe index.

</member>
        <member name="F:Ogre.TimeIndex.mTimePos">
The time position (in relation to the whole animation sequence)

</member>
        <member name="T:Ogre.TimeIndex">
\addtogroup Core
	*  @{

\addtogroup Animation
	*  @{

Time index object used to search keyframe at the given position.

</member>
        <member name="F:Ogre.Pose.mBuffer">
Derived hardware buffer, covers all vertices
</member>
        <member name="F:Ogre.Pose.mVertexOffsetMap">
Primary storage, sparse vertex use
</member>
        <member name="F:Ogre.Pose.mName">
Optional name
</member>
        <member name="F:Ogre.Pose.mTarget">
Target geometry index
</member>
        <member name="M:Ogre.Pose.clone">
Clone this pose and create another one configured exactly the same
			way (only really useful for cloning holders of this class).

</member>
        <member name="M:Ogre.Pose._getHardwareVertexBuffer(System.UInt32)">
Get a hardware vertex buffer version of the vertex offsets. 
</member>
        <member name="M:Ogre.Pose.getVertexOffsets">
Gets a const reference to the vertex offsets. 
</member>
        <member name="M:Ogre.Pose.getVertexOffsetIterator">
Gets an iterator over all the vertex offsets. 

Gets an iterator over all the vertex offsets. 
</member>
        <member name="M:Ogre.Pose.clearVertexOffsets">
Clear all vertex offsets. 
</member>
        <member name="M:Ogre.Pose.removeVertex(System.UInt32)">
Remove a vertex offset. 
</member>
        <member name="M:Ogre.Pose.addVertex(System.UInt32,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds an offset to a vertex for this pose. 
		@param index The vertex index
		@param offset The position offset for this pose

</member>
        <member name="D:Ogre.Pose.ConstVertexOffsetIterator">
An iterator over the vertex offsets
</member>
        <member name="D:Ogre.Pose.VertexOffsetIterator">
An iterator over the vertex offsets
</member>
        <member name="D:Ogre.Pose.VertexOffsetMap">
A collection of vertex offsets based on the vertex index
</member>
        <member name="M:Ogre.Pose.getTarget">
Return the target geometry index of the pose
</member>
        <member name="M:Ogre.Pose.getName">
Return the name of the pose (may be blank)
</member>
        <member name="M:Ogre.Pose.#ctor(System.UInt16,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor
			@param target The target vertexdata index (0 for shared, 1+ for 
				dedicated at the submesh index + 1)
			@param name Optional name

</member>
        <member name="T:Ogre.Pose">
\addtogroup Core
	*  @{

\addtogroup Animation
	*  @{

A pose is a linked set of vertex offsets applying to one set of vertex
		data. 
	@remarks
		The target index referred to by the pose has a meaning set by the user
		of this class; but for example when used by Mesh it refers to either the
		Mesh shared geometry (0) or a SubMesh dedicated geometry (1+).
		Pose instances can be referred to by keyframes in VertexAnimationTrack in
		order to animate based on blending poses together.

</member>
        <member name="M:Ogre.VertexPoseKeyFrame._clone(Ogre.AnimationTrack*)">
Clone a keyframe (internal use only) 
</member>
        <member name="M:Ogre.VertexPoseKeyFrame.getPoseReferenceIterator">
Get an iterator over the pose references. 

Get a const iterator over the pose references. 
</member>
        <member name="M:Ogre.VertexPoseKeyFrame.getPoseReferences">
Get a const reference to the list of pose references. 
</member>
        <member name="M:Ogre.VertexPoseKeyFrame.removeAllPoseReferences">
Remove all pose references. 
</member>
        <member name="M:Ogre.VertexPoseKeyFrame.removePoseReference(System.UInt16)">
Remove reference to a given pose. 
		@param poseIndex The pose index (not the index of the reference)

</member>
        <member name="M:Ogre.VertexPoseKeyFrame.updatePoseReference(System.UInt16,System.Single)">
Update the influence of a pose reference. 
		@see PoseRef

</member>
        <member name="M:Ogre.VertexPoseKeyFrame.addPoseReference(System.UInt16,System.Single)">
Add a new pose reference. 
		@see PoseRef

</member>
        <member name="F:Ogre.VertexPoseKeyFrame.PoseRef.influence">
Influence level of the linked pose. 
				1.0 for full influence (full offset), 0.0 for no influence.

</member>
        <member name="F:Ogre.VertexPoseKeyFrame.PoseRef.poseIndex">
The linked pose index.
			@remarks
				The Mesh contains all poses for all vertex data in one list, both 
				for the shared vertex data and the dedicated vertex data on submeshes.
				The 'target' on the parent track must match the 'target' on the 
				linked pose.

</member>
        <member name="T:Ogre.VertexPoseKeyFrame.PoseRef">
Reference to a pose at a given influence level 
		@remarks
			Each keyframe can refer to many poses each at a given influence level.
		*
</member>
        <member name="M:Ogre.VertexPoseKeyFrame.#ctor(Ogre.AnimationTrack!System.Runtime.CompilerServices.IsConst*,System.Single)">
Default constructor, you should not call this but use AnimationTrack::createKeyFrame instead. 
</member>
        <member name="T:Ogre.VertexPoseKeyFrame">
Specialised KeyFrame which references a Mesh::Pose at a certain influence
		level, which stores offsets for a subset of the vertices 
		in a buffer to provide a blendable pose.

</member>
        <member name="M:Ogre.VertexMorphKeyFrame._clone(Ogre.AnimationTrack*)">
Clone a keyframe (internal use only) 
</member>
        <member name="M:Ogre.VertexMorphKeyFrame.getVertexBuffer">
Gets the vertex buffer containing positions for this keyframe. 
</member>
        <member name="M:Ogre.VertexMorphKeyFrame.setVertexBuffer(Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the vertex buffer containing the source positions for this keyframe. 
		@remarks    
			We assume that positions are the first 3 float elements in this buffer,
			although we don't necessarily assume they're the only ones in there.
		@param buf Vertex buffer link; will not be modified so can be shared
			read-only data

</member>
        <member name="M:Ogre.VertexMorphKeyFrame.#ctor(Ogre.AnimationTrack!System.Runtime.CompilerServices.IsConst*,System.Single)">
Default constructor, you should not call this but use AnimationTrack::createKeyFrame instead. 
</member>
        <member name="T:Ogre.VertexMorphKeyFrame">
Specialised KeyFrame which stores absolute vertex positions for a complete
		buffer, designed to be interpolated with other keys in the same track. 

</member>
        <member name="M:Ogre.TransformKeyFrame._clone(Ogre.AnimationTrack*)">
Clone a keyframe (internal use only) 
</member>
        <member name="M:Ogre.TransformKeyFrame.getRotation">
Gets the rotation applied by this keyframe. 
</member>
        <member name="M:Ogre.TransformKeyFrame.setRotation(Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the rotation applied by this keyframe.
		@param rot The rotation applied; use Quaternion methods to convert from angle/axis or Matrix3 if
		you don't like using Quaternions directly.

</member>
        <member name="M:Ogre.TransformKeyFrame.getScale">
Gets the scaling factor applied by this keyframe. 
</member>
        <member name="M:Ogre.TransformKeyFrame.setScale(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the scaling factor applied by this keyframe to the animable
		object at it's time index.
		@param scale The vector to scale by (beware of supplying zero values for any component of this
		vector, it will scale the object to zero dimensions)

</member>
        <member name="M:Ogre.TransformKeyFrame.getTranslate">
Gets the translation applied by this keyframe. 
</member>
        <member name="M:Ogre.TransformKeyFrame.setTranslate(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the translation associated with this keyframe. 
		@remarks    
		The translation factor affects how much the keyframe translates (moves) it's animable
		object at it's time index.
		@param trans The vector to translate by

</member>
        <member name="M:Ogre.TransformKeyFrame.#ctor(Ogre.AnimationTrack!System.Runtime.CompilerServices.IsConst*,System.Single)">
Default constructor, you should not call this but use AnimationTrack::createKeyFrame instead. 
</member>
        <member name="T:Ogre.TransformKeyFrame">
Specialised KeyFrame which stores a full transform. 
</member>
        <member name="M:Ogre.NumericKeyFrame._clone(Ogre.AnimationTrack*)">
Clone a keyframe (internal use only) 
</member>
        <member name="M:Ogre.NumericKeyFrame.setValue(Ogre.AnyNumeric!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the value at this keyframe.
		@remarks
			All keyframe values must have a consistent type. 

</member>
        <member name="M:Ogre.NumericKeyFrame.getValue">
Get the value at this keyframe. 
</member>
        <member name="M:Ogre.NumericKeyFrame.#ctor(Ogre.AnimationTrack!System.Runtime.CompilerServices.IsConst*,System.Single)">
Default constructor, you should not call this but use AnimationTrack::createKeyFrame instead. 
</member>
        <member name="T:Ogre.NumericKeyFrame">
Specialised KeyFrame which stores any numeric value.

</member>
        <member name="M:Ogre.KeyFrame._clone(Ogre.AnimationTrack*)">
Clone a keyframe (internal use only) 
</member>
        <member name="M:Ogre.KeyFrame.getTime">
Gets the time of this keyframe in the animation sequence. 
</member>
        <member name="M:Ogre.KeyFrame.#ctor(Ogre.AnimationTrack!System.Runtime.CompilerServices.IsConst*,System.Single)">
Default constructor, you should not call this but use AnimationTrack::createKeyFrame instead. 
</member>
        <member name="T:Ogre.KeyFrame">
\addtogroup Core
	*  @{

\addtogroup Animation
	*  @{

A key frame in an animation sequence defined by an AnimationTrack.
    @remarks
        This class can be used as a basis for all kinds of key frames. 
        The unifying principle is that multiple KeyFrames define an 
        animation sequence, with the exact state of the animation being an 
        interpolation between these key frames. 

</member>
        <member name="M:Ogre.VertexBufferBinding.closeGaps(std.map&lt;System.UInt16,System.UInt16,std.less&lt;System.UInt16&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Remove any gaps in the bindings.
        @remarks
            This is useful if you've removed vertex buffer from this vertex buffer
            bindings and want to remove any gaps in the bindings. Note, however,
            that if this bindings is already being used with a VertexDeclaration,
            you will need to alter that too. This method is mainly useful when
            reorganising buffers manually.
        @param
            bindingIndexMap To be retrieve the binding index map that used to
            translation old index to new index; will be cleared by this method
            before fill-in.

</member>
        <member name="M:Ogre.VertexBufferBinding.hasGaps">
Check whether any gaps in the bindings.

</member>
        <member name="M:Ogre.VertexBufferBinding.getLastBoundIndex">
Gets the last bound index.

</member>
        <member name="M:Ogre.VertexBufferBinding.getNextIndex">
Gets the highest index which has already been set, plus 1.
		@remarks
			This is to assist in binding the vertex buffers such that there are
			not gaps in the list.

</member>
        <member name="M:Ogre.VertexBufferBinding.isBufferBound(System.UInt16)">
Gets whether a buffer is bound to the given source index
</member>
        <member name="M:Ogre.VertexBufferBinding.getBuffer(System.UInt16)">
Gets the buffer bound to the given source index
</member>
        <member name="M:Ogre.VertexBufferBinding.getBindings">
Gets a read-only version of the buffer bindings
</member>
        <member name="M:Ogre.VertexBufferBinding.unsetAllBindings">
Removes all the bindings. 
</member>
        <member name="M:Ogre.VertexBufferBinding.unsetBinding(System.UInt16)">
Removes an existing binding. 
</member>
        <member name="M:Ogre.VertexBufferBinding.setBinding(System.UInt16,Ogre.HardwareVertexBufferSharedPtr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set a binding, associating a vertex buffer with a given index.
		@remarks
			If the index is already associated with a vertex buffer,
            the association will be replaced. This may cause the old buffer
            to be destroyed if nothing else is referring to it.
			You should assign bindings from 0 and not leave gaps, although you can
			bind them in any order.

</member>
        <member name="M:Ogre.VertexBufferBinding.#ctor">
Constructor, should not be called direct, use HardwareBufferManager::createVertexBufferBinding
</member>
        <member name="D:Ogre.VertexBufferBinding.VertexBufferBindingMap">
Defines the vertex buffer bindings used as source for vertex declarations
</member>
        <member name="T:Ogre.VertexBufferBinding">
Records the state of all the vertex buffer bindings required to provide a vertex declaration
		with the input data it needs for the vertex elements.
	@remarks
		Why do we have this binding list rather than just have VertexElement referring to the
		vertex buffers direct? Well, in the underlying APIs, binding the vertex buffers to an
		index (or 'stream') is the way that vertex data is linked, so this structure better
		reflects the realities of that. In addition, by separating the vertex declaration from
		the list of vertex buffer bindings, it becomes possible to reuse bindings between declarations
		and vice versa, giving opportunities to reduce the state changes required to perform rendering.
	@par
		Like the other classes in this functional area, these binding maps should be created and
		destroyed using the HardwareBufferManager.

</member>
        <member name="M:Ogre.VertexDeclaration.clone(Ogre.HardwareBufferManagerBase*)">
Clones this declaration. 
		@param mgr Optional HardwareBufferManager to use for creating the clone
			(if null, use the current default).

</member>
        <member name="M:Ogre.VertexDeclaration.getVertexSize(System.UInt16)">
Gets the vertex size defined by this declaration for a given source. 
</member>
        <member name="M:Ogre.VertexDeclaration.findElementsBySource(System.UInt16)">
Based on the current elements, gets the size of the vertex for a given buffer source.
		@param source The buffer binding index for which to get the vertex size.

Gets a list of elements which use a given source.
		@remarks
			Note that the list of elements is returned by value therefore is separate from
			the declaration as soon as this method returns.

</member>
        <member name="M:Ogre.VertexDeclaration.findElementBySemantic(Ogre.VertexElementSemantic,System.UInt16)">
Finds a VertexElement with the given semantic, and index if there is more than
			one element with the same semantic.
        @remarks
            If the element is not found, this method returns null.

</member>
        <member name="M:Ogre.VertexDeclaration.modifyElement(System.UInt16,System.UInt16,System.UInt32,Ogre.VertexElementType,Ogre.VertexElementSemantic,System.UInt16)">
Modify an element in-place, params as addElement.
	   @remarks
	   <b>Please read the information in VertexDeclaration about
	    the importance of ordering and structure for compatibility with older D3D drivers</b>.

</member>
        <member name="M:Ogre.VertexDeclaration.removeAllElements">
Remove all elements. 
</member>
        <member name="M:Ogre.VertexDeclaration.removeElement(Ogre.VertexElementSemantic,System.UInt16)">
Remove the element with the given semantic and usage index.
        @remarks
            In this case 'index' means the usage index for repeating elements such
            as texture coordinates. For other elements this will always be 0 and does
            not refer to the index in the vector.

</member>
        <member name="M:Ogre.VertexDeclaration.removeElement(System.UInt16)">
Remove the element at the given index from this declaration. 
</member>
        <member name="M:Ogre.VertexDeclaration.insertElement(System.UInt16,System.UInt16,System.UInt32,Ogre.VertexElementType,Ogre.VertexElementSemantic,System.UInt16)">
Inserts a new VertexElement at a given position in this declaration.
        @remarks
        This method adds a single element (positions, normals etc) at a given position in this
        vertex declaration. <b>Please read the information in VertexDeclaration about
        the importance of ordering and structure for compatibility with older D3D drivers</b>.
        @param source The binding index of HardwareVertexBuffer which will provide the source for this element.
        See VertexBufferBindingState for full information.
        @param offset The offset in bytes where this element is located in the buffer
        @param theType The data format of the element (3 floats, a colour etc)
        @param semantic The meaning of the data (position, normal, diffuse colour etc)
        @param index Optional index for multi-input elements like texture coordinates
        @returns A reference to the VertexElement added.

</member>
        <member name="M:Ogre.VertexDeclaration.addElement(System.UInt16,System.UInt32,Ogre.VertexElementType,Ogre.VertexElementSemantic,System.UInt16)">
Adds a new VertexElement to this declaration.
        @remarks
            This method adds a single element (positions, normals etc) to the end of the
            vertex declaration. <b>Please read the information in VertexDeclaration about
	    the importance of ordering and structure for compatibility with older D3D drivers</b>.
	    @param source The binding index of HardwareVertexBuffer which will provide the source for this element.
			See VertexBufferBindingState for full information.
        @param offset The offset in bytes where this element is located in the buffer
        @param theType The data format of the element (3 floats, a colour etc)
        @param semantic The meaning of the data (position, normal, diffuse colour etc)
        @param index Optional index for multi-input elements like texture coordinates
		@returns A reference to the VertexElement added.

</member>
        <member name="M:Ogre.VertexDeclaration.getMaxSource">
Gets the index of the highest source value referenced by this declaration. 
</member>
        <member name="M:Ogre.VertexDeclaration.getAutoOrganisedDeclaration(System.Boolean,System.Boolean)">
Generates a new VertexDeclaration for optimal usage based on the current
            vertex declaration, which can be used with VertexData::reorganiseBuffers later
            if you wish, or simply used as a template.
		@remarks
			Different buffer organisations and buffer usages will be returned
            depending on the parameters passed to this method.
        @param skeletalAnimation Whether this vertex data is going to be
			skeletally animated
		@param vertexAnimation Whether this vertex data is going to be vertex animated

</member>
        <member name="M:Ogre.VertexDeclaration.closeGapsInSource">
Remove any gaps in the source buffer list used by this declaration.
        @remarks
            This is useful if you've modified a declaration and want to remove
            any gaps in the list of buffers being used. Note, however, that if this
            declaration is already being used with a VertexBufferBinding, you will
            need to alter that too. This method is mainly useful when reorganising
            buffers based on an altered declaration.
        @note
            This will cause the vertex declaration to be re-sorted.

</member>
        <member name="M:Ogre.VertexDeclaration.sort">
Sorts the elements in this list to be compatible with the maximum
            number of rendering APIs / graphics cards.
        @remarks
            Older graphics cards require vertex data to be presented in a more
            rigid way, as defined in the main documentation for this class. As well
            as the ordering being important, where shared source buffers are used, the
            declaration must list all the elements for each source in turn.

</member>
        <member name="M:Ogre.VertexDeclaration.getElement(System.UInt16)">
Get a single element. 
</member>
        <member name="M:Ogre.VertexDeclaration.getElements">
Gets read-only access to the list of vertex elements. 
</member>
        <member name="M:Ogre.VertexDeclaration.getElementCount">
Get the number of elements in the declaration. 
</member>
        <member name="M:Ogre.VertexDeclaration.#ctor">
Standard constructor, not you should use HardwareBufferManager::createVertexDeclaration
</member>
        <member name="M:Ogre.VertexDeclaration.vertexElementLess(Ogre.VertexElement!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.VertexElement!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sort routine for vertex elements
</member>
        <member name="D:Ogre.VertexDeclaration.VertexElementList">
Defines the list of vertex elements that makes up this declaration
</member>
        <member name="M:Ogre.VertexElement.baseVertexPointerToElement(System.Void*,System.UInt16**)">
Adjusts a pointer to the base of a vertex to point at this element.
        @remarks
        This variant is for ushort pointers, passed as a parameter because we can't
        rely on covariant return types.
        @param pBase Pointer to the start of a vertex in this buffer.
        @param pElem Pointer to a pointer which will be set to the start of this element.

</member>
        <member name="M:Ogre.VertexElement.baseVertexPointerToElement(System.Void*,System.Byte**)">
Adjusts a pointer to the base of a vertex to point at this element.
        @remarks
            This variant is for char pointers, passed as a parameter because we can't
            rely on covariant return types.
        @param pBase Pointer to the start of a vertex in this buffer.
        @param pElem Pointer to a pointer which will be set to the start of this element.

</member>
        <member name="M:Ogre.VertexElement.baseVertexPointerToElement(System.Void*,System.UInt32**)">
Adjusts a pointer to the base of a vertex to point at this element.
        @remarks
            This variant is for RGBA pointers, passed as a parameter because we can't
            rely on covariant return types.
        @param pBase Pointer to the start of a vertex in this buffer.
        @param pElem Pointer to a pointer which will be set to the start of this element.

</member>
        <member name="M:Ogre.VertexElement.baseVertexPointerToElement(System.Void*,System.Single**)">
Adjusts a pointer to the base of a vertex to point at this element.
        @remarks
            This variant is for float pointers, passed as a parameter because we can't
            rely on covariant return types.
        @param pBase Pointer to the start of a vertex in this buffer.
        @param pElem Pointer to a pointer which will be set to the start of this element.

</member>
        <member name="M:Ogre.VertexElement.baseVertexPointerToElement(System.Void*,System.Void**)">
Adjusts a pointer to the base of a vertex to point at this element.
        @remarks
            This variant is for void pointers, passed as a parameter because we can't
            rely on covariant return types.
        @param pBase Pointer to the start of a vertex in this buffer.
        @param pElem Pointer to a pointer which will be set to the start of this element.

</member>
        <member name="M:Ogre.VertexElement.getBestColourVertexElementType">
Utility method to get the most appropriate packed colour vertex element format. 
</member>
        <member name="M:Ogre.VertexElement.convertColourValue(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.VertexElementType)">
Utility method for converting colour to
			a packed 32-bit colour type.
		@param src source colour
		@param dst The destination type

</member>
        <member name="M:Ogre.VertexElement.convertColourValue(Ogre.VertexElementType,Ogre.VertexElementType,System.UInt32*)">
Utility method for converting colour from
			one packed 32-bit colour type to another.
		@param srcType The source type
		@param dstType The destination type
		@param ptr Read / write value to change

</member>
        <member name="M:Ogre.VertexElement.getBaseType(Ogre.VertexElementType)">
Simple converter function which will a type into it's single-value
			equivalent - makes switches on type easier.

</member>
        <member name="M:Ogre.VertexElement.multiplyTypeCount(Ogre.VertexElementType,System.UInt16)">
Simple converter function which will turn a single-value type into a
			multi-value type based on a parameter.

</member>
        <member name="M:Ogre.VertexElement.getTypeCount(Ogre.VertexElementType)">
Utility method which returns the count of values in a given type
</member>
        <member name="M:Ogre.VertexElement.getTypeSize(Ogre.VertexElementType)">
Utility method for helping to calculate offsets
</member>
        <member name="M:Ogre.VertexElement.getSize">
Gets the size of this element in bytes
</member>
        <member name="M:Ogre.VertexElement.getIndex">
Gets the index of this element, only applicable for repeating elements
</member>
        <member name="M:Ogre.VertexElement.getSemantic">
Gets the meaning of this element
</member>
        <member name="M:Ogre.VertexElement.getType">
Gets the data format of this element
</member>
        <member name="M:Ogre.VertexElement.getOffset">
Gets the offset into the buffer where this element starts
</member>
        <member name="M:Ogre.VertexElement.getSource">
Gets the vertex buffer index from where this element draws it's values
</member>
        <member name="M:Ogre.VertexElement.#ctor(System.UInt16,System.UInt32,Ogre.VertexElementType,Ogre.VertexElementSemantic,System.UInt16)">
Constructor, should not be called directly, call VertexDeclaration::addElement
</member>
        <member name="M:Ogre.VertexElement.#ctor">
Constructor, should not be called directly, only needed because of list
</member>
        <member name="F:Ogre.VertexElement.mIndex">
Index of the item, only applicable for some elements like texture coords
</member>
        <member name="F:Ogre.VertexElement.mSemantic">
The meaning of the element
</member>
        <member name="F:Ogre.VertexElement.mType">
The type of element
</member>
        <member name="F:Ogre.VertexElement.mOffset">
The offset in the buffer that this element starts at
</member>
        <member name="F:Ogre.VertexElement.mSource">
The source vertex buffer, as bound to an index using VertexBufferBinding
</member>
        <member name="T:Ogre.VertexElement">
This class declares the usage of a single vertex buffer as a component
        of a complete VertexDeclaration.
        @remarks
        Several vertex buffers can be used to supply the input geometry for a
        rendering operation, and in each case a vertex buffer can be used in
        different ways for different operations; the buffer itself does not
        define the semantics (position, normal etc), the VertexElement
        class does.

</member>
        <member name="T:Ogre.VertexElementType">
Vertex element type, used to identify the base types of the vertex contents
</member>
        <member name="F:VET_COLOUR_ABGR">
GL style compact colour
</member>
        <member name="F:VET_COLOUR_ARGB">
D3D style compact colour
</member>
        <member name="F:VET_COLOUR">
alias to more specific colour type - use the current rendersystem's colour packing
</member>
        <member name="T:Ogre.VertexElementSemantic">
Vertex element semantics, used to identify the meaning of vertex buffer contents
</member>
        <member name="F:VES_TANGENT">
Tangent (X axis if normal is Z)
</member>
        <member name="F:VES_BINORMAL">
Binormal (Y axis if normal is Z)
</member>
        <member name="F:VES_TEXTURE_COORDINATES">
Texture coordinates
</member>
        <member name="F:VES_SPECULAR">
Specular colours
</member>
        <member name="F:VES_DIFFUSE">
Diffuse colours
</member>
        <member name="F:VES_NORMAL">
Normal, 3 reals per vertex
</member>
        <member name="F:VES_BLEND_INDICES">
Blending indices
</member>
        <member name="F:VES_BLEND_WEIGHTS">
Blending weights
</member>
        <member name="F:VES_POSITION">
Position, 3 reals per vertex
</member>
        <member name="T:Ogre.HardwareVertexBufferSharedPtr">
Shared pointer implementation used to share index buffers. 
</member>
        <member name="M:Ogre.HardwareVertexBuffer.getNumVertices">
Get the number of vertices in this buffer
</member>
        <member name="M:Ogre.HardwareVertexBuffer.getVertexSize">
Gets the size in bytes of a single vertex in this buffer
</member>
        <member name="M:Ogre.HardwareVertexBuffer.getManager">
Return the manager of this buffer, if any
</member>
        <member name="M:Ogre.HardwareVertexBuffer.#ctor(Ogre.HardwareBufferManagerBase*,System.UInt32,System.UInt32,Ogre.HardwareBuffer.Usage,System.Boolean,System.Boolean)">
Should be called by HardwareBufferManager
</member>
        <member name="T:Ogre.HardwareVertexBuffer">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

Specialisation of HardwareBuffer for a vertex buffer. 
</member>
        <member name="M:Ogre.HardwareBuffer.suppressHardwareUpdate(System.Boolean)">
Pass true to suppress hardware upload of shadow buffer changes
</member>
        <member name="M:Ogre.HardwareBuffer.isLocked">
Returns whether or not this buffer is currently locked.
</member>
        <member name="M:Ogre.HardwareBuffer.hasShadowBuffer">
Returns whether this buffer has a system memory shadow for quicker reading
</member>
        <member name="M:Ogre.HardwareBuffer.isSystemMemory">
Returns whether this buffer is held in system memory
</member>
        <member name="M:Ogre.HardwareBuffer.getUsage">
Returns the Usage flags with which this buffer was created
</member>
        <member name="M:Ogre.HardwareBuffer.getSizeInBytes">
Returns the size of this buffer in bytes
</member>
        <member name="M:Ogre.HardwareBuffer._updateFromShadow">
Updates the real buffer from the shadow buffer, if required
</member>
        <member name="M:Ogre.HardwareBuffer.copyData(Ogre.HardwareBuffer*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy all data from another buffer into this one. 
			@remarks
				Normally these buffers should be of identical size, but if they're
				not, the routine will use the smallest of the two sizes.

</member>
        <member name="M:Ogre.HardwareBuffer.copyData(Ogre.HardwareBuffer*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
Copy data from another buffer into this one.
			@remarks
				Note that the source buffer must not be created with the
                usage HBU_WRITE_ONLY otherwise this will fail. 
			@param srcBuffer The buffer from which to read the copied data
			@param srcOffset Offset in the source buffer at which to start reading
			@param dstOffset Offset in the destination buffer to start writing
			@param length Length of the data to copy, in bytes.
			@param discardWholeBuffer If true, will discard the entire contents of this buffer before copying

</member>
        <member name="M:Ogre.HardwareBuffer.writeData(System.UInt32,System.UInt32,System.Void!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Writes data to the buffer from an area of system memory; note that you must
                ensure that your buffer is big enough.
		    @param offset The byte offset from the start of the buffer to start writing
		    @param length The size of the data to write to, in bytes
            @param pSource The source of the data to be written
			@param discardWholeBuffer If true, this allows the driver to discard the entire buffer when writing,
				such that DMA stalls can be avoided; use if you can.

</member>
        <member name="M:Ogre.HardwareBuffer.readData(System.UInt32,System.UInt32,System.Void*)">
Reads data from the buffer and places it in the memory pointed to by pDest.
		    @param offset The byte offset from the start of the buffer to read
		    @param length The size of the area to read, in bytes
            @param pDest The area of memory in which to place the data, must be large enough to 
                accommodate the data!

</member>
        <member name="M:Ogre.HardwareBuffer.unlock">
Releases the lock on this buffer. 
            @remarks 
                Locking and unlocking a buffer can, in some rare circumstances such as 
                switching video modes whilst the buffer is locked, corrupt the 
                contents of a buffer. This is pretty rare, but if it occurs, 
                this method will throw an exception, meaning you
                must re-upload the data.
            @par
                Note that using the 'read' and 'write' forms of updating the buffer does not
                suffer from this problem, so if you want to be 100% sure your
                data will not be lost, use the 'read' and 'write' forms instead.

</member>
        <member name="M:Ogre.HardwareBuffer.lock(Ogre.HardwareBuffer.LockOptions)">
Lock the entire buffer for (potentially) reading / writing.
		    @param options Locking options
		    @returns Pointer to the locked memory

</member>
        <member name="M:Ogre.HardwareBuffer.lock(System.UInt32,System.UInt32,Ogre.HardwareBuffer.LockOptions)">
Lock the buffer for (potentially) reading / writing.
		    @param offset The byte offset from the start of the buffer to lock
		    @param length The size of the area to lock, in bytes
		    @param options Locking options
		    @returns Pointer to the locked memory

</member>
        <member name="M:Ogre.HardwareBuffer.#ctor(Ogre.HardwareBuffer.Usage,System.Boolean,System.Boolean)">
Constructor, to be called by HardwareBufferManager only
</member>
        <member name="M:Ogre.HardwareBuffer.unlockImpl">
Internal implementation of unlock()
</member>
        <member name="M:Ogre.HardwareBuffer.lockImpl(System.UInt32,System.UInt32,Ogre.HardwareBuffer.LockOptions)">
Internal implementation of lock()
</member>
        <member name="F:HBL_NO_OVERWRITE">
As HBL_NORMAL, except the application guarantees not to overwrite any 
                region of the buffer which has already been used in this frame, can allow
                some optimisation on some APIs. 
</member>
        <member name="F:HBL_READ_ONLY">
Lock the buffer for reading only. Not allowed in buffers which are created with HBU_WRITE_ONLY. 
				Mandatory on static buffers, i.e. those created without the HBU_DYNAMIC flag. 

</member>
        <member name="F:HBL_DISCARD">
Discards the <em>entire</em> buffer while locking; this allows optimisation to be 
				performed because synchronisation issues are relaxed. Only allowed on buffers 
			    created with the HBU_DYNAMIC flag. 

</member>
        <member name="F:HBL_NORMAL">
Normal mode, ie allows read/write and contents are preserved. 
</member>
        <member name="T:Ogre.HardwareBuffer.LockOptions">
Locking options
</member>
        <member name="F:HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE">
Combination of HBU_DYNAMIC, HBU_WRITE_ONLY and HBU_DISCARDABLE
</member>
        <member name="F:HBU_DYNAMIC_WRITE_ONLY">
Combination of HBU_DYNAMIC and HBU_WRITE_ONLY. If you use 
                this, strongly consider using HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE
                instead if you update the entire contents of the buffer very 
                regularly. 

</member>
        <member name="F:HBU_STATIC_WRITE_ONLY">
Combination of HBU_STATIC and HBU_WRITE_ONLY
</member>
        <member name="F:HBU_DISCARDABLE">
Indicates that the application will be refilling the contents
                of the buffer regularly (not just updating, but generating the
                contents from scratch), and therefore does not mind if the contents 
                of the buffer are lost somehow and need to be recreated. This
                allows and additional level of optimisation on the buffer.
                This option only really makes sense when combined with 
                HBU_DYNAMIC_WRITE_ONLY.

</member>
        <member name="F:HBU_WRITE_ONLY">
Indicates the application will never read the contents of the buffer back, 
			    it will only ever write data. Locking a buffer with this flag will ALWAYS 
			    return a pointer to new, blank memory rather than the memory associated 
			    with the contents of the buffer; this avoids DMA stalls because you can 
			    write to a new memory area while the previous one is being used. 

</member>
        <member name="F:HBU_DYNAMIC">
Indicates the application would like to modify this buffer with the CPU
			    fairly often. 
			    Buffers created with this flag will typically end up in AGP memory rather 
			    than video memory.

</member>
        <member name="F:HBU_STATIC">
Static buffer which the application rarely modifies once created. Modifying 
                the contents of this buffer will involve a performance hit.

</member>
        <member name="T:Ogre.HardwareBuffer.Usage">
Enums describing buffer usage; not mutually exclusive
</member>
        <member name="T:Ogre.HardwareBuffer">
\addtogroup Core
	*  @{

\addtogroup RenderSystem
	*  @{

Abstract class defining common features of hardware buffers.
    @remarks
 	    A 'hardware buffer' is any area of memory held outside of core system ram,
	    and in our case refers mostly to video ram, although in theory this class
	    could be used with other memory areas such as sound card memory, custom
	    coprocessor memory etc.
    @par
 	    This reflects the fact that memory held outside of main system RAM must 
	    be interacted with in a more formal fashion in order to promote
	    cooperative and optimal usage of the buffers between the various 
	    processing units which manipulate them.
    @par
 	    This abstract class defines the core interface which is common to all
	    buffers, whether it be vertex buffers, index buffers, texture memory
	    or framebuffer memory etc.
	@par
		Buffers have the ability to be 'shadowed' in system memory, this is because
		the kinds of access allowed on hardware buffers is not always as flexible as
		that allowed for areas of system memory - for example it is often either 
		impossible, or extremely undesirable from a performance standpoint to read from
		a hardware buffer; when writing to hardware buffers, you should also write every
		byte and do it sequentially. In situations where this is too restrictive, 
		it is possible to create a hardware, write-only buffer (the most efficient kind) 
		and to back it with a system memory 'shadow' copy which can be read and updated arbitrarily.
		Ogre handles synchronising this buffer with the real hardware buffer (which should still be
		created with the HBU_DYNAMIC flag if you intend to update it very frequently). Whilst this
		approach does have it's own costs, such as increased memory overhead, these costs can 
		often be outweighed by the performance benefits of using a more hardware efficient buffer.
		You should look for the 'useShadowBuffer' parameter on the creation methods used to create
		the buffer of the type you require (see HardwareBufferManager) to enable this feature.

</member>
        <member name="M:Ogre.RotationalSpline.recalcTangents">
Recalculates the tangents associated with this spline. 
        @remarks
            If you tell the spline not to update on demand by calling setAutoCalculate(false)
            then you must call this after completing your updates to the spline points.

</member>
        <member name="M:Ogre.RotationalSpline.setAutoCalculate(System.Boolean)">
Tells the spline whether it should automatically calculate tangents on demand
            as points are added.
        @remarks
            The spline calculates tangents at each point automatically based on the input points.
            Normally it does this every time a point changes. However, if you have a lot of points
            to add in one go, you probably don't want to incur this overhead and would prefer to 
            defer the calculation until you are finished setting all the points. You can do this
            by calling this method with a parameter of 'false'. Just remember to manually call 
            the recalcTangents method when you are done.
        @param autoCalc If true, tangents are calculated for you whenever a point changes. If false, 
            you must call reclacTangents to recalculate them when it best suits.

</member>
        <member name="M:Ogre.RotationalSpline.interpolate(System.UInt32,System.Single,System.Boolean)">
Interpolates a single segment of the spline given a parametric value.
        @param fromIndex The point index to treat as t=0. fromIndex + 1 is deemed to be t=1
        @param t Parametric value
		@param useShortestPath Defines if rotation should take the shortest possible path

</member>
        <member name="M:Ogre.RotationalSpline.interpolate(System.Single,System.Boolean)">
Returns an interpolated point based on a parametric value over the whole series.
        @remarks
            Given a t value between 0 and 1 representing the parametric distance along the
            whole length of the spline, this method returns an interpolated point.
        @param t Parametric value.
		@param useShortestPath Defines if rotation should take the shortest possible path

</member>
        <member name="M:Ogre.RotationalSpline.updatePoint(System.UInt16,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Updates a single point in the spline. 
        @remarks
            This point must already exist in the spline.

</member>
        <member name="M:Ogre.RotationalSpline.clear">
Clears all the points in the spline. 
</member>
        <member name="M:Ogre.RotationalSpline.getNumPoints">
Gets the number of control points in the spline. 
</member>
        <member name="M:Ogre.RotationalSpline.getPoint(System.UInt16)">
Gets the detail of one of the control points of the spline. 
</member>
        <member name="M:Ogre.RotationalSpline.addPoint(Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds a control point to the end of the spline. 
</member>
        <member name="T:Ogre.RotationalSpline">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

This class interpolates orientations (rotations) along a spline using 
        derivatives of quaternions.
    @remarks
        Like the SimpleSpline class, this class is about interpolating values 
        smoothly over a spline. Whilst SimpleSpline deals with positions (the normal
        sense we think about splines), this class interpolates orientations. The
        theory is identical, except we're now in 4-dimensional space instead of 3.
    @par
        In positional splines, we use the points and tangents on those points to generate
        control points for the spline. In this case, we use quaternions and derivatives
        of the quaternions (i.e. the rate and direction of change at each point). This is the
        same as SimpleSpline since a tangent is a derivative of a position. We effectively 
        generate an extra quaternion in between each actual quaternion which when take with 
        the original quaternion forms the 'tangent' of that quaternion.

</member>
        <member name="F:Ogre.SimpleSpline.mCoeffs">
Matrix of coefficients 
</member>
        <member name="M:Ogre.SimpleSpline.recalcTangents">
Recalculates the tangents associated with this spline. 
        @remarks
            If you tell the spline not to update on demand by calling setAutoCalculate(false)
            then you must call this after completing your updates to the spline points.

</member>
        <member name="M:Ogre.SimpleSpline.setAutoCalculate(System.Boolean)">
Tells the spline whether it should automatically calculate tangents on demand
            as points are added.
        @remarks
            The spline calculates tangents at each point automatically based on the input points.
            Normally it does this every time a point changes. However, if you have a lot of points
            to add in one go, you probably don't want to incur this overhead and would prefer to 
            defer the calculation until you are finished setting all the points. You can do this
            by calling this method with a parameter of 'false'. Just remember to manually call 
            the recalcTangents method when you are done.
        @param autoCalc If true, tangents are calculated for you whenever a point changes. If false, 
            you must call reclacTangents to recalculate them when it best suits.

</member>
        <member name="M:Ogre.SimpleSpline.interpolate(System.UInt32,System.Single)">
Interpolates a single segment of the spline given a parametric value.
        @param fromIndex The point index to treat as t=0. fromIndex + 1 is deemed to be t=1
        @param t Parametric value

</member>
        <member name="M:Ogre.SimpleSpline.interpolate(System.Single)">
Returns an interpolated point based on a parametric value over the whole series.
        @remarks
            Given a t value between 0 and 1 representing the parametric distance along the
            whole length of the spline, this method returns an interpolated point.
        @param t Parametric value.

</member>
        <member name="M:Ogre.SimpleSpline.updatePoint(System.UInt16,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Updates a single point in the spline. 
        @remarks
            This point must already exist in the spline.

</member>
        <member name="M:Ogre.SimpleSpline.clear">
Clears all the points in the spline. 
</member>
        <member name="M:Ogre.SimpleSpline.getNumPoints">
Gets the number of control points in the spline. 
</member>
        <member name="M:Ogre.SimpleSpline.getPoint(System.UInt16)">
Gets the detail of one of the control points of the spline. 
</member>
        <member name="M:Ogre.SimpleSpline.addPoint(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds a control point to the end of the spline. 
</member>
        <member name="T:Ogre.SimpleSpline">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

A very simple spline class which implements the Catmull-Rom class of splines.
    @remarks
        Splines are bendy lines. You define a series of points, and the spline forms
        a smoother line between the points to eliminate the sharp angles.
    @par
        Catmull-Rom splines are a specialisation of the general Hermite spline. With
        a Hermite spline, you define the start and end point of the line, and 2 tangents,
        one at the start of the line and one at the end. The Catmull-Rom spline simplifies
        this by just asking you to define a series of points, and the tangents are 
        created for you. 

</member>
        <member name="M:Ogre.Matrix4.transformAffine(Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
4-D Vector transformation specially for an affine matrix.
            @note
                The matrix must be an affine matrix. @see Matrix4::isAffine.

</member>
        <member name="M:Ogre.Matrix4.transformAffine(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
3-D Vector transformation specially for an affine matrix.
            @remarks
                Transforms the given 3-D vector by the matrix, projecting the 
                result back into <i>w</i> = 1.
            @note
                The matrix must be an affine matrix. @see Matrix4::isAffine.

</member>
        <member name="M:Ogre.Matrix4.concatenateAffine(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Concatenate two affine matrices.
            @note
                The matrices must be affine matrix. @see Matrix4::isAffine.

</member>
        <member name="M:Ogre.Matrix4.inverseAffine">
Returns the inverse of the affine matrix.
            @note
                The matrix must be an affine matrix. @see Matrix4::isAffine.

</member>
        <member name="M:Ogre.Matrix4.isAffine">
Check whether or not the matrix is affine matrix.
            @remarks
                An affine matrix is a 4x4 matrix with row 3 equal to (0, 0, 0, 1),
                e.g. no projective coefficients.

</member>
        <member name="M:Ogre.Matrix4.decomposition(Ogre.Vector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Quaternion*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Decompose a Matrix4 to orientation / scale / position.

</member>
        <member name="M:Ogre.Matrix4.makeInverseTransform(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Building an inverse Matrix4 from orientation / scale / position.
        @remarks
            As makeTransform except it build the inverse given the same data as makeTransform, so
            performing -translation, -rotate, 1/scale in that order.

</member>
        <member name="M:Ogre.Matrix4.makeTransform(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Building a Matrix4 from orientation / scale / position.
        @remarks
            Transform is performed in the order scale, rotate, translation, i.e. translation is independent
            of orientation axes, scale does not affect size of translation, rotation and scaling are always
            centered on the origin.

</member>
        <member name="M:Ogre.Matrix4.op_LeftShift(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Function for writing to a stream.

</member>
        <member name="F:Ogre.Matrix4.CLIPSPACE2DTOIMAGESPACE">
Useful little matrix which takes 2D clipspace {-1, 1} to {0,1}
            and inverts the Y. 
</member>
        <member name="M:Ogre.Matrix4.extractQuaternion">
Extracts the rotation / scaling part as a quaternion from the Matrix.

</member>
        <member name="M:Ogre.Matrix4.hasNegativeScale">
Determines if this matrix involves a negative scaling. 
</member>
        <member name="M:Ogre.Matrix4.hasScale">
Determines if this matrix involves a scaling. 
</member>
        <member name="M:Ogre.Matrix4.extract3x3Matrix(Ogre.Matrix3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Extracts the rotation / scaling part of the Matrix as a 3x3 matrix. 
        @param m3x3 Destination Matrix3

</member>
        <member name="M:Ogre.Matrix4.getScale(System.Single,System.Single,System.Single)">
Gets a scale matrix - variation for not using a vector.

</member>
        <member name="M:Ogre.Matrix4.getScale(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets a scale matrix.

</member>
        <member name="M:Ogre.Matrix4.setScale(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the scale part of the matrix.

</member>
        <member name="M:Ogre.Matrix4.getTrans(System.Single,System.Single,System.Single)">
Gets a translation matrix - variation for not using a vector.

</member>
        <member name="M:Ogre.Matrix4.getTrans(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets a translation matrix.

</member>
        <member name="M:Ogre.Matrix4.makeTrans(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Builds a translation matrix

</member>
        <member name="M:Ogre.Matrix4.getTrans">
Extracts the translation transformation part of the matrix.

</member>
        <member name="M:Ogre.Matrix4.setTrans(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the translation transformation part of the matrix.

</member>
        <member name="M:Ogre.Matrix4.op_Assign(Ogre.Matrix3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment from 3x3 matrix.

</member>
        <member name="M:Ogre.Matrix4.op_Inequality(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tests 2 matrices for inequality.

</member>
        <member name="M:Ogre.Matrix4.op_Equality(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Tests 2 matrices for equality.

</member>
        <member name="M:Ogre.Matrix4.op_Subtraction(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Matrix subtraction.

</member>
        <member name="M:Ogre.Matrix4.op_Addition(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Matrix addition.

</member>
        <member name="M:Ogre.Matrix4.op_Multiply(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Vector transformation using '*'.
            @remarks
                Transforms the given 3-D vector by the matrix, projecting the 
                result back into <i>w</i> = 1.
            @note
                This means that the initial <i>w</i> is considered to be 1.0,
                and then all the tree elements of the resulting 3-D vector are
                divided by the resulting <i>w</i>.

</member>
        <member name="M:Ogre.Matrix4.op_Multiply(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Matrix concatenation using '*'.

</member>
        <member name="M:Ogre.Matrix4.swap(Ogre.Matrix4*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Exchange the contents of this matrix with another. 

</member>
        <member name="M:Ogre.Matrix4.#ctor(Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a standard 4x4 transformation matrix with a zero translation part from a rotation/scaling Quaternion.

</member>
        <member name="M:Ogre.Matrix4.#ctor(Ogre.Matrix3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a standard 4x4 transformation matrix with a zero translation part from a rotation/scaling 3x3 matrix.

</member>
        <member name="M:Ogre.Matrix4.#ctor">
Default constructor.
            @note
                It does <b>NOT</b> initialize the matrix for efficiency.

</member>
        <member name="T:Ogre.Matrix4">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

Class encapsulating a standard 4x4 homogeneous matrix.
        @remarks
            OGRE uses column vectors when applying matrix multiplications,
            This means a vector is represented as a single column, 4-row
            matrix. This has the effect that the transformations implemented
            by the matrices happens right-to-left e.g. if vector V is to be
            transformed by M1 then M2 then M3, the calculation would be
            M3 * M2 * M1 * V. The order that matrices are concatenated is
            vital since matrix multiplication is not commutative, i.e. you
            can get a different result if you concatenate in the wrong order.
        @par
            The use of column vectors and right-to-left ordering is the
            standard in most mathematical texts, and is the same as used in
            OpenGL. It is, however, the opposite of Direct3D, which has
            inexplicably chosen to differ from the accepted standard and uses
            row vectors and left-to-right matrix multiplication.
        @par
            OGRE deals with the differences between D3D and OpenGL etc.
            internally when operating through different render systems. OGRE
            users only need to conform to standard maths conventions, i.e.
            right-to-left matrix multiplication, (OGRE transposes matrices it
            passes to D3D to compensate).
        @par
            The generic form M * V which shows the layout of the matrix 
            entries is shown below:
            <pre>
                [ m[0][0]  m[0][1]  m[0][2]  m[0][3] ]   {x}
                | m[1][0]  m[1][1]  m[1][2]  m[1][3] | * {y}
                | m[2][0]  m[2][1]  m[2][2]  m[2][3] |   {z}
                [ m[3][0]  m[3][1]  m[3][2]  m[3][3] ]   {1}
            </pre></member>
        <member name="M:Ogre.Plane.op_Equality(Ogre.Plane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Comparison operator
</member>
        <member name="M:Ogre.Plane.normalise">
Normalises the plane.
            @remarks
                This method normalises the plane's normal and the length scale of d
                is as well.
            @note
                This function will not crash for zero-sized vectors, but there
                will be no changes made to their components.
            @returns The previous length of the plane's normal.

</member>
        <member name="M:Ogre.Plane.projectVector(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Project a vector onto the plane. 
		@remarks This gives you the element of the input vector that is perpendicular 
			to the normal of the plane. You can get the element which is parallel
			to the normal of the plane by subtracting the result of this method
			from the original vector, since parallel + perpendicular = original.
		@param v The input vector

</member>
        <member name="M:Ogre.Plane.redefine(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Redefine this plane based on a normal and a point. 
</member>
        <member name="M:Ogre.Plane.redefine(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Redefine this plane based on 3 points. 
</member>
        <member name="M:Ogre.Plane.getDistance(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This is a pseudodistance. The sign of the return value is
            positive if the point is on the positive side of the plane,
            negative if the point is on the negative side, and zero if the
            point is on the plane.
            @par
            The absolute value of the return value is the true distance only
            when the plane normal is a unit length vector.

</member>
        <member name="M:Ogre.Plane.getSide(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns which side of the plane that the given box lies on.
            The box is defined as centre/half-size pairs for effectively.
        @param centre The centre of the box.
        @param halfSize The half-size of the box.
        @returns
            POSITIVE_SIDE if the box complete lies on the "positive side" of the plane,
            NEGATIVE_SIDE if the box complete lies on the "negative side" of the plane,
            and BOTH_SIDE if the box intersects the plane.

</member>
        <member name="M:Ogre.Plane.getSide(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
returns the side where the aligneBox is. the flag BOTH_SIDE indicates an intersecting box.
one corner ON the plane is sufficient to consider the box and the plane intersecting.

</member>
        <member name="T:Ogre.Plane.Side">
The "positive side" of the plane is the half space to which the
            plane normal points. The "negative side" is the other half
            space. The flag "no side" indicates the plane itself.

</member>
        <member name="M:Ogre.Plane.#ctor(System.Single,System.Single,System.Single,System.Single)">
Construct a plane using the 4 constants directly *
</member>
        <member name="M:Ogre.Plane.#ctor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Construct a plane through a normal, and a distance to move the plane along the normal.
</member>
        <member name="M:Ogre.Plane.#ctor">
Default constructor - sets everything to 0.

</member>
        <member name="T:Ogre.Plane">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

Defines a plane in 3D space.
        @remarks
            A plane is defined in 3D space by the equation
            Ax + By + Cz + D = 0
        @par
            This equates to a vector (the normal of the plane, whose x, y
            and z components equate to the coefficients A, B and C
            respectively), and a constant (D) which is the distance along
            the normal you have to go to move the plane back to the origin.

</member>
        <member name="M:Ogre.Matrix3.op_LeftShift(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Matrix3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Function for writing to a stream.

</member>
        <member name="M:Ogre.Matrix3.hasScale">
Determines if this matrix involves a scaling. 
</member>
        <member name="M:Ogre.Matrix3.swap(Ogre.Matrix3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Exchange the contents of this matrix with another. 

</member>
        <member name="M:Ogre.Matrix3.#ctor">
Default constructor.
            @note
                It does <b>NOT</b> initialize the matrix for efficiency.

</member>
        <member name="T:Ogre.Matrix3">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

A 3x3 matrix which can represent rotations around axes.
        @note
            <b>All the code is adapted from the Wild Magic 0.2 Matrix
            library (http://www.geometrictools.com/).</b>
        @par
            The coordinate system is assumed to be <b>right-handed</b>.

</member>
        <member name="M:Ogre.AnimableObject.createAnimableValue(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a reference-counted AnimableValuePtr for the named value.
		@remarks
			You can use the returned object to animate a value on this object,
			using AnimationTrack. Subclasses must override this if they wish 
			to support animation of their values.

</member>
        <member name="M:Ogre.AnimableObject.getAnimableValueNames">
Gets a list of animable value names for this object. 
</member>
        <member name="M:Ogre.AnimableObject.initialiseAnimableDictionary(std.vector&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method for initialising dictionary; should be implemented by 
			subclasses wanting to expose animable parameters.

</member>
        <member name="M:Ogre.AnimableObject._getAnimableValueNames">
Get an updateable reference to animable value list
</member>
        <member name="M:Ogre.AnimableObject.createAnimableDictionary">
Internal method for creating a dictionary of animable value names 
			for the class, if it does not already exist.

</member>
        <member name="M:Ogre.AnimableObject.getAnimableDictionaryName">
Get the name of the animable dictionary for this class.
		@remarks
			Subclasses must override this if they want to support animation of
			their values.

</member>
        <member name="F:Ogre.AnimableObject.msAnimableDictionary">
Static map of class name to list of animable value names
</member>
        <member name="T:Ogre.AnimableObject">
Defines an interface to classes which have one or more AnimableValue
		instances to expose.

</member>
        <member name="M:Ogre.AnimableValue.applyDeltaValue(Ogre.Any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Apply delta value 
</member>
        <member name="M:Ogre.AnimableValue.applyDeltaValue(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Apply delta value 
</member>
        <member name="M:Ogre.AnimableValue.applyDeltaValue(Ogre.Degree!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Apply delta value 
</member>
        <member name="M:Ogre.AnimableValue.applyDeltaValue(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Apply delta value 
</member>
        <member name="M:Ogre.AnimableValue.applyDeltaValue(Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Apply delta value 
</member>
        <member name="M:Ogre.AnimableValue.applyDeltaValue(Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Apply delta value 
</member>
        <member name="M:Ogre.AnimableValue.applyDeltaValue(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Apply delta value 
</member>
        <member name="M:Ogre.AnimableValue.applyDeltaValue(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Apply delta value 
</member>
        <member name="M:Ogre.AnimableValue.applyDeltaValue(System.Single)">
Set value 
</member>
        <member name="M:Ogre.AnimableValue.applyDeltaValue(System.Int32)">
Apply delta value
</member>
        <member name="M:Ogre.AnimableValue.setValue(Ogre.Any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set value 
</member>
        <member name="M:Ogre.AnimableValue.setValue(Ogre.Degree!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set value 
</member>
        <member name="M:Ogre.AnimableValue.setValue(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set value 
</member>
        <member name="M:Ogre.AnimableValue.setValue(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set value 
</member>
        <member name="M:Ogre.AnimableValue.setValue(Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set value 
</member>
        <member name="M:Ogre.AnimableValue.setValue(Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set value 
</member>
        <member name="M:Ogre.AnimableValue.setValue(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set value 
</member>
        <member name="M:Ogre.AnimableValue.setValue(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set value 
</member>
        <member name="M:Ogre.AnimableValue.setValue(System.Single)">
Set value 
</member>
        <member name="M:Ogre.AnimableValue.setValue(System.Int32)">
Set value 
</member>
        <member name="M:Ogre.AnimableValue.setCurrentStateAsBaseValue">
Sets the current state as the 'base' value; used for delta animation
</member>
        <member name="M:Ogre.AnimableValue.getType">
Gets the value type of this animable value
</member>
        <member name="M:Ogre.AnimableValue.setAsBaseValue(Ogre.Degree!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method to set a value as base
</member>
        <member name="M:Ogre.AnimableValue.setAsBaseValue(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method to set a value as base
</member>
        <member name="M:Ogre.AnimableValue.setAsBaseValue(Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method to set a value as base
</member>
        <member name="M:Ogre.AnimableValue.setAsBaseValue(Ogre.Any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method to set a value as base
</member>
        <member name="M:Ogre.AnimableValue.setAsBaseValue(Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method to set a value as base
</member>
        <member name="M:Ogre.AnimableValue.setAsBaseValue(Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method to set a value as base
</member>
        <member name="M:Ogre.AnimableValue.setAsBaseValue(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method to set a value as base
</member>
        <member name="M:Ogre.AnimableValue.setAsBaseValue(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal method to set a value as base
</member>
        <member name="M:Ogre.AnimableValue.setAsBaseValue(System.Single)">
Internal method to set a value as base
</member>
        <member name="M:Ogre.AnimableValue.setAsBaseValue(System.Int32)">
Internal method to set a value as base
</member>
        <member name="F:Ogre.AnimableValue.mType">
Value type
</member>
        <member name="T:Ogre.AnimableValue.ValueType">
The type of the value being animated
</member>
        <member name="T:Ogre.AnimableValue">
\addtogroup Core
	*  @{

\addtogroup Animation
	*  @{

Defines an object property which is animable, i.e. may be keyframed.
	@remarks
		Animable properties are those which can be altered over time by a 
		predefined keyframe sequence. They may be set directly, or they may
		be modified from their existing state (common if multiple animations
		are expected to apply at once). Implementors of this interface are
		expected to override the 'setValue', 'setCurrentStateAsBaseValue' and 
		'applyDeltaValue' methods appropriate to the type in question, and to 
		initialise the type.
	@par
		AnimableValue instances are accessible through any class which extends
		AnimableObject in order to expose it's animable properties.
	@note
		This class is an instance of the Adapter pattern, since it generalises
		access to a particular property. Whilst it could have been templated
		such that the type which was being referenced was compiled in, this would
		make it more difficult to aggregated generically, and since animations
		are often comprised of multiple properties it helps to be able to deal
		with all values through a single class.

</member>
        <member name="M:Ogre.AnyNumeric.#ctor(Ogre.Any.placeholder*)">
Construct from holder
</member>
        <member name="T:Ogre.AnyNumeric">
Specialised Any class which has built in arithmetic operators, but can 
		hold only types which support operator +,-,* and / .

</member>
        <member name="T:Ogre.Any">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

Variant type that can hold Any other type.

</member>
        <member name="M:Ogre.ExceptionFactory.#ctor">
Private constructor, no construction
</member>
        <member name="T:Ogre.ExceptionFactory">
Class implementing dispatch methods in order to construct by-value
		exceptions of a derived type based just on an exception code.
	@remarks
		This nicely handles construction of derived Exceptions by value (needed
		for throwing) without suffering from ambiguity - each code is turned into
		a distinct type so that methods can be overloaded. This allows OGRE_EXCEPT
		to stay small in implementation (desirable since it is embedded) whilst
		still performing rich code-to-type mapping. 

</member>
        <member name="M:Ogre.Exception.getLastException">
Retrieves a pointer to the last exception created.

</member>
        <member name="M:Ogre.Exception.what">
Override std::exception::what
</member>
        <member name="M:Ogre.Exception.getDescription">
Returns a string with only the 'description' field of this exception. Use 
			getFullDescriptionto get a full description of the error including line number,
			error number and what function threw the exception.

</member>
        <member name="M:Ogre.Exception.getLine">
Gets line number.

</member>
        <member name="M:Ogre.Exception.getFile">
Gets source file name.

</member>
        <member name="M:Ogre.Exception.getSource">
Gets the source function.

</member>
        <member name="M:Ogre.Exception.getNumber">
Gets the error code.

</member>
        <member name="M:Ogre.Exception.getFullDescription">
Returns a string with the full description of this error.
            @remarks
                The description contains the error number, the description
                supplied by the thrower, what routine threw the exception,
                and will also supply extra platform-specific information
                where applicable. For example - in the case of a rendering
                library error, the description of the error will include both
                the place in which OGRE found the problem, and a text
                description from the 3D rendering library, if available.

</member>
        <member name="M:Ogre.Exception.op_Assign(Ogre.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator.

</member>
        <member name="M:Ogre.Exception.Dispose">
Needed for  compatibility with std::exception
</member>
        <member name="M:Ogre.Exception.#ctor(Ogre.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor.

</member>
        <member name="M:Ogre.Exception.#ctor(System.Int32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerService">
Advanced constructor.

</member>
        <member name="M:Ogre.Exception.#ctor(System.Int32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Default constructor.

</member>
        <member name="T:Ogre.Exception.ExceptionCodes">
Static definitions of error codes.
            @todo
                Add many more exception codes, since we want the user to be able
                to catch most of them.

</member>
        <member name="D:Ogre.StringVector">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

</member>
        <member name="T:Ogre.SharedPtrFreeMethod">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

The method to use to free memory on destruction
</member>
        <member name="F:SPFM_FREE">
Use OGRE_FREE to free (only MEMCATEGORY_GENERAL supported)
</member>
        <member name="F:SPFM_DELETE_T">
Use OGRE_DELETE_T to free (only MEMCATEGORY_GENERAL supported)
</member>
        <member name="F:SPFM_DELETE">
Use OGRE_DELETE to free the memory
</member>
        <member name="M:Ogre.ColourValue.op_LeftShift(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.ColourValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Function for writing to a stream.

</member>
        <member name="M:Ogre.ColourValue.getHSB(System.Single*,System.Single*,System.Single*)">
Convert the current colour to Hue, Saturation and Brightness values. 
		@param hue Output hue value, scaled to the [0,1] range as opposed to the 0-360
		@param saturation Output saturation level, [0,1]
		@param brightness Output brightness level, [0,1]

</member>
        <member name="M:Ogre.ColourValue.setHSB(System.Single,System.Single,System.Single)">
Set a colour value from Hue, Saturation and Brightness.
		@param hue Hue value, scaled to the [0,1] range as opposed to the 0-360
		@param saturation Saturation level, [0,1]
		@param brightness Brightness level, [0,1]

</member>
        <member name="M:Ogre.ColourValue.ptr">
Pointer accessor for direct copying

Pointer accessor for direct copying
</member>
        <member name="M:Ogre.ColourValue.op_Subscript(System.UInt32!System.Runtime.CompilerServices.IsConst)">
Array accessor operator

Array accessor operator
</member>
        <member name="M:Ogre.ColourValue.saturateCopy">
As saturate, except that this colour value is unaffected and
            the saturated colour value is returned as a copy. 
</member>
        <member name="M:Ogre.ColourValue.saturate">
Clamps colour value to the range [0, 1].

</member>
        <member name="M:Ogre.ColourValue.setAsABGR(System.UInt32!System.Runtime.CompilerServices.IsConst)">
Sets colour as ABGR.

</member>
        <member name="M:Ogre.ColourValue.setAsBGRA(System.UInt32!System.Runtime.CompilerServices.IsConst)">
Sets colour as BGRA.

</member>
        <member name="M:Ogre.ColourValue.setAsARGB(System.UInt32!System.Runtime.CompilerServices.IsConst)">
Sets colour as ARGB.

</member>
        <member name="M:Ogre.ColourValue.setAsRGBA(System.UInt32!System.Runtime.CompilerServices.IsConst)">
Sets colour as RGBA.

</member>
        <member name="M:Ogre.ColourValue.getAsABGR">
Retrieves colours as ABGR 
</member>
        <member name="M:Ogre.ColourValue.getAsBGRA">
Retrieves colour as BGRA.

</member>
        <member name="M:Ogre.ColourValue.getAsARGB">
Retrieves colour as ARGB.

</member>
        <member name="M:Ogre.ColourValue.getAsRGBA">
Retrieves colour as RGBA.

</member>
        <member name="T:Ogre.ColourValue">
Class representing colour.
	    @remarks
		    Colour is represented as 4 components, each of which is a
		    floating-point value from 0.0 to 1.0.
	    @par
		    The 3 'normal' colour components are red, green and blue, a higher
		    number indicating greater amounts of that component in the colour.
		    The forth component is the 'alpha' value, which represents
		    transparency. In this case, 0.0 is completely transparent and 1.0 is
		    fully opaque.

</member>
        <member name="D:Ogre.RGBA">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

</member>
        <member name="M:Ogre.Vector4.op_LeftShift(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Function for writing to a stream.

</member>
        <member name="M:Ogre.Vector4.isNaN">
Check whether this vector contains valid values
</member>
        <member name="M:Ogre.Vector4.dotProduct(Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the dot (scalar) product of this vector with another.
            @param
                vec Vector with which to calculate the dot product (together
                with this one).
            @returns
                A float representing the dot product value.

</member>
        <member name="M:Ogre.Vector4.op_Assign(Ogre.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assigns the value of the other vector.
            @param
                rkVector The other vector

</member>
        <member name="M:Ogre.Vector4.ptr">
Pointer accessor for direct copying

Pointer accessor for direct copying
</member>
        <member name="M:Ogre.Vector4.swap(Ogre.Vector4*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Exchange the contents of this vector with another. 

</member>
        <member name="T:Ogre.Vector4">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

4-dimensional homogeneous vector.

</member>
        <member name="M:Ogre.Vector3.op_LeftShift(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Function for writing to a stream.

</member>
        <member name="M:Ogre.Vector3.isNaN">
Check whether this vector contains valid values
</member>
        <member name="M:Ogre.Vector3.directionEquals(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns whether this vector is within a directional tolerance
			of another vector.
		@param rhs The vector to compare with
		@param tolerance The maximum angle by which the vectors may vary and
			still be considered equal
		@note Both vectors should be normalised.

</member>
        <member name="M:Ogre.Vector3.positionCloses(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Returns whether this vector is within a positional tolerance
			of another vector, also take scale of the vectors into account.
		@param rhs The vector to compare with
		@param tolerance The amount (related to the scale of vectors) that distance
            of the vector may vary by and still be considered close

</member>
        <member name="M:Ogre.Vector3.positionEquals(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
Returns whether this vector is within a positional tolerance
			of another vector.
		@param rhs The vector to compare with
		@param tolerance The amount that each element of the vector may vary by
			and still be considered equal

</member>
        <member name="M:Ogre.Vector3.reflect(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates a reflection vector to the plane with the given normal .
        @remarks NB assumes 'this' is pointing AWAY FROM the plane, invert if it is not.

</member>
        <member name="M:Ogre.Vector3.normalisedCopy">
As normalise, except that this vector is unaffected and the
            normalised vector is returned as a copy. 
</member>
        <member name="M:Ogre.Vector3.isZeroLength">
Returns true if this vector is zero length. 
</member>
        <member name="M:Ogre.Vector3.getRotationTo(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the shortest arc quaternion to rotate this vector to the destination
            vector.
        @remarks
            If you call this with a dest vector that is close to the inverse
            of this vector, we will rotate 180 degrees around the 'fallbackAxis'
			(if specified, or a generated axis if not) since in this case
			ANY axis of rotation is valid.

</member>
        <member name="M:Ogre.Vector3.angleBetween(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the angle between 2 vectors.
		@remarks
			Vectors do not have to be unit-length but must represent directions.

</member>
        <member name="M:Ogre.Vector3.randomDeviant(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Generates a new random vector which deviates from this vector by a
            given angle in a random direction.
            @remarks
                This method assumes that the random number generator has already
                been seeded appropriately.
            @param
                angle The angle at which to deviate
            @param
                up Any vector perpendicular to this one (which could generated
                by cross-product of this vector and any other non-colinear
                vector). If you choose not to provide this the function will
                derive one on it's own, however if you provide one yourself the
                function will be faster (this allows you to reuse up vectors if
                you call this method more than once)
            @returns
                A random vector which deviates from this vector by angle. This
                vector will not be normalised, normalise it if you wish
                afterwards.

</member>
        <member name="M:Ogre.Vector3.perpendicular">
Generates a vector perpendicular to this vector (eg an 'up' vector).
            @remarks
                This method will return a vector which is perpendicular to this
                vector. There are an infinite number of possibilities but this
                method will guarantee to generate one of them. If you need more
                control you should use the Quaternion class.

</member>
        <member name="M:Ogre.Vector3.makeCeil(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets this vector's components to the maximum of its own and the
            ones of the passed in vector.
            @remarks
                'Maximum' in this case means the combination of the highest
                value of x, y and z from both vectors. Highest is taken just
                numerically, not magnitude, so 1 &gt; -3.

</member>
        <member name="M:Ogre.Vector3.op_GreaterThan(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns true if the vector's scalar components are all smaller
            that the ones of the vector it is compared against.

</member>
        <member name="M:Ogre.Vector3.op_LessThan(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns true if the vector's scalar components are all greater
            that the ones of the vector it is compared against.

</member>
        <member name="M:Ogre.Vector3.midPoint(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a vector at a point half way between this and the passed
            in vector.

</member>
        <member name="M:Ogre.Vector3.crossProduct(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the cross-product of 2 vectors, i.e. the vector that
            lies perpendicular to them both.
            @remarks
                The cross-product is normally used to calculate the normal
                vector of a plane, by calculating the cross-product of 2
                non-equivalent vectors which lie on the plane (e.g. 2 edges
                of a triangle).
            @param
                vec Vector which, together with this one, will be used to
                calculate the cross-product.
            @returns
                A vector which is the result of the cross-product. This
                vector will <b>NOT</b> be normalised, to maximise efficiency
                - call Vector3::normalise on the result if you wish this to
                be done. As for which side the resultant vector will be on, the
                returned vector will be on the side from which the arc from 'this'
                to rkVector is anticlockwise, e.g. UNIT_Y.crossProduct(UNIT_Z)
                = UNIT_X, whilst UNIT_Z.crossProduct(UNIT_Y) = -UNIT_X.
				This is because OGRE uses a right-handed coordinate system.
            @par
                For a clearer explanation, look a the left and the bottom edges
                of your monitor's screen. Assume that the first vector is the
                left edge and the second vector is the bottom edge, both of
                them starting from the lower-left corner of the screen. The
                resulting vector is going to be perpendicular to both of them
                and will go <i>inside</i> the screen, towards the cathode tube
                (assuming you're using a CRT monitor, of course).

</member>
        <member name="M:Ogre.Vector3.normalise">
Normalises the vector.
            @remarks
                This method normalises the vector such that it's
                length / magnitude is 1. The result is called a unit vector.
            @note
                This function will not crash for zero-sized vectors, but there
                will be no changes made to their components.
            @returns The previous length of the vector.

</member>
        <member name="M:Ogre.Vector3.absDotProduct(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the absolute dot (scalar) product of this vector with another.
            @remarks
                This function work similar dotProduct, except it use absolute value
                of each component of the vector to computing.
            @param
                vec Vector with which to calculate the absolute dot product (together
                with this one).
            @returns
                A Real representing the absolute dot product value.

</member>
        <member name="M:Ogre.Vector3.dotProduct(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the dot (scalar) product of this vector with another.
            @remarks
                The dot product can be used to calculate the angle between 2
                vectors. If both are unit vectors, the dot product is the
                cosine of the angle; otherwise the dot product must be
                divided by the product of the lengths of both vectors to get
                the cosine of the angle. This result can further be used to
                calculate the distance of a point from a plane.
            @param
                vec Vector with which to calculate the dot product (together
                with this one).
            @returns
                A float representing the dot product value.

</member>
        <member name="M:Ogre.Vector3.squaredDistance(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the square of the distance to another vector.
            @remarks
                This method is for efficiency - calculating the actual
                distance to another vector requires a square root, which is
                expensive in terms of the operations required. This method
                returns the square of the distance to another vector, i.e.
                the same as the distance but before the square root is taken.
                Use this if you want to find the longest / shortest distance
                without incurring the square root.

</member>
        <member name="M:Ogre.Vector3.distance(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the distance to another vector.
            @warning
                This operation requires a square root and is expensive in
                terms of CPU operations. If you don't need to know the exact
                distance (e.g. for just comparing distances) use squaredDistance()
                instead.

</member>
        <member name="M:Ogre.Vector3.squaredLength">
Returns the square of the length(magnitude) of the vector.
            @remarks
                This  method is for efficiency - calculating the actual
                length of a vector requires a square root, which is expensive
                in terms of the operations required. This method returns the
                square of the length of the vector, i.e. the same as the
                length but before the square root is taken. Use this if you
                want to find the longest / shortest vector without incurring
                the square root.

</member>
        <member name="M:Ogre.Vector3.length">
Returns the length (magnitude) of the vector.
            @warning
                This operation requires a square root and is expensive in
                terms of CPU operations. If you don't need to know the exact
                length (e.g. for just comparing lengths) use squaredLength()
                instead.

</member>
        <member name="M:Ogre.Vector3.op_Assign(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assigns the value of the other vector.
            @param
                rkVector The other vector

</member>
        <member name="M:Ogre.Vector3.ptr">
Pointer accessor for direct copying

Pointer accessor for direct copying
</member>
        <member name="M:Ogre.Vector3.swap(Ogre.Vector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Exchange the contents of this vector with another. 

</member>
        <member name="T:Ogre.Vector3">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

Standard 3-dimensional vector.
        @remarks
            A direction in 3D space represented as distances along the 3
            orthogonal axes (x, y, z). Note that positions, directions and
            scaling factors can be represented by a vector, depending on how
            you interpret the values.

</member>
        <member name="M:Ogre.Quaternion.op_LeftShift(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Function for writing to a stream. Outputs "Quaternion(w, x, y, z)" with w,x,y,z
            being the member values of the quaternion.

</member>
        <member name="M:Ogre.Quaternion.isNaN">
Check whether this quaternion contains valid values
</member>
        <member name="M:Ogre.Quaternion.equals(Ogre.Quaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Equality with tolerance (tolerance is max angle difference)
</member>
        <member name="M:Ogre.Quaternion.getYaw(System.Boolean)">
Calculate the local yaw element of this quaternion
		@param reprojectAxis By default the method returns the 'intuitive' result
			that is, if you projected the local Z of the quaternion onto the X and
			Z axes, the angle between them is returned. If set to true though, the
			result is the actual yaw that will be used to implement the quaternion,
			which is the shortest possible path to get to the same orientation and 
			may involve less axial rotation. 

</member>
        <member name="M:Ogre.Quaternion.getPitch(System.Boolean)">
Calculate the local pitch element of this quaternion
		@param reprojectAxis By default the method returns the 'intuitive' result
			that is, if you projected the local Z of the quaternion onto the X and
			Y axes, the angle between them is returned. If set to true though, the
			result is the actual yaw that will be used to implement the quaternion,
			which is the shortest possible path to get to the same orientation and 
			may involve less axial rotation. 

</member>
        <member name="M:Ogre.Quaternion.getRoll(System.Boolean)">
Calculate the local roll element of this quaternion.
		@param reprojectAxis By default the method returns the 'intuitive' result
			that is, if you projected the local Y of the quaternion onto the X and
			Y axes, the angle between them is returned. If set to false though, the
			result is the actual yaw that will be used to implement the quaternion,
			which is the shortest possible path to get to the same orientation and 
			may involve less axial rotation. 

</member>
        <member name="M:Ogre.Quaternion.normalise">
Normalises this quaternion, and returns the previous length
</member>
        <member name="M:Ogre.Quaternion.zAxis">
Get the local z-axis
</member>
        <member name="M:Ogre.Quaternion.yAxis">
Get the local y-axis
</member>
        <member name="M:Ogre.Quaternion.xAxis">
Get the local x-axis
</member>
        <member name="M:Ogre.Quaternion.ptr">
Pointer accessor for direct copying

Pointer accessor for direct copying
</member>
        <member name="M:Ogre.Quaternion.op_Subscript(System.UInt32!System.Runtime.CompilerServices.IsConst)">
Array accessor operator

Array accessor operator
</member>
        <member name="M:Ogre.Quaternion.swap(Ogre.Quaternion*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Exchange the contents of this quaternion with another. 

</member>
        <member name="M:Ogre.Quaternion.#ctor(System.Single*)">
Construct a quaternion from 4 manual w/x/y/z values
</member>
        <member name="M:Ogre.Quaternion.#ctor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*)">
Construct a quaternion from 3 orthonormal local axes
</member>
        <member name="M:Ogre.Quaternion.#ctor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Construct a quaternion from 3 orthonormal local axes
</member>
        <member name="M:Ogre.Quaternion.#ctor(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Construct a quaternion from an angle/axis
</member>
        <member name="M:Ogre.Quaternion.#ctor(Ogre.Matrix3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Construct a quaternion from a rotation matrix
</member>
        <member name="T:Ogre.Quaternion">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

Implementation of a Quaternion, i.e. a rotation around an axis.

</member>
        <member name="M:Ogre.Vector2.op_LeftShift(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Function for writing to a stream.

</member>
        <member name="M:Ogre.Vector2.isNaN">
Check whether this vector contains valid values
</member>
        <member name="M:Ogre.Vector2.reflect(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates a reflection vector to the plane with the given normal .
        @remarks NB assumes 'this' is pointing AWAY FROM the plane, invert if it is not.

</member>
        <member name="M:Ogre.Vector2.normalisedCopy">
As normalise, except that this vector is unaffected and the
            normalised vector is returned as a copy. 
</member>
        <member name="M:Ogre.Vector2.isZeroLength">
Returns true if this vector is zero length. 
</member>
        <member name="M:Ogre.Vector2.randomDeviant(System.Single)">
Generates a new random vector which deviates from this vector by a
            given angle in a random direction.
            @remarks
                This method assumes that the random number generator has already
                been seeded appropriately.
            @param
                angle The angle at which to deviate in radians
            @param
                up Any vector perpendicular to this one (which could generated
                by cross-product of this vector and any other non-colinear
                vector). If you choose not to provide this the function will
                derive one on it's own, however if you provide one yourself the
                function will be faster (this allows you to reuse up vectors if
                you call this method more than once)
            @returns
                A random vector which deviates from this vector by angle. This
                vector will not be normalised, normalise it if you wish
                afterwards.

</member>
        <member name="M:Ogre.Vector2.crossProduct(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the 2 dimensional cross-product of 2 vectors, which results
			in a single floating point value which is 2 times the area of the triangle.

</member>
        <member name="M:Ogre.Vector2.perpendicular">
Generates a vector perpendicular to this vector (eg an 'up' vector).
            @remarks
                This method will return a vector which is perpendicular to this
                vector. There are an infinite number of possibilities but this
                method will guarantee to generate one of them. If you need more
                control you should use the Quaternion class.

</member>
        <member name="M:Ogre.Vector2.makeCeil(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets this vector's components to the maximum of its own and the
            ones of the passed in vector.
            @remarks
                'Maximum' in this case means the combination of the highest
                value of x, y and z from both vectors. Highest is taken just
                numerically, not magnitude, so 1 &gt; -3.

</member>
        <member name="M:Ogre.Vector2.op_GreaterThan(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns true if the vector's scalar components are all smaller
            that the ones of the vector it is compared against.

</member>
        <member name="M:Ogre.Vector2.op_LessThan(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns true if the vector's scalar components are all greater
            that the ones of the vector it is compared against.

</member>
        <member name="M:Ogre.Vector2.midPoint(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a vector at a point half way between this and the passed
            in vector.

</member>
        <member name="M:Ogre.Vector2.normalise">
Normalises the vector.
            @remarks
                This method normalises the vector such that it's
                length / magnitude is 1. The result is called a unit vector.
            @note
                This function will not crash for zero-sized vectors, but there
                will be no changes made to their components.
            @returns The previous length of the vector.

</member>
        <member name="M:Ogre.Vector2.dotProduct(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the dot (scalar) product of this vector with another.
            @remarks
                The dot product can be used to calculate the angle between 2
                vectors. If both are unit vectors, the dot product is the
                cosine of the angle; otherwise the dot product must be
                divided by the product of the lengths of both vectors to get
                the cosine of the angle. This result can further be used to
                calculate the distance of a point from a plane.
            @param
                vec Vector with which to calculate the dot product (together
                with this one).
            @returns
                A float representing the dot product value.

</member>
        <member name="M:Ogre.Vector2.squaredDistance(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the square of the distance to another vector.
            @remarks
                This method is for efficiency - calculating the actual
                distance to another vector requires a square root, which is
                expensive in terms of the operations required. This method
                returns the square of the distance to another vector, i.e.
                the same as the distance but before the square root is taken.
                Use this if you want to find the longest / shortest distance
                without incurring the square root.

</member>
        <member name="M:Ogre.Vector2.distance(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the distance to another vector.
            @warning
                This operation requires a square root and is expensive in
                terms of CPU operations. If you don't need to know the exact
                distance (e.g. for just comparing distances) use squaredDistance()
                instead.

</member>
        <member name="M:Ogre.Vector2.squaredLength">
Returns the square of the length(magnitude) of the vector.
            @remarks
                This  method is for efficiency - calculating the actual
                length of a vector requires a square root, which is expensive
                in terms of the operations required. This method returns the
                square of the length of the vector, i.e. the same as the
                length but before the square root is taken. Use this if you
                want to find the longest / shortest vector without incurring
                the square root.

</member>
        <member name="M:Ogre.Vector2.length">
Returns the length (magnitude) of the vector.
            @warning
                This operation requires a square root and is expensive in
                terms of CPU operations. If you don't need to know the exact
                length (e.g. for just comparing lengths) use squaredLength()
                instead.

</member>
        <member name="M:Ogre.Vector2.op_Assign(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assigns the value of the other vector.
            @param
                rkVector The other vector

</member>
        <member name="M:Ogre.Vector2.ptr">
Pointer accessor for direct copying

Pointer accessor for direct copying
</member>
        <member name="M:Ogre.Vector2.swap(Ogre.Vector2*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Exchange the contents of this vector with another. 

</member>
        <member name="T:Ogre.Vector2">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

Standard 2-dimensional vector.
        @remarks
            A direction in 2D space represented as distances along the 2
            orthogonal axes (x, y). Note that positions, directions and
            scaling factors can be represented by a vector, depending on how
            you interpret the values.

</member>
        <member name="M:Ogre.Math.boundingRadiusFromAABB(Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get a bounding radius value from a bounding box. 
</member>
        <member name="M:Ogre.Math.gaussianDistribution(System.Single,System.Single,System.Single)">
Generates a value based on the Gaussian (normal) distribution function
			with the given offset and scale parameters.

</member>
        <member name="M:Ogre.Math.calculateBasicFaceNormalWithoutNormalize(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculate a face normal without normalize, no w-information. 
</member>
        <member name="M:Ogre.Math.calculateFaceNormalWithoutNormalize(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculate a face normal without normalize, including the w component which is the offset from the origin. 
</member>
        <member name="M:Ogre.Math.calculateBasicFaceNormal(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculate a face normal, no w-information. 
</member>
        <member name="M:Ogre.Math.calculateFaceNormal(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculate a face normal, including the w component which is the offset from the origin. 
</member>
        <member name="M:Ogre.Math.buildReflectionMatrix(Ogre.Plane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Build a reflection matrix for the passed in plane. 
</member>
        <member name="M:Ogre.Math.calculateTangentSpaceVector(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
Calculates the tangent space vector for a given set of positions / texture coords. 
</member>
        <member name="M:Ogre.Math.RealEqual(System.Single,System.Single,System.Single)">
Compare 2 reals, using tolerance for inaccuracies.

</member>
        <member name="M:Ogre.Math.intersects(Ogre.Sphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Plane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sphere / plane intersection test. 
        @remarks NB just do a plane.getDistance(sphere.getCenter()) for more detail!

</member>
        <member name="M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.list&lt;Ogre.Plane&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Ray / convex plane list intersection test. 
        @param ray The ray to test with
        @param plaeList List of planes which form a convex volume
        @param normalIsOutside Does the normal point outside the volume

</member>
        <member name="M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Ogre.Plane&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Ray / convex plane list intersection test. 
        @param ray The ray to test with
        @param plaeList List of planes which form a convex volume
        @param normalIsOutside Does the normal point outside the volume

</member>
        <member name="M:Ogre.Math.intersects(Ogre.Plane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Plane / box intersection test. 
</member>
        <member name="M:Ogre.Math.intersects(Ogre.Sphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sphere / box intersection test. 
</member>
        <member name="M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
Ray / triangle intersection, returns boolean result and distance.
        @param
            ray The ray.
        @param
            a The triangle's first vertex.
        @param
            b The triangle's second vertex.
        @param
            c The triangle's third vertex.
        @param
            positiveSide Intersect with "positive side" of the triangle
        @param
            negativeSide Intersect with "negative side" of the triangle
        @returns
            If the ray is intersects the triangle, a pair of <b>true</b> and the
            distance between intersection point and ray origin returned.
        @par
            If the ray isn't intersects the triangle, a pair of <b>false</b> and
            <b>0</b> returned.

</member>
        <member name="M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
Ray / triangle intersection, returns boolean result and distance.
        @param
            ray The ray.
        @param
            a The triangle's first vertex.
        @param
            b The triangle's second vertex.
        @param
            c The triangle's third vertex.
		@param 
			normal The triangle plane's normal (passed in rather than calculated
				on demand since the caller may already have it), doesn't need
                normalised since we don't care.
        @param
            positiveSide Intersect with "positive side" of the triangle
        @param
            negativeSide Intersect with "negative side" of the triangle
        @returns
            If the ray is intersects the triangle, a pair of <b>true</b> and the
            distance between intersection point and ray origin returned.
        @par
            If the ray isn't intersects the triangle, a pair of <b>false</b> and
            <b>0</b> returned.

</member>
        <member name="M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Ray / box intersection, returns boolean result and distance. 
</member>
        <member name="M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Sphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Ray / sphere intersection, returns boolean result and distance. 
</member>
        <member name="M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Plane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Ray / plane intersection, returns boolean result and distance. 
</member>
        <member name="M:Ogre.Math.pointInTri3D(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Checks whether a given 3D point is inside a triangle.
       @remarks
            The vertices of the triangle must be given in either
            trigonometrical (anticlockwise) or inverse trigonometrical
            (clockwise) order, and the point must be guaranteed to be in the
			same plane as the triangle
        @param
            p The point.
        @param
            a The triangle's first vertex.
        @param
            b The triangle's second vertex.
        @param
            c The triangle's third vertex.
		@param 
			normal The triangle plane's normal (passed in rather than calculated
				on demand since the caller may already have it)
        @returns
            If the point resides in the triangle, <b>true</b> is
            returned.
        @par
            If the point is outside the triangle, <b>false</b> is
            returned.

</member>
        <member name="M:Ogre.Math.pointInTri2D(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Checks whether a given point is inside a triangle, in a
            2-dimensional (Cartesian) space.
            @remarks
                The vertices of the triangle must be given in either
                trigonometrical (anticlockwise) or inverse trigonometrical
                (clockwise) order.
            @param
                p The point.
            @param
                a The triangle's first vertex.
            @param
                b The triangle's second vertex.
            @param
                c The triangle's third vertex.
            @returns
                If the point resides in the triangle, <b>true</b> is
                returned.
            @par
                If the point is outside the triangle, <b>false</b> is
                returned.

</member>
        <member name="M:Ogre.Math.DegreesToAngleUnits(System.Single)">
Convert from degrees to the current AngleUnit. 
</member>
        <member name="M:Ogre.Math.AngleUnitsToDegrees(System.Single)">
Convert from the current AngleUnit to degrees. 
</member>
        <member name="M:Ogre.Math.RadiansToAngleUnits(System.Single)">
Convert from radians to the current AngleUnit . 
</member>
        <member name="M:Ogre.Math.AngleUnitsToRadians(System.Single)">
Convert from the current AngleUnit to radians. 
</member>
        <member name="M:Ogre.Math.getAngleUnit">
Get the unit being used for angles. 
</member>
        <member name="M:Ogre.Math.setAngleUnit(Ogre.Math.AngleUnit)">
These functions used to set the assumed angle units (radians or degrees) 
            expected when using the Angle type.
       @par
            You can set this directly after creating a new Root, and also before/after resource creation,
            depending on whether you want the change to affect resource files.

</member>
        <member name="M:Ogre.Math.Tan(System.Single,System.Boolean)">
Tangent function.
            @param
                fValue Angle in radians
            @param
                useTables If true, uses lookup tables rather than
                calculation - faster but less accurate.

</member>
        <member name="M:Ogre.Math.Tan(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Tangent function.
            @param
                fValue Angle in radians
            @param
                useTables If true, uses lookup tables rather than
                calculation - faster but less accurate.

</member>
        <member name="M:Ogre.Math.InvSqrt(System.Single)">
Inverse square root i.e. 1 / Sqrt(x), good for vector
            normalisation.

</member>
        <member name="M:Ogre.Math.Sin(System.Single,System.Boolean)">
Sine function.
            @param
                fValue Angle in radians
            @param
                useTables If true, uses lookup tables rather than
                calculation - faster but less accurate.

</member>
        <member name="M:Ogre.Math.Sin(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Sine function.
            @param
                fValue Angle in radians
            @param
                useTables If true, uses lookup tables rather than
                calculation - faster but less accurate.

</member>
        <member name="F:Ogre.Math.LOG2">
Stored value of log(2) for frequent use
</member>
        <member name="M:Ogre.Math.Cos(System.Single,System.Boolean)">
Cosine function.
            @param
                fValue Angle in radians
            @param
                useTables If true, uses lookup tables rather than
                calculation - faster but less accurate.

</member>
        <member name="M:Ogre.Math.Cos(Ogre.Radian!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Cosine function.
            @param
                fValue Angle in radians
            @param
                useTables If true, uses lookup tables rather than
                calculation - faster but less accurate.

</member>
        <member name="M:Ogre.Math.Dispose">
Default destructor.

</member>
        <member name="M:Ogre.Math.#ctor(System.UInt32)">
Default constructor.
            @param
                trigTableSize Optional parameter to set the size of the
                tables used to implement Sin, Cos, Tan

</member>
        <member name="M:Ogre.Math.buildTrigTables">
Private function to build trig tables.

</member>
        <member name="F:Ogre.Math.mTrigTableFactor">
Radian -&gt; index factor value ( mTrigTableSize / 2 * PI )
</member>
        <member name="F:Ogre.Math.mTrigTableSize">
Size of the trig tables as determined by constructor.
</member>
        <member name="T:Ogre.Math.AngleUnit">
The angular units used by the API. This functionality is now deprecated in favor
	       of discreet angular unit types ( see Degree and Radian above ). The only place
		   this functionality is actually still used is when parsing files. Search for
		   usage of the Angle class for those instances

</member>
        <member name="T:Ogre.Angle">
Wrapper class which identifies a value as the currently default angle 
        type, as defined by Math::setAngleUnit.
    @remarks
        Angle values will be automatically converted between radians and degrees,
        as appropriate.

</member>
        <member name="T:Ogre.Degree">
Wrapper class which indicates a given angle value is in Degrees.
    @remarks
        Degree values are interchangeable with Radian values, and conversions
        will be done automatically between them.

</member>
        <member name="T:Ogre.Radian">
\addtogroup Core
	*  @{

\addtogroup Math
	*  @{

Wrapper class which indicates a given angle value is in Radians.
    @remarks
        Radian values are interchangeable with Degree values, and conversions
        will be done automatically between them.

</member>
        <member name="F:Ogre.StringUtil.BLANK">
Constant blank string, useful for returning by ref where local does not exist
</member>
        <member name="M:Ogre.StringUtil.replaceAll(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.Compi">
replace all instances of a sub-string with a another sub-string.
		@param source Source string
		@param replaceWhat Sub-string to find and replace
		@param replaceWithWhat Sub-string to replace with (the new sub-string)
		@returns An updated string with the sub-string replaced

</member>
        <member name="M:Ogre.StringUtil.match(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Simple pattern-matching routine allowing a wildcard pattern.
        @param str String to test
        @param pattern Pattern to match against; can include simple '*' wildcards
        @param caseSensitive Whether the match is case sensitive or not

</member>
        <member name="M:Ogre.StringUtil.splitBaseFilename(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte">
Method for splitting a filename into the base name
		and extension.

</member>
        <member name="M:Ogre.StringUtil.splitFullFilename(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte">
Method for splitting a fully qualified filename into the base name,
		extension and path.
		@remarks
		Path is standardised as in standardisePath

</member>
        <member name="M:Ogre.StringUtil.splitFilename(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std">
Method for splitting a fully qualified filename into the base name
            and path.
        @remarks
            Path is standardised as in standardisePath

</member>
        <member name="M:Ogre.StringUtil.standardisePath(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Method for standardising paths - use forward slashes only, end with slash.

</member>
        <member name="M:Ogre.StringUtil.endsWith(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Returns whether the string ends with the pattern passed in.
        @param pattern The pattern to compare with.
        @param lowerCase If true, the end of the string will be lower cased before
            comparison, pattern should also be in lower case.

</member>
        <member name="M:Ogre.StringUtil.startsWith(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Returns whether the string begins with the pattern passed in.
        @param pattern The pattern to compare with.
        @param lowerCase If true, the start of the string will be lower cased before
            comparison, pattern should also be in lower case.

</member>
        <member name="M:Ogre.StringUtil.toUpperCase(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Upper-cases all the characters in the string.

</member>
        <member name="M:Ogre.StringUtil.toLowerCase(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Lower-cases all the characters in the string.

</member>
        <member name="M:Ogre.StringUtil.tokenise(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.Compile">
Returns a StringVector that contains all the substrings delimited
            by the characters in the passed <code>delims</code> argument, 
			or in the <code>doubleDelims</code> argument, which is used to include (normal) 
			delimeters in the tokenised string. For example, "strings like this".
            @param
                delims A list of delimiter characters to split by
			@param
                delims A list of double delimeters characters to tokenise by
            @param
                maxSplits The maximum number of splits to perform (0 for unlimited splits). If this
                parameters is &gt; 0, the splitting process will stop after this many splits, left to right.

</member>
        <member name="M:Ogre.StringUtil.split(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Returns a StringVector that contains all the substrings delimited
            by the characters in the passed <code>delims</code> argument.
            @param
                delims A list of delimiter characters to split by
            @param
                maxSplits The maximum number of splits to perform (0 for unlimited splits). If this
                parameters is &gt; 0, the splitting process will stop after this many splits, left to right.

</member>
        <member name="M:Ogre.StringUtil.trim(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
Removes any whitespace characters, be it standard space or
            TABs and so on.
            @remarks
                The user may specify wether they want to trim only the
                beginning or the end of the String ( the default action is
                to trim both).

</member>
        <member name="T:Ogre.StringUtil">
\addtogroup Core
	*  @{

\addtogroup General
	*  @{

Utility class for manipulating Strings.  
</member>
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.MeshManager.UpdateGeometry(Mogre.Camera)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MeshManager.MaterialName'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.MeshManager.SetGeometryParameters(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.MeshManager.SetUnderHorizonParams(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.MeshManager.SetUnderHorizonParams(System.Int32,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.MeshManager.SetUnderHorizonParams(System.Int32,System.Boolean,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.MeshManager.SetUnderHorizonParams(System.Int32,System.Boolean,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MeshManager.RadiusMultiplier'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.MeshManager.GetSkydomeRadius(Mogre.Camera)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.MSkyX.Update(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.MSkyX.NotifyCameraRender(Mogre.Camera)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.IsCreated'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.Visible'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.TimeMultiplier'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.MeshMgr'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.AtmosphereMgr'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.GPUMgr'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.MoonMgr'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.CloudsMgr'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.VCloudsMgr'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.Controller'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.CurrentRenderQueueGroups'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.CurrentLightingMode'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.StarfieldEnabled'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.InfiniteCameraFarClipDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.SceneManager'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.Camera'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MSkyX.Autoupdate'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.GeometryManager.IsCreated'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.GeometryManager.SceneNode'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.GeometryManager.IsCreated'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.GeometryManager.SceneNode'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.VClouds.LightningManager.AddLightning(Mogre.Vector3,Mogre.Vector3,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.VClouds.LightningManager.AddLightning(Mogre.Vector3,Mogre.Vector3,System.Single,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.VClouds.LightningManager.UpdateMaterial'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.LightningManager.Enabled'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.LightningManager.LightningColor'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.LightningManager.LightningTimeMultiplier'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.LightningManager.AverageLightningApparitionTime'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.LightningManager.IsCreated'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.VClouds.VClouds.RegisterCamera(Mogre.Camera)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.VClouds.VClouds.UnregisterCamera(Mogre.Camera)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.IsCreated'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.CurrentGeometrySettings'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.DistanceFallingParams'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.CurrentRenderQueueGroups'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.WindDirection'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.WindDirectionV2'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.WindSpeed'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.SunDirection'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.SunColor'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.AmbientColor'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.LightResponse'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.AmbientFactors'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.GlobalOpacity'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.CloudFieldScale'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.NoiseScale'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.Wheater'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.Visible'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.SceneManager'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.Camera'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.DataMgr'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.GeometryMgr'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.LightningMgr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.Lightning.Direction'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.Lightning.Length'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.Lightning.Intensity'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.Lightning.BillboardSet'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.Lightning.SceneNode'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.Lightning.IsFinished'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.VClouds.VClouds.RegisterCamera(Mogre.Camera)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.VClouds.VClouds.UnregisterCamera(Mogre.Camera)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.IsCreated'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.CurrentGeometrySettings'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.DistanceFallingParams'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.CurrentRenderQueueGroups'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.WindDirection'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.WindDirectionV2'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.WindSpeed'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.SunDirection'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.SunColor'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.AmbientColor'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.LightResponse'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.AmbientFactors'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.GlobalOpacity'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.CloudFieldScale'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.NoiseScale'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.Wheater'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.Visible'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.SceneManager'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.Camera'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.DataMgr'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.GeometryMgr'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.LightningMgr'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.Lightning.Direction'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.Lightning.Length'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.Lightning.Intensity'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.Lightning.BillboardSet'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.Lightning.SceneNode'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.Lightning.IsFinished'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.VClouds.LightningManager.AddLightning(Mogre.Vector3,Mogre.Vector3,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.VClouds.LightningManager.AddLightning(Mogre.Vector3,Mogre.Vector3,System.Single,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.VClouds.LightningManager.UpdateMaterial'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.LightningManager.Enabled'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.LightningManager.LightningColor'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.LightningManager.LightningTimeMultiplier'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.LightningManager.AverageLightningApparitionTime'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.LightningManager.IsCreated'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.MeshManager.UpdateGeometry(Mogre.Camera)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MeshManager.MaterialName'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.MeshManager.SetGeometryParameters(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.MeshManager.SetUnderHorizonParams(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.MeshManager.SetUnderHorizonParams(System.Int32,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.MeshManager.SetUnderHorizonParams(System.Int32,System.Boolean,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.MeshManager.SetUnderHorizonParams(System.Int32,System.Boolean,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.MeshManager.RadiusMultiplier'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.MeshManager.GetSkydomeRadius(Mogre.Camera)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.VClouds.VClouds.RegisterCamera(Mogre.Camera)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.VClouds.VClouds.UnregisterCamera(Mogre.Camera)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.IsCreated'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.CurrentGeometrySettings'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.DistanceFallingParams'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.CurrentRenderQueueGroups'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.WindDirection'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.WindDirectionV2'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.WindSpeed'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.SunDirection'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.SunColor'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.AmbientColor'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.LightResponse'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.AmbientFactors'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.GlobalOpacity'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.CloudFieldScale'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.NoiseScale'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.Wheater'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.Visible'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.SceneManager'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.Camera'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.DataMgr'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.GeometryMgr'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.VClouds.LightningMgr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.GeometryBlock.IsCreated'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.GeometryBlock.Mesh'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.GeometryBlock.SubMesh'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.GeometryBlock.Entity'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.GeometryBlock.HardwareVertexBuffer'. -->
        <!-- Discarding badly formed XML document comment for member 'P:MSkyX.VClouds.GeometryBlock.HardwareIndexBuffer'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MSkyX.VClouds.GeometryBlock.IsInFrustum(Mogre.Camera)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Math'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Math.intersects(Ogre.Ray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.AxisAlignedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,System.Single*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector2.makeFloor(Ogre.Vector2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Vector3.makeFloor(Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.VertexDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.AnimationTrack.getKeyFramesAtTime(Ogre.TimeIndex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.KeyFrame**,Ogre.KeyFrame**,System.UInt16*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:Ogre.ResourcePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MaterialPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuLogicalBufferStruct'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_VIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACT_WORLDVIEWPROJ_MATRIX'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getFloatLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.getIntLogicalIndexForPhysicalIndex(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters.setNamedConstant(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Ogre.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.GpuProgram.createParameterMappingStructures(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.GpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Renderable.preRender(Ogre.SceneManager*,Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.MovableObject.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.BillboardSet.mActiveBillboards'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SkeletonPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.MeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.Node.mListener'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.FrameEvent.timeSinceLastEvent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,Ogre.PixelFormat,System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.loadRawData(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Image.load(Ogre.SharedPtr<Ogre.DataStream>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TexturePtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setCubicTextureName(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.TextureUnitState.setTextureTransform(Ogre.Matrix4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ControllerManager.destroyController(Ogre.Controller<System.Single>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.HardwareOcclusionQuery.beginOcclusionQuery'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.HighLevelGpuProgramPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.Log.Stream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.position(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.normal(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ManualObject.tangent(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialSerializer.invokeParser(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,=FUNC:System.Boolean(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSi'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.MaterialManager.getDefaultSettings'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.PatchMeshPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_PIXELS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:GMM_RELATIVE_ASPECT_ADJUSTED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.ParticleEmitter.initDurationRepeat'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.ParticleSystem.mActiveParticles'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ParticleSystemManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Pass.setShadowReceiverFragmentProgram(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.TextureManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderTarget.addListener(Ogre.RenderTargetListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setAmbientLight(System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._createRenderWindow(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,st'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem._setSeparateSceneBlending(Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendFactor,Ogre.SceneBlendOperation,Ogre.SceneBlendOperation)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.setStencilBufferParams(Ogre.CompareFunction,System.UInt32,System.UInt32,Ogre.StencilOperation,Ogre.StencilOperation,Ogre.StencilOperation,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderSystem.preExtraThreadsStarted'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.RenderTargetListener'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.RenderWindow.create(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,std.map<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.SceneQuery.WorldFragmentType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Ogre.SkeletonInstance.mActiveTagPoints'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.InstancedGeometry.BatchInstance'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.ViewPoint'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureCasterPreViewProj(Ogre.Light*,Ogre.Camera*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.Listener.shadowTextureReceiverPreViewProj(Ogre.Light*,Ogre.Frustum*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(Ogre.Entity*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyEntity(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllEntities'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(Ogre.ManualObject*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyManualObject(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllManualObjects'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(Ogre.BillboardChain*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardChain(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardChains'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(Ogre.RibbonTrail*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyRibbonTrail(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllRibbonTrails'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(Ogre.ParticleSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyParticleSystem(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllParticleSystems'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(Ogre.BillboardSet*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyBillboardSet(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllBillboardSets'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.createAnimationState(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Ogre.PixelFormat)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowTextureConfig(System.UInt32,Ogre.ShadowTextureConfig!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.setShadowUseInfiniteFarPlane(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(Ogre.StaticGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyStaticGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllStaticGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(Ogre.InstancedGeometry*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyInstancedGeometry(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.SceneManager.destroyAllInstancedGeometry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addRenderSystem(Ogre.RenderSystem*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.addFrameListener(Ogre.FrameListener*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.Root.startRendering'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.GeometryBucket'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.StaticGeometry.Region'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.CompositorPtr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setTechnique(Ogre.CompositionTechnique*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.CompositorInstance.setScheme(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.FocusedShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Ogre.LiSPSMShadowCameraSetup'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.setSplitPadding(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Ogre.PSSMShadowCameraSetup.getSplitPadding'. -->
    </members>
</doc>